<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>【妄言之言】2021总结：再见西安，你好杭州！</title>
    <url>/2022/02/01/%5B20220201%5D/</url>
    <content><![CDATA[<blockquote>
<p>与有肝胆人共事；从无字句处读书。</p>
</blockquote>
<p>今天是大年初一，和去年一样，一个人在外地过年，在除夕夜吃海底捞自嗨锅。去年是想体验一下在学校过年，毕竟是最后一年在学校里。今年由于杭州疫情原因，只能独自一人在家过年。回想这四年来，只回家过年一次。第一年是在美国留学，春节期间自驾美国东部六七个州；第二年由于武汉疫情，在家待了半年，直到6月底才去学校。记得去年除夕的时候，我在实验室写了2020年的总结。时隔一年，我将追述去年一年的点点滴滴。2021这一年，主要完成了三件事：学校学生到职场菜鸟的转变；将所有csdn的博客重新整理到个人博客上；带着奶奶去旅游。</p>
<a id="more"></a>
<p>2021年上半年，主要是完成找工作和毕业答辩相关内容。关于找工作，也没有什么好的建议。博士毕业，一般取向就是学校、研究所、和公司。我们学院大多选择了高校当老师，而我从来没有考虑过高校，所以没有经过高校的面试。据我所知，现在985、211和一本都开始实行非升即走的策略，所以去一个好学校是比较容易的，但是想要留下来就比较难了。去差一点的学校会有编制，当是工资那是非常低的，而且平台资源有限。敝人普通话不标准，也不想上课、写项目申请书等原因，就没有考虑去高校当老师。在学校这几年，看透了高校教育的机制，真真搞学术的少之又少。要么想着怎么申请项目赚钱，要么想着养生科研。大多数真正搞科研的都是那些已经满足物质需求，想要追求精神文明的人。显然，大多数人不是这种人，也包括我。研究所相当于高校和公司之间的择中，有编制，钱也比高校多，比公司少。研究所我只面过航天五院和中电十四所，还有一个兵器研究所没去面试。据说这些研究所，工资都在三十来万，福利待遇也不错，不过都有保密要求。记得当初面试的时候，面试官都认识我的博士导师，估计是录用的主要原因。所以说，找好导师对工作也很有帮助。最后就是公司，由于本硕博都是通信专业，对口的公司也只有中兴华为了。本来我也想去互联网大厂，但是对于博士，也需要有CS领域的顶会门槛，只能作罢。若是当初选择硕士毕业去互联网，BAT应该是不成问题的。经过博士这几年，编码能力未有进步，也没时间进行所谓码农“八股文”的训练。最后在深圳中兴和杭州华为中，我选择了后者。毕竟，在深圳买房太难了，杭州踮起脚还能够着。</p>
<p>找完工作后就是五六月，已经没有啥事了。这两个月主要是将博客整理到个人网站上、进行辉光管的制作、以及毕业答辩。距离上一次写的博客，已经过去7个月了；距离第一篇博客的发表已经9年了。9年时间，共写作200+原创文章，博客访问量已突破100万。这些年，很多人留下过评论，也发过私信，说明这些博文也或多或少地帮助到一些网友。我也尽可能地回复网友的问题，当然，对于许多问题我也无法问答。一是因为没有空闲时间；二是因为时间间隔太久，博文相关知识已经忘了。对此，我深表歉意。在9年的时间里，真正写作的阶段并不多，主要集中在大四保研后、研一、以及留学回来之后。这些时间短是比较闲，没有考试、毕业等压力的阶段。工作过后，更加没有写作的动力了。因为每天都干着工作相关的事情，由于相关资料保密等因素，无法写成博客。双休日的时候，也不想学习，只想着睡懒觉。说到这，我也看了看许多我关注的博主都是在校期间写作，工作之后很少继续创作的。刚开始写作时，正直大三，已经确定可以保研，就有时间开始写作了。于是，我学习了算法导论这本书，并将相关内容写成博客。那时，会时不时地去看看有多少浏览量，有没有评论，也会从中获得成就感。之后，博客主要是我将学到的东西记录在上面，也包含一些生活体悟等等。历时两年，我获得了博客专家称号，写作动力就没有这么强了。接着，选择读博，忙着看论文，写论文，没有时间学习技术相关知识，博客基本处于停更状态。后来，从国外留学回来，感觉能够完成毕业论文指标，便又开始写作，主要是介绍科研工具相关文章。毕业工作之后，技术被局限在通信物理层这个圈子里，现在还处于一知半解的状态。写这种具有技术深度的东西一般都是吃力不讨好。从发表的文章浏览次数来看，浅显易懂的没有深度的文章往往具有极高的浏览量，而我自以为写的有技术内涵的东西常常无人问津。现在互联网充斥着快餐文化，人们并不会静下心来看一篇文章或看一部电影。那些拿来能用的文章因此获得了大家的青睐，无论其是否解释了背后的原理与意义。许多博主也知道这些流量密码，用博人眼球的标题来吸引读者眼球。写作这么多年，我已看淡了这些，保持本心，写作的目的只为记录，只为总结。为此，我建立了个人博客，重新规范化了文章的排版，抛弃了充满广告、博人眼球标题、垃圾评论的CSDN平台，只为读者阅读起来更加赏心悦目。工作之后，在往后的日子里，只会越来越忙，业余写作的时间越来越少，希望自己能够坚持下去吧。</p>
<p>在毕业前最后两个月里，我还做了辉光管时钟，本来想着送给导师的，奈何到目前为止还没有做完，目前只剩下一个木制的盒子没有制作。在制作时钟的过程中，我将每个功能模块都写成了一篇博文，现在还欠一篇辉光管部分相关电路，等到以后有时间再说吧。。。辉光管时钟的制作，用的还是我大一暑假学的单片机知识，现在又重新学了一下，电路原理和编程也比较简单。等疫情结束后，准备去找个木匠手艺馆，完成时钟的包装。</p>
<p>毕业答辩也是人生第一次穿正装，可能自己觉得还是小孩吧，觉得自己穿正装很滑稽。答辩过程还算比较顺利吧，没有想象中的紧张与激动。之后就是拍毕业照，也没有像本科时那样，拍遍学校的每一个角落，也没有参加学习的授位仪式。没有往日的激情，只有一种解脱的感觉。读博期间的种种心酸，不足为外人道也。记得在毕业前的答师宴上，导师们也提及我大论文的致谢写得不错。诚然，致谢部分，是我博士期间的简影，是我发自内心的叙述。</p>
<p>毕业回家，便是休息，自知工作后，就很难有长时间的放假时间了。这期间，我完成了几年前的愿望-带着我奶奶出去看看。作为一个七十多岁的老人，还从未出过省，最远就只是去过我们市区，也没有做过地铁、高铁、轮船、飞机。奶奶从小带我长大，这份恩情太重。我多年前就和奶奶说，叫她不要干累活，注意身体，等我毕业后带她去玩。现在，这个梦想实现了，我们去了武汉黄鹤楼；去了北京天安门、全聚德排队两小时吃了北京烤鸭；去了豫园，在外滩拍照，在黄浦江上做了游轮，去了东方明珠；去了台州我阿姨家。期间，做了动车、飞机、地铁、高铁、轮船。奶奶说不枉在人世间走一遭。年纪大了，腿脚也更加不方便了，现在感觉耳朵也时不时听不见了，大脑也反应慢了。愿时光再慢一些吧！</p>
<p>2021年8月7号，我从深圳飞到杭州，开始了职业生涯。本来是准备去东莞培训的，结果由于旅游时经过南京，南京爆发疫情，东莞不接受，只能直接飞到杭州进行培训。接下来的6个月就是在公式工作，作为新手，还在慢慢适应。现在的方向是通信物理层方向，和博士期间的研究工作无关，都是本科课程通信原理和信息论相关的知识。办公室同事十分优秀，大多是浙大博士，还有一部分是海外博士，我这学位也只能是垫底的存在了。因此，我更加得好好学习，加油干。工作之后才发现，现在的工作才是真正的搞通信的，博士期间感觉和通信关系不大。工作之后才发现，在学校才是最悠闲自由的时光，在公司就是用钱买自由。但是，在公式有着更多的资源，能够听高校合作老师的项目报告，能够使用公司的服务器和GPU。总的来说，各有利弊，各有得失。</p>
<p>2021的上半年在西安，在学校中度过，已完成“愿乘风破万里浪；甘面壁读廿年书”。2021的下半年在杭州，在公司中度过，正进行“与有肝胆人共事；从无字句处读书”。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>Life Thoughts</tag>
      </tags>
  </entry>
  <entry>
    <title>【LaTeX排版】Windows系统下西电硕\博士论文LaTeX模版</title>
    <url>/2020/12/03/%5B20201203%5D/</url>
    <content><![CDATA[<p>昨天实验室同学，直接使用西电官网的<a href="https://gr.xidian.edu.cn/xwsy/zlxz.htm" target="_blank" rel="noopener">LaTeX模板](https://gr.xidian.edu.cn/xwsy/zlxz.htm</a>，使用WinEdt环境，然后编译运行失败。由于我之前已经写过一篇关于在MacOS系统上的LaTeX模板文章，对于官方的模板有些经验：无非就是编码问题或者有些package过时。下面我们逐一排查这些错误。</p>
<p>当我们使用WinEdt打开官网的templet.tex文件并编译运行时，会出现如下图1所示错误：</p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20201203/20201203_fig001.jpg" width="400" height="250" title="图1" alt="图1" ></p>
<p>按着提示按键<code>H+Enter</code>后显示的是编码问题。想到之前在MacOS下也出现过编码问题(可以使用Sublime Text3 查看当前文件编码，具体方法可以自己网上搜索)，我们可以将所有文件的编码转换为UTF-8编码，转换方法在<a href="http://www.tengweitw.com/2020/11/18/%5B20201118%5D/" target="_blank" rel="noopener">文章</a>中已经介绍过，这里不再赘述。当全部转化为UTF-8编码后，再次尝试编译运行，出现如图2所示错误：</p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20201203/20201203_fig002.jpg" width="400" height="300" title="图2" alt="图2" ></p>
<p>显然是这里类文件XDUthesis.cls有问题。打开该文件，找到<code>\XDU@underline[#1]#2</code>这一句，在第154行如图3：</p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20201203/20201203_fig003.jpg" width="600" height="450" title="图3" alt="图3" ></p>
<p>当我把\CTEXunderline删除时，重新编译(XeLaTeX)可以成功编译。通过参考CTeX手册第11.3节可知，此命令已经过时，我们可以将其简单地使用<code>\underline</code>即可，修改后的内容如图4所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20201203/20201203_fig004.jpg" width="600" height="450" title="图4" alt="图4" ></p>
<p>至此，Windows下对应的西电硕、博士论文LaTeX模板完成，完整的可运行版本请见github地址：<a href="https://github.com/tengweitw/XDUThesis_Windows" target="_blank" rel="noopener">https://github.com/tengweitw/XDUThesis_Windows</a></p>
<p>另外，推荐大家使用sublime + text live来作为编写大论文环境，个人感觉比WinEdt好太多，其安装方法见另一篇文章:<a href="http://www.tengweitw.com/2020/03/18/%5B20200318%5D/" target="_blank" rel="noopener">http://www.tengweitw.com/2020/03/18/%5B20200318%5D/</a> 。在该环境下，LaTeX模板也得到了验证，能成功运行。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>LaTeX Coding</tag>
      </tags>
  </entry>
  <entry>
    <title>【CUDA编程】最常用的Bug Fixing方法</title>
    <url>/2020/11/22/%5B20201122%5D/</url>
    <content><![CDATA[<p>今天，西安下雪了，2020年的第一场雪，比往年来的早些。依稀记得，2010年刚来西安上学时，第一场雪是12月24日，由于是在平安夜，所以还能记得，一晃都十年了……</p>
<p>在CUDA编程过程中，最易出错的部分就是内存的相关操作。时常出现的问题是：程序能够运行，但是其中的Kernel函数未能成功运行。这使得排错相对传统的C语言编程复杂。好在我们依旧可以使用最传统的方法：使用printf函数打印输出进行排查Bug。但是，printf函数在CUDA编程过程中，存在局限性。具体地说，运行在CPU上的代码和运行在GPU上的代码是异步的，运行在GPU核函数中的每个线程也是异步的。这使得printf函数的显示上比较复杂，不是那么直观。</p>
<a id="more"></a>
<hr>
<p>这时，我们可以使用专门的错误检查库函数<code>checkCudaError()</code>，注意需要包含头文件<code>#include &lt;helper_functions.h&gt;</code>,<code>#include &lt;helper_cuda.h&gt;</code>。在CUDA编程中，最容易出错的是就是内存分配<code>cudaMalloc()</code>和<code>cudaMemcpy()</code>。为了防止内存溢出，我们可以首先检查电脑中关于GPU的一些信息。这时，我们可以直接使用安装CUDA后自带的样例，具体位置在<code>C:\ProgramData\NVIDIA Corporation\CUDA Samples\v10.1\1_Utilities\deviceQuery</code>中。我的个人电脑配置如图1：</p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20201122/20201122_fig001.jpg" width="700" height="400" title="图1" alt="图1" ></p>
<p>在图1中，主要需要注意的有四点：</p>
<ul>
<li>Total amount of shared memory per block</li>
<li>Total number of registers available per block</li>
<li>Maximum number of threads per multiprocessor</li>
<li>Maximum number of threads per block</li>
</ul>
<p>在我们进行核函数配置和变量定义时需要注意上述四点。当然，我们还可以使用上述的<code>checkCudaError</code>来检查内存操作是否正常。</p>
<p>当我们包含头文件<code>#include &lt;helper_functions.h&gt;</code>,<code>#include &lt;helper_cuda.h&gt;</code>可能会出现错误： 无法打开包括文件 helper_cuda.h。这时我们需要在项目中添加目录，具体操作为：右键项目-&gt; 属性-&gt;配置属性-&gt;C/C++-&gt;常规-&gt;附加包含目录：</p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20201122/20201122_fig002.jpg" width="700" height="450" title="图2" alt="图2" ></p>
<p>这里在目录中添加上述.h文件所在目录，默认目录为<code>C:\ProgramData\NVIDIA Corporation\CUDA Samples\v10.1\common\inc</code>。这样我们就可以正常使用<code>checkCudaError()</code>函数了，关于<code>checkCudaError()</code>函数的使用，可以自行搜索官方文档。由于我只是最简单地使用，我主要参考了CUDA自带的例子，就足够了。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>CUDA Coding</tag>
      </tags>
  </entry>
  <entry>
    <title>【LaTeX排版】MacOS系统下西电硕\博士论文LaTeX模版</title>
    <url>/2020/11/18/%5B20201118%5D/</url>
    <content><![CDATA[<p>现在终于可以着手写大论文了，但是学校官网上的LaTeX模板主要是针对windows系统上的，实验室师兄师姐也没有MacOS系统的LaTeX版本。一想到我本科毕设的时候就是自己按照毕设手册的格式自己制作的LaTeX模板（详情见我之前的<a href="http://www.tengweitw.com/2014/06/28/%5B20140628%5D/" target="_blank" rel="noopener">相关文章</a>），我准备自己制作模板。转念一想，我是否可以根据官网中的LaTeX模板进行修改，这样可以节省好多时间。其中官网的latex模板可以在研究生院网站上进行下载，见下载地址：<a href="https://gr.xidian.edu.cn/xwsy/zlxz.htm" target="_blank" rel="noopener">https://gr.xidian.edu.cn/xwsy/zlxz.htm</a> 。现在想想，为啥当初为啥完全是自己根据本科毕设格式自己弄的LaTeX模板？可能一方面是因为github上西电本科毕设LaTeX模板好像都是2017年以后的，二是没有找到西电官方的本科LaTeX模板。</p>
<p>本文主要介绍在MacOS系统下使用的硕士或者博士论文的LaTeX模板，Windows系统下的LaTeX应该可以直接使用上述官网的模板。</p>
<a id="more"></a>
<hr>
<h4 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h4><ul>
<li>编译器：Textlive 2018</li>
<li>编辑器：Vim</li>
</ul>
<p>注意：在其它集成开发环境中也可以使用，例如Texmaker, Texpad或者网络上的Overleaf等等，这里需要将默认的编译方式改为XeLaTeX !</p>
<hr>
<h4 id="修改部分"><a href="#修改部分" class="headerlink" title="修改部分"></a>修改部分</h4><p>由于我们是用中文来编写毕业论文，而XeLaTeX对中文支持比PDFLaTeX好，具体区别可以自行网上搜索，大致区别如下：</p>
<ul>
<li>PDFLaTeX是比较旧的编译器，对Unicode编码支持不好，显示汉字需要使用CJK宏包。</li>
<li>XeLaTeX是比较新的编译器，支持Unicode编码（如，常用的utf-8），自然就可以显示汉字。</li>
</ul>
<p>使用XeLaTeX来生成PDF文件的话，我们需要对官网的源文件进行修改如下：</p>
<ul>
<li>修改驱动方式</li>
<li>修改编码格式</li>
</ul>
<p>具体操作如下：</p>
<h5 id="修改驱动方式"><a href="#修改驱动方式" class="headerlink" title="修改驱动方式"></a>修改驱动方式</h5><p>当我们对原始文件进行编译运行时，结果如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20201118/20201118_fig001.jpg" width="600" height="450" title="图1" alt="图1" ></p>
<p>上述出现错误：Wrong DVI mode driver option ‘dvipdfm’. 主要原因是使用XeLaTex时，是不需要该驱动的。为此，我们可以在类文件<code>XDUthesis.cls</code>中修改驱动，具体位置在文件第75行，如图2:</p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20201118/20201118_fig002.jpg" width="600" height="450" title="图2" alt="图2" ></p>
<p>删除该驱动后，结果如图3:</p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20201118/20201118_fig003.jpg" width="600" height="400" title="图3" alt="图3" ></p>
<hr>
<h5 id="修改编码方式"><a href="#修改编码方式" class="headerlink" title="修改编码方式"></a>修改编码方式</h5><p>修改完上述驱动后，编译运行后会出现乱码，这是因为这些源文件基本上都是GB2312编码，我们需要将这些源文件改为UTF - 8编码，具体我们可以使用sublime Text 3来实现，如图4所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20201118/20201118_fig004.jpg" width="600" height="450" title="图4" alt="图4" ></p>
<hr>
<p>经过上述的修改，我们就可以开始得到正确的PDF文件了。当然如果你不想修改，我也提供了修改过后MacOS下的LaTeX模板，链接为：<a href="https://github.com/tengweitw/XDUThesis" target="_blank" rel="noopener">https://github.com/tengweitw/XDUThesis</a></p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>LaTeX Coding</tag>
      </tags>
  </entry>
  <entry>
    <title>【CUDA编程】随机数生成</title>
    <url>/2020/10/24/%5B20201024%5D/</url>
    <content><![CDATA[<p>随机数在一般编程中都会涉及，特别是在仿真过程中。我之前有几篇文章介绍了如何通过CPU函数调用产生随机数，这里我介绍如何在CUDA中产生随机数。在CUDA中，主要使用cuRAND库中的函数来产生随机数，其链接文档为<a href="https://docs.nvidia.com/cuda/curand/index.html" target="_blank" rel="noopener">https://docs.nvidia.com/cuda/curand/index.html</a> 。</p>
<a id="more"></a>
<hr>
<p>通过文档可知，cuRAND库提供两种方式的随机数生成：host与device。关于具体如何生成随机数，我们可参考文档中的<a href="https://docs.nvidia.com/cuda/curand/host-api-overview.html#host-api-example" target="_blank" rel="noopener">Host API Example</a> 和<a href="https://docs.nvidia.com/cuda/curand/device-api-overview.html#device-api-example" target="_blank" rel="noopener">Device API Examples</a>。其中<a href="https://docs.nvidia.com/cuda/curand/host-api-overview.html#host-api-example" target="_blank" rel="noopener">Host API Example</a>的例子非常简单，这里不具体描述，唯一需要注意的点是，在VS中可能会出现error LNK2019的错误，此时需要在项目属性中添加依赖库，具体可以网上搜索答案。本文主要介绍如何参考<a href="https://docs.nvidia.com/cuda/curand/device-api-overview.html#device-api-example" target="_blank" rel="noopener">Device API Examples</a>的例子，来具体实现在核函数中产生随机数。为了便于介绍，我们首先给出了具体的代码实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"cuda_runtime.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"device_launch_parameters.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"curand_kernel.h"</span><span class="comment">// this lib shoulb be included</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;random&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//-------------------generate random numbers-------//</span></span><br><span class="line">__<span class="function">device__ <span class="keyword">float</span> <span class="title">generate</span><span class="params">(curandState *globalState, <span class="keyword">int</span> ind)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	curandState localState = globalState[ind];</span><br><span class="line">	<span class="keyword">float</span> RANDOM = curand_uniform(&amp;localState);<span class="comment">// uniform distribution</span></span><br><span class="line">	globalState[ind] = localState;</span><br><span class="line">	<span class="keyword">return</span> RANDOM;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">__<span class="function">global__ <span class="keyword">void</span> <span class="title">setup_kernel</span><span class="params">(curandState *state, <span class="keyword">unsigned</span> <span class="keyword">long</span> seed)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ix = threadIdx.x + blockIdx.x*blockDim.x;</span><br><span class="line">	<span class="keyword">int</span> iy = threadIdx.y + blockIdx.y*blockDim.y;</span><br><span class="line">	<span class="keyword">int</span> idx = iy * blockDim.x*gridDim.x + ix;</span><br><span class="line">	curand_init(seed, idx, <span class="number">0</span>, &amp;state[idx]);<span class="comment">// initialize the state</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//-------------This is our kernel function where the random numbers generated------//</span></span><br><span class="line">__<span class="function">global__ <span class="keyword">void</span> <span class="title">our_kernel</span><span class="params">(curandState *globalState,<span class="keyword">int</span> nx,<span class="keyword">int</span> ny)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ix = threadIdx.x + blockIdx.x*blockDim.x;</span><br><span class="line">	<span class="keyword">int</span> iy = threadIdx.y + blockIdx.y*blockDim.y;</span><br><span class="line">	<span class="keyword">int</span> idx = iy * blockDim.x*gridDim.x + ix;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ix &lt; nx&amp;&amp;iy &lt; ny)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> k = generate(globalState, idx) * <span class="number">100000</span>;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, k);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> nx = <span class="number">5</span>;</span><br><span class="line">	<span class="keyword">int</span> ny = <span class="number">2</span>;<span class="comment">// generate nx*ny random numbers</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> blockx = <span class="number">32</span>;</span><br><span class="line">	<span class="keyword">int</span> blocky = <span class="number">1</span>;</span><br><span class="line">	<span class="function">dim3 <span class="title">block</span><span class="params">(blockx, blocky)</span></span>;<span class="comment">//(32,1)</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> gridx = (nx + block.x - <span class="number">1</span>) / block.x;</span><br><span class="line">	<span class="keyword">int</span> gridy = (ny + block.y - <span class="number">1</span>) / block.y;</span><br><span class="line">	<span class="function">dim3 <span class="title">grid</span><span class="params">(gridx,gridy)</span></span>; <span class="comment">//(1,10)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> N = gridx*gridy*blockx*blocky;<span class="comment">// the number of states</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//--------------------//</span></span><br><span class="line">	curandState* devStates;</span><br><span class="line"></span><br><span class="line">	cudaMalloc(&amp;devStates, N * <span class="keyword">sizeof</span>(curandState));</span><br><span class="line"></span><br><span class="line">	srand(time(<span class="number">0</span>));</span><br><span class="line">	<span class="keyword">int</span> seed = rand();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//  Initialize the states</span></span><br><span class="line">	setup_kernel &lt;&lt;&lt;grid, block&gt;&gt;&gt; (devStates, seed);</span><br><span class="line"></span><br><span class="line">	our_kernel &lt;&lt; &lt;grid, block &gt;&gt; &gt; (devStates,nx,ny);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	cudaDeviceReset();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面代码可以看出，主要的有两点：一是首先使用<code>setup_kernel</code>来初始化，二是使用<code>generate</code>来产生随机数。最需要注意的是，<code>setup_kernel</code>和<code>our_kernel</code>运行的维度一致<code>&lt;&lt;&lt;grid, block&gt;&gt;&gt;</code>。并且，<code>devStates</code>的维度要相同，这样确保<code>devStates</code>为每一个thread都生成对应的state.</p>
<p>最后给出上述代码结果图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20201024/20201024_fig001.jpg" width="600" height="450" title="图1" alt="图1" ></p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>Programming Art</tag>
      </tags>
  </entry>
  <entry>
    <title>【CUDA编程】CPU计时与GPU计时</title>
    <url>/2020/10/18/%5B20201018%5D/</url>
    <content><![CDATA[<p>使用CUDA进行编程，主要目的就是时间上加速。为此，如何计时必不可少。在CUDA中，我们可以使用CPU计时函数和GPU计时函数。对于CPU计时，我们在之前的文章(<a href="http://www.tengweitw.com/2013/06/02/%5B20130602b%5D/" target="_blank" rel="noopener">精确系统计时：秒、毫秒、微秒</a>)中已经介绍在一般的C/C++编程中的计时方法。下面我们介绍在CUDA中如何计时：</p>
<a id="more"></a>
<hr>
<h4 id="CPU计时"><a href="#CPU计时" class="headerlink" title="CPU计时"></a>CPU计时</h4><p>CUDA中的核函数是异步执行的，即调用核函数后（而非等待其运行结束）就继续执行后面的语句。因此，使用CPU计时的时候，我们需要加上同步函数，这样才能得到核函数的运行时间，否则就是调用时间。下面给出一个简单的实例，由于代码简单，这里不再过多说明：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"cuda_runtime.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"device_launch_parameters.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;random&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line">__<span class="function">global__ <span class="keyword">void</span> <span class="title">kernel_function</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Hello From GPU\n"</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//Timing using CPU </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">float</span> esp_time_cpu;</span><br><span class="line">	<span class="keyword">clock_t</span> start_cpu, stop_cpu;</span><br><span class="line"></span><br><span class="line">	kernel_function &lt;&lt; &lt;<span class="number">1</span>, <span class="number">10</span>&gt;&gt; &gt; ();<span class="comment">// warming up</span></span><br><span class="line"></span><br><span class="line">	start_cpu = clock();<span class="comment">// start timing</span></span><br><span class="line">	kernel_function&lt;&lt;&lt;<span class="number">1</span>,<span class="number">10</span>&gt;&gt;&gt; ();</span><br><span class="line">	cudaDeviceSynchronize(); <span class="comment">// synchronzie</span></span><br><span class="line">	stop_cpu = clock();<span class="comment">// end timing</span></span><br><span class="line"></span><br><span class="line">	esp_time_cpu = (<span class="keyword">float</span>)(stop_cpu - start_cpu) / CLOCKS_PER_SEC;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"The time by host:\t%f(ms)\n"</span>, esp_time_cpu);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	cudaDeviceReset();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的是：在计时前最好先warming up一下，即先把要计时的函数运行一遍。</p>
<hr>
<h4 id="GPU计时"><a href="#GPU计时" class="headerlink" title="GPU计时"></a>GPU计时</h4><p>这里我们可以使用CUDA提供的事件管理API来实现计时，具体可以参考NVIDIA官方的<a href="https://developer.nvidia.com/blog/how-implement-performance-metrics-cuda-cc/" target="_blank" rel="noopener">文档</a>。具体实例如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"cuda_runtime.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"device_launch_parameters.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;random&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">__<span class="function">global__ <span class="keyword">void</span> <span class="title">kernel_function</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Hello From GPU\n"</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> Timing <span class="keyword">using</span> GPU</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cudaEvent_t start, <span class="built_in">stop</span>;</span><br><span class="line">	<span class="keyword">float</span> esp_time_gpu;</span><br><span class="line">	cudaEventCreate(&amp;start);</span><br><span class="line">	cudaEventCreate(&amp;<span class="built_in">stop</span>);</span><br><span class="line"></span><br><span class="line">	kernel_function &lt;&lt; &lt;<span class="number">1</span>, <span class="number">10</span> &gt;&gt; &gt; ();<span class="comment">// warming up</span></span><br><span class="line"></span><br><span class="line">	cudaEventRecord(start, <span class="number">0</span>);<span class="comment">// start</span></span><br><span class="line"></span><br><span class="line">	kernel_function &lt;&lt; &lt;<span class="number">1</span>, <span class="number">10</span> &gt;&gt; &gt; ();</span><br><span class="line"></span><br><span class="line">	cudaEventRecord(<span class="built_in">stop</span>, <span class="number">0</span>);<span class="comment">// stop</span></span><br><span class="line"></span><br><span class="line">	cudaEventSynchronize(<span class="built_in">stop</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	cudaEventElapsedTime(&amp;esp_time_gpu, start, <span class="built_in">stop</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Time for the kernel: %f ms\n"</span>, esp_time_gpu);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	cudaDeviceReset();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>CPU和GPU计时的结果分别如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20201018/20201018_fig001.jpg" width="600" height="500" title="图1" alt="图1" ></p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20201018/20201018_fig002.jpg" width="600" height="500" title="图2" alt="图2" ></p>
<p>注意：上述的结果不同，是因为有误差，我们可以通过多运行几次取平均值。</p>
<p>另外，上述CPU和GPU计时上的主要区别在于是否需要同步：CPU计时需要在核函数后调用同步函数。为此，当需要同步时，我们可以使用CPU计时；当不能同步时，我们使用GPU计时。当然，GPU计时也能用于需要同步的场景，此时的同步函数<code>cudaDeviceSynchronize()</code>需要放置在计时模块的后面。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>Programming Art</tag>
      </tags>
  </entry>
  <entry>
    <title>【妄言之言】MacOS上的效率工具</title>
    <url>/2020/09/30/%5B20200930%5D/</url>
    <content><![CDATA[<h2 id="Routine"><a href="#Routine" class="headerlink" title="Routine"></a>Routine</h2><p>目前，作为一个科研工作者，我主要的工作流程是在网页中查找文献、使用PDF阅读器阅读文献、以及使用Vim写论文。这一工作流程主要涉及了软件的开启，浏览器的操作(前进、后退、关闭)，本地文件的查找与打开。作为一个使用过windows，Linux, macOS系统的我来说，我是极为推崇使用macOS来进行科研工作的(主要为文献阅读，论文编辑，Matlab等常用软件编程)。在apple的所有系列产品中，通过我的使用体验，apple的笔记本是最具有工作效率的。下面我来介绍macOS下科研工作常用到的、能提升工作效率的一些软件操作。</p>
<a id="more"></a>
<hr>
<h2 id="Software"><a href="#Software" class="headerlink" title="Software"></a>Software</h2><h3 id="Alfred"><a href="#Alfred" class="headerlink" title="Alfred"></a>Alfred</h3><p>我们将通过通用(General)、特征(Features)、工作流(Workflows)、外观(Appearance)四个方面来介绍其中常用的功能：</p>
<ul>
<li>General<br>我一般都是开机自启动，唤出的快捷键为<code>Ctrl+Space</code>，设置如下图1：<br><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20200930/20200930_fig001.jpg" width="800" height="450" title="图1" alt="图1" ></li>
</ul>
<ul>
<li><p>Features</p>
<ul>
<li><p>默认设置(Default Results)<br>这里默认就行，唯一需要改变的是右下角按钮<code>Setup fallback results</code>中设置百度为默认搜索引擎，毕竟谷歌时常不工作。设置如下图2:<br><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20200930/20200930_fig002.jpg" width="800" height="450" title="图2" alt="图2" ></p>
</li>
<li><p>文件搜索(File Search)<br>使用默认设置就可以了，如图3:</p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20200930/20200930_fig003.jpg" width="800" height="450" title="图3" alt="图3" >最常用的就是命令<code>open</code> 和 <code>find</code> 。前者用来直接打开文件，后者用来打开文件所在目录。操作见图4，5:</p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20200930/20200930_fig004.jpg" width="600" height="500" title="图4" alt="图4" ></p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20200930/20200930_fig005.jpg" width="600" height="500" title="图5" alt="图5" ><br>现在，我基本不用打开一层一层目录去找到我所需要的文件。</p>
</li>
<li><p>网页搜索(Web Search)<br>我们只需要直接输入<code>关键词+想要搜索的内容</code>，就可以直接打开浏览器并进行搜索。我们只需要添加常用的搜索，如百度搜索、ieee搜索、京东搜索、淘宝搜索以及github搜索。设置如图6:<br><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20200930/20200930_fig006.jpg" width="600" height="150" title="图6" alt="图6" ><br>效果如图7所示：<br><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20200930/20200930_fig007.jpg" width="800" height="450" title="图7" alt="图7" ></p>
<p>关于如何设置这些搜索方式，详细可以网上自行搜索。在默认设置(Default Results)中，我们设置了默认搜索引擎为百度搜索，这样我们可以不用输入关键词，也可以进行百度搜索。</p>
</li>
</ul>
</li>
</ul>
<p>​    </p>
<ul>
<li>Workflows<br>工作流是一个十分好的功能，使用Workflow需要购买Powerpack(这也是我第一次购买正版软件，主要是害怕在美国不让用盗版)，即购买后才能使用这个高级功能。我安装的工作流如图8所示：<br><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20200930/20200930_fig008.jpg" width="800" height="450" title="图8" alt="图8" ></li>
</ul>
<p>  官网上有一些经典的<a href="https://www.alfredapp.com/workflows/" target="_blank" rel="noopener">workflow</a> , 还有<a href="http://alfredworkflow.com/" target="_blank" rel="noopener">http://alfredworkflow.com/</a> 上列举了许多workflow插件，大家可以根据自己的喜好来选择。  目前，我还经常使用到的有Find Folder、 Open with MacVim、  Simple Screenshots、  YouDao，下面我来逐一介绍：</p>
<ul>
<li><p>Find Folder<br>如图9所示，我设置的关键词为folder，当在Alfred搜索栏中输入 <code>folder+目录名</code>时，即可出现我们要寻找的目录，如图10所示：<br><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20200930/20200930_fig009.jpg" width="800" height="450" title="图9" alt="图9" ><br><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20200930/20200930_fig010.jpg" width="600" height="500" title="图10" alt="图10" ></p>
</li>
<li><p><a href="https://github.com/franzheidl/alfred-workflows/tree/master/open-with-macvim" target="_blank" rel="noopener">Open with MacVim</a><br>如图11，设置的关键词为mvim，选择需要打开的文件，在Alfred搜索栏中输入 <code>mvim</code>并回车时，即可用MacVIM打开该文件。不过，我一般都使用热键<code>Ctrl+m</code>直接使用MacVim打开选中的文件。<br><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20200930/20200930_fig011.jpg" width="800" height="450" title="图11" alt="图11" ></p>
</li>
<li><p>Simple Screenshots<br>如图12，设置关键词为ss或ssc，在Alfred搜索栏中输入 <code>ss</code>或者<code>ssc</code>后：<code>Enter</code>截取全屏；<code>Ctrl+Enter</code>截图窗口；<code>Alt+Enter</code>自行选择矩形区域截图。截图会保存在系统粘贴板中。这样截图就十分方便，不用专门打开截图app。对于截图app，腾讯出品的<a href="https://jietu.qq.com/" target="_blank" rel="noopener">截图</a>还不错。<br><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20200930/20200930_fig012.jpg" width="800" height="450" title="图12" alt="图12" ></p>
</li>
<li><p>YouDao<br>如图13，设置关键词为<code>yd</code>，在Alfred搜索栏中输入 <code>yd+单词</code>,就可以查看意思了，然后<code>Enter</code>就可以复制翻译到粘贴板中，或则<code>Shift+Enter</code>打开有道单词网页查词，如图13所示：<br><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20200930/20200930_fig013.jpg" width="800" height="450" title="图13" alt="图13" ><br><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20200930/20200930_fig014.jpg" width="600" height="500" title="图14" alt="图14" ></p>
<p>除此之外，我还设置了热键<code>Alt+y</code>可以直接对选中的单词进行查询，这对阅读英文文献时特别管用。一般来说，能够选中单词的，我都使用热键，其他情况只有自己在搜索栏中输入单词了。</p>
</li>
</ul>
<ul>
<li>Appearance<br>如图15，我选的是Alfred macOS Dark，感觉还不错，与电脑本身的颜色比较契合。<br><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20200930/20200930_fig015.jpg" width="800" height="450" title="图15" alt="图15" ></li>
</ul>
<hr>
<hr>
<h3 id="BetterTouchTool"><a href="#BetterTouchTool" class="headerlink" title="BetterTouchTool"></a>BetterTouchTool</h3><p>从15年开始，我就基本没有使用过鼠标了。之前使用thinkpad，用的是小红点键盘。这两年使用MacOS，用的是magic trackpad。对于使用magic trackpad，我只使用过触摸板软件<a href="https://www.better365.cn/bab.html" target="_blank" rel="noopener">Better And Better</a> 和 BetterTouchTool。其中前者是国人编写的免费软件，后者是需要购买的。我一开始使用的是Better And Better，但是经常容易出现bug，我就又用我discover信用卡剩余的bonus购买了<a href="https://folivora.ai/" target="_blank" rel="noopener">BetterTouchTool</a>。下面我介绍一下在BetterTouchTool中我的常用手势设置。</p>
<ul>
<li><p>Finder<br>如图16，我主要设置的手势有三指左右滑(上下级目录)，双指左右轻拍(返回、前进):<br><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20200930/20200930_fig016.jpg" width="800" height="450" title="图16" alt="图16" ></p>
</li>
<li><p>Google Chrome<br>如图17，我主要设置的手势有三指左右滑(当前页面返回、前进)，双指左右轻拍(前、后一个标签页)，双指双击(关闭当前页面):<br><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20200930/20200930_fig017.jpg" width="800" height="450" title="图17" alt="图17" ></p>
</li>
<li><p>PDF Expert<br>如图17，我主要设置的手势有双指左右轻拍(前、后一个标签页):<br><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20200930/20200930_fig018.jpg" width="800" height="450" title="图18" alt="图18" ></p>
<p>Matlab，Sublime Text也是类似的设置，这里不在赘述。</p>
</li>
</ul>
<p>上述三个软件，是我在工作科研中最常用到的，经过上述手势设置，极大的简化了我工作流程，提升了工作效率。</p>
<hr>
<h3 id="Karabiner-Elements"><a href="#Karabiner-Elements" class="headerlink" title="Karabiner-Elements"></a>Karabiner-Elements</h3><p>之前没有使用这个软件，自从有了HHKB键盘，方向键十分别扭，使用这个改键工具后完美解决60键盘的问题。我的主要设置如图19：<br><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20200930/20200930_fig019.jpg" width="800" height="450" title="图19" alt="图19" ></p>
<p>我们是通过左下角的Add rule按钮，然后点击Import more rules from the Internet，就会打开一些可以导入的规则的<a href="https://ke-complex-modifications.pqrs.org/" target="_blank" rel="noopener">网页</a>，如图20。从该网页就可以选择你想要的功能，如果不满足你的需求，你可以自己定义规则。<br><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20200930/20200930_fig020.jpg" width="800" height="450" title="图20" alt="图20" ></p>
<p>图19所示的4个规则介绍如下：</p>
<ul>
<li>Mouse Keys Mode v4主要是利用键盘来控制鼠标的移动，单击功能；</li>
<li>Post caps_lock 表示当单击左手Ctrl键时，表示时按下的大小写切换键caps。在HHKB中，Ctrl键正好在正常键盘caps_lock的键位，在MacOS中，caps是用于切换中英文的。所以这条映射规则可以实现单击ctrl实现切换中英文输入法的作用；</li>
<li>Change Contrl + hjkl to Arrows用于使用Ctrl+hjkl来实现正常键盘的上下左右按键功能。在HHKB中，使用自带的Fn来使用上下左右是十分不方便的；</li>
<li>Toggle caps_lock by pressing 可以实现同时按下左右shift键来切换中英文输入法，当同时按下shift 时间较长时，就相当于锁定英文大写。</li>
</ul>
<hr>
<h3 id="NutStore"><a href="#NutStore" class="headerlink" title="NutStore"></a>NutStore</h3><p>坚果云是我用于科研工作同步的云同步工具。使用它的主要原因一方面是因为百度云限速，另一方面是因为苹果的icloud好像只能通过Document文件夹，不能自己选择需要同步的文件夹。但是，免费使用坚果云每个月都有上传(1G/月)和下载流量(3G/月)限制，不过对于科研工作常用于同步的pdf文件已经足够了。一般来说，云同步功能没有啥用，不过坚果云在疫情期间帮助了我的大忙。当初计划的就是回家一周，就没有带科研资料回家，后来因为疫情原因，在家待了5个月。所幸是有坚果云帮我同步了科研工作资料，才让我能够继续工作。这也让我吸取了教训，以后回家不管几天，也要带上工作资料。</p>
<h3 id="iStat-Menus"><a href="#iStat-Menus" class="headerlink" title="iStat Menus"></a>iStat Menus</h3><p>这是一款非常好用的系统监控工具，是我在9to5Toys上买的一个软件集合。当时花了25.5美金，比较有用的软件是PDF Expert, IStat Menus, Fantastical 2这三款软件。如图21所示：<br><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20200930/20200930_fig021.jpg" width="350" height="500" title="图21" alt="图21" ></p>
<p>上面可以显示非常多的东西，不过上面的天气显示需要额外花钱购买。该软件的显示信息可定制化程度非常高，用户可以根据自己喜好自定义。</p>
<hr>
<p>尽管上述的功能在windows和linux上也能通过一些软件和方法实现，在我看来，其体验是不够好的。如果你不玩电脑游戏，苹果笔记本可能是最好的选择。当然，如果你必要的专业软件只能在windows下运行，那么thinkpad是不错的选择，毕竟小红点也是不错的。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>Algorithm Design</tag>
      </tags>
  </entry>
  <entry>
    <title>【Vim】Vim常用配置&lt;二&gt;</title>
    <url>/2020/08/05/%5B20200805%5D/</url>
    <content><![CDATA[<p>在前面的文章《<a href="https://blog.csdn.net/tengweitw/article/details/103759321" target="_blank" rel="noopener">使用Vim撰写科研论文</a>》和《<a href="https://tengweitw.blog.csdn.net/article/details/107737921" target="_blank" rel="noopener">Vim常用配置&lt;一&gt;</a>》中，我们介绍了一些较为实用的vim插件的安装和使用。这篇文章介绍一下，最基础普适的设置，主要分为：一般性设置，键位设置。</p>
<a id="more"></a>
<ul>
<li><p>一般性设置</p>
<ul>
<li><p>设置显示行号</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">" set line number</span><br><span class="line">set number</span><br><span class="line">set numberwidth=4</span><br><span class="line">set relativenumber</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置光标</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">"Keep the cursor above the bottom by 7 lines</span><br><span class="line">set scrolloff=7</span><br><span class="line">set cursorcolumn</span><br><span class="line">set cursorline</span><br></pre></td></tr></table></figure>
</li>
<li><p>光标颜色设置</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">" Visual Mode Orange Background, Black Text</span><br><span class="line">hi Visual          guifg=DarkGreen guibg=#DDDDDD</span><br><span class="line"></span><br><span class="line">" Default Colors for CursorLine</span><br><span class="line">highlight CursorLine guibg=#3E3D32</span><br><span class="line">highlight Cursor guibg=#A6E22E;</span><br><span class="line"></span><br><span class="line">" Change Color when entering Insert Mode</span><br><span class="line">autocmd InsertEnter * highlight  CursorLine guibg=#323D3E</span><br><span class="line">autocmd InsertEnter * highlight  Cursor guibg=#00AAFF;</span><br><span class="line"></span><br><span class="line">" Revert Color to default when leaving Insert Mode</span><br><span class="line">autocmd InsertLeave * highlight  CursorLine guibg=#3E3D32</span><br><span class="line">autocmd InsertLeave * highlight  Cursor guibg=#A6E22E;</span><br></pre></td></tr></table></figure>
</li>
<li><p>宽度设置</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">"Set the height and weight for vim form</span><br><span class="line">set lines=35 columns=118</span><br><span class="line"></span><br><span class="line">" the width of tab is 4 space</span><br><span class="line">set tabstop=4</span><br><span class="line">" the width of autoindent is 4 space</span><br><span class="line">set sw=4</span><br><span class="line">set noexpandtab</span><br><span class="line">set autoindent</span><br><span class="line">" set smartindent</span><br><span class="line">" Highlight the search results, use :noh to cancel</span><br><span class="line">set hlsearch</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>键位设置</p>
<ul>
<li><p>组合命令前缀设置</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">let mapleader = ","</span><br></pre></td></tr></table></figure>
<p>这个键基本是用的很频繁的，所以我们设置在键盘上方便触及的地方。</p>
</li>
<li><p>行间跳转</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">"To move in one long line</span><br><span class="line">nnoremap k gk</span><br><span class="line">nnoremap gk k</span><br><span class="line">nnoremap j gj</span><br><span class="line">nnoremap gj j</span><br><span class="line">vnoremap k gk</span><br><span class="line">vnoremap gk k</span><br><span class="line">vnoremap j gj</span><br><span class="line">vnoremap gj j</span><br></pre></td></tr></table></figure>
<p>上述命令就是将行间移动和行内移动进行对调。</p>
</li>
<li><p>自定义快捷键</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">inoremap jk &lt;esc&gt;</span><br><span class="line">"To move to the beginning or end</span><br><span class="line">nnoremap H ^</span><br><span class="line">nnoremap L $</span><br></pre></td></tr></table></figure>
<p>原来的键位<code>esc</code>, <code>^</code>, <code>$</code> 手指都需要移动较远距离来点击。之所以选择<code>jk</code>来返回到命令模式，主要原因是，一方面在编辑模式下，以<code>jk</code>开头的英文单词很少；另一方面，在命令模式下，<code>j,k</code> 只是上下移动的命令，并不会修改文本内容。</p>
</li>
<li><p>编辑.vimrc快捷键设置</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nnoremap &lt;leader&gt;ev :vsplit $MYVIMRC&lt;cr&gt;</span><br><span class="line">"-------Choose one for execute the vimrc file when it's saved</span><br><span class="line">nnoremap &lt;leader&gt;sv :source $MYVIMRC&lt;cr&gt;</span><br><span class="line">autocmd BufWritePost $MYVIMRC source $MYVIMRC</span><br></pre></td></tr></table></figure>
<p>这样我们可以通过命令<code>&lt;leader&gt;ev</code>打开配置文件，通过命令<code>&lt;leader&gt;sv</code>来使之生效。当然，我们可以直接保存该文件使之生效。</p>
</li>
</ul>
</li>
</ul>
<hr>
<p>至此，我们完成了.vimrc配置文件的全部讲解，下面给出完整的.vimrc文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">set nocompatible              " be iMproved, required</span><br><span class="line">filetype on                  " required</span><br><span class="line">" set the runtime path to include Vundle and initialize</span><br><span class="line">set rtp+=~/.vim/bundle/Vundle.vim</span><br><span class="line">call vundle#begin()</span><br><span class="line">" alternatively, pass a path where Vundle should install plugins</span><br><span class="line">"call vundle#begin('~/some/path/here')</span><br><span class="line"></span><br><span class="line">" let Vundle manage Vundle, required</span><br><span class="line">Plugin 'VundleVim/Vundle.vim'</span><br><span class="line">Plugin 'lervag/vimtex'</span><br><span class="line">Plugin 'vim-airline/vim-airline'</span><br><span class="line">Plugin 'vim-airline/vim-airline-themes'</span><br><span class="line">Bundle 'kien/ctrlp.vim'</span><br><span class="line">Plugin 'altercation/vim-colors-solarized'</span><br><span class="line"> "A Vim Plugin for Lively Previewing LaTeX PDF Output</span><br><span class="line">Plugin 'xuhdev/vim-latex-live-preview'</span><br><span class="line">Plugin 'rking/ag.vim'</span><br><span class="line">Plugin 'scrooloose/nerdtree'</span><br><span class="line">Plugin 'ryanoasis/vim-devicons'</span><br><span class="line">Plugin 'tiagofumo/vim-nerdtree-syntax-highlight'</span><br><span class="line">Plugin 'sirver/ultisnips'</span><br><span class="line">Plugin 'honza/vim-snippets'</span><br><span class="line">Plugin 'tpope/vim-surround'</span><br><span class="line">Plugin 'skywind3000/asyncrun.vim' "for running C</span><br><span class="line">Plugin 'scrooloose/nerdcommenter'</span><br><span class="line">Plugin 'Yggdroot/indentLine'</span><br><span class="line">Plugin 'majutsushi/tagbar'</span><br><span class="line">Plugin 'KeitaNakamura/tex-conceal.vim'</span><br><span class="line">Plugin 'vim-scripts/indentpython.vim'</span><br><span class="line">call vundle#end()            " required</span><br><span class="line">filetype plugin indent on    " required</span><br><span class="line"></span><br><span class="line">"----------------General Configurations----------------</span><br><span class="line">set encoding=UTF-8</span><br><span class="line">"To show icons</span><br><span class="line">set guifont=DroidSansMono_Nerd_Font:h16</span><br><span class="line"></span><br><span class="line">" set line number</span><br><span class="line">set number</span><br><span class="line">set numberwidth=4</span><br><span class="line">set relativenumber</span><br><span class="line"></span><br><span class="line">" set the theme</span><br><span class="line">set t_Co=256</span><br><span class="line">set background=dark</span><br><span class="line">colorscheme solarized</span><br><span class="line"></span><br><span class="line">let g:ag_prg="&lt;/usr/local/bin/&gt; --vimgrep"</span><br><span class="line"></span><br><span class="line">"Set the height and weight for vim form</span><br><span class="line">set lines=35 columns=118</span><br><span class="line"></span><br><span class="line">" the width of tab is 4 space</span><br><span class="line">set tabstop=4</span><br><span class="line">" the width of autoindent is 4 space</span><br><span class="line">set sw=4</span><br><span class="line">set noexpandtab</span><br><span class="line">set autoindent</span><br><span class="line">" set smartindent</span><br><span class="line">" Highlight the search results, use :noh to cancel</span><br><span class="line">set hlsearch</span><br><span class="line"></span><br><span class="line">syntax enable</span><br><span class="line">syntax on</span><br><span class="line"></span><br><span class="line">"Set the transparency of the vim</span><br><span class="line">set transparency=2  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">"Keep the cursor above the bottom by 7 lines</span><br><span class="line">set scrolloff=7</span><br><span class="line">set cursorcolumn</span><br><span class="line">set cursorline</span><br><span class="line"></span><br><span class="line">" " Visual Mode Orange Background, Black Text</span><br><span class="line">" hi Visual          guifg=DarkGreen guibg=#DDDDDD</span><br><span class="line"></span><br><span class="line">" " Default Colors for CursorLine</span><br><span class="line">" highlight CursorLine guibg=#3E3D32</span><br><span class="line">" highlight Cursor guibg=#A6E22E;</span><br><span class="line"></span><br><span class="line">" " Change Color when entering Insert Mode</span><br><span class="line">" autocmd InsertEnter * highlight  CursorLine guibg=#323D3E</span><br><span class="line">" autocmd InsertEnter * highlight  Cursor guibg=#00AAFF;</span><br><span class="line"></span><br><span class="line">" " Revert Color to default when leaving Insert Mode</span><br><span class="line">" autocmd InsertLeave * highlight  CursorLine guibg=#3E3D32</span><br><span class="line">" autocmd InsertLeave * highlight  Cursor guibg=#A6E22E;</span><br><span class="line"></span><br><span class="line">set spelllang=en_us</span><br><span class="line">set spell</span><br><span class="line"></span><br><span class="line">"-----------------Key Mapping------------------</span><br><span class="line">let mapleader = ","</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">"To move in one long line</span><br><span class="line">nnoremap k gk</span><br><span class="line">nnoremap gk k</span><br><span class="line">nnoremap j gj</span><br><span class="line">nnoremap gj j</span><br><span class="line">vnoremap k gk</span><br><span class="line">vnoremap gk k</span><br><span class="line">vnoremap j gj</span><br><span class="line">vnoremap gj j</span><br><span class="line"></span><br><span class="line">inoremap jk &lt;esc&gt;</span><br><span class="line">"To move to the beginning or end</span><br><span class="line">nnoremap H ^</span><br><span class="line">nnoremap L $</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">nnoremap &lt;leader&gt;ev :vsplit $MYVIMRC&lt;cr&gt;</span><br><span class="line">"-------Choose one for execute the vimrc file when it's saved</span><br><span class="line">nnoremap &lt;leader&gt;sv :source $MYVIMRC&lt;cr&gt;</span><br><span class="line">autocmd BufWritePost $MYVIMRC source $MYVIMRC</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">"Set the airline's theme</span><br><span class="line">let g:airline_theme="solarized"</span><br><span class="line"></span><br><span class="line">"----------------Configuration for LaTeX---------------"</span><br><span class="line">"Type help vimtex for detailed information</span><br><span class="line">let g:tex_flavor='latex'</span><br><span class="line">let g:vimtex_view_method='skim' "Use Skim as the pdf viewer</span><br><span class="line">let g:vimtex_view_automatic=1</span><br><span class="line">let g:vimtex_quickfix_mode=2</span><br><span class="line">let g:vimtex_quickfix_autoclose_after_keystrokes=1</span><br><span class="line">set conceallevel=2</span><br><span class="line">let g:tex_conceal='abdmg'</span><br><span class="line">let g:vimtex_quickfix_autojump=1</span><br><span class="line">let g:vimtex_compiler_latexmk = &#123;</span><br><span class="line">    \ 'options' : [</span><br><span class="line">    \   '-xelatex',</span><br><span class="line">    \   '-verbose',</span><br><span class="line">    \   '-file-line-error',</span><br><span class="line">    \   '-synctex=1',</span><br><span class="line">    \   '-interaction=nonstopmode',</span><br><span class="line">    \ ],</span><br><span class="line">    \&#125;</span><br><span class="line"></span><br><span class="line">let g:vimtex_complete_ignore_case=1</span><br><span class="line">let g:vimtex_complete_close_braces=1</span><br><span class="line"></span><br><span class="line">"In insert mode show the details, show the math equations othewise</span><br><span class="line">autocmd FileType tex inoremap jk &lt;esc&gt;:set conceallevel=0&lt;cr&gt;</span><br><span class="line">autocmd FileType tex nnoremap i :set conceallevel=0&lt;cr&gt;i</span><br><span class="line">autocmd FileType tex nnoremap s :set conceallevel=0&lt;cr&gt;s</span><br><span class="line">autocmd FileType tex nnoremap a :set conceallevel=0&lt;cr&gt;a</span><br><span class="line">autocmd Filetype tex setlocal nofoldenable</span><br><span class="line"></span><br><span class="line">"-------set the shortcuts for compiling, viewing, and cleaning .tex files</span><br><span class="line">autocmd FileType tex nmap &lt;leader&gt;b  \ll</span><br><span class="line">autocmd FileType tex nmap &lt;leader&gt;v \lv</span><br><span class="line">autocmd FileType tex  nmap &lt;leader&gt;c \lc</span><br><span class="line">autocmd FileType tex nmap &lt;leader&gt;t \lt</span><br><span class="line"></span><br><span class="line">"Trigger the autocompletion for \cite and \ref in latex</span><br><span class="line">imap &lt;leader&gt;&lt;tab&gt; &lt;C-X&gt;&lt;C-O&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">"----------Settings for xuhdev/vim-latex-live-preview</span><br><span class="line">autocmd Filetype tex setl updatetime=15 "To set the update time for live view</span><br><span class="line">let g:livepreview_previewer='open -a skim'</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">"-------Shortcuts for the plugin tpope/vim-surround</span><br><span class="line">nmap &lt;leader&gt;) ysiw)</span><br><span class="line">nmap &lt;leader&gt;&#125; ysiw&#125;</span><br><span class="line">nmap &lt;leader&gt;" ysiw"</span><br><span class="line"></span><br><span class="line">"-------Shortcuts for the plugin ctrlp</span><br><span class="line">let g:ctrlp_map = '&lt;c-p&gt;'</span><br><span class="line">let g:ctrlp_cmd = 'CtrlP'</span><br><span class="line">let g:ctrlp_by_filename=1</span><br><span class="line">"set the types of files that can be ignored</span><br><span class="line">let g:ctrlp_custom_ignore = &#123;</span><br><span class="line">    \ 'dir':  '\v[\/]\.(git|hg|svn|rvm)$',</span><br><span class="line">    \ 'file': '\v\.(exe|so|dll|zip|tar|tar.gz|pyc)$',</span><br><span class="line">    \ &#125;</span><br><span class="line"></span><br><span class="line">"-------Settings for NERDTree</span><br><span class="line">autocmd StdinReadPre * let s:std_in=1</span><br><span class="line">autocmd VimEnter * if argc() == 0 &amp;&amp; !exists("s:std_in") | NERDTree | endif</span><br><span class="line">autocmd vimenter * NERDTree</span><br><span class="line">"Close vim when the NERDTree is the only window</span><br><span class="line">autocmd bufenter * if (winnr("$") == 1 &amp;&amp; exists("b:NERDTree") &amp;&amp; b:NERDTree.isTabTree()) | q | endif</span><br><span class="line"></span><br><span class="line">"To update the NERDTree when change the Tab by gt</span><br><span class="line">nnoremap gt gt:NERDTreeFind&lt;CR&gt;&lt;C-w&gt;l </span><br><span class="line">" Open or close the NERDTree </span><br><span class="line">nmap &lt;C-e&gt; :NERDTreeToggle&lt;CR&gt;</span><br><span class="line">let NERDTreeIgnore=['\.pyc','\~$','\.swp']</span><br><span class="line"></span><br><span class="line">let g:NERDTreeShowLineNumbers=1</span><br><span class="line"></span><br><span class="line">" NERDTress File highlighting</span><br><span class="line">"Set the vim-devicons</span><br><span class="line">"vim-nerdtree-syntax-highlight settings</span><br><span class="line">""""""""""""""""""""""""""""""</span><br><span class="line">let g:WebDevIconsDisableDefaultFolderSymbolColorFromNERDTreeDir = 1</span><br><span class="line">let g:WebDevIconsDisableDefaultFileSymbolColorFromNERDTreeFile = 1</span><br><span class="line">" not to show brackets around flags</span><br><span class="line">let g:webdevicons_conceal_nerdtree_brackets = 1</span><br><span class="line">" enable folder/directory glyph flag (disabled by default with 0)</span><br><span class="line">let g:WebDevIconsUnicodeDecorateFolderNodes = 1</span><br><span class="line">" enable open and close folder/directory glyph flags (disabled by default with 0)</span><br><span class="line">let g:DevIconsEnableFoldersOpenClose = 1</span><br><span class="line">" use double-width(1) or single-width(0) glyphs</span><br><span class="line">" only manipulates padding, has no effect on terminal or set(guifont) font</span><br><span class="line">let g:WebDevIconsUnicodeGlyphDoubleWidth = 0</span><br><span class="line">" Force extra padding in NERDTree so that the filetype icons line up vertically</span><br><span class="line">let g:WebDevIconsNerdTreeGitPluginForceVAlign = 1</span><br><span class="line"></span><br><span class="line">augroup custom_nerdtree_options</span><br><span class="line">    autocmd!</span><br><span class="line">    autocmd FileType,WinEnter * :call &lt;SID&gt;SetNerdTreeOptions()</span><br><span class="line">augroup END</span><br><span class="line"></span><br><span class="line">function! s:SetNerdTreeOptions() abort</span><br><span class="line">    if &amp;l:filetype ==# 'nerdtree'</span><br><span class="line">        let g:default_opts = &#123;</span><br><span class="line">                    \   'ambiwidth': &amp;ambiwidth,</span><br><span class="line">                    \   'listchars': &amp;listchars,</span><br><span class="line">                    \   'list'     : &amp;l:list,</span><br><span class="line">                    \ &#125;</span><br><span class="line">        setlocal ambiwidth=double listchars=space:. nolist</span><br><span class="line">    else</span><br><span class="line">        if exists('g:default_opts')</span><br><span class="line">            let [&amp;ambiwidth, &amp;listchars, &amp;l:list] = [</span><br><span class="line">                        \   g:default_opts.ambiwidth,</span><br><span class="line">                        \   g:default_opts.listchars,</span><br><span class="line">                        \   g:default_opts.list</span><br><span class="line">                        \ ]</span><br><span class="line">            unlet g:default_opts</span><br><span class="line">        endif</span><br><span class="line">    endif</span><br><span class="line">endfunction</span><br><span class="line"></span><br><span class="line">"Highlight full name (not only icons). You need to add this if you don't have vim-devicons and want highlight.</span><br><span class="line">let g:NERDTreeFileExtensionHighlightFullName = 1</span><br><span class="line">let g:NERDTreeExactMatchHighlightFullName = 1</span><br><span class="line">let g:NERDTreePatternMatchHighlightFullName = 1</span><br><span class="line"></span><br><span class="line">"Highlight full name (not only icons). You need to add this if you don't have vim-devicons and want highlight.</span><br><span class="line">let g:NERDTreeHighlightFolders = 1</span><br><span class="line"></span><br><span class="line">"highlights the folder name</span><br><span class="line">let g:NERDTreeHighlightFoldersFullName = 1</span><br><span class="line"></span><br><span class="line">"you can add these colors to your .vimrc to help customizing</span><br><span class="line">let s:brown = "905532"</span><br><span class="line">let s:aqua =  "3AFFDB"</span><br><span class="line">let s:blue = "689FB6"</span><br><span class="line">let s:darkBlue = "44788E"</span><br><span class="line">let s:purple = "834F79"</span><br><span class="line">let s:lightPurple = "834F79"</span><br><span class="line">let s:red = "AE403F"</span><br><span class="line">let s:beige = "F5C06F"</span><br><span class="line">let s:yellow = "F09F17"</span><br><span class="line">let s:orange = "D4843E"</span><br><span class="line">let s:darkOrange = "F16529"</span><br><span class="line">let s:pink = "CB6F6F"</span><br><span class="line">let s:salmon = "EE6E73"</span><br><span class="line">let s:green = "8FAA54"</span><br><span class="line">let s:Turquoise = "40E0D0"</span><br><span class="line">let s:lightGreen = "31B53E"</span><br><span class="line">let s:white = "FFFFFF"</span><br><span class="line">let s:rspec_red = "FE405F"</span><br><span class="line">let s:git_orange = "F54D27"</span><br><span class="line">let s:gray = "808A87"</span><br><span class="line"></span><br><span class="line">let g:NERDTreeExtensionHighlightColor = &#123;&#125; " this line is needed to avoid error</span><br><span class="line">let g:NERDTreeExtensionHighlightColor['py'] = s:orange " sets the color of py files to blue</span><br><span class="line">let g:NERDTreeExtensionHighlightColor['tex'] = s:yellow " sets the color of tex files to blue</span><br><span class="line">let g:NERDTreeExtensionHighlightColor['c'] = s:green " sets the color of c files to blue</span><br><span class="line">let g:NERDTreeExtensionHighlightColor['pdf'] = s:beige " sets the color of pdf files to blue</span><br><span class="line">let g:NERDTreeExtensionHighlightColor['c++'] = s:green " sets the color of c++ files to blue</span><br><span class="line"></span><br><span class="line">"---------------settings for the nerdcommenter--------------------------------"</span><br><span class="line">" Add a space before comments</span><br><span class="line">let g:NERDSpaceDelims=1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">"---------------configurations for the plugin ultisnips--------------------"</span><br><span class="line">let g:UltiSnipsExpandTrigger = '&lt;tab&gt;'</span><br><span class="line">let g:UltiSnipsJumpForwardTrigger = '&lt;tab&gt;'</span><br><span class="line">let g:UltiSnipsJumpBackwardTrigger = '&lt;s-tab&gt;'</span><br><span class="line"></span><br><span class="line">"---------------settings for the plugin asyncrun---------------------------"</span><br><span class="line">let g:asyncrun_open =6</span><br><span class="line">let g:asyncrun_bell =1</span><br><span class="line">let g:asyncrun_rootmarks = ['.svn', '.git', '.root', '_darcs', 'build.xml'] </span><br><span class="line"></span><br><span class="line">"call for the quickfix window</span><br><span class="line">autocmd FileType c,cpp nnoremap &lt;leader&gt;c :call asyncrun#quickfix_toggle(6)&lt;cr&gt;</span><br><span class="line">"Shortcuts for compiling and run the c file</span><br><span class="line">autocmd FileType c,cpp nnoremap &lt;silent&gt; &lt;leader&gt;b :AsyncRun -cwd=&lt;root&gt;  make &lt;cr&gt;</span><br><span class="line">autocmd FileType c,cpp nnoremap &lt;silent&gt; &lt;leader&gt;r :AsyncRun  -cwd=&lt;root&gt; -raw make run &lt;cr&gt;</span><br><span class="line"></span><br><span class="line">"---------------Configurations for the plugin ctags-----------------------"</span><br><span class="line">let g:tagbar_ctags_bin='/usr/local/bin/ctags'</span><br><span class="line">let g:tagbar_width=30</span><br><span class="line">let g:tagbar_right=1</span><br><span class="line">"AutoOpen tagbar for c/c++ files</span><br><span class="line">autocmd BufReadPost *.cpp,*.c,*.h,*.hpp,*.cc call tagbar#autoopen()</span><br><span class="line">"Open or close tagbar</span><br><span class="line">map &lt;leader&gt;tb :TagbarToggle&lt;CR&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">"---------------Settings for the plugin indentline-----------------------"</span><br><span class="line">let g:indentLine_char='|'</span><br><span class="line">let g:indentLine_enabled=1</span><br><span class="line"></span><br><span class="line">"---------------Configurations for Python-------------------------------"</span><br><span class="line">set encoding=utf-8</span><br><span class="line">au BufNewFile,BufRead *.py set tabstop=4 |set softtabstop=4|set shiftwidth=4|set textwidth=79|set expandtab|set autoindent|set fileformat=unix</span><br><span class="line">set clipboard=unnamed</span><br><span class="line"></span><br><span class="line">let python_highlight_all=1</span><br><span class="line"></span><br><span class="line">function CheckPythonSyntax() </span><br><span class="line">    let mp = &amp;makeprg </span><br><span class="line">    let ef = &amp;errorformat </span><br><span class="line">    let exeFile = expand("%:t") </span><br><span class="line">    setlocal makeprg=python3\ -u  </span><br><span class="line">    set efm=%C\ %.%#,%A\ \ File\ \"%f\"\\,\ line\ %l%.%#,%Z%[%^\ ]%\\@=%m </span><br><span class="line">    silent make %</span><br><span class="line">    copen </span><br><span class="line">   let &amp;makeprg     = mp  </span><br><span class="line">    let &amp;errorformat = ef  </span><br><span class="line">endfunction</span><br><span class="line">au filetype python map &lt;leader&gt;b  :w &lt;cr&gt; :call CheckPythonSyntax() &lt;cr&gt; :cw&lt;cr&gt;</span><br></pre></td></tr></table></figure><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>Vim</tag>
      </tags>
  </entry>
  <entry>
    <title>【Vim】Vim常用配置&lt;一&gt;</title>
    <url>/2020/08/01/%5B20200801%5D/</url>
    <content><![CDATA[<p>疫情在家期间，也在新电脑上准备用vim写科研论文。但是之前配置好的.vimrc文件中的配置在实验室的电脑上，我自己又懒得再配置一遍，于是作罢，选择了sublime来进行科研写作，顺便写了一篇《使用Sublime Text3撰写科研论文》。现在已经在实验室了，于是乎我将我的vim配置文件介绍介绍，放在网上，以防万一。同时，也给有需要的人借鉴参考。虽然去年在文章《使用Vim撰写科研论文》介绍了如何利用vim编写论文，只是介绍了与LaTex相关的插件。这里，我们将介绍一般性的编辑工作所需要的配置。</p>
<hr>
<a id="more"></a>
<h2 id="状态栏设置"><a href="#状态栏设置" class="headerlink" title="状态栏设置"></a>状态栏设置</h2><p>安装插件代码如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Plugin 'vim-airline/vim-airline'</span><br><span class="line">Plugin 'vim-airline/vim-airline-themes'</span><br></pre></td></tr></table></figure>
<p>然后，我们可以在主题中选择颜色样式，主题列表见<a href="https://github.com/vim-airline/vim-airline-themes/tree/master/autoload/airline/themes" target="_blank" rel="noopener">链接</a>。可使用如下命令指定主题：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">let g:airline_theme="solarized"</span><br></pre></td></tr></table></figure>
<p>呈现效果如图1:</p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20200801/20200801_fig001.jpg" width="600" height="80" title="图1" alt="图1" ></p>
<p>关于状态栏每个区域的含义可以见<a href="https://github.com/vim-airline/vim-airline" target="_blank" rel="noopener">vim-airline</a>的描述文件，这里不再赘述。</p>
<hr>
<h2 id="文件搜索"><a href="#文件搜索" class="headerlink" title="文件搜索"></a>文件搜索</h2><p>安装插件代码如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Bundle 'kien/ctrlp.vim'</span><br></pre></td></tr></table></figure>
<p>常用设置代码如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">"-------Shortcuts for the plugin ctrlp</span><br><span class="line">let g:ctrlp_map = '&lt;c-p&gt;'</span><br><span class="line">let g:ctrlp_cmd = 'CtrlP'</span><br><span class="line">let g:ctrlp_by_filename=1</span><br><span class="line">"set the types of files that can be ignored</span><br><span class="line">let g:ctrlp_custom_ignore = &#123;</span><br><span class="line">    \ 'dir':  '\v[\/]\.(git|hg|svn|rvm)$',</span><br><span class="line">    \ 'file': '\v\.(exe|so|dll|zip|tar|tar.gz|pyc)$',</span><br><span class="line">    \ &#125;</span><br></pre></td></tr></table></figure>
<p>这样我们可以通过<code>Ctrl+p</code>打开文件搜索，这时，我们可以通过<code>Ctrl+f</code>或者<code>Ctrl+b</code>在不同模式（mru, files, buffers）中选择，然后输入要搜索的文件名，如下图2：</p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20200801/20200801_fig002.jpg" width="600" height="280" title="图2" alt="图2" ></p>
<p>在搜索结果中，我们可以使用<code>Ctrl+j,k</code>来上下选择我们想要的文件，最后<code>enter</code>就可以打开该文件了。更多操作可见该项目的<a href="https://github.com/kien/ctrlp.vim" target="_blank" rel="noopener">说明文档</a>。</p>
<hr>
<h2 id="界面颜色设置"><a href="#界面颜色设置" class="headerlink" title="界面颜色设置"></a>界面颜色设置</h2><p>安装插件代码如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Plugin 'altercation/vim-colors-solarized'</span><br></pre></td></tr></table></figure>
<p>设置代码如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">set t_Co=256</span><br><span class="line">set background=dark</span><br><span class="line">colorscheme solarized</span><br></pre></td></tr></table></figure>
<p>这里我们设置为深色模式，比较契合MacOS的深色模式，如上图2所示。注意本文中的所有设置是针对MacVIM的，对于在终端使用vim(而不是gvim)打开的vim编辑器，会出现雾面现象，主要是颜色的支持问题，如下图所示：<br><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20200801/20200801_fig003.jpg" width="600" height="380" title="图3" alt="图3" ></p>
<p>还有，我们可以使用如下命令来设置界面的透明化程度：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">set transparency=2</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="树形目录插件"><a href="#树形目录插件" class="headerlink" title="树形目录插件"></a>树形目录插件</h2><p>安装插件代码如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Plugin 'scrooloose/nerdtree'</span><br></pre></td></tr></table></figure>
<p>设置代码如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">"-------Settings for NERDTree--------</span><br><span class="line">autocmd StdinReadPre * let s:std_in=1</span><br><span class="line">autocmd VimEnter * if argc() == 0 &amp;&amp; !exists("s:std_in") | NERDTree | endif</span><br><span class="line">autocmd vimenter * NERDTree</span><br><span class="line">"Close vim when the NERDTree is the only window</span><br><span class="line">autocmd bufenter * if (winnr("$") == 1 &amp;&amp; exists("b:NERDTree") &amp;&amp; b:NERDTree.isTabTree()) | q | endif</span><br><span class="line">let NERDTreeIgnore=['\.pyc','\~$','\.swp']</span><br><span class="line">let g:NERDTreeShowLineNumbers=1</span><br></pre></td></tr></table></figure>
<p>经过上述设置，每次打开一个新文件时，左侧都会有目录，效果如下图(目录中的图标和颜色设置会在下一小节中介绍)：</p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20200801/20200801_fig004.jpg" width="600" height="380" title="图4" alt="图4" ></p>
<p>但是，左侧的目录并不会随着打开的文件所在目录而更新。为此，我们可以添加如下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">"To update the NERDTree when change the Tab by gt</span><br><span class="line">nnoremap gt gt:NERDTreeFind&lt;CR&gt;&lt;C-w&gt;l</span><br></pre></td></tr></table></figure>
<p>这样我们可以通过<code>gt</code>来切换tab，同时更新左侧的目录。关于NERDTree的更多操作，可以直接在目录窗口，输入<code>?</code>来查看说明。</p>
<hr>
<h2 id="文件类型高亮"><a href="#文件类型高亮" class="headerlink" title="文件类型高亮"></a>文件类型高亮</h2><p>对于我们日常工作科研来说，常遇到的就是这几类文件：<code>.tex</code>， <code>.pdf</code>， <code>.c</code>， <code>.py</code>等等文件。为了在NERDTree目录中高亮显示，我们需要安装如下插件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Plugin 'ryanoasis/vim-devicons'</span><br><span class="line">Plugin 'tiagofumo/vim-nerdtree-syntax-highlight'</span><br></pre></td></tr></table></figure>
<p>其中，<code>vim-devicons</code>是给不同文件类型显示不同图标；<code>vim-nerdtree-syntax-highlight</code>是让不同类型文件显示不同颜色。</p>
<p>其常用设置如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">" NERDTress File highlighting</span><br><span class="line">"Set the vim-devicons</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">"Can be enabled or disabled</span><br><span class="line">"vim-nerdtree-syntax-highlight settings</span><br><span class="line">""""""""""""""""""""""""""""""</span><br><span class="line">let g:WebDevIconsDisableDefaultFolderSymbolColorFromNERDTreeDir = 1</span><br><span class="line">let g:WebDevIconsDisableDefaultFileSymbolColorFromNERDTreeFile = 1</span><br><span class="line">" not to show brackets around flags</span><br><span class="line">let g:webdevicons_conceal_nerdtree_brackets = 1</span><br><span class="line">" enable folder/directory glyph flag (disabled by default with 0)</span><br><span class="line">let g:WebDevIconsUnicodeDecorateFolderNodes = 1</span><br><span class="line">" enable open and close folder/directory glyph flags (disabled by default with 0)</span><br><span class="line">let g:DevIconsEnableFoldersOpenClose = 1</span><br><span class="line"></span><br><span class="line">" use double-width(1) or single-width(0) glyphs</span><br><span class="line">" only manipulates padding, has no effect on terminal or set(guifont) font</span><br><span class="line">let g:WebDevIconsUnicodeGlyphDoubleWidth = 0</span><br><span class="line">" Force extra padding in NERDTree so that the filetype icons line up vertically</span><br><span class="line">let g:WebDevIconsNerdTreeGitPluginForceVAlign = 1</span><br><span class="line"></span><br><span class="line">"Highlight full name (not only icons). You need to add this if you don't have vim-devicons and want highlight.</span><br><span class="line">let g:NERDTreeFileExtensionHighlightFullName = 1</span><br><span class="line">let g:NERDTreeExactMatchHighlightFullName = 1</span><br><span class="line">let g:NERDTreePatternMatchHighlightFullName = 1</span><br><span class="line"></span><br><span class="line">"Highlight full name (not only icons). You need to add this if you don't have vim-devicons and want highlight.</span><br><span class="line">let g:NERDTreeHighlightFolders = 1</span><br><span class="line"></span><br><span class="line">"highlights the folder name</span><br><span class="line">let g:NERDTreeHighlightFoldersFullName = 1</span><br><span class="line"></span><br><span class="line">"you can add these colors to your .vimrc to help customizing</span><br><span class="line">let s:brown = "905532"</span><br><span class="line">let s:aqua =  "3AFFDB"</span><br><span class="line">let s:blue = "689FB6"</span><br><span class="line">let s:darkBlue = "44788E"</span><br><span class="line">let s:purple = "834F79"</span><br><span class="line">let s:lightPurple = "834F79"</span><br><span class="line">let s:red = "AE403F"</span><br><span class="line">let s:beige = "F5C06F"</span><br><span class="line">let s:yellow = "F09F17"</span><br><span class="line">let s:orange = "D4843E"</span><br><span class="line">let s:darkOrange = "F16529"</span><br><span class="line">let s:pink = "CB6F6F"</span><br><span class="line">let s:salmon = "EE6E73"</span><br><span class="line">let s:green = "8FAA54"</span><br><span class="line">let s:Turquoise = "40E0D0"</span><br><span class="line">let s:lightGreen = "31B53E"</span><br><span class="line">let s:white = "FFFFFF"</span><br><span class="line">let s:rspec_red = "FE405F"</span><br><span class="line">let s:git_orange = "F54D27"</span><br><span class="line">let s:gray = "808A87"</span><br><span class="line"></span><br><span class="line">let g:NERDTreeExtensionHighlightColor = &#123;&#125; " this line is needed to avoid error</span><br><span class="line">let g:NERDTreeExtensionHighlightColor['py'] = s:orange " sets the color of py files to blue</span><br><span class="line">let g:NERDTreeExtensionHighlightColor['tex'] = s:yellow " sets the color of tex files to blue</span><br><span class="line">let g:NERDTreeExtensionHighlightColor['c'] = s:green " sets the color of c files to blue</span><br><span class="line">let g:NERDTreeExtensionHighlightColor['pdf'] = s:beige " sets the color of pdf files to blue</span><br><span class="line">let g:NERDTreeExtensionHighlightColor['c++'] = s:green " sets the color of c++ files to blue</span><br></pre></td></tr></table></figure>
<p>上述设置都是参考官方主页<a href="https://github.com/tiagofumo/vim-nerdtree-syntax-highlight" target="_blank" rel="noopener">https://github.com/tiagofumo/vim-nerdtree-syntax-highlight</a> 和 <a href="https://github.com/ryanoasis/vim-devicons" target="_blank" rel="noopener">https://github.com/ryanoasis/vim-devicons</a> 。其效果如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20200801/20200801_fig005.jpg" width="600" height="380" title="图5" alt="图5" ></p>
<p>安装上述两个包时，需要安装<a href="https://github.com/ryanoasis/nerd-fonts" target="_blank" rel="noopener">nerd-fonts</a>这个字体库。在MacOS中可以使用方法4（Homebrew Fonts）安装，即在终端输入：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">brew tap homebrew/cask-fonts</span><br><span class="line"></span><br><span class="line">brew cask install font-hack-nerd-font</span><br><span class="line">brew cask install font-droid-sans-mono-nerd-font</span><br><span class="line">brew cask install font-droid-sans-mono-for-powerline</span><br></pre></td></tr></table></figure>
<p>使用上述第一条命令时，要经过漫长的等待过程，并且经常会出现如下错误：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">error: RPC failed; curl 56 LibreSSL SSL_read: SSL_ERROR_SYSCALL, errno 54</span><br><span class="line">fatal: The remote end hung up unexpectedly</span><br><span class="line">fatal: early EOF</span><br><span class="line">fatal: index-pack failed</span><br></pre></td></tr></table></figure>
<p>这时可以采用如下链接：<a href="https://www.jianshu.com/p/24c7430fa124" target="_blank" rel="noopener">https://www.jianshu.com/p/24c7430fa124</a> 解决。接下来的三条命令是具体字体的安装，所有的字体可见链接：<a href="https://github.com/Homebrew/homebrew-cask-fonts/tree/master/Casks" target="_blank" rel="noopener">https://github.com/Homebrew/homebrew-cask-fonts/tree/master/Casks</a> 。完成上述命令后，我们需要在MacVim中的.vimrc文件中添加配置命令来防止目录的图标乱码不显示：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">set encoding=UTF-8</span><br><span class="line">set guifont=DroidSansMono_Nerd_Font:h16</span><br></pre></td></tr></table></figure>
<p>效果如上图5所示。我们发现，图5中的图标会出现显示不完全的情况，这是一个Open issue （未完全解决）：<a href="https://github.com/ryanoasis/vim-devicons/issues/133，一个可能的方式是在`.vimrc`文件中添加如下命令：" target="_blank" rel="noopener">https://github.com/ryanoasis/vim-devicons/issues/133，一个可能的方式是在`.vimrc`文件中添加如下命令：</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">augroup custom_nerdtree_options</span><br><span class="line">    autocmd!</span><br><span class="line">    autocmd FileType,WinEnter * :call &lt;SID&gt;SetNerdTreeOptions()</span><br><span class="line">augroup END</span><br><span class="line"></span><br><span class="line">function! s:SetNerdTreeOptions() abort</span><br><span class="line">    if &amp;l:filetype ==# 'nerdtree'</span><br><span class="line">        let g:default_opts = &#123;</span><br><span class="line">                    \   'ambiwidth': &amp;ambiwidth,</span><br><span class="line">                    \   'listchars': &amp;listchars,</span><br><span class="line">                    \   'list'     : &amp;l:list,</span><br><span class="line">                    \ &#125;</span><br><span class="line">        setlocal ambiwidth=double listchars=space:. nolist</span><br><span class="line">    else</span><br><span class="line">        if exists('g:default_opts')</span><br><span class="line">            let [&amp;ambiwidth, &amp;listchars, &amp;l:list] = [</span><br><span class="line">                        \   g:default_opts.ambiwidth,</span><br><span class="line">                        \   g:default_opts.listchars,</span><br><span class="line">                        \   g:default_opts.list</span><br><span class="line">                        \ ]</span><br><span class="line">            unlet g:default_opts</span><br><span class="line">        endif</span><br><span class="line">    endif</span><br><span class="line">endfunction</span><br></pre></td></tr></table></figure>
<p>这样，图标就能完全显示了：</p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20200801/20200801_fig006.jpg" width="600" height="380" title="图6" alt="图6" ></p>
<p>这样做其实还有一个bug：当在一个macvim窗口用多个tab打开多个文件时，图标又会显示不完全，但是此时当焦点在目录时，图标会完全显示。</p>
<hr>
<h2 id="成对插入符号"><a href="#成对插入符号" class="headerlink" title="成对插入符号"></a>成对插入符号</h2><p>安装插件如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Plugin 'tpope/vim-surround'</span><br></pre></td></tr></table></figure>
<p>常用设置代码如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">"-------Shortcuts for the plugin tpope/vim-surround</span><br><span class="line">nmap &lt;leader&gt;) ysiw)</span><br><span class="line">nmap &lt;leader&gt;&#125; ysiw&#125;</span><br><span class="line">nmap &lt;leader&gt;" ysiw"</span><br></pre></td></tr></table></figure>
<p>关于快捷键的详细设置，我们可以参考其<a href="https://github.com/tpope/vim-surround" target="_blank" rel="noopener">主页</a>，或则直接使用命令 <code>:help surround</code>在Vim中查看。我们发现很多命令都需要按多个键，比如上面的用括号包围一个单词，命令为<code>ysiw)</code>。在我的日常使用场景（写文章），最常用的就是中括号和大括号。为方便起见，我就用上述的快捷键映射就可以只需要输入<code>,)</code>即可，这里的逗号是我定义的<code>&lt;leader&gt;</code>。</p>
<hr>
<h2 id="构建C-C-项目"><a href="#构建C-C-项目" class="headerlink" title="构建C/C++项目"></a>构建C/C++项目</h2><p>安装插件如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Plugin 'skywind3000/asyncrun.vim' "for running C</span><br></pre></td></tr></table></figure>
<p>快捷键设置如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">"-------settings for the plugin asyncrun</span><br><span class="line">"open quickfix windown, the height is 6</span><br><span class="line">let g:asyncrun_open =6</span><br><span class="line">"The bell rings when the task is finished</span><br><span class="line">let g:asyncrun_bell =1</span><br><span class="line">let g:asyncrun_rootmarks = ['.svn', '.git', '.root', '_darcs', 'build.xml'] </span><br><span class="line">"call for the quickfix window</span><br><span class="line">autocmd FileType c,cpp nnoremap &lt;leader&gt;c :call asyncrun#quickfix_toggle(6)&lt;cr&gt;</span><br><span class="line">"Shortcuts for compiling and run the c file</span><br><span class="line">autocmd FileType c,cpp nnoremap &lt;silent&gt; &lt;leader&gt;b :AsyncRun -cwd=&lt;root&gt; make &lt;cr&gt;</span><br><span class="line">autocmd FileType c,cpp nnoremap &lt;silent&gt; &lt;leader&gt;r :AsyncRun -cwd=&lt;root&gt; -raw make run &lt;cr&gt;</span><br></pre></td></tr></table></figure>
<p>这样我们就可以使用<code>&lt;leader&gt;b</code>和<code>&lt;leader&gt;r</code>来分别编译和运行C/C++项目了。关于这个插件更详细的介绍说明，可以参考<a href="https://github.com/skywind3000/asyncrun.vim" target="_blank" rel="noopener">主页</a>或者该作者的<a href="http://www.skywind.me/blog/archives/2084" target="_blank" rel="noopener">博客</a>。</p>
<p>需要注意的是，如果只有单个文件，上面这些设置已经足够了。但是，一般来说，一个项目会包含多个源文件，这时我们就得自己编写makefile文件来关联多个源文件。下面以一个简单的例子来说明：有三个文件，分别为<code>hello.h</code>，<code>hello.c</code>, <code>test.c</code>（主文件）。其内容分别为：</p>
<ul>
<li><p>hello.h</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>hello.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"hello.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"Hello World From hello.c!\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>test.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"hello.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> abstact=<span class="number">1</span>;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">"Hello World From test.c!\n"</span>);</span><br><span class="line"> hello();</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>这里我们直接编译会报错如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20200801/20200801_fig007.jpg" width="600" height="380" title="图7" alt="图7" ></p>
<p>这就是提醒我们需要编写makefile文件，具体如何编写makefile文件，请自行网上搜索。下面给出了对于这个例子的makefile文件：</p>
<ul>
<li><p>makefile</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">objects=test.o hello.o</span><br><span class="line">cc=g++</span><br><span class="line"></span><br><span class="line">test:$(objects)</span><br><span class="line">	cc -o test $(objects)</span><br><span class="line"></span><br><span class="line">test.o:test.c  </span><br><span class="line">hello.o:hello.h</span><br><span class="line"></span><br><span class="line">run: test</span><br><span class="line">	./test</span><br><span class="line">.PHONY:clean</span><br><span class="line">clean:</span><br><span class="line">	rm test $(objects)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>这样我们就有四个文件：<code>hello.h</code>，<code>hello.c</code>, <code>test.c</code> 和 <code>makefile</code>。这时，我们按下<code>&lt;leader&gt;b</code>编译项目可得：</p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20200801/20200801_fig008.jpg" width="600" height="380" title="图8" alt="图8" ></p>
<p>最后按键<code>&lt;leader&gt;r</code>运行该项目可得：</p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20200801/20200801_fig009.jpg" width="600" height="380" title="图9" alt="图9" ></p>
<p>从上面可以看出，使用Vim来开发大型项目（源文件很多）是不太方便，使用集成开发环境VS或者VS code是一个相对更好的选择。Vim更适合来编写单个文件，比如我经常来写论文的.tex文件。当然，在写论文时，我们也可以将不同部分（比如 abstract, introduction, system model等等）分成不同的.tex文件，然后在主文件中使用<code>\input</code>命令直接调用即可，这里就没有这里的C/C++项目复杂，不要自己编写makefile。另外需要注意的是，我也是设置<code>&lt;leader&gt;b</code>编译.tex文件。在编译C项目后，在同一vim窗口不同tab再编译.tex文件会产生错误。这里我们可以用一个新的vim窗口打开.tex文件编译即可。</p>
<hr>
<h2 id="目录导航"><a href="#目录导航" class="headerlink" title="目录导航"></a>目录导航</h2><p>在写较长的文章或则程序时，我们可以借助这里的目录导航快速跳转到想到的地方去。安装该插件的代码如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Plugin 'majutsushi/tagbar'</span><br></pre></td></tr></table></figure>
<p>其常用设置如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">"-------Configurations for the plugin ctags</span><br><span class="line">let g:tagbar_ctags_bin='/usr/local/bin/ctags'</span><br><span class="line">let g:tagbar_width=30</span><br><span class="line">let g:tagbar_right=1</span><br><span class="line">"AutoOpen tagbar for c/c++ files</span><br><span class="line">autocmd BufReadPost *.cpp,*.c,*.h,*.hpp,*.cc call tagbar#autoopen()</span><br><span class="line">"Open or close tagbar</span><br><span class="line">map &lt;leader&gt;tb :TagbarToggle&lt;CR&gt;</span><br></pre></td></tr></table></figure>
<p>这样，我们可以通过<code>&lt;leader&gt;tb</code>打开和关闭目录侧边栏。</p>
<p>如下图10所示，在c文件中，右侧显示的每个函数名：</p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20200801/20200801_fig010.jpg" width="600" height="300" title="图10" alt="图10" ></p>
<p>如下图11所示，在.tex文件中，右侧显示的是每个part和label：</p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20200801/20200801_fig011.jpg" width="600" height="300" title="图11" alt="图11" ></p>
<p>左侧显示的是vimtex插件自带的目录，其快捷键我定义为<code>&lt;leader&gt;t</code>。可见，ctags所显示的目录个人觉得更加具有条理性。</p>
<hr>
<h2 id="注释与反注释"><a href="#注释与反注释" class="headerlink" title="注释与反注释"></a>注释与反注释</h2><p>插件安装代码如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Plugin 'scrooloose/nerdcommenter'</span><br></pre></td></tr></table></figure>
<p>配置代码如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">" Add a space before comments</span><br><span class="line">let g:NERDSpaceDelims=1</span><br></pre></td></tr></table></figure>
<p>这样们可以通过<code>&lt;leader&gt;cc</code>来进行注释或者批量注释，通过<code>&lt;leader&gt;cu</code>进行反注释，相比于VS的<code>Ctrl + k + c</code>和<code>Ctrl + k + u</code>的注释方便多了。注释时，会在注释符和代码前加个空格，更多的个性化设置请见其<a href="https://github.com/preservim/nerdcommenter" target="_blank" rel="noopener">主页</a>。</p>
<hr>
<h2 id="对齐线"><a href="#对齐线" class="headerlink" title="对齐线"></a>对齐线</h2><p>插件安装代码如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Plugin 'Yggdroot/indentLine'</span><br></pre></td></tr></table></figure>
<p>配置代码如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">"-------Settings for the plugin indentline</span><br><span class="line">let g:indentLine_char='|'</span><br><span class="line">let g:indentLine_enabled=1</span><br></pre></td></tr></table></figure>
<p>这个对齐线对于python编程应该比较友好，毕竟python语法对于缩进敏感，其效果图如图12：</p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20200801/20200801_fig012.jpg" width="600" height="300" title="图12" alt="图12" ></p>
<p>更多的样式设置请参考其<a href="https://github.com/Yggdroot/indentLine" target="_blank" rel="noopener">主页</a>。</p>
<hr>
<h2 id="代码隐藏"><a href="#代码隐藏" class="headerlink" title="代码隐藏"></a>代码隐藏</h2><p>插件安装代码如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Plugin 'KeitaNakamura/tex-conceal.vim'</span><br></pre></td></tr></table></figure>
<p>配置代码如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">set conceallevel=2</span><br><span class="line">let g:tex_conceal='abdmg'</span><br></pre></td></tr></table></figure>
<p>这样一些数学的LaTeX代码就显示为数学符号，即所见即所得。如下图13所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20200801/20200801_fig013.jpg" width="600" height="300" title="图13" alt="图13" ></p>
<hr>
<h2 id="Python环境配置"><a href="#Python环境配置" class="headerlink" title="Python环境配置"></a>Python环境配置</h2><p>插件安装代码如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Plugin 'vim-scripts/indentpython.vim'</span><br></pre></td></tr></table></figure>
<p>配置代码如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">"-------Configurations for Python</span><br><span class="line">set encoding=utf-8</span><br><span class="line">au BufNewFile,BufRead *.py set tabstop=4 |set softtabstop=4|set shiftwidth=4|set textwidth=79|set expandtab|set autoindent|set fileformat=unix</span><br><span class="line">set clipboard=unnamed</span><br><span class="line">let python_highlight_all=1</span><br><span class="line"></span><br><span class="line">function CheckPythonSyntax() </span><br><span class="line">    let mp = &amp;makeprg </span><br><span class="line">    let ef = &amp;errorformat </span><br><span class="line">    let exeFile = expand("%:t") </span><br><span class="line">    setlocal makeprg=python3\ -u  </span><br><span class="line">    set efm=%C\ %.%#,%A\ \ File\ \"%f\"\\,\ line\ %l%.%#,%Z%[%^\ ]%\\@=%m </span><br><span class="line">    silent make %</span><br><span class="line">    copen </span><br><span class="line">   let &amp;makeprg     = mp  </span><br><span class="line">    let &amp;errorformat = ef  </span><br><span class="line">endfunction</span><br><span class="line">au filetype python map &lt;leader&gt;b  :w &lt;cr&gt; :call CheckPythonSyntax() &lt;cr&gt; :cw&lt;cr&gt;</span><br></pre></td></tr></table></figure>
<p>这样我们只需要通过命令<code>&lt;leader&gt;b</code>来编译运行.py文件了，如图14:</p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20200801/20200801_fig014.jpg" width="600" height="380" title="图14" alt="图14" ></p>
<p>这里有个缺点就是，输出是使用quickfit window (使用<code>:copen</code>打开该窗口)，无法交互式输入。所以我还是推荐使用pycharm来作为python的开发环境吧。</p>
<hr>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>Algorithm Design</tag>
      </tags>
  </entry>
  <entry>
    <title>写博客的一些规范</title>
    <url>/2020/07/30/%5B20200730%5D/</url>
    <content><![CDATA[<p>最近开始将CSDN的博客转到个人博客上，主要是采用Markdown将以前的文章保存下来，然后将其用hexo部署到github。在这里，我介绍一下使用Markdown写博客时一些技巧，格式，以及如何用部署到网站上。</p>
<a id="more"></a>
<hr>
<h4 id="用新电脑继续写博客"><a href="#用新电脑继续写博客" class="headerlink" title="用新电脑继续写博客"></a>用新电脑继续写博客</h4><p>去年我在旧电脑使用hexo搭建了博客，其配置文件的没有上传到github。今年疫情在家，用新的电脑想写博客的时候发现无法发布到网站上。于是乎，到了学校之后，我就把配置文件也上传到了github上面，这样以后也可以在其他电脑上愉快的写博客了。具体的操作步骤如下：</p>
<ol>
<li><p>在旧电脑上，使用hexo+github搭建博客(具体步骤网上有很多教程)，会创建一个名为你名称的库，例如我的为tengweitw.github.io。该库中的master分支会存储你博客中的静态网页内容。我们需要手动创建一个新的分支(命名为hexo)，并将该分支设置为默认分支，这个hexo分支的目的就是为了保存网站的配置文件。</p>
<p>图1为master分支中的内容：</p>
<p>​     <img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20200730/20200730_fig001.jpg" width="500" height="550" title="图1" alt="图1" ></p>
</li>
</ol>
<p>​       图2为hexo分支中的内容：</p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20200730/20200730_fig002.jpg" width="500" height="450" title="图2" alt="图2" ></p>
<ol>
<li><p>在新电脑上，我们使用如下命令将库克隆到本地tengweitw.github.io文件夹中：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone git@github.com:tengweitw/tengweitw.github.io</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p>在本地tengweitw.github.io文件夹中右击运行Git bash(需要安装Git)，依次输入如下命令来安装hexo环境：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo</span><br><span class="line">hexo init</span><br><span class="line">npm install</span><br><span class="line">npm install hexo-deployer-git</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p>修改文件夹中的_config.yml中的deploy参数，分支改为master，这里的目的是在hexo分支中使用hexo d部署博客时，是上传到master分支下。</p>
</li>
<li><p>然后执行如下命令，将配置文件同步到hexo分支中：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m "add something"</span><br><span class="line">git push</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p>最后执行如下命令(在hexo分支下执行即可），生成静态网页并同步到master分支中：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>总的来说，在一台新电脑写博客时，执行步骤2-6即可。当我们对博客进行修改(修改配置文件，或者添加新的博文)时，只需要执行步骤5-6即可。</p>
<hr>
<h4 id="写博客的一些规范"><a href="#写博客的一些规范" class="headerlink" title="写博客的一些规范"></a>写博客的一些规范</h4><p>本想在网上找一些写一篇博文的格式规范，却发现相关内容少之又少。下面介绍一下我自己在写文章过程中常用的一些格式规范。</p>
<ul>
<li><p>Markdown 编辑器<br>我使用的是Typora，网上好评很多。对我来说，我有时需要在不同操作系统中切换，Typora也支持多系统。</p>
</li>
<li><p>图床<br>最开始一直都是存在本地，后来发现发布到网上就不行了。网上很多推荐使用各种图床的，付费的免费的都有。但是有可能不稳定，不开放外链，就会出现找不到图片的问题。我现在使用的是在github建立了一个名为FigureBed的仓库，将博客所有的图片放在这里面，每篇文章的图片按着其发布时间建立一个文件夹，如下图所示：<br>   <img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20200730/20200730_fig003.jpg" width="500" height="350" title="图1" alt="图1" ></p>
<p>使用github库作为图床的一个问题就是国内网络有时访问不了。不过我们    可以使用jsDelivr来进行CDN加速，其访问github仓库的方法特别简单，格式如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">https://cdn.jsdelivr.net/gh/用户名称/仓库名称@latest/目录</span><br></pre></td></tr></table></figure>
<p>举例来说，对于本文的第一个图，我们使用的语句为：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20200730/20200730_fig001.jpg"</span> <span class="attr">width</span>=<span class="string">"500"</span> <span class="attr">height</span>=<span class="string">"550"</span> <span class="attr">title</span>=<span class="string">"图1"</span> <span class="attr">alt</span>=<span class="string">"图1"</span> &gt;</span></span><br></pre></td></tr></table></figure>
<p>其中20200730是以文章发布日期为名的文件夹，20200730_fig001.jpg为该文章的第一个图。</p>
<p>当然，我们最好将FigureBed库git到本地，然后在本地新建文件夹(比如，以日期为名)，将图放进去，然后使用前面步骤5的命令将图上传到github中。对于博文中图的大小设置，即width和height我一直都不知道怎样才合适？怎样才比较美观？</p>
</li>
<li><p>未完待续</p>
</li>
</ul>
<p>​      </p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>Algorithm Design</tag>
      </tags>
  </entry>
  <entry>
    <title>【CUDA编程】初始配置及一个简单实例</title>
    <url>/2020/07/28/%5B20200728%5D/</url>
    <content><![CDATA[<p>在去年写的一篇文章《Win10 + VS2017 + CUDA10.1 + CPLEX12.9 配置》中，我们已经介绍了如何安装CUDA和使用VS作为编程环境。一晃半年过去了，现在准备用GPU做点东西，投个会议。由于新换了电脑，我又重新安装了运行环境，结果遇到了如下语法问题：<br><a id="more"></a></p>
<ol>
<li>C语言常用的一些头文件都无法打开，如图1：<br>  <img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20200728/20200728_fig001.jpg" width="200" height="50" title="图1" alt="图1" ></li>
<li>在调用核函数时, 也会显示语法有错(但是可以编译运行)，如图2：<br><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20200728/20200728_fig002.jpg" width="500" height="50" title="图2" alt="图2" ></li>
</ol>
<hr>
<p><strong>解决办法：</strong></p>
<p><strong>对于问题1</strong>，主要原因是VS在安装时，有些文件没有进行勾选安装。此时，我们需要使用Visual Studio Installer进行安装。具体来说：</p>
<ol>
<li>打开Visual Studio, 选择工具(Tool)中的获取工具(Get Tools and Features)，从而打开Visual Studio Installer; 或者你可以直接从开始菜单中打开；</li>
<li>在单个组件中，勾选如下文件并安装：<br><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20200728/20200728_fig003.jpg" width="300" height="250" title="图3" alt="图3" ></li>
<li>右击你的项目，选择属性，在Windows SDK Version中选择你刚才安装的组件版本：<br><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20200728/20200728_fig004.jpg" width="800" height="200" title="图4" alt="图4" ></li>
</ol>
<p><strong>对于问题2</strong>，主要原因是版本问题，具体可见链接：<a href="https://stackoverflow.com/questions/6061565/setting-up-visual-studio-intellisense-for-cuda-kernel-calls" target="_blank" rel="noopener">https://stackoverflow.com/questions/6061565/setting-up-visual-studio-intellisense-for-cuda-kernel-calls</a> 。我主要采用了上述中的办法，即在文件头中定义宏：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __CUDACC__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KERNEL_ARGS2(grid, block) <span class="meta-string">&lt;&lt;&lt; grid, block &gt;&gt;&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KERNEL_ARGS3(grid, block, sh_mem) <span class="meta-string">&lt;&lt;&lt; grid, block, sh_mem &gt;&gt;&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KERNEL_ARGS4(grid, block, sh_mem, stream) <span class="meta-string">&lt;&lt;&lt; grid, block, sh_mem, stream &gt;&gt;&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KERNEL_ARGS2(grid, block)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KERNEL_ARGS3(grid, block, sh_mem)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KERNEL_ARGS4(grid, block, sh_mem, stream)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>然后我们可以在调用核函数的时候使用上述命令：</p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20200728/20200728_fig005.jpg" width="500" height="100" title="图5" alt="图5" ></p>
<hr>
<p><strong>一个例子</strong>：</p>
<p>这里我们给出一个简单的小例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"cuda_runtime.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"device_launch_parameters.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __CUDACC__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KERNEL_ARGS2(grid, block) <span class="meta-string">&lt;&lt;&lt; grid, block &gt;&gt;&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KERNEL_ARGS3(grid, block, sh_mem) <span class="meta-string">&lt;&lt;&lt; grid, block, sh_mem &gt;&gt;&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KERNEL_ARGS4(grid, block, sh_mem, stream) <span class="meta-string">&lt;&lt;&lt; grid, block, sh_mem, stream &gt;&gt;&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KERNEL_ARGS2(grid, block)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KERNEL_ARGS3(grid, block, sh_mem)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KERNEL_ARGS4(grid, block, sh_mem, stream)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">__<span class="function">global__ <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Hello world From GPU!!!\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	hello &lt;&lt; &lt;<span class="number">1</span>, <span class="number">10</span> &gt;&gt; &gt; ();</span><br><span class="line">	cudaDeviceSynchronize();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="function">hello <span class="title">KERNEL_ARGS2</span><span class="params">(<span class="number">1</span>, <span class="number">10</span>)</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20200728/20200728_fig006.jpg" width="600" height="500" title="图6" alt="图6" ></p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>Programming Art</tag>
      </tags>
  </entry>
  <entry>
    <title>【图解例说机器学习】集成学习之AdaBoost算法</title>
    <url>/2020/06/18/%5B20200618%5D/</url>
    <content><![CDATA[<blockquote>
<p>三个臭皮匠，顶个诸葛亮。</p>
</blockquote>
<p>集成学习 (Ensemble learning) 通过构建并结合多个学习器来完成学习任务，即先产生一组<strong>个体学习器</strong>，再通过<strong>某种策略</strong>将它们结合起来完成学习任务。</p>
<p>个体学习器通常为一个现有的学习算法从训练数据产生，例如决策树，神经网络等。结合策略：在回归问题中，一般采用 (加权) 平均法，在分类问题中，一般采用 (加权) 投票法。当训练数据很多时，一种更为强大的结合策略为学习法，即通过另一个学习器来进行结合，典型代表为Stacking.</p>
<p>根据个体学习器的生成方式不同，目前的集成学习方法大致分为两大类：<strong>序列化方法</strong>和<strong>并行化方法</strong>。在序列化方法中，个体学习器之间存在强依赖关系，需要串行生成，其代表为Boosting；在并行化方法中，个体学习器间不存在强依赖关系，可同时生成，其代表为Bagging和随机森林 (Random Forest)。</p>
<a id="more"></a>
<p>本文主要介绍Boosting算法簇中最经典的代表AdaBoost。</p>
<hr>
<h2 id="AdaBoost"><a href="#AdaBoost" class="headerlink" title="AdaBoost"></a>AdaBoost</h2><p>AdaBoost算法有多种推导方式，比较简单易懂的是基于<strong>加性模型</strong>，以<strong>指数函数为损失函数</strong>，优化方法为<strong>前向分步</strong>算法的推导。具体如下所示：</p>
<h4 id="模型与损失函数"><a href="#模型与损失函数" class="headerlink" title="模型与损失函数"></a>模型与损失函数</h4><p>假设给定一个二分类的训练数据集$\mathcal D={(\mathrm x_i,y_i)\mid i=1,2,\cdots,N}$，总共有$K$个个体学习器$f_k(\mathrm x),k=1,2,\cdots,K$。此时，模型的表达式为：</p>
<script type="math/tex; mode=display">
f(\mathrm x)=\sum\limits_{k=1}^{K}\alpha_kf_k(\mathrm x)\tag{1}</script><p>这里我们采用指数损失函数：</p>
<script type="math/tex; mode=display">
E=\sum\limits_{i=1}^{N}E_i=\sum\limits_{i=1}^{N}\exp(-y_if(\mathrm x_i))\tag{2}</script><p>我们的目标是优化参数$\alpha_k, f_k(\mathrm x)$使得损失函数最小，即</p>
<script type="math/tex; mode=display">
\min_{\alpha_k,f_k(\mathrm x)}\quad\sum\limits_{i=1}^{N}\exp(-y_if(\mathrm x_i))\tag{3}</script><p>一般来说，优化问题(3)不易求解。我们可以采用前向分布算法逐一地学习个体学习器$f_k(\mathrm x)$, 具体操作如下：</p>
<p>在第$t$次迭代中，我们假设已经学习得到了$\alpha_k, f_k(\mathrm x),k=1,2,\cdots,t-1$, 根据公式(1)，我们有</p>
<script type="math/tex; mode=display">
f(x)=\sum\limits_{k=1}^{t-1}\alpha_kf_k(\mathrm x)+\alpha_tf_t(\mathrm x)\tag{4}</script><p>根据公式(2)，此时的损失函数为：</p>
<script type="math/tex; mode=display">
\begin{aligned}
E&=\sum\limits_{i=1}^{N}\exp(-y_if(\mathrm x_i))=\sum\limits_{i=1}^{N}\exp\left(-y_i\left[\sum\limits_{k=1}^{t-1}\alpha_kf_k(\mathrm x_i)+\alpha_tf_t(\mathrm x_i)\right]\right)\\
&=\sum\limits_{i=1}^{N}\exp(-y_i\sum\limits_{k=1}^{t-1}\alpha_kf_t(\mathrm x_i))\exp(-y_i\alpha_tf_t(\mathrm x_i))=\sum\limits_{i=1}^{N}w_{ti}\exp(-y_i\alpha_tf_t(\mathrm x_i))
\end{aligned}\tag{5}</script><p>注意：在公式(5)中，$w_{ti}$已经由前$t-1$次迭代得到。为此，为最小化当前的损失函数，我们可以对$\alpha_t$求导可得：</p>
<script type="math/tex; mode=display">
\frac{\partial E}{\partial\alpha_t}=\sum\limits_{i=1}^{N}\frac{\partial E_i}{\partial\alpha_t}\tag{6}</script><p>其中，我们有：</p>
<script type="math/tex; mode=display">
\frac{\partial E_i}{\partial\alpha_t}=
\begin{cases}
w_{ti}\exp(-\alpha_t),\quad if\hspace{3pt}(f_t(\mathrm x_i)==y_i)\\
w_{ti}\exp(\alpha_t),\quad if\hspace{3pt}(f_t(\mathrm x_i)!=y_i)
\end{cases}\tag{7}</script><p>令公式(6)等于0，我们可得：</p>
<script type="math/tex; mode=display">
\alpha_t=\frac{1}{2}ln\frac{1-e_t}{e_t}\tag{8}</script><p>其中，分类误差率$e_t$可以表示为：</p>
<script type="math/tex; mode=display">
e_t=\frac{\sum\nolimits_{i=1}^{N}w_{ti}\mathbb I(f_t(\mathrm x_i)\neq y_i)}{\sum\nolimits_{i=1}^{N}w_{ti}}\tag{9}</script><p>由公式(2)：</p>
<script type="math/tex; mode=display">
\sum\limits_{k=1}^{t}\alpha_kf_k(\mathrm x)=\sum\limits_{k=1}^{t-1}\alpha_kf_k(\mathrm x)+\alpha_tf_t(\mathrm x)\tag{10}</script><p>根据公式(5)中$w_{ti}$的定义可知</p>
<script type="math/tex; mode=display">
\begin{aligned}
w_{t+1,i}&=\exp[-y_i\sum\limits_{k=1}^{t}\alpha_kf_t(\mathrm x_i)]\\&=\exp[-y_i\sum\limits_{k=1}^{t-1}\alpha_kf_t(\mathrm x_i)]\exp[-y_i\alpha_tf_t(\mathrm x_i)]\\&=w_{ti}\exp[-y_i\alpha_tf_t(\mathrm x_i)]
\end{aligned}\tag{11}</script><p>这里我们对$w_{t+1,i},i=1,2,\cdots,N$进行归一化，即：</p>
<script type="math/tex; mode=display">
\bar w_{t+1,i}=\frac{w_{t+1,i}}{\sum\nolimits_{i=1}^{N}w_{t+1,i}}=\frac{w_{ti}\exp(-y_i\alpha_tf_t(\mathrm x_i))}{\sum\nolimits_{i=1}^{N}w_{ti}\exp(-y_i\alpha_tf_t(\mathrm x_i))}\tag{12}</script><p>由公式(9)可知，$w<em>{ti}$可以看成是在$t$次迭代过程中，样例点$\mathrm x_i$的误差权重。$w</em>{ti}$越大，说明越期望$\mathrm x_i$被正确分类，其被误分类的损失越大。</p>
<p>到目前为止，我们就完成了第$t$次迭代过程中需要更新的值：个体学习器$f<em>t(x)$及其权重$\alpha_t$ ，以及下一次迭代时计算误差率(9)所需要的权重$\bar w</em>{t+1,i}$。注意：这里的个体学习器$f_t(x)$可以是一些常见的算法，如决策树，神经网络等；另外，初始的权重值可以设置为$1/N$，即可把所有样例等同看待。</p>
<hr>
<h2 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h2><p>如下表所示包含10个训练样例的训练集。假设个体分类器简单地设为$x&lt;v$或者$x\ge v$，其阈值$v$使得该分类器在训练数据集上误分类率最低，这里我们可以采用穷举来得到。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">$\mathrm x$</th>
<th style="text-align:center">0</th>
<th style="text-align:center">1</th>
<th style="text-align:center">2</th>
<th style="text-align:center">3</th>
<th style="text-align:center">4</th>
<th style="text-align:center">5</th>
<th style="text-align:center">6</th>
<th style="text-align:center">7</th>
<th style="text-align:center">8</th>
<th style="text-align:center">9</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">$y$</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">-1</td>
<td style="text-align:center">-1</td>
<td style="text-align:center">-1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">-1</td>
</tr>
</tbody>
</table>
</div>
<h4 id="第-t-1-次迭代："><a href="#第-t-1-次迭代：" class="headerlink" title="第$t=1$次迭代："></a><strong>第$t=1$次迭代：</strong></h4><p>我们假设初始权值为</p>
<script type="math/tex; mode=display">
w_{1i}=0.1, i=1,2,\cdots,10\tag{13}</script><p>然后根据公式(9)和我们假定的分类器</p>
<script type="math/tex; mode=display">
f_1(\mathrm x)=
\begin{cases}
1,\quad x<v\\
-1,\quad x\ge v
\end{cases}\tag{14}</script><p>通过穷举$v={-0.5,0.5,1.5,\cdots,9.5}$来找到最优的$v=2.5$使得误分类率(9)最小，即：</p>
<script type="math/tex; mode=display">
e_1=0.3\tag{15}</script><p>根据公式(8)和(15)，我们计算</p>
<script type="math/tex; mode=display">
\alpha_1=0.4236\tag{16}</script><p>至此，我们得到第$t=1$次的表达式：</p>
<script type="math/tex; mode=display">
f(\mathrm x)=\alpha_1f_1(\mathrm x)=0.4236f_1(\mathrm x)\tag{17}</script><p>(17)对应的分类函数为：</p>
<script type="math/tex; mode=display">
\hat y=f(\mathrm x)=
\begin{cases}
1,\quad\alpha_1f_1(\mathrm x)<0\\
-1,\quad\alpha_1f_1(\mathrm x)\ge 0
\end{cases}\tag{18}</script><p>根据(18)，我们有</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">$\mathrm x$</th>
<th style="text-align:center">0</th>
<th style="text-align:center">1</th>
<th style="text-align:center">2</th>
<th style="text-align:center">3</th>
<th style="text-align:center">4</th>
<th style="text-align:center">5</th>
<th style="text-align:center">6</th>
<th style="text-align:center">7</th>
<th style="text-align:center">8</th>
<th style="text-align:center">9</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">y</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">-1</td>
<td style="text-align:center">-1</td>
<td style="text-align:center">-1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">-1</td>
</tr>
<tr>
<td style="text-align:center">$\hat y$</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">-1</td>
<td style="text-align:center">-1</td>
<td style="text-align:center">-1</td>
<td style="text-align:center">$\color{red}-1$</td>
<td style="text-align:center">$\color{red}-1$</td>
<td style="text-align:center">$\color{red}-1$</td>
<td style="text-align:center">-1</td>
</tr>
</tbody>
</table>
</div>
<p>最后根据(12)来计算下次迭代所需要的权重：</p>
<script type="math/tex; mode=display">
\begin{aligned}
w_{21}=w_{22}=w_{23}=w_{24}=w_{25}=w_{26}=w_{210}=0.0714\\
w_{27}=w_{28}=w_{29}=0.1667
\end{aligned}\tag{19}</script><h4 id="第-t-2-次迭代："><a href="#第-t-2-次迭代：" class="headerlink" title="第$t=2$次迭代："></a>第$t=2$次迭代：</h4><p>然后根据公式(9)和我们假定的第二个分类器</p>
<script type="math/tex; mode=display">
f_2(\mathrm x)=
\begin{cases}
1,\quad x<v\\
-1,\quad x\ge v
\end{cases}\tag{20}</script><p>通过穷举$v={-0.5,0.5,1.5,\cdots,9.5}$来找到最优的$v=8.5$使得误分类率(9)最小，即：</p>
<script type="math/tex; mode=display">
e_2=0.2143\tag{21}</script><p>根据公式(8)和(21)，我们计算：</p>
<script type="math/tex; mode=display">
\alpha_2=0.6496\tag{22}</script><p>此时，我们得到第$t=2$次的表达式：</p>
<script type="math/tex; mode=display">
f(\mathrm x)=\alpha_1f_1(\mathrm x)+\alpha_2f_2(\mathrm x)=0.4236f_1(\mathrm x)+0.6496f_2(\mathrm x)\tag{23}</script><p>(23)对应的分类函数为：</p>
<script type="math/tex; mode=display">
\hat y=f(\mathrm x)=
\begin{cases}
1,\quad\alpha_1f_1(\mathrm x)+\alpha_2f_2(\mathrm x)<0\\
-1,\quad\alpha_1f_1(\mathrm x)+\alpha_2f_2(\mathrm x)\ge 0
\end{cases}\tag{24}</script><p>根据(24)，我们有</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">$\mathrm x$</th>
<th style="text-align:center">0</th>
<th style="text-align:center">1</th>
<th style="text-align:center">2</th>
<th style="text-align:center">3</th>
<th style="text-align:center">4</th>
<th style="text-align:center">5</th>
<th style="text-align:center">6</th>
<th style="text-align:center">7</th>
<th style="text-align:center">8</th>
<th style="text-align:center">9</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">y</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">-1</td>
<td style="text-align:center">-1</td>
<td style="text-align:center">-1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">-1</td>
</tr>
<tr>
<td style="text-align:center">$\hat y$</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">$\color{red}1$</td>
<td style="text-align:center">$\color{red}1$</td>
<td style="text-align:center">$\color{red}1$</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">-1</td>
</tr>
</tbody>
</table>
</div>
<p>最后根据(12)来计算下次迭代所需要的权重：</p>
<script type="math/tex; mode=display">
\begin{aligned}
w_{31}=w_{32}=w_{33}=w_{310}=0.0455\\
w_{34}=w_{35}=w_{36}=0.1667\\
w_{37}=w_{38}=w_{39}=0.1061
\end{aligned}\tag{25}</script><h4 id="第-t-3-次迭代："><a href="#第-t-3-次迭代：" class="headerlink" title="第$t=3$次迭代："></a><strong>第$t=3$次迭代：</strong></h4><p>然后根据公式(9)和我们假定的第三个分类器</p>
<script type="math/tex; mode=display">
f_3(\mathrm x)=
\begin{cases}
-1,\quad x<v\\
1,\quad x\ge v
\end{cases}\tag{26}</script><p>通过穷举$v={-0.5,0.5,1.5,\cdots,9.5}$来找到最优的$v=5.5$使得误分类率(9)最小，即：</p>
<script type="math/tex; mode=display">
e_3=0.1818\tag{27}</script><p>根据公式(8)和(27)，我们计算：</p>
<script type="math/tex; mode=display">
\alpha_3=0.7520\tag{28}</script><p>此时，我们得到第$t=3$次的表达式：</p>
<script type="math/tex; mode=display">
f(\mathrm x)=\alpha_1f_1(\mathrm x)+\alpha_2f_2(\mathrm x)+\alpha_3f_3(\mathrm x)=0.4236f_1(\mathrm x)+0.6496f_2(\mathrm x)+0.7514f_3(\mathrm x)\tag{29}</script><p>(29)对应的分类函数为：</p>
<script type="math/tex; mode=display">
\hat y=f(\mathrm x)=
\begin{cases}
1,\quad\alpha_1f_1(\mathrm x)+\alpha_2f_2(\mathrm x)+\alpha_3f_3(\mathrm x)<0\\
-1,\quad\alpha_1f_1(\mathrm x)+\alpha_2f_2(\mathrm x)+\alpha_3f_3(\mathrm x)\ge 0
\end{cases}\tag{30}</script><p>根据(30)，我们有</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">$\mathrm x$</th>
<th style="text-align:center">0</th>
<th style="text-align:center">1</th>
<th style="text-align:center">2</th>
<th style="text-align:center">3</th>
<th style="text-align:center">4</th>
<th style="text-align:center">5</th>
<th style="text-align:center">6</th>
<th style="text-align:center">7</th>
<th style="text-align:center">8</th>
<th style="text-align:center">9</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">y</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">-1</td>
<td style="text-align:center">-1</td>
<td style="text-align:center">-1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">-1</td>
</tr>
<tr>
<td style="text-align:center">$\hat y$</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">-1</td>
<td style="text-align:center">-1</td>
<td style="text-align:center">-1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">-1</td>
</tr>
</tbody>
</table>
</div>
<p>最后根据(12)来计算下次迭代所需要的权重：</p>
<script type="math/tex; mode=display">
\begin{aligned}
w_{41}=w_{42}=w_{43}=w_{410}=0.125\\
w_{44}=w_{45}=w_{46}=0.102\\
w_{47}=w_{48}=w_{49}=0.065
\end{aligned}\tag{31}</script><p>从上表可知，分类函数(30)已经能成功将这10个样例分类，实际上(31)已经不需要计算了。此时，最终的分类函数即为(30)。</p>
<hr>
<h3 id="具体算法实现"><a href="#具体算法实现" class="headerlink" title="具体算法实现"></a>具体算法实现</h3><p>对于上面的例子，我们使用python进行了算法实践，其结果与上述过程相同，如图1：</p>
<table>
    <tr>
        <td ><center><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20200618/AdaBoost_fig001.jpg"  ></center>  <center>图1 </center></td>
    </tr>
</table>

<p>对应的Python源代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- encoding: utf-8 -*-</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">@File    : AdaBoost.py</span></span><br><span class="line"><span class="string">@Time    : 2020/6/17 22:02</span></span><br><span class="line"><span class="string">@Author  : tengweitw</span></span><br><span class="line"><span class="string">@Email   : tengweitw@foxmail.com</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">train_x = range(<span class="number">10</span>)</span><br><span class="line">train_y = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">N = len(train_x)  <span class="comment"># num of instances</span></span><br><span class="line">K = <span class="number">3</span>  <span class="comment"># num of basic classfier</span></span><br><span class="line"></span><br><span class="line">w = np.zeros((K + <span class="number">1</span>, N))</span><br><span class="line">alpha = np.zeros((K, <span class="number">1</span>))</span><br><span class="line">v = np.zeros((K, <span class="number">1</span>))</span><br><span class="line">f_t_x = np.zeros((K, <span class="number">1</span>))</span><br><span class="line"><span class="comment"># used for brute force</span></span><br><span class="line">values = np.linspace(<span class="number">-0.5</span>, <span class="number">9.5</span>, <span class="number">11</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># exhaust search for the optimal threshold value</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Choose_values</span><span class="params">(values, w, train_x, train_y, N)</span>:</span></span><br><span class="line">    error1 = []</span><br><span class="line">    tmp1 = np.zeros((N, <span class="number">1</span>))</span><br><span class="line">    tmp2 = np.zeros((N, <span class="number">1</span>))</span><br><span class="line">    <span class="keyword">for</span> v <span class="keyword">in</span> values:</span><br><span class="line">        tmp3 = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(N):</span><br><span class="line">            <span class="keyword">if</span> (train_x[i] &lt; v):</span><br><span class="line">                tmp1[i] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                tmp1[i] = <span class="number">-1</span></span><br><span class="line">            <span class="keyword">if</span> (tmp1[i] == train_y[i]):</span><br><span class="line">                tmp2[i] = <span class="number">0</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                tmp2[i] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            tmp3 = tmp3 + tmp2[i] * w[i]</span><br><span class="line">        error1.append(tmp3)</span><br><span class="line">    <span class="comment"># Note that there are two cases: y=1,if x&gt;v or y=-1, if x&gt;v</span></span><br><span class="line">    err_min1 = min(error1)</span><br><span class="line">    err_min_index1 = error1.index(err_min1)</span><br><span class="line"></span><br><span class="line">    error2 = []</span><br><span class="line">    tmp1 = np.zeros((N, <span class="number">1</span>))</span><br><span class="line">    tmp2 = np.zeros((N, <span class="number">1</span>))</span><br><span class="line">    <span class="keyword">for</span> v <span class="keyword">in</span> values:</span><br><span class="line">        tmp3 = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(N):</span><br><span class="line">            <span class="keyword">if</span> (train_x[i] &lt; v):</span><br><span class="line">                tmp1[i] = <span class="number">-1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                tmp1[i] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> (tmp1[i] == train_y[i]):</span><br><span class="line">                tmp2[i] = <span class="number">0</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                tmp2[i] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            tmp3 = tmp3 + tmp2[i] * w[i]</span><br><span class="line">        error2.append(tmp3)</span><br><span class="line">    err_min2 = min(error2)</span><br><span class="line">    err_min_index2 = error2.index(err_min2)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (err_min1 &lt; err_min2):</span><br><span class="line">        error = err_min1</span><br><span class="line">        index = err_min_index1</span><br><span class="line">        flag = <span class="number">0</span>  <span class="comment"># case 0: y=1 if x&lt;v</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        error = err_min2</span><br><span class="line">        index = err_min_index2</span><br><span class="line">        flag = <span class="number">1</span>  <span class="comment"># case 1: y=-1 if x&lt;v</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> index, error, flag</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> range(K):</span><br><span class="line">    print(<span class="string">'------------------The %d-th iteration------------------'</span> % (k))</span><br><span class="line">    <span class="keyword">if</span> k == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(N):</span><br><span class="line">            w[k][i] = <span class="number">1.0</span> / N  <span class="comment"># initialization: equal weigh</span></span><br><span class="line"></span><br><span class="line">    v_index, err, flag = Choose_values(values, w[k], train_x, train_y, N)</span><br><span class="line">    v[k] = values[v_index]</span><br><span class="line">    alpha[k] = np.log((<span class="number">1</span> - err) / err) / <span class="number">2.0</span></span><br><span class="line">    print(<span class="string">'The optimal threshold v:'</span>, v[k])</span><br><span class="line">    print(<span class="string">'The minimum error e:'</span>, err)</span><br><span class="line">    print(<span class="string">'The coefficient of the basic function: alpha'</span>, alpha[k])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(N):</span><br><span class="line">        <span class="keyword">if</span> train_x[i] &lt; v[k]:</span><br><span class="line">            f_t_x = <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            f_t_x = <span class="number">-1</span></span><br><span class="line">        <span class="keyword">if</span> flag == <span class="number">1</span>: <span class="comment"># check case 0 or case 1</span></span><br><span class="line">            f_t_x = -f_t_x</span><br><span class="line">        w[k + <span class="number">1</span>][i] = w[k][i] * np.exp(-train_y[i] * alpha[k] * f_t_x)</span><br><span class="line"></span><br><span class="line">    sum_tmp = sum(w[k + <span class="number">1</span>])</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(N):</span><br><span class="line">        w[k + <span class="number">1</span>][i] = w[k + <span class="number">1</span>][i] / sum_tmp <span class="comment"># regularization</span></span><br><span class="line">    print(<span class="string">'The weight of the next iteration w:'</span>)</span><br><span class="line">    print(w[k + <span class="number">1</span>])</span><br></pre></td></tr></table></figure>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>Machine Learning</tag>
      </tags>
  </entry>
  <entry>
    <title>【漫漫科研路\Python】画支持向量机相关图</title>
    <url>/2020/06/11/%5B20200611%5D/</url>
    <content><![CDATA[<p>在之前的一篇文章<a href="https://blog.csdn.net/tengweitw/article/details/106088030" target="_blank" rel="noopener">【图解例说机器学习】支持向量机 (SVM)</a>中，由于篇幅有限，我们只介绍了其理论部分。作为补充，本文介绍文中所有图像的绘制。我们全都是采用Python绘制，具体如下：</p>
<p>图1-2：</p>
<table>
    <tr>
        <td ><center><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20200611/SVM_fig001.jpg"  >图1</center></td>
        <td ><center><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20200611/SVM_fig002.jpg"  >图2</center></td>
    </tr>
</table>


<a id="more"></a>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        图1对应的Python源代码为:
    </div>
    <div class='spoiler-content'>
        <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time : 2020/5/8 21:03</span></span><br><span class="line"><span class="comment"># @Author : tengweitw</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="comment"># Set the format of labels</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">LabelFormat</span><span class="params">(plt)</span>:</span></span><br><span class="line">    ax = plt.gca()</span><br><span class="line">    plt.tick_params(labelsize=<span class="number">14</span>)</span><br><span class="line">    labels = ax.get_xticklabels() + ax.get_yticklabels()</span><br><span class="line">    [label.set_fontname(<span class="string">'Times New Roman'</span>) <span class="keyword">for</span> label <span class="keyword">in</span> labels]</span><br><span class="line">    font = &#123;<span class="string">'family'</span>: <span class="string">'Times New Roman'</span>,</span><br><span class="line">            <span class="string">'weight'</span>: <span class="string">'normal'</span>,</span><br><span class="line">            <span class="string">'size'</span>: <span class="number">16</span>,</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="keyword">return</span> font</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">x = [<span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>]</span><br><span class="line">y = [<span class="number">3</span>, <span class="number">3</span>, <span class="number">1</span>]</span><br><span class="line">c = [<span class="string">r'$\mathrm&#123;x&#125;_1$'</span>,<span class="string">r'$\mathrm&#123;x&#125;_2$'</span>,<span class="string">r'$\mathrm&#123;x&#125;_3$'</span>]</span><br><span class="line"></span><br><span class="line">x1=np.linspace(<span class="number">0</span>,<span class="number">2.5</span>,<span class="number">10</span>)</span><br><span class="line">y1=<span class="number">5</span><span class="number">-2</span>*x1</span><br><span class="line"></span><br><span class="line">x2=np.linspace(<span class="number">0</span>,<span class="number">3</span>,<span class="number">10</span>)</span><br><span class="line">y2=<span class="number">3</span>-x2</span><br><span class="line"></span><br><span class="line">plt.figure()</span><br><span class="line"></span><br><span class="line">plt.plot(x[:<span class="number">2</span>],y[:<span class="number">2</span>],<span class="string">'rs'</span>)</span><br><span class="line">plt.plot(x[<span class="number">-1</span>],y[<span class="number">-1</span>],<span class="string">'bo'</span>)</span><br><span class="line"></span><br><span class="line">plt.plot(x1,y1,<span class="string">'k-'</span>)</span><br><span class="line">plt.plot(x2,y2,<span class="string">'k-'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(x)):</span><br><span class="line">    plt.annotate(c[i], xy=(x[i], y[i]), xytext=(x[i] + <span class="number">0.05</span>, y[i] + <span class="number">0.05</span>),fontsize=<span class="number">16</span>)</span><br><span class="line">plt.annotate(<span class="string">'$2x^&#123;(1)&#125;+x^&#123;(2)&#125;-5=0$'</span>, xy=(<span class="number">1</span>, <span class="number">3</span>), xycoords=<span class="string">'data'</span>,</span><br><span class="line">             xytext=(<span class="number">0</span>, <span class="number">60</span>), textcoords=<span class="string">'offset points'</span>, color=<span class="string">'g'</span>, fontsize=<span class="number">16</span>, arrowprops=dict(arrowstyle=<span class="string">"-&gt;"</span>,</span><br><span class="line">             connectionstyle=<span class="string">"arc,rad=0"</span>, color=<span class="string">'k'</span>))</span><br><span class="line">plt.annotate(<span class="string">'$x^&#123;(1)&#125;+x^&#123;(2)&#125;-3=0$'</span>, xy=(<span class="number">2.5</span>, <span class="number">0.5</span>), xycoords=<span class="string">'data'</span>,</span><br><span class="line">             xytext=(<span class="number">30</span>, <span class="number">30</span>), textcoords=<span class="string">'offset points'</span>, color=<span class="string">'g'</span>, fontsize=<span class="number">16</span>, arrowprops=dict(arrowstyle=<span class="string">"-&gt;"</span>,</span><br><span class="line">             connectionstyle=<span class="string">"arc,rad=0"</span>, color=<span class="string">'k'</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Set the labels</span></span><br><span class="line">font = LabelFormat(plt)</span><br><span class="line">plt.xlabel(<span class="string">'$x^&#123;(1)&#125;$'</span>, font)</span><br><span class="line">plt.ylabel(<span class="string">'$y^&#123;(2)&#125;$'</span>, font)</span><br><span class="line"></span><br><span class="line">plt.xlim(<span class="number">0</span>,<span class="number">6</span>)</span><br><span class="line">plt.ylim(<span class="number">0</span>,<span class="number">6</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

    </div>
</div>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        图2对应的Python源代码为:
    </div>
    <div class='spoiler-content'>
        <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time : 2020/5/8 21:27</span></span><br><span class="line"><span class="comment"># @Author : tengweitw</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> mpl_toolkits.axisartist <span class="keyword">as</span> axisartist</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="comment"># Set the format of labels</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">LabelFormat</span><span class="params">(plt)</span>:</span></span><br><span class="line">    ax = plt.gca()</span><br><span class="line">    plt.tick_params(labelsize=<span class="number">14</span>)</span><br><span class="line">    labels = ax.get_xticklabels() + ax.get_yticklabels()</span><br><span class="line">    [label.set_fontname(<span class="string">'Times New Roman'</span>) <span class="keyword">for</span> label <span class="keyword">in</span> labels]</span><br><span class="line">    font = &#123;<span class="string">'family'</span>: <span class="string">'Times New Roman'</span>,</span><br><span class="line">            <span class="string">'weight'</span>: <span class="string">'normal'</span>,</span><br><span class="line">            <span class="string">'size'</span>: <span class="number">16</span>,</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="keyword">return</span> font</span><br><span class="line"></span><br><span class="line">x1=<span class="number">2</span></span><br><span class="line">y1=<span class="number">4</span></span><br><span class="line">x11=<span class="number">1</span></span><br><span class="line">y11=<span class="number">3</span></span><br><span class="line"></span><br><span class="line">x2=<span class="number">2.5</span></span><br><span class="line">y2=<span class="number">0.5</span></span><br><span class="line">x22=<span class="number">3</span></span><br><span class="line">y22=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">x3=np.linspace(<span class="number">-0.2</span>,<span class="number">4.2</span>,<span class="number">100</span>)</span><br><span class="line">y3=<span class="number">4</span>-x3</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fig = plt.figure(figsize=(<span class="number">6</span>, <span class="number">6</span>))</span><br><span class="line"></span><br><span class="line">ax = axisartist.Subplot(fig, <span class="number">111</span>)</span><br><span class="line"></span><br><span class="line">fig.add_axes(ax)</span><br><span class="line"></span><br><span class="line">ax.axis[:].set_visible(<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">font = LabelFormat(plt)</span><br><span class="line"></span><br><span class="line">ax.axis[<span class="string">"x"</span>] = ax.new_floating_axis(<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#Set properties of X axis</span></span><br><span class="line">ax.axis[<span class="string">"x"</span>].major_ticklabels.set_fontsize(<span class="number">14</span>)</span><br><span class="line">ax.axis[<span class="string">"x"</span>].major_ticklabels.set_fontname(<span class="string">'Times New Roman'</span>)</span><br><span class="line">ax.axis[<span class="string">"x"</span>].set_axisline_style(<span class="string">"-&gt;"</span>, size = <span class="number">1.0</span>)</span><br><span class="line">ax.axis[<span class="string">"x"</span>].label.set_text(<span class="string">'$x^&#123;(1)&#125;$'</span>)</span><br><span class="line">ax.axis[<span class="string">"x"</span>].label.set_fontsize(<span class="number">16</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#Set properties of Y axis</span></span><br><span class="line"></span><br><span class="line">ax.axis[<span class="string">"y"</span>] = ax.new_floating_axis(<span class="number">1</span>,<span class="number">0</span>)</span><br><span class="line">ax.axis[<span class="string">"y"</span>].major_ticklabels.set_fontsize(<span class="number">14</span>)</span><br><span class="line">ax.axis[<span class="string">"y"</span>].major_ticklabels.set_fontname(<span class="string">'Times New Roman'</span>)</span><br><span class="line">ax.axis[<span class="string">"y"</span>].set_axisline_style(<span class="string">"-&gt;"</span>, size = <span class="number">1.0</span>)</span><br><span class="line">ax.axis[<span class="string">"y"</span>].label.set_text(<span class="string">'$x^&#123;(2)&#125;$'</span>)</span><br><span class="line">ax.axis[<span class="string">"y"</span>].label.set_fontsize(<span class="number">16</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Set ticks's direction</span></span><br><span class="line">ax.axis[<span class="string">"x"</span>].set_axis_direction(<span class="string">"bottom"</span>)</span><br><span class="line">ax.axis[<span class="string">"y"</span>].set_axis_direction(<span class="string">"left"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Plot figures</span></span><br><span class="line">plt.plot(x1,y1,<span class="string">'rs'</span>)</span><br><span class="line">plt.text(x1+<span class="number">0.1</span>,y1,<span class="string">r'$\mathrm&#123;x&#125;_1$'</span>,fontsize=<span class="number">16</span>)</span><br><span class="line">plt.plot(x2,y2,<span class="string">'bo'</span>)</span><br><span class="line">plt.text(x2+<span class="number">0.05</span>,y2<span class="number">-0.1</span>,<span class="string">r'$\mathrm&#123;x&#125;_2$'</span>,fontsize=<span class="number">16</span>)</span><br><span class="line">plt.plot(x11,y11,<span class="string">'k+'</span>, markersize=<span class="number">16</span>)</span><br><span class="line">plt.text(x11<span class="number">-0.4</span>,y11,<span class="string">r'$\mathrm&#123;x&#125;_1^&#123;\perp&#125;$'</span>,fontsize=<span class="number">16</span>)</span><br><span class="line">plt.plot(x22,y22,<span class="string">'k+'</span>, markersize=<span class="number">16</span>)</span><br><span class="line">plt.text(x22+<span class="number">0.1</span>,y22<span class="number">-0.1</span>,<span class="string">r'$\mathrm&#123;x&#125;_2^&#123;\perp&#125;$'</span>,fontsize=<span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">plt.plot(x3,y3,<span class="string">'k-'</span>)</span><br><span class="line">plt.quiver(<span class="number">0</span>,<span class="number">0</span>,np.sqrt(<span class="number">2</span>)/<span class="number">2</span>,np.sqrt(<span class="number">2</span>)/<span class="number">2</span>,units=<span class="string">'xy'</span>,color=<span class="string">'deepskyblue'</span>,scale=<span class="number">1</span>,scale_units=<span class="string">'xy'</span>)</span><br><span class="line">plt.text(np.sqrt(<span class="number">2</span>)/<span class="number">2</span>,np.sqrt(<span class="number">2</span>)/<span class="number">2</span>, <span class="string">r'$\frac&#123;\mathrm&#123;w&#125;&#125;&#123;|\mathrm&#123;w&#125;|&#125;=(\frac&#123;\sqrt&#123;2&#125;&#125;&#123;2&#125;,\frac&#123;\sqrt&#123;2&#125;&#125;&#123;2&#125;)$'</span>, color=<span class="string">'deepskyblue'</span>,  fontsize=<span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">plt.quiver(<span class="number">0</span>,<span class="number">0</span>,x11,y11,units=<span class="string">'xy'</span>,color=<span class="string">'black'</span>,scale=<span class="number">1</span>,scale_units=<span class="string">'xy'</span>)</span><br><span class="line">plt.quiver(x11,y11,x1-x11,y1-y11,units=<span class="string">'xy'</span>,color=<span class="string">'deepskyblue'</span>,scale=<span class="number">1</span>,scale_units=<span class="string">'xy'</span>)</span><br><span class="line">plt.quiver(<span class="number">0</span>,<span class="number">0</span>,x1,y1,units=<span class="string">'xy'</span>,color=<span class="string">'red'</span>,scale=<span class="number">1</span>,scale_units=<span class="string">'xy'</span>)</span><br><span class="line"></span><br><span class="line">plt.quiver(<span class="number">0</span>,<span class="number">0</span>,x22,y22,units=<span class="string">'xy'</span>,color=<span class="string">'black'</span>,scale=<span class="number">1</span>,scale_units=<span class="string">'xy'</span>)</span><br><span class="line">plt.quiver(x22,y22,x2-x22,y2-y22,units=<span class="string">'xy'</span>,color=<span class="string">'deepskyblue'</span>,scale=<span class="number">1</span>,scale_units=<span class="string">'xy'</span>)</span><br><span class="line">plt.quiver(<span class="number">0</span>,<span class="number">0</span>,x2,y2,units=<span class="string">'xy'</span>,color=<span class="string">'blue'</span>,scale=<span class="number">1</span>,scale_units=<span class="string">'xy'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">plt.annotate(<span class="string">'$x^&#123;(1)&#125;+x^&#123;(2)&#125;-4=0$'</span>, xy=(<span class="number">2</span>, <span class="number">2</span>), xycoords=<span class="string">'data'</span>,</span><br><span class="line">             xytext=(<span class="number">0</span>, <span class="number">100</span>), textcoords=<span class="string">'offset points'</span>, color=<span class="string">'g'</span>, fontsize=<span class="number">16</span>, arrowprops=dict(arrowstyle=<span class="string">"-&gt;"</span>,</span><br><span class="line">             connectionstyle=<span class="string">"arc,rad=0"</span>, color=<span class="string">'k'</span>))</span><br><span class="line">plt.xlim(<span class="number">-0.5</span>,<span class="number">4.5</span>)</span><br><span class="line">plt.ylim(<span class="number">-0.5</span>,<span class="number">4.5</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

    </div>
</div>
<p>图3-4主要体现了如何添加文字，旋转，和标记点</p>
<table>
    <tr>
        <td ><center><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20200611/SVM_fig003.jpg"  >图3</center></td>
        <td ><center><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20200611/SVM_fig008.jpg"  >图4</center></td>
    </tr>
</table>


<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        图3对应的Python源代码：
    </div>
    <div class='spoiler-content'>
        <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time : 2020/5/10 16:39</span></span><br><span class="line"><span class="comment"># @Author : tengweitw</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> mpl_toolkits.axisartist <span class="keyword">as</span> axisartist</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="comment"># Set the format of labels</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">LabelFormat</span><span class="params">(plt)</span>:</span></span><br><span class="line">    ax = plt.gca()</span><br><span class="line">    plt.tick_params(labelsize=<span class="number">14</span>)</span><br><span class="line">    labels = ax.get_xticklabels() + ax.get_yticklabels()</span><br><span class="line">    [label.set_fontname(<span class="string">'Times New Roman'</span>) <span class="keyword">for</span> label <span class="keyword">in</span> labels]</span><br><span class="line">    font = &#123;<span class="string">'family'</span>: <span class="string">'Times New Roman'</span>,</span><br><span class="line">            <span class="string">'weight'</span>: <span class="string">'normal'</span>,</span><br><span class="line">            <span class="string">'size'</span>: <span class="number">16</span>,</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="keyword">return</span> font</span><br><span class="line"></span><br><span class="line">x1=<span class="number">3</span></span><br><span class="line">y1=<span class="number">3</span></span><br><span class="line"></span><br><span class="line">x2=<span class="number">4</span></span><br><span class="line">y2=<span class="number">3</span></span><br><span class="line"></span><br><span class="line">x3=<span class="number">1</span></span><br><span class="line">y3=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">x4=np.linspace(<span class="number">-1.2</span>,<span class="number">4.2</span>,<span class="number">100</span>)</span><br><span class="line">y4=<span class="number">4</span>-x4</span><br><span class="line"></span><br><span class="line">x11=np.linspace(<span class="number">-0.2</span>,<span class="number">5.2</span>,<span class="number">100</span>)</span><br><span class="line">y11=<span class="number">6</span>-x11</span><br><span class="line">x33=np.linspace(<span class="number">-2.2</span>,<span class="number">3.2</span>,<span class="number">100</span>)</span><br><span class="line">y33=<span class="number">2</span>-x33</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fig = plt.figure(figsize=(<span class="number">6</span>, <span class="number">6</span>))</span><br><span class="line"></span><br><span class="line">ax = axisartist.Subplot(fig, <span class="number">111</span>)</span><br><span class="line"></span><br><span class="line">fig.add_axes(ax)</span><br><span class="line"></span><br><span class="line">ax.axis[:].set_visible(<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">font = LabelFormat(plt)</span><br><span class="line"></span><br><span class="line">ax.axis[<span class="string">"x"</span>] = ax.new_floating_axis(<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ax.axis[<span class="string">"x"</span>].major_ticklabels.set_fontsize(<span class="number">14</span>)</span><br><span class="line">ax.axis[<span class="string">"x"</span>].major_ticklabels.set_fontname(<span class="string">'Times New Roman'</span>)</span><br><span class="line">ax.axis[<span class="string">"x"</span>].set_axisline_style(<span class="string">"-&gt;"</span>, size = <span class="number">1.0</span>)</span><br><span class="line">ax.axis[<span class="string">"x"</span>].label.set_text(<span class="string">'$x^&#123;(1)&#125;$'</span>)</span><br><span class="line">ax.axis[<span class="string">"x"</span>].label.set_fontsize(<span class="number">16</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ax.axis[<span class="string">"y"</span>] = ax.new_floating_axis(<span class="number">1</span>,<span class="number">0</span>)</span><br><span class="line">ax.axis[<span class="string">"y"</span>].major_ticklabels.set_fontsize(<span class="number">14</span>)</span><br><span class="line">ax.axis[<span class="string">"y"</span>].major_ticklabels.set_fontname(<span class="string">'Times New Roman'</span>)</span><br><span class="line">ax.axis[<span class="string">"y"</span>].set_axisline_style(<span class="string">"-&gt;"</span>, size = <span class="number">1.0</span>)</span><br><span class="line">ax.axis[<span class="string">"y"</span>].label.set_text(<span class="string">'$x^&#123;(2)&#125;$'</span>)</span><br><span class="line">ax.axis[<span class="string">"y"</span>].label.set_fontsize(<span class="number">16</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ax.axis[<span class="string">"x"</span>].set_axis_direction(<span class="string">"bottom"</span>)</span><br><span class="line">ax.axis[<span class="string">"y"</span>].set_axis_direction(<span class="string">"left"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Plot figures</span></span><br><span class="line">plt.plot(x1,y1,<span class="string">'rs'</span>)</span><br><span class="line">plt.text(x1<span class="number">-0.5</span>,y1,<span class="string">r'$\mathrm&#123;x&#125;_1$'</span>,fontsize=<span class="number">16</span>)</span><br><span class="line">plt.plot(x2,y2,<span class="string">'rs'</span>)</span><br><span class="line">plt.text(x2+<span class="number">0.05</span>,y2<span class="number">-0.1</span>,<span class="string">r'$\mathrm&#123;x&#125;_2$'</span>,fontsize=<span class="number">16</span>)</span><br><span class="line">plt.plot(x3,y3,<span class="string">'bo'</span>)</span><br><span class="line">plt.text(x3<span class="number">-0.5</span>,y3<span class="number">-0.1</span>,<span class="string">r'$\mathrm&#123;x&#125;_3$'</span>,fontsize=<span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">plt.plot(x4,y4,<span class="string">'g-'</span>)</span><br><span class="line">plt.text(<span class="number">1</span>,<span class="number">1</span>,<span class="string">r'$\frac&#123;1&#125;&#123;2&#125;x^&#123;(1)&#125;+\frac&#123;1&#125;&#123;2&#125;x^&#123;(2)&#125;-2=0$'</span>,fontsize=<span class="number">16</span>,rotation=<span class="number">-45</span>,color=<span class="string">'g'</span>)</span><br><span class="line">plt.plot(x11,y11,<span class="string">'r-'</span>)</span><br><span class="line">plt.text(<span class="number">2</span>,<span class="number">2</span>,<span class="string">r'$\frac&#123;1&#125;&#123;2&#125;x^&#123;(1)&#125;+\frac&#123;1&#125;&#123;2&#125;x^&#123;(2)&#125;-2=1$'</span>,fontsize=<span class="number">16</span>,rotation=<span class="number">-45</span>,color=<span class="string">'r'</span>)</span><br><span class="line">plt.plot(x33,y33,<span class="string">'b-'</span>)</span><br><span class="line">plt.text(<span class="number">0</span>,<span class="number">0</span>,<span class="string">r'$\frac&#123;1&#125;&#123;2&#125;x^&#123;(1)&#125;+\frac&#123;1&#125;&#123;2&#125;x^&#123;(2)&#125;-2=-1$'</span>,fontsize=<span class="number">16</span>,rotation=<span class="number">-45</span>,color=<span class="string">'b'</span>)</span><br><span class="line"></span><br><span class="line">plt.xlim(<span class="number">-2.5</span>,<span class="number">6.5</span>)</span><br><span class="line">plt.ylim(<span class="number">-2.5</span>,<span class="number">6.5</span>)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

    </div>
</div>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        图4对应的Python源代码：
    </div>
    <div class='spoiler-content'>
        <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time : 2020/5/17 17:14</span></span><br><span class="line"><span class="comment"># @Author : tengweitw</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> mpl_toolkits.axisartist <span class="keyword">as</span> axisartist</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="comment"># Set the format of labels</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">LabelFormat</span><span class="params">(plt)</span>:</span></span><br><span class="line">    ax = plt.gca()</span><br><span class="line">    plt.tick_params(labelsize=<span class="number">14</span>)</span><br><span class="line">    labels = ax.get_xticklabels() + ax.get_yticklabels()</span><br><span class="line">    [label.set_fontname(<span class="string">'Times New Roman'</span>) <span class="keyword">for</span> label <span class="keyword">in</span> labels]</span><br><span class="line">    font = &#123;<span class="string">'family'</span>: <span class="string">'Times New Roman'</span>,</span><br><span class="line">            <span class="string">'weight'</span>: <span class="string">'normal'</span>,</span><br><span class="line">            <span class="string">'size'</span>: <span class="number">16</span>,</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="keyword">return</span> font</span><br><span class="line"></span><br><span class="line">x1=<span class="number">3</span></span><br><span class="line">y1=<span class="number">3</span></span><br><span class="line"></span><br><span class="line">x2=<span class="number">4</span></span><br><span class="line">y2=<span class="number">3</span></span><br><span class="line"></span><br><span class="line">x3=<span class="number">1</span></span><br><span class="line">y3=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">x4,x5,x6,x12=<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span></span><br><span class="line">y4,y5,y6,y12=<span class="number">5</span>,<span class="number">5.5</span>,<span class="number">1</span>,<span class="number">2.5</span></span><br><span class="line"></span><br><span class="line">x7,x8,x9,x10,x11=<span class="number">2</span>,<span class="number">-1</span>,<span class="number">-2</span>,<span class="number">0.5</span>,<span class="number">1</span></span><br><span class="line">y7,y8,y9,y10,y11=<span class="number">-1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4.5</span>,<span class="number">2.2</span></span><br><span class="line"></span><br><span class="line">x222=np.linspace(<span class="number">-1.2</span>,<span class="number">4.2</span>,<span class="number">100</span>)</span><br><span class="line">y222=<span class="number">4</span>-x222</span><br><span class="line"></span><br><span class="line">x111=np.linspace(<span class="number">-0.2</span>,<span class="number">5.2</span>,<span class="number">100</span>)</span><br><span class="line">y111=<span class="number">6</span>-x111</span><br><span class="line">x333=np.linspace(<span class="number">-2.2</span>,<span class="number">3.2</span>,<span class="number">100</span>)</span><br><span class="line">y333=<span class="number">2</span>-x333</span><br><span class="line"></span><br><span class="line"><span class="comment">#Create figure square</span></span><br><span class="line">fig = plt.figure(figsize=(<span class="number">6</span>, <span class="number">6</span>))</span><br><span class="line"></span><br><span class="line">ax = axisartist.Subplot(fig, <span class="number">111</span>)</span><br><span class="line"></span><br><span class="line">fig.add_axes(ax)</span><br><span class="line"></span><br><span class="line">ax.axis[:].set_visible(<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">font = LabelFormat(plt)</span><br><span class="line"></span><br><span class="line">ax.axis[<span class="string">"x"</span>] = ax.new_floating_axis(<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#Set properties of X axis</span></span><br><span class="line">ax.axis[<span class="string">"x"</span>].major_ticklabels.set_fontsize(<span class="number">14</span>)</span><br><span class="line">ax.axis[<span class="string">"x"</span>].major_ticklabels.set_fontname(<span class="string">'Times New Roman'</span>)</span><br><span class="line">ax.axis[<span class="string">"x"</span>].set_axisline_style(<span class="string">"-&gt;"</span>, size = <span class="number">1.0</span>)</span><br><span class="line">ax.axis[<span class="string">"x"</span>].label.set_fontsize(<span class="number">16</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#Set properties of Y axis</span></span><br><span class="line">ax.axis[<span class="string">"y"</span>] = ax.new_floating_axis(<span class="number">1</span>,<span class="number">0</span>)</span><br><span class="line">ax.axis[<span class="string">"y"</span>].major_ticklabels.set_fontsize(<span class="number">14</span>)</span><br><span class="line">ax.axis[<span class="string">"y"</span>].major_ticklabels.set_fontname(<span class="string">'Times New Roman'</span>)</span><br><span class="line">ax.axis[<span class="string">"y"</span>].set_axisline_style(<span class="string">"-&gt;"</span>, size = <span class="number">1.0</span>)</span><br><span class="line">ax.axis[<span class="string">"y"</span>].label.set_fontsize(<span class="number">16</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Set ticks's direction</span></span><br><span class="line">ax.axis[<span class="string">"x"</span>].set_axis_direction(<span class="string">"bottom"</span>)</span><br><span class="line">ax.axis[<span class="string">"y"</span>].set_axis_direction(<span class="string">"left"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Plot figures</span></span><br><span class="line">plt.plot(x2,y2,<span class="string">'rs'</span>)</span><br><span class="line">plt.text(x2+<span class="number">0.5</span>,y2<span class="number">-0.1</span>,<span class="string">r'$\mathrm&#123;x&#125;_2$'</span>,fontsize=<span class="number">16</span>)</span><br><span class="line">plt.plot(x4,y4,<span class="string">'rs'</span>)</span><br><span class="line">plt.text(x4+<span class="number">0.5</span>,y4<span class="number">-0.1</span>,<span class="string">r'$\mathrm&#123;x&#125;_4$'</span>,fontsize=<span class="number">16</span>)</span><br><span class="line">plt.plot(x5,y5,<span class="string">'rs'</span>)</span><br><span class="line">plt.text(x5+<span class="number">0.5</span>,y5<span class="number">-0.1</span>,<span class="string">r'$\mathrm&#123;x&#125;_5$'</span>,fontsize=<span class="number">16</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#-------------------------------#</span></span><br><span class="line">plt.plot(x1,y1,<span class="string">'rs'</span>)</span><br><span class="line">plt.text(x1+<span class="number">0.2</span>,y1<span class="number">-0.2</span>,<span class="string">r'$\mathrm&#123;x&#125;_1$'</span>,fontsize=<span class="number">16</span>)</span><br><span class="line">plt.text(x1<span class="number">-0.2</span>,y1+<span class="number">0.2</span>,<span class="string">r'$\xi_1=0$'</span>,fontsize=<span class="number">14</span>)</span><br><span class="line"></span><br><span class="line">plt.plot(x6,y6,<span class="string">'rs'</span>)</span><br><span class="line">plt.text(x6+<span class="number">0.2</span>,y6<span class="number">-0.1</span>,<span class="string">r'$\mathrm&#123;x&#125;_6$'</span>,fontsize=<span class="number">16</span>)</span><br><span class="line">plt.plot(x6,y6,<span class="string">'bs'</span>, markersize=<span class="number">10</span>, markerfacecolor=<span class="string">"none"</span>)</span><br><span class="line">plt.text(x6<span class="number">-0</span>,y6<span class="number">-0.7</span>,<span class="string">r'$\xi_6&gt;1$'</span>,fontsize=<span class="number">14</span>)</span><br><span class="line"></span><br><span class="line">plt.plot(x12,y12,<span class="string">'rs'</span>)</span><br><span class="line">plt.text(x12<span class="number">-0.9</span>,y12<span class="number">-0.1</span>,<span class="string">r'$\mathrm&#123;x&#125;_&#123;12&#125;&#125;$'</span>,fontsize=<span class="number">16</span>)</span><br><span class="line">plt.plot(x12,y12,<span class="string">'rs'</span>, markersize=<span class="number">10</span>, markerfacecolor=<span class="string">"none"</span>)</span><br><span class="line">plt.text(x12<span class="number">-0.7</span>,y12<span class="number">-0.7</span>,<span class="string">r'$0&lt;\xi_&#123;12&#125;&lt;1$'</span>,fontsize=<span class="number">14</span>)</span><br><span class="line"></span><br><span class="line">plt.plot(x7,y7,<span class="string">'bo'</span>)</span><br><span class="line">plt.text(x7<span class="number">-0.7</span>,y7<span class="number">-0.1</span>,<span class="string">r'$\mathrm&#123;x&#125;_7$'</span>,fontsize=<span class="number">16</span>)</span><br><span class="line">plt.plot(x8,y8,<span class="string">'bo'</span>)</span><br><span class="line">plt.text(x8<span class="number">-0.7</span>,y8<span class="number">-0.1</span>,<span class="string">r'$\mathrm&#123;x&#125;_8$'</span>,fontsize=<span class="number">16</span>)</span><br><span class="line">plt.plot(x9,y9,<span class="string">'bo'</span>)</span><br><span class="line">plt.text(x9<span class="number">-0.7</span>,y9<span class="number">-0.1</span>,<span class="string">r'$\mathrm&#123;x&#125;_9$'</span>,fontsize=<span class="number">16</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#-----------------------------#</span></span><br><span class="line">plt.plot(x3,y3,<span class="string">'bo'</span>)</span><br><span class="line">plt.text(x3<span class="number">-0.7</span>,y3<span class="number">-0.1</span>,<span class="string">r'$\mathrm&#123;x&#125;_3$'</span>,fontsize=<span class="number">16</span>)</span><br><span class="line">plt.text(x3<span class="number">-0.9</span>,y3<span class="number">-0.7</span>,<span class="string">r'$\xi_3=0$'</span>,fontsize=<span class="number">14</span>)</span><br><span class="line"></span><br><span class="line">plt.plot(x10,y10,<span class="string">'bo'</span>)</span><br><span class="line">plt.text(x10+<span class="number">0.2</span>,y10<span class="number">-0.1</span>,<span class="string">r'$\mathrm&#123;x&#125;_&#123;10&#125;$'</span>,fontsize=<span class="number">16</span>)</span><br><span class="line">plt.plot(x10,y10,<span class="string">'ro'</span>, markersize=<span class="number">10</span>, markerfacecolor=<span class="string">"none"</span>)</span><br><span class="line">plt.text(x10<span class="number">-0.2</span>,y10<span class="number">-0.5</span>,<span class="string">r'$\xi_&#123;10&#125;&gt;1$'</span>,fontsize=<span class="number">14</span>)</span><br><span class="line"></span><br><span class="line">plt.plot(x11,y11,<span class="string">'bo'</span>)</span><br><span class="line">plt.text(x11<span class="number">-0.7</span>,y11<span class="number">-0.3</span>,<span class="string">r'$\mathrm&#123;x&#125;_&#123;11&#125;$'</span>,fontsize=<span class="number">16</span>)</span><br><span class="line">plt.plot(x11,y11,<span class="string">'bo'</span>, markersize=<span class="number">10</span>, markerfacecolor=<span class="string">"none"</span>)</span><br><span class="line">plt.text(x11<span class="number">-1.5</span>,y11+<span class="number">0.2</span>,<span class="string">r'$0&lt;\xi_&#123;11&#125;&lt;1$'</span>,fontsize=<span class="number">14</span>)</span><br><span class="line"></span><br><span class="line">plt.plot(x222,y222,<span class="string">'g-'</span>)</span><br><span class="line">plt.text(<span class="number">4</span>,<span class="number">-1</span>,<span class="string">r'$\hat y=0$'</span>,fontsize=<span class="number">16</span>,rotation=<span class="number">45</span>,color=<span class="string">'g'</span>)</span><br><span class="line">plt.plot(x111,y111,<span class="string">'r-'</span>)</span><br><span class="line">plt.text(<span class="number">5</span>,<span class="number">-0</span>,<span class="string">r'$\hat y=+1$'</span>,fontsize=<span class="number">16</span>,rotation=<span class="number">45</span>,color=<span class="string">'r'</span>)</span><br><span class="line">plt.plot(x333,y333,<span class="string">'b-'</span>)</span><br><span class="line">plt.text(<span class="number">2.5</span>,<span class="number">-2.5</span>,<span class="string">r'$\hat y=-1$'</span>,fontsize=<span class="number">16</span>,rotation=<span class="number">45</span>,color=<span class="string">'b'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">plt.text(<span class="number">-0.8</span>,<span class="number">6.5</span>,<span class="string">r'$x^&#123;(2)&#125;$'</span>,fontsize=<span class="number">16</span>,rotation=<span class="number">90</span>,color=<span class="string">'k'</span>)</span><br><span class="line">plt.text(<span class="number">6.3</span>,<span class="number">-0.8</span>,<span class="string">r'$x^&#123;(1)&#125;$'</span>,fontsize=<span class="number">16</span>,rotation=<span class="number">0</span>,color=<span class="string">'k'</span>)</span><br><span class="line"></span><br><span class="line">plt.xlim(<span class="number">-2.5</span>,<span class="number">6.5</span>)</span><br><span class="line">plt.ylim(<span class="number">-2.5</span>,<span class="number">6.5</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

    </div>
</div>
<p>图5-6主要体现画三维图</p>
<table>
    <tr>
        <td ><center><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20200611/SVM_fig004.jpg"  >图5</center></td>
        <td ><center><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20200611/SVM_fig005.jpg"  >图6</center></td>
    </tr>
</table>


<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        图5对应的Python源代码：
    </div>
    <div class='spoiler-content'>
        <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time : 2020/5/14 16:35</span></span><br><span class="line"><span class="comment"># @Author : tengweitw</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> mpl_toolkits.axisartist <span class="keyword">as</span> axisartist</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="comment"># Set the format of labels</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">LabelFormat</span><span class="params">(plt)</span>:</span></span><br><span class="line">    ax = plt.gca()</span><br><span class="line">    plt.tick_params(labelsize=<span class="number">14</span>)</span><br><span class="line">    labels = ax.get_xticklabels() + ax.get_yticklabels()</span><br><span class="line">    [label.set_fontname(<span class="string">'Times New Roman'</span>) <span class="keyword">for</span> label <span class="keyword">in</span> labels]</span><br><span class="line">    font = &#123;<span class="string">'family'</span>: <span class="string">'Times New Roman'</span>,</span><br><span class="line">            <span class="string">'weight'</span>: <span class="string">'normal'</span>,</span><br><span class="line">            <span class="string">'size'</span>: <span class="number">16</span>,</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="keyword">return</span> font</span><br><span class="line"></span><br><span class="line">x1=<span class="number">0</span></span><br><span class="line">y1=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">x2=<span class="number">1</span></span><br><span class="line">y2=<span class="number">0</span></span><br><span class="line"></span><br><span class="line">x3=<span class="number">0</span></span><br><span class="line">y3=<span class="number">0</span></span><br><span class="line"></span><br><span class="line">x4=<span class="number">1</span></span><br><span class="line">y4=<span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fig = plt.figure(figsize=(<span class="number">6</span>, <span class="number">6</span>))</span><br><span class="line"></span><br><span class="line">ax = axisartist.Subplot(fig, <span class="number">111</span>)</span><br><span class="line"></span><br><span class="line">fig.add_axes(ax)</span><br><span class="line"></span><br><span class="line">ax.axis[:].set_visible(<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">font = LabelFormat(plt)</span><br><span class="line"></span><br><span class="line">ax.axis[<span class="string">"x"</span>] = ax.new_floating_axis(<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ax.axis[<span class="string">"x"</span>].major_ticklabels.set_fontsize(<span class="number">14</span>)</span><br><span class="line">ax.axis[<span class="string">"x"</span>].major_ticklabels.set_fontname(<span class="string">'Times New Roman'</span>)</span><br><span class="line">ax.axis[<span class="string">"x"</span>].set_axisline_style(<span class="string">"-&gt;"</span>, size = <span class="number">1.0</span>)</span><br><span class="line">ax.axis[<span class="string">"x"</span>].label.set_text(<span class="string">'$x^&#123;(1)&#125;$'</span>)</span><br><span class="line">ax.axis[<span class="string">"x"</span>].label.set_fontsize(<span class="number">16</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ax.axis[<span class="string">"y"</span>] = ax.new_floating_axis(<span class="number">1</span>,<span class="number">0</span>)</span><br><span class="line">ax.axis[<span class="string">"y"</span>].major_ticklabels.set_fontsize(<span class="number">14</span>)</span><br><span class="line">ax.axis[<span class="string">"y"</span>].major_ticklabels.set_fontname(<span class="string">'Times New Roman'</span>)</span><br><span class="line">ax.axis[<span class="string">"y"</span>].set_axisline_style(<span class="string">"-&gt;"</span>, size = <span class="number">1.0</span>)</span><br><span class="line">ax.axis[<span class="string">"y"</span>].label.set_text(<span class="string">'$x^&#123;(2)&#125;$'</span>)</span><br><span class="line">ax.axis[<span class="string">"y"</span>].label.set_fontsize(<span class="number">16</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ax.axis[<span class="string">"x"</span>].set_axis_direction(<span class="string">"bottom"</span>)</span><br><span class="line">ax.axis[<span class="string">"y"</span>].set_axis_direction(<span class="string">"left"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Plot figures</span></span><br><span class="line">plt.plot(x1,y1,<span class="string">'rs'</span>)</span><br><span class="line">plt.text(x1+<span class="number">0.05</span>,y1+<span class="number">0.1</span>,<span class="string">r'$\mathrm&#123;x&#125;_1$'</span>,fontsize=<span class="number">20</span>)</span><br><span class="line">plt.plot(x2,y2,<span class="string">'rs'</span>)</span><br><span class="line">plt.text(x2+<span class="number">0.05</span>,y2+<span class="number">0.1</span>,<span class="string">r'$\mathrm&#123;x&#125;_2$'</span>,fontsize=<span class="number">20</span>)</span><br><span class="line">plt.plot(x3,y3,<span class="string">'bo'</span>)</span><br><span class="line">plt.text(x3+<span class="number">0.05</span>,y3+<span class="number">0.1</span>,<span class="string">r'$\mathrm&#123;x&#125;_3$'</span>,fontsize=<span class="number">20</span>)</span><br><span class="line">plt.plot(x4,y4,<span class="string">'bo'</span>)</span><br><span class="line">plt.text(x4+<span class="number">0.05</span>,y4+<span class="number">0.1</span>,<span class="string">r'$\mathrm&#123;x&#125;_4$'</span>,fontsize=<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line">plt.xlim(<span class="number">-0.2</span>,<span class="number">1.5</span>)</span><br><span class="line">plt.ylim(<span class="number">-0.2</span>,<span class="number">1.5</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

    </div>
</div>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        图6对应的Python源代码:
    </div>
    <div class='spoiler-content'>
        <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time : 2020/5/14 16:47</span></span><br><span class="line"><span class="comment"># @Author : tengweitw</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> mpl_toolkits.mplot3d <span class="keyword">import</span> Axes3D</span><br><span class="line"><span class="keyword">import</span> mpl_toolkits.axisartist <span class="keyword">as</span> axisartist</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="comment"># Set the format of labels</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">LabelFormat</span><span class="params">(plt)</span>:</span></span><br><span class="line">    ax = plt.gca()</span><br><span class="line">    plt.tick_params(labelsize=<span class="number">14</span>)</span><br><span class="line">    labels = ax.get_xticklabels() + ax.get_yticklabels()</span><br><span class="line">    [label.set_fontname(<span class="string">'Times New Roman'</span>) <span class="keyword">for</span> label <span class="keyword">in</span> labels]</span><br><span class="line">    font = &#123;<span class="string">'family'</span>: <span class="string">'Times New Roman'</span>,</span><br><span class="line">            <span class="string">'weight'</span>: <span class="string">'normal'</span>,</span><br><span class="line">            <span class="string">'size'</span>: <span class="number">16</span>,</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="keyword">return</span> font</span><br><span class="line"></span><br><span class="line">fig = plt.figure(figsize=(<span class="number">6</span>, <span class="number">6</span>))</span><br><span class="line">ax = plt.axes(projection=<span class="string">'3d'</span>)</span><br><span class="line"></span><br><span class="line">x1,y1,z1=<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span></span><br><span class="line">x2,y2,z2=<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span></span><br><span class="line">x3,y3,z3=<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span></span><br><span class="line">x4,y4,z4=<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span></span><br><span class="line"></span><br><span class="line">x=np.linspace(<span class="number">-0.1</span>,<span class="number">1.1</span>,<span class="number">100</span>)</span><br><span class="line">y=np.linspace(<span class="number">-0.1</span>,<span class="number">1.1</span>,<span class="number">100</span>)</span><br><span class="line">X, Y = np.meshgrid(x, y)</span><br><span class="line">Z = <span class="number">0.75</span>+<span class="number">2</span>*X-Y</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ax.scatter([x1,x2],[y1,y2],[z1,z2],marker=<span class="string">'s'</span>,alpha=<span class="number">1</span>,c=<span class="string">'r'</span>,s=<span class="number">30</span>)</span><br><span class="line">ax.scatter([x3,x4],[y3,y4],[z3,z4],marker=<span class="string">'o'</span>,alpha=<span class="number">1</span>,c=<span class="string">'b'</span>,s=<span class="number">30</span>)</span><br><span class="line"></span><br><span class="line">ax.plot_surface(X,Y,Z,cmap=<span class="string">'rainbow'</span>)</span><br><span class="line"></span><br><span class="line">ax.set_xlim(<span class="number">-0.1</span>, <span class="number">1.1</span>)</span><br><span class="line">ax.set_ylim(<span class="number">-0.1</span>, <span class="number">1.1</span>)</span><br><span class="line">ax.set_zlim(<span class="number">-0.1</span>, <span class="number">1.1</span>)</span><br><span class="line">ax.set_xlabel(<span class="string">'X'</span>)</span><br><span class="line">ax.set_ylabel(<span class="string">'Y'</span>)</span><br><span class="line">ax.set_zlabel(<span class="string">'Z'</span>)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

    </div>
</div>
<p>图7-8是特征空间转化图：</p>
<table>
    <tr>
        <td ><center><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20200611/SVM_fig006.jpg"  >图7</center></td>
        <td ><center><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20200611/SVM_fig007.jpg"  >图8</center></td>
    </tr>
</table>


<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        图7对应的Python源代码为：
    </div>
    <div class='spoiler-content'>
        <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time : 2020/5/14 16:57</span></span><br><span class="line"><span class="comment"># @Author : tengweitw</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> mpl_toolkits.axisartist <span class="keyword">as</span> axisartist</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="comment"># Set the format of labels</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">LabelFormat</span><span class="params">(plt)</span>:</span></span><br><span class="line">    ax = plt.gca()</span><br><span class="line">    plt.tick_params(labelsize=<span class="number">14</span>)</span><br><span class="line">    labels = ax.get_xticklabels() + ax.get_yticklabels()</span><br><span class="line">    [label.set_fontname(<span class="string">'Times New Roman'</span>) <span class="keyword">for</span> label <span class="keyword">in</span> labels]</span><br><span class="line">    font = &#123;<span class="string">'family'</span>: <span class="string">'Times New Roman'</span>,</span><br><span class="line">            <span class="string">'weight'</span>: <span class="string">'normal'</span>,</span><br><span class="line">            <span class="string">'size'</span>: <span class="number">16</span>,</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="keyword">return</span> font</span><br><span class="line"></span><br><span class="line">theta=np.linspace(<span class="number">0</span>,<span class="number">2</span>*np.pi,<span class="number">10</span>)</span><br><span class="line">r1=<span class="number">1</span></span><br><span class="line">r2=<span class="number">2</span></span><br><span class="line">x1=r1*np.sin(theta)</span><br><span class="line">y1=r1*np.cos(theta)</span><br><span class="line">x2=r2*np.sin(theta)</span><br><span class="line">y2=r2*np.cos(theta)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fig = plt.figure(figsize=(<span class="number">6</span>, <span class="number">6</span>))</span><br><span class="line"></span><br><span class="line">ax = axisartist.Subplot(fig, <span class="number">111</span>)</span><br><span class="line">fig.add_axes(ax)</span><br><span class="line">ax.axis[:].set_visible(<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">font = LabelFormat(plt)</span><br><span class="line">ax.axis[<span class="string">"x"</span>] = ax.new_floating_axis(<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">ax.axis[<span class="string">"x"</span>].major_ticklabels.set_fontsize(<span class="number">14</span>)</span><br><span class="line">ax.axis[<span class="string">"x"</span>].major_ticklabels.set_fontname(<span class="string">'Times New Roman'</span>)</span><br><span class="line">ax.axis[<span class="string">"x"</span>].set_axisline_style(<span class="string">"-&gt;"</span>, size = <span class="number">1.0</span>)</span><br><span class="line"><span class="comment"># ax.axis["x"].label.set_text('$x^&#123;(1)&#125;$')</span></span><br><span class="line">ax.axis[<span class="string">"x"</span>].label.set_fontsize(<span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">ax.axis[<span class="string">"y"</span>] = ax.new_floating_axis(<span class="number">1</span>,<span class="number">0</span>)</span><br><span class="line">ax.axis[<span class="string">"y"</span>].major_ticklabels.set_fontsize(<span class="number">14</span>)</span><br><span class="line">ax.axis[<span class="string">"y"</span>].major_ticklabels.set_fontname(<span class="string">'Times New Roman'</span>)</span><br><span class="line">ax.axis[<span class="string">"y"</span>].set_axisline_style(<span class="string">"-&gt;"</span>, size = <span class="number">1.0</span>)</span><br><span class="line"><span class="comment"># ax.axis["y"].label.set_text('$x^&#123;(2)&#125;$')</span></span><br><span class="line">ax.axis[<span class="string">"y"</span>].label.set_fontsize(<span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">ax.axis[<span class="string">"x"</span>].set_axis_direction(<span class="string">"bottom"</span>)</span><br><span class="line">ax.axis[<span class="string">"y"</span>].set_axis_direction(<span class="string">"left"</span>)</span><br><span class="line">ax.axis[<span class="string">"y"</span>].label.set_verticalalignment(<span class="string">"top"</span>)</span><br><span class="line">ax.axis[<span class="string">"x"</span>].label.set_verticalalignment(<span class="string">"top"</span>)</span><br><span class="line">ax.axis[<span class="string">"y"</span>].label.set_horizontalalignment(<span class="string">"left"</span>)</span><br><span class="line">ax.axis[<span class="string">"x"</span>].label.set_horizontalalignment(<span class="string">"left"</span>)</span><br><span class="line"><span class="comment"># Plot figures</span></span><br><span class="line">plt.plot(x1,y1,<span class="string">'bo'</span>)</span><br><span class="line">plt.plot(x2,y2,<span class="string">'rs'</span>)</span><br><span class="line"></span><br><span class="line">plt.text(<span class="number">-0.4</span>,<span class="number">3.5</span>,<span class="string">r'$x^&#123;(2)&#125;$'</span>,fontsize=<span class="number">16</span>,rotation=<span class="number">90</span>,color=<span class="string">'k'</span>)</span><br><span class="line">plt.text(<span class="number">3.3</span>,<span class="number">-0.4</span>,<span class="string">r'$x^&#123;(1)&#125;$'</span>,fontsize=<span class="number">16</span>,rotation=<span class="number">0</span>,color=<span class="string">'k'</span>)</span><br><span class="line"></span><br><span class="line">plt.xlim(<span class="number">-4</span>,<span class="number">4</span>)</span><br><span class="line">plt.ylim(<span class="number">-4</span>,<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

    </div>
</div>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        图8对应的Python源代码为：
    </div>
    <div class='spoiler-content'>
        <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time : 2020/5/16 14:50</span></span><br><span class="line"><span class="comment"># @Author : tengweitw</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> mpl_toolkits.axisartist <span class="keyword">as</span> axisartist</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="comment"># Set the format of labels</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">LabelFormat</span><span class="params">(plt)</span>:</span></span><br><span class="line">    ax = plt.gca()</span><br><span class="line">    plt.tick_params(labelsize=<span class="number">14</span>)</span><br><span class="line">    labels = ax.get_xticklabels() + ax.get_yticklabels()</span><br><span class="line">    [label.set_fontname(<span class="string">'Times New Roman'</span>) <span class="keyword">for</span> label <span class="keyword">in</span> labels]</span><br><span class="line">    font = &#123;<span class="string">'family'</span>: <span class="string">'Times New Roman'</span>,</span><br><span class="line">            <span class="string">'weight'</span>: <span class="string">'normal'</span>,</span><br><span class="line">            <span class="string">'size'</span>: <span class="number">16</span>,</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="keyword">return</span> font</span><br><span class="line"></span><br><span class="line">theta=np.linspace(<span class="number">0</span>,<span class="number">2</span>*np.pi,<span class="number">10</span>)</span><br><span class="line">r1=<span class="number">1</span></span><br><span class="line">r2=<span class="number">2</span></span><br><span class="line">x1=r1*np.sin(theta)</span><br><span class="line">y1=r1*np.cos(theta)</span><br><span class="line">x2=r2*np.sin(theta)</span><br><span class="line">y2=r2*np.cos(theta)</span><br><span class="line"></span><br><span class="line">x11=x1**<span class="number">2</span></span><br><span class="line">y11=y1**<span class="number">2</span></span><br><span class="line"></span><br><span class="line">x22=x2**<span class="number">2</span></span><br><span class="line">y22=y2**<span class="number">2</span></span><br><span class="line"></span><br><span class="line">x3=np.linspace(<span class="number">-0.5</span>,<span class="number">3</span>,<span class="number">100</span>)</span><br><span class="line">y3=<span class="number">2.5</span>-x3</span><br><span class="line"></span><br><span class="line">fig = plt.figure(figsize=(<span class="number">6</span>, <span class="number">6</span>))</span><br><span class="line"></span><br><span class="line">ax = axisartist.Subplot(fig, <span class="number">111</span>)</span><br><span class="line">fig.add_axes(ax)</span><br><span class="line">ax.axis[:].set_visible(<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">font = LabelFormat(plt)</span><br><span class="line">ax.axis[<span class="string">"x"</span>] = ax.new_floating_axis(<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">ax.axis[<span class="string">"x"</span>].major_ticklabels.set_fontsize(<span class="number">14</span>)</span><br><span class="line">ax.axis[<span class="string">"x"</span>].major_ticklabels.set_fontname(<span class="string">'Times New Roman'</span>)</span><br><span class="line">ax.axis[<span class="string">"x"</span>].set_axisline_style(<span class="string">"-&gt;"</span>, size = <span class="number">1.0</span>)</span><br><span class="line">ax.axis[<span class="string">"x"</span>].label.set_text(<span class="string">'$x^&#123;(1)&#125;$'</span>)</span><br><span class="line">ax.axis[<span class="string">"x"</span>].label.set_fontsize(<span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">ax.axis[<span class="string">"y"</span>] = ax.new_floating_axis(<span class="number">1</span>,<span class="number">0</span>)</span><br><span class="line">ax.axis[<span class="string">"y"</span>].major_ticklabels.set_fontsize(<span class="number">14</span>)</span><br><span class="line">ax.axis[<span class="string">"y"</span>].major_ticklabels.set_fontname(<span class="string">'Times New Roman'</span>)</span><br><span class="line">ax.axis[<span class="string">"y"</span>].set_axisline_style(<span class="string">"-&gt;"</span>, size = <span class="number">1.0</span>)</span><br><span class="line">ax.axis[<span class="string">"y"</span>].label.set_text(<span class="string">'$x^&#123;(2)&#125;$'</span>)</span><br><span class="line">ax.axis[<span class="string">"y"</span>].label.set_fontsize(<span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">ax.axis[<span class="string">"x"</span>].set_axis_direction(<span class="string">"bottom"</span>)</span><br><span class="line">ax.axis[<span class="string">"y"</span>].set_axis_direction(<span class="string">"left"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Plot figures</span></span><br><span class="line">plt.plot(x11,y11,<span class="string">'bo'</span>)</span><br><span class="line">plt.plot(x22,y22,<span class="string">'rs'</span>)</span><br><span class="line">plt.plot(x3,y3,<span class="string">'g-'</span>)</span><br><span class="line">plt.text(<span class="number">0.5</span>,<span class="number">0.5</span>,<span class="string">r'$x^&#123;(1)&#125;+x^&#123;(2)&#125;-2.5=0$'</span>,fontsize=<span class="number">16</span>,rotation=<span class="number">-45</span>,color=<span class="string">'g'</span>)</span><br><span class="line"></span><br><span class="line">plt.xlim(<span class="number">-1</span>,<span class="number">5</span>)</span><br><span class="line">plt.ylim(<span class="number">-1</span>,<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

    </div>
</div>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>Machine Learning</tag>
      </tags>
  </entry>
  <entry>
    <title>【漫漫科研路\Python&amp;Tikz】画神经网络相关图</title>
    <url>/2020/06/10/%5B20200610%5D/</url>
    <content><![CDATA[<p>前一篇文章【<a href="https://blog.csdn.net/tengweitw/article/details/106646865" target="_blank" rel="noopener">图解例说机器学习】神经网络</a>中，由于篇幅有限，我们只介绍了其理论部分。作为补充，本文主要介绍文中所有图像的绘制(使用Tikz或者Python)。对于神经网络中的框架图 (例如神经元，神经网络结构)，我们采用Tikz绘制；对于坐标系的函数图像，我们采用Python绘制。注意：Tikz源代码需要在LaTeX中运行，其配置环境可以参考我之前的文章<a href="https://blog.csdn.net/tengweitw/article/details/104954220" target="_blank" rel="noopener">【漫漫科研路\LaTeX】使用Sublime Text3撰写科研论文</a>(Windows系统下)或者<a href="https://blog.csdn.net/tengweitw/article/details/103759321" target="_blank" rel="noopener">【漫漫科研路\LaTeX】使用Vim撰写科研论文</a>(MacOS系统下)。</p>
<hr>
<a id="more"></a>
<h2 id="Tikz-pgfplots-绘制神经网络"><a href="#Tikz-pgfplots-绘制神经网络" class="headerlink" title="Tikz/pgfplots 绘制神经网络"></a>Tikz/pgfplots 绘制神经网络</h2><p>图1,2是M-P神经元</p>
<table>
    <tr>
        <td ><center><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20200610/Neural_Networks_fig001.jpg"  >图1</center></td>
        <td ><center><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20200610/Neural_Networks_fig004.jpg"  >图2</center></td>
    </tr>
</table>


<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        图1的tikz源代码：
    </div>
    <div class='spoiler-content'>
        <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\documentclass&#123;article&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">\usepackage&#123;amsmath&#125;</span><br><span class="line">\usepackage&#123;tikz&#125;</span><br><span class="line">\usetikzlibrary&#123;shapes, calc, shapes, arrows&#125;</span><br><span class="line"></span><br><span class="line">\begin&#123;document&#125;</span><br><span class="line"></span><br><span class="line">\tikzstyle&#123;inputNode&#125;&#x3D;[draw,circle,minimum size&#x3D;25pt,inner sep&#x3D;0pt]</span><br><span class="line">\tikzstyle&#123;stateTransition&#125;&#x3D;[-&gt;, thick]</span><br><span class="line">\begin&#123;tikzpicture&#125;</span><br><span class="line">    \node[draw,circle,minimum size&#x3D;35pt,inner sep&#x3D;0pt] (x) at (0,0) &#123;$\Sigma$ $f$&#125;;</span><br><span class="line"></span><br><span class="line">    \node[inputNode] (x0) at (-3, 2.25) &#123;\color&#123;red&#125;$x^&#123;(0)&#125;$&#125;;</span><br><span class="line">    \node[inputNode] (x1) at (-3, 1.25) &#123;\color&#123;red&#125;$x^&#123;(1)&#125;$&#125;;</span><br><span class="line">    \node[inputNode] (xj) at (-3, -0.5) &#123;\color&#123;red&#125;$x^&#123;(j)&#125;$&#125;;</span><br><span class="line">    \node[inputNode] (xm) at (-3, -2.25) &#123;\color&#123;red&#125;$x^&#123;(M)&#125;$&#125;;</span><br><span class="line"></span><br><span class="line">    \draw[stateTransition] (x0) to[out&#x3D;0,in&#x3D;120] node [midway, sloped, above&#x3D;-2] &#123;\color&#123;green!40!black&#125;$\omega_0$&#125; (x);</span><br><span class="line">    \draw[stateTransition] (x1) to[out&#x3D;0,in&#x3D;150] node [midway, sloped, above&#x3D;-2] &#123;\color&#123;green!40!black&#125;$\omega_1$&#125; (x);</span><br><span class="line">    \draw[stateTransition] (xj) to[out&#x3D;0,in&#x3D;210] node [midway, sloped, above&#x3D;-2] &#123;\color&#123;green!40!black&#125;$\omega_j$&#125; (x);</span><br><span class="line">    \draw[stateTransition] (xm) to[out&#x3D;0,in&#x3D;240] node [midway, sloped, above&#x3D;-2] &#123;\color&#123;green!40!black&#125;$\omega_M$&#125; (x);</span><br><span class="line">    \color&#123;blue&#125;</span><br><span class="line">    \draw[stateTransition] (x) -- (2,0) node [midway,above&#x3D;-0.1cm] &#123;y&#125;;</span><br><span class="line">    \draw[dashed] (0,-0.5) -- (0,0.5);</span><br><span class="line">    \node (dots) at (-3, -1.25) &#123;$\vdots$&#125;;</span><br><span class="line">    \node (dots) at (-3, 0.5) &#123;$\vdots$&#125;;</span><br><span class="line">\end&#123;tikzpicture&#125;</span><br><span class="line"></span><br><span class="line">\end&#123;document&#125;</span><br></pre></td></tr></table></figure>

    </div>
</div>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        图2的tikz源代码:
    </div>
    <div class='spoiler-content'>
        <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\documentclass[crop, tikz]&#123;standalone&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">\usepackage&#123;amsmath&#125;</span><br><span class="line">\usepackage&#123;tikz&#125;</span><br><span class="line">\usetikzlibrary&#123;shapes, calc, shapes, arrows&#125;</span><br><span class="line"></span><br><span class="line">\begin&#123;document&#125;</span><br><span class="line"></span><br><span class="line">\tikzstyle&#123;inputNode&#125;&#x3D;[draw,circle,minimum size&#x3D;25pt,inner sep&#x3D;0pt]</span><br><span class="line">\tikzstyle&#123;stateTransition&#125;&#x3D;[-&gt;, thick]</span><br><span class="line">\begin&#123;tikzpicture&#125;</span><br><span class="line">    \node[draw,circle,minimum size&#x3D;35pt,inner sep&#x3D;0pt] (x) at (0,0) &#123;$\Sigma$ $\hspace&#123;1.5mm&#125;sgn$&#125;;</span><br><span class="line"></span><br><span class="line">    \node[inputNode] (x0) at (-3, 1.25) &#123;\color&#123;red&#125;$x^&#123;(0)&#125;$&#125;;</span><br><span class="line">    \node[inputNode] (x1) at (-3, 0) &#123;\color&#123;red&#125;$x^&#123;(1)&#125;$&#125;;</span><br><span class="line">    \node[inputNode] (x2) at (-3, -1.25) &#123;\color&#123;red&#125;$x^&#123;(2)&#125;$&#125;;</span><br><span class="line"></span><br><span class="line">    \draw[stateTransition] (x0) to node [midway, sloped, above&#x3D;-2] &#123;\color&#123;green!40!black&#125;$\omega_0$&#125; (x);</span><br><span class="line">    \draw[stateTransition] (x1) to node [midway, sloped, above&#x3D;-2] &#123;\color&#123;green!40!black&#125;$\omega_1$&#125; (x);</span><br><span class="line">    \draw[stateTransition] (x2) to node [midway, sloped, above&#x3D;-2] &#123;\color&#123;green!40!black&#125;$\omega_2$&#125; (x);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    \color&#123;blue&#125;</span><br><span class="line">    \draw[stateTransition] (x) -- (4,0) node [midway,above&#x3D;-0.1cm] &#123;$y&#x3D;\color&#123;black&#125;sgn\left(\sum\limits_&#123;j&#x3D;0&#125;^&#123;2&#125;\color&#123;green!40!black&#125;\omega_j\color&#123;red&#125;x^&#123;(j)&#125;\color&#123;black&#125;\right)$&#125;;</span><br><span class="line">    \draw[dashed] (0,-0.5) -- (0,0.5);</span><br><span class="line"></span><br><span class="line">\end&#123;tikzpicture&#125;</span><br><span class="line"></span><br><span class="line">\end&#123;document&#125;</span><br></pre></td></tr></table></figure>

    </div>
</div>
<p>图3和图4是常见的神经网络结构图：</p>
<table>
    <tr>
        <td ><center><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20200610/Neural_Networks_fig005.jpg"  >图3</center></td>
        <td ><center><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20200610/Neural_Networks_fig009.jpg"  >图4</center></td>
    </tr>
</table>


<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        图3的Tikz源代码为：
    </div>
    <div class='spoiler-content'>
        <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\documentclass[crop, tikz]&#123;standalone&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">\usepackage&#123;amsmath&#125;</span><br><span class="line">\usepackage&#123;tikz&#125;</span><br><span class="line">\usetikzlibrary&#123;shapes, calc, shapes, arrows&#125;</span><br><span class="line"></span><br><span class="line">\begin&#123;document&#125;</span><br><span class="line"></span><br><span class="line">\tikzstyle&#123;inputNode&#125;&#x3D;[draw,circle,minimum size&#x3D;25pt,inner sep&#x3D;0pt]</span><br><span class="line">\tikzstyle&#123;stateTransition&#125;&#x3D;[-&gt;, thick]</span><br><span class="line">\begin&#123;tikzpicture&#125;</span><br><span class="line">    \node[draw,circle,minimum size&#x3D;25pt,inner sep&#x3D;0pt,blue] (x) at (3,0) &#123;$y$&#125;;</span><br><span class="line"></span><br><span class="line">    \node[inputNode] (x0) at (-3, 2.25) &#123;\color&#123;red&#125;$x^&#123;(0)&#125;$&#125;;</span><br><span class="line">    \node[inputNode] (x1) at (-3, 0) &#123;\color&#123;red&#125;$x^&#123;(1)&#125;$&#125;;</span><br><span class="line">    \node[inputNode] (x2) at (-3, -2.25) &#123;\color&#123;red&#125;$x^&#123;(2)&#125;$&#125;;</span><br><span class="line"></span><br><span class="line">    \node[inputNode] (z0) at (0, 2.25) &#123;\color&#123;green&#125;$z^&#123;(0)&#125;$&#125;;</span><br><span class="line">    \node[inputNode] (z1) at (0, 0) &#123;\color&#123;green&#125;$z^&#123;(1)&#125;$&#125;;</span><br><span class="line">    \node[inputNode] (z2) at (0, -2.25) &#123;\color&#123;green&#125;$z^&#123;(2)&#125;$&#125;;</span><br><span class="line"></span><br><span class="line">    \draw[stateTransition] (x0) to node [midway, sloped, above&#x3D;-2,xshift&#x3D;-25] &#123;\color&#123;green!40!black&#125;$\omega_&#123;01&#125;^&#123;(1)&#125;$&#125; (z1);</span><br><span class="line">    \draw[stateTransition] (x1) to node [midway, sloped, above&#x3D;-2,xshift&#x3D;-15] &#123;\color&#123;green!40!black&#125;$\omega_&#123;11&#125;^&#123;(1)&#125;$&#125; (z1);</span><br><span class="line">    \draw[stateTransition] (x2) to node [midway, sloped, above&#x3D;-2,xshift&#x3D;-15] &#123;\color&#123;green!40!black&#125;$\omega_&#123;21&#125;^&#123;(1)&#125;$&#125; (z1);</span><br><span class="line"></span><br><span class="line">    \draw[stateTransition] (x0) to node [midway, sloped, above&#x3D;-2,xshift&#x3D;-35] &#123;\color&#123;green!40!black&#125;$\omega_&#123;02&#125;^&#123;(1)&#125;$&#125; (z2);</span><br><span class="line">    \draw[stateTransition] (x1) to node [midway, sloped, above&#x3D;-2,xshift&#x3D;-25] &#123;\color&#123;green!40!black&#125;$\omega_&#123;12&#125;^&#123;(1)&#125;$&#125; (z2);</span><br><span class="line">    \draw[stateTransition] (x2) to node [midway, sloped, above&#x3D;-2,xshift&#x3D;-15] &#123;\color&#123;green!40!black&#125;$\omega_&#123;22&#125;^&#123;(1)&#125;$&#125; (z2);</span><br><span class="line"></span><br><span class="line">    \draw[stateTransition] (z0) to node [midway, sloped, above&#x3D;-2] &#123;\color&#123;green!60!black&#125;$\omega_&#123;0&#125;^&#123;(2)&#125;$&#125; (x);</span><br><span class="line">    \draw[stateTransition] (z1) to node [midway, sloped, above&#x3D;-2] &#123;\color&#123;green!60!black&#125;$\omega_&#123;1&#125;^&#123;(2)&#125;$&#125; (x);</span><br><span class="line">    \draw[stateTransition] (z2) to node [midway, sloped, above&#x3D;-2] &#123;\color&#123;green!60!black&#125;$\omega_&#123;2&#125;^&#123;(2)&#125;$&#125; (x);</span><br><span class="line"></span><br><span class="line">    \color&#123;blue&#125;</span><br><span class="line">    \draw[stateTransition] (x) -- (8,0) node [midway,above&#x3D;1cm] &#123;$\color&#123;green&#125;z^&#123;(j)&#125;\color&#123;black&#125;&#x3D;\color&#123;black&#125;sgn\left(\sum\limits_&#123;i&#x3D;0&#125;^&#123;2&#125;\color&#123;green!40!black&#125;\omega_&#123;ij&#125;^&#123;(1)&#125;\color&#123;red&#125;x^&#123;(i)&#125;\color&#123;black&#125;\right)$&#125;;</span><br><span class="line">        \draw[stateTransition] (x) -- (8,0) node [midway,above&#x3D;0.5cm] &#123;$\color&#123;red&#125;x^&#123;(0)&#125;\color&#123;black&#125;&#x3D;\color&#123;green&#125;z^&#123;(0)&#125;&#x3D;1$&#125;;</span><br><span class="line">    \draw[stateTransition] (x) -- (8,0) node [midway,below&#x3D;1cm] &#123;$\color&#123;blue&#125;y\color&#123;black&#125;&#x3D;\color&#123;black&#125;sgn\left(\sum\limits_&#123;j&#x3D;0&#125;^&#123;2&#125;\color&#123;green!60!black&#125;\omega_&#123;i&#125;^&#123;(2)&#125;\color&#123;green&#125;z^&#123;(j)&#125;\color&#123;black&#125;\right)$&#125;;</span><br><span class="line"></span><br><span class="line">\end&#123;tikzpicture&#125;</span><br><span class="line"></span><br><span class="line">\end&#123;document&#125;</span><br></pre></td></tr></table></figure>

    </div>
</div>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        图4的Tikz源代码为：
    </div>
    <div class='spoiler-content'>
        <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\documentclass[crop, tikz]&#123;standalone&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">\usepackage&#123;amsmath&#125;</span><br><span class="line">\usepackage&#123;tikz&#125;</span><br><span class="line">\usetikzlibrary&#123;shapes, calc, shapes, arrows&#125;</span><br><span class="line"></span><br><span class="line">\begin&#123;document&#125;</span><br><span class="line"></span><br><span class="line">\tikzstyle&#123;inputNode&#125;&#x3D;[draw,circle,minimum size&#x3D;25pt,inner sep&#x3D;0pt]</span><br><span class="line">\tikzstyle&#123;inputNode1&#125;&#x3D;[draw,circle,minimum size&#x3D;35pt,inner sep&#x3D;0pt]</span><br><span class="line">\tikzstyle&#123;stateTransition&#125;&#x3D;[-&gt;, thick]</span><br><span class="line">\begin&#123;tikzpicture&#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    \node[inputNode] (x0) at (-3, 3.4) &#123;\color&#123;red&#125;$x^&#123;(0)&#125;$&#125;;</span><br><span class="line">    \node[inputNode] (x1) at (-3, 1.75) &#123;\color&#123;red&#125;$x^&#123;(1)&#125;$&#125;;</span><br><span class="line">    \node (dots) at (-3, 0.75) &#123;$\vdots$&#125;;</span><br><span class="line">    \node[inputNode] (xi) at (-3, -0.75) &#123;\color&#123;red&#125;$x^&#123;(i)&#125;$&#125;;</span><br><span class="line">    \node (dots) at (-3, -1.75) &#123;$\vdots$&#125;;</span><br><span class="line">    \node[inputNode] (xI) at (-3, -3.4) &#123;\color&#123;red&#125;$x^&#123;(I)&#125;$&#125;;</span><br><span class="line">    </span><br><span class="line">    \node[inputNode1] (z0) at (0, 3.4) &#123;\color&#123;green&#125;$z^&#123;(0)&#125;$&#125;;</span><br><span class="line">    \node[inputNode1] (z1) at (0, 1.75) &#123;\color&#123;green&#125;$\alpha^&#123;(1)&#125; z^&#123;(1)&#125;$&#125;;</span><br><span class="line">    \draw[dashed] (0,1.75-0.5) -- (0,1.75+0.5);</span><br><span class="line">    \node (dots) at (0, 0.75) &#123;$\vdots$&#125;;</span><br><span class="line">    \node[inputNode1] (zj) at (0, -0.75) &#123;\color&#123;green&#125;$\alpha^&#123;(j)&#125; z^&#123;(j)&#125;$&#125;;</span><br><span class="line">    \draw[dashed] (0,-0.75-0.5) -- (0,-0.75+0.5);</span><br><span class="line">    \node (dots) at (0, -1.75) &#123;$\vdots$&#125;;</span><br><span class="line">    \node[inputNode1] (zJ) at (0, -3.4) &#123;\color&#123;green&#125;$\alpha^&#123;(J)&#125; z^&#123;(J)&#125;$&#125;;</span><br><span class="line">    \draw[dashed] (0,-3.2-0.5) -- (0,-3.2+0.5);</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    \node[inputNode1] (y1) at (3, 1.75) &#123;\color&#123;blue&#125;$\beta^&#123;(1)&#125; \hat y^&#123;(1)&#125;$&#125;;</span><br><span class="line">    \draw[dashed] (3,1.75-0.5) -- (3,1.75+0.5);</span><br><span class="line">    \node (dots) at (3, 0.75) &#123;$\vdots$&#125;;</span><br><span class="line">    \node[inputNode1] (yk) at (3, -0.75) &#123;\color&#123;blue&#125;$\beta^&#123;(k)&#125; \hat y^&#123;(k)&#125;$&#125;;</span><br><span class="line">    \draw[dashed] (3,-0.75-0.5) -- (3,-0.75+0.5);</span><br><span class="line">    \node (dots) at (3, -1.75) &#123;$\vdots$&#125;;</span><br><span class="line">    \node[inputNode1] (yK) at (3, -3.4) &#123;\color&#123;blue&#125;$\beta^&#123;(K)&#125; \hat y^&#123;(K)&#125;$&#125;;</span><br><span class="line">    \draw[dashed] (3,-3.4-0.5) -- (3,-3.4+0.5);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    \draw[stateTransition,opacity&#x3D;0.2] (x0) to node [midway, sloped, above&#x3D;-2,xshift&#x3D;-25] &#123;&#125; (z1);</span><br><span class="line">    \draw[stateTransition,opacity&#x3D;0.2] (x1) to node [midway, sloped, above&#x3D;-2,xshift&#x3D;-15] &#123;&#125; (z1);</span><br><span class="line">    \draw[stateTransition,opacity&#x3D;0.2] (xi) to node [midway, sloped, above&#x3D;-2,xshift&#x3D;-15] &#123;&#125; (z1);</span><br><span class="line">    \draw[stateTransition,opacity&#x3D;0.2] (xI) to node [midway, sloped, above&#x3D;-2,xshift&#x3D;-15] &#123;&#125; (z1);</span><br><span class="line"></span><br><span class="line">    \draw[stateTransition] (x0) to node [midway, sloped, above&#x3D;-2,xshift&#x3D;-35] &#123;\color&#123;red!60!green&#125;$\omega_&#123;0j&#125;^&#123;(1)&#125;$&#125; (zj);</span><br><span class="line">    \draw[stateTransition] (x1) to node [midway, sloped, above&#x3D;-2,xshift&#x3D;-25] &#123;\color&#123;red!60!green&#125;$\omega_&#123;1j&#125;^&#123;(1)&#125;$&#125; (zj);</span><br><span class="line">    \draw[stateTransition] (xi) to node [midway, sloped, above&#x3D;-2,xshift&#x3D;-15] &#123;\color&#123;red!60!green&#125;$\omega_&#123;ij&#125;^&#123;(1)&#125;$&#125; (zj);</span><br><span class="line">    \draw[stateTransition] (xI) to node [midway, sloped, above&#x3D;-2,xshift&#x3D;-15] &#123;\color&#123;red!60!green&#125;$\omega_&#123;Ij&#125;^&#123;(1)&#125;$&#125; (zj);</span><br><span class="line"></span><br><span class="line">    \draw[stateTransition,opacity&#x3D;0.2] (x0) to node [midway, sloped, above&#x3D;-2,xshift&#x3D;-35] &#123;&#125; (zJ);</span><br><span class="line">    \draw[stateTransition,opacity&#x3D;0.2] (x1) to node [midway, sloped, above&#x3D;-2,xshift&#x3D;-25] &#123;&#125; (zJ);</span><br><span class="line">    \draw[stateTransition,opacity&#x3D;0.2] (xi) to node [midway, sloped, above&#x3D;-2,xshift&#x3D;-15] &#123;&#125; (zJ);</span><br><span class="line">    \draw[stateTransition,opacity&#x3D;0.2] (xI) to node [midway, sloped, above&#x3D;-2,xshift&#x3D;-15] &#123;&#125; (zJ);</span><br><span class="line"></span><br><span class="line">%-----------%</span><br><span class="line">    \draw[stateTransition,opacity&#x3D;0.2] (z0) to node [midway, sloped, above&#x3D;-2,xshift&#x3D;-25] &#123;&#125; (y1);</span><br><span class="line">    \draw[stateTransition,opacity&#x3D;0.2] (z1) to node [midway, sloped, above&#x3D;-2,xshift&#x3D;-15] &#123;&#125; (y1);</span><br><span class="line">    \draw[stateTransition,opacity&#x3D;0.2] (zj) to node [midway, sloped, above&#x3D;-2,xshift&#x3D;-15] &#123;&#125; (y1);</span><br><span class="line">    \draw[stateTransition,opacity&#x3D;0.2] (zJ) to node [midway, sloped, above&#x3D;-2,xshift&#x3D;-15] &#123;&#125; (y1);</span><br><span class="line"></span><br><span class="line">    \draw[stateTransition] (z0) to node [midway, sloped, above&#x3D;-2,xshift&#x3D;-35] &#123;\color&#123;green!60!blue&#125;$\omega_&#123;0k&#125;^&#123;(2)&#125;$&#125; (yk);</span><br><span class="line">    \draw[stateTransition] (z1) to node [midway, sloped, above&#x3D;-2,xshift&#x3D;-25] &#123;\color&#123;green!60!blue&#125;$\omega_&#123;1k&#125;^&#123;(2)&#125;$&#125; (yk);</span><br><span class="line">    \draw[stateTransition] (zj) to node [midway, sloped, above&#x3D;-2,xshift&#x3D;-15] &#123;\color&#123;green!60!blue&#125;$\omega_&#123;jk&#125;^&#123;(2)&#125;$&#125; (yk);</span><br><span class="line">    \draw[stateTransition] (zJ) to node [midway, sloped, above&#x3D;-2,xshift&#x3D;-15] &#123;\color&#123;green!60!blue&#125;$\omega_&#123;Jk&#125;^&#123;(2)&#125;$&#125; (yk);</span><br><span class="line"></span><br><span class="line">    \draw[stateTransition,opacity&#x3D;0.2] (z0) to node [midway, sloped, above&#x3D;-2,xshift&#x3D;-35] &#123;&#125; (yK);</span><br><span class="line">    \draw[stateTransition,opacity&#x3D;0.2] (z1) to node [midway, sloped, above&#x3D;-2,xshift&#x3D;-25] &#123;&#125; (yK);</span><br><span class="line">    \draw[stateTransition,opacity&#x3D;0.2] (zj) to node [midway, sloped, above&#x3D;-2,xshift&#x3D;-15] &#123;&#125; (yK);</span><br><span class="line">    \draw[stateTransition,opacity&#x3D;0.2] (zJ) to node [midway, sloped, above&#x3D;-2,xshift&#x3D;-15] &#123;&#125; (yK);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    \color&#123;blue&#125;</span><br><span class="line">    \draw[stateTransition] (yk) node [midway,above&#x3D;2cm,xshift&#x3D;6cm] &#123;$\color&#123;green&#125;\alpha^&#123;(j)&#125;\color&#123;black&#125;&#x3D;\color&#123;black&#125;\sum\limits_&#123;i&#x3D;0&#125;^&#123;I&#125;\color&#123;red!60!green&#125;\omega_&#123;ij&#125;^&#123;(1)&#125;\color&#123;red&#125;x^&#123;(i)&#125;\color&#123;black&#125;$&#125;;</span><br><span class="line">        \draw[stateTransition] (yk) node [midway,above&#x3D;1cm,xshift&#x3D;6cm] &#123;$\color&#123;green&#125;z^&#123;(j)&#125;\color&#123;black&#125;&#x3D;\color&#123;black&#125;\sigma\left(\color&#123;green&#125;\alpha^&#123;(j)&#125;\color&#123;black&#125;\right)$&#125;;</span><br><span class="line"></span><br><span class="line">        \draw[stateTransition] (yk) node [midway,above&#x3D;0cm,xshift&#x3D;6cm] &#123;$\color&#123;red&#125;x^&#123;(0)&#125;\color&#123;black&#125;&#x3D;\color&#123;green&#125;z^&#123;(0)&#125;\color&#123;black&#125;&#x3D;1$&#125;;</span><br><span class="line"></span><br><span class="line">    \draw[stateTransition] (yk)  node [midway,below&#x3D;0.25cm,xshift&#x3D;6cm] &#123;$\color&#123;blue&#125;\beta^&#123;(k)&#125;\color&#123;black&#125;&#x3D;\sum\limits_&#123;j&#x3D;0&#125;^&#123;J&#125;\color&#123;green!60!blue&#125;\omega_&#123;jk&#125;^&#123;(2)&#125;\color&#123;green&#125;z^&#123;(j)&#125;\color&#123;black&#125;$&#125;;</span><br><span class="line"></span><br><span class="line">        \draw[stateTransition] (yk)  node [midway,below&#x3D;1.35cm,xshift&#x3D;6cm] &#123;$\color&#123;blue&#125;\hat y^&#123;(k)&#125;\color&#123;black&#125;&#x3D;\color&#123;black&#125;\sigma\left(\color&#123;blue&#125;\beta^&#123;(k)&#125;\color&#123;black&#125;\right)$&#125;;</span><br><span class="line"></span><br><span class="line">\end&#123;tikzpicture&#125;</span><br><span class="line"></span><br><span class="line">\end&#123;document&#125;</span><br></pre></td></tr></table></figure>

    </div>
</div>
<p>图5为多层神经网络与M-P神经元的关系图：</p>
<table>
    <tr>
        <td ><center><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20200610/Neural_Networks_fig008.jpg"  ></center>  <center>图5 </center></td>
    </tr>
</table>




<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        图5对应的Tikz源代码为：
    </div>
    <div class='spoiler-content'>
        <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\documentclass[crop, tikz]&#123;standalone&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">\usepackage&#123;amsmath&#125;</span><br><span class="line">\usepackage&#123;tikz&#125;</span><br><span class="line">\usetikzlibrary&#123;shapes, calc, shapes, arrows&#125;</span><br><span class="line"></span><br><span class="line">\begin&#123;document&#125;</span><br><span class="line"></span><br><span class="line">\tikzstyle&#123;inputNode&#125;&#x3D;[draw,circle,minimum size&#x3D;25pt,inner sep&#x3D;0pt]</span><br><span class="line">\tikzstyle&#123;inputNode1&#125;&#x3D;[draw,circle,minimum size&#x3D;35pt,inner sep&#x3D;0pt]</span><br><span class="line">\tikzstyle&#123;stateTransition&#125;&#x3D;[-&gt;, thick]</span><br><span class="line">\begin&#123;tikzpicture&#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    \node[inputNode] (x0) at (-3, 3.4) &#123;\color&#123;red&#125;$x^&#123;(0)&#125;$&#125;;</span><br><span class="line">    \node[inputNode] (x1) at (-3, 1.75) &#123;\color&#123;red&#125;$x^&#123;(1)&#125;$&#125;;</span><br><span class="line">    \node (dots) at (-3, 0.75) &#123;$\vdots$&#125;;</span><br><span class="line">    \node[inputNode] (xi) at (-3, -0.75) &#123;\color&#123;red&#125;$x^&#123;(i)&#125;$&#125;;</span><br><span class="line">    \node (dots) at (-3, -1.75) &#123;$\vdots$&#125;;</span><br><span class="line">    \node[inputNode] (xI) at (-3, -3.4) &#123;\color&#123;red&#125;$x^&#123;(I)&#125;$&#125;;</span><br><span class="line">    </span><br><span class="line">    \node[inputNode1] (z0) at (0, 3.4) &#123;\color&#123;green&#125;$z^&#123;(0)&#125;$&#125;;</span><br><span class="line">    \node[inputNode1] (z1) at (0, 1.75) &#123;\color&#123;green&#125;$\alpha^&#123;(1)&#125; z^&#123;(1)&#125;$&#125;;</span><br><span class="line">    \draw[dashed] (0,1.75-0.5) -- (0,1.75+0.5);</span><br><span class="line">    \node (dots) at (0, 0.75) &#123;$\vdots$&#125;;</span><br><span class="line">    \node[inputNode1] (zj) at (0, -0.75) &#123;\color&#123;green&#125;$\alpha^&#123;(j)&#125; z^&#123;(j)&#125;$&#125;;</span><br><span class="line">    \draw[dashed] (0,-0.75-0.5) -- (0,-0.75+0.5);</span><br><span class="line">    \node (dots) at (0, -1.75) &#123;$\vdots$&#125;;</span><br><span class="line">    \node[inputNode1] (zJ) at (0, -3.4) &#123;\color&#123;green&#125;$\alpha^&#123;(J)&#125; z^&#123;(J)&#125;$&#125;;</span><br><span class="line">    \draw[dashed] (0,-3.2-0.5) -- (0,-3.2+0.5);</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    \node[inputNode1] (y1) at (3, 1.75) &#123;\color&#123;blue&#125;$\beta^&#123;(1)&#125; \hat y^&#123;(1)&#125;$&#125;;</span><br><span class="line">    \draw[dashed] (3,1.75-0.5) -- (3,1.75+0.5);</span><br><span class="line">    \node (dots) at (3, 0.75) &#123;$\vdots$&#125;;</span><br><span class="line">    \node[inputNode1] (yk) at (3, -0.75) &#123;\color&#123;blue&#125;$\beta^&#123;(k)&#125; \hat y^&#123;(k)&#125;$&#125;;</span><br><span class="line">    \draw[dashed] (3,-0.75-0.5) -- (3,-0.75+0.5);</span><br><span class="line">    \node (dots) at (3, -1.75) &#123;$\vdots$&#125;;</span><br><span class="line">    \node[inputNode1] (yK) at (3, -3.4) &#123;\color&#123;blue&#125;$\beta^&#123;(K)&#125; \hat y^&#123;(K)&#125;$&#125;;</span><br><span class="line">    \draw[dashed] (3,-3.4-0.5) -- (3,-3.4+0.5);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    \draw[stateTransition,opacity&#x3D;0.2] (x0) to node [midway, sloped, above&#x3D;-2,xshift&#x3D;-25] &#123;&#125; (z1);</span><br><span class="line">    \draw[stateTransition,opacity&#x3D;0.2] (x1) to node [midway, sloped, above&#x3D;-2,xshift&#x3D;-15] &#123;&#125; (z1);</span><br><span class="line">    \draw[stateTransition,opacity&#x3D;0.2] (xi) to node [midway, sloped, above&#x3D;-2,xshift&#x3D;-15] &#123;&#125; (z1);</span><br><span class="line">    \draw[stateTransition,opacity&#x3D;0.2] (xI) to node [midway, sloped, above&#x3D;-2,xshift&#x3D;-15] &#123;&#125; (z1);</span><br><span class="line"></span><br><span class="line">    \draw[stateTransition] (x0) to node [midway, sloped, above&#x3D;-2,xshift&#x3D;-35] &#123;\color&#123;red!60!green&#125;$\omega_&#123;0j&#125;^&#123;(1)&#125;$&#125; (zj);</span><br><span class="line">    \draw[stateTransition] (x1) to node [midway, sloped, above&#x3D;-2,xshift&#x3D;-25] &#123;\color&#123;red!60!green&#125;$\omega_&#123;1j&#125;^&#123;(1)&#125;$&#125; (zj);</span><br><span class="line">    \draw[stateTransition] (xi) to node [midway, sloped, above&#x3D;-2,xshift&#x3D;-15] &#123;\color&#123;red!60!green&#125;$\omega_&#123;ij&#125;^&#123;(1)&#125;$&#125; (zj);</span><br><span class="line">    \draw[stateTransition] (xI) to node [midway, sloped, above&#x3D;-2,xshift&#x3D;-15] &#123;\color&#123;red!60!green&#125;$\omega_&#123;Ij&#125;^&#123;(1)&#125;$&#125; (zj);</span><br><span class="line"></span><br><span class="line">    \draw[stateTransition,opacity&#x3D;0.2] (x0) to node [midway, sloped, above&#x3D;-2,xshift&#x3D;-35] &#123;&#125; (zJ);</span><br><span class="line">    \draw[stateTransition,opacity&#x3D;0.2] (x1) to node [midway, sloped, above&#x3D;-2,xshift&#x3D;-25] &#123;&#125; (zJ);</span><br><span class="line">    \draw[stateTransition,opacity&#x3D;0.2] (xi) to node [midway, sloped, above&#x3D;-2,xshift&#x3D;-15] &#123;&#125; (zJ);</span><br><span class="line">    \draw[stateTransition,opacity&#x3D;0.2] (xI) to node [midway, sloped, above&#x3D;-2,xshift&#x3D;-15] &#123;&#125; (zJ);</span><br><span class="line"></span><br><span class="line">%-----------%</span><br><span class="line">    \draw[stateTransition,opacity&#x3D;0.2] (z0) to node [midway, sloped, above&#x3D;-2,xshift&#x3D;-25] &#123;&#125; (y1);</span><br><span class="line">    \draw[stateTransition,opacity&#x3D;0.2] (z1) to node [midway, sloped, above&#x3D;-2,xshift&#x3D;-15] &#123;&#125; (y1);</span><br><span class="line">    \draw[stateTransition,opacity&#x3D;0.2] (zj) to node [midway, sloped, above&#x3D;-2,xshift&#x3D;-15] &#123;&#125; (y1);</span><br><span class="line">    \draw[stateTransition,opacity&#x3D;0.2] (zJ) to node [midway, sloped, above&#x3D;-2,xshift&#x3D;-15] &#123;&#125; (y1);</span><br><span class="line"></span><br><span class="line">    \draw[stateTransition] (z0) to node [midway, sloped, above&#x3D;-2,xshift&#x3D;-35] &#123;\color&#123;green!60!blue&#125;$\omega_&#123;0k&#125;^&#123;(2)&#125;$&#125; (yk);</span><br><span class="line">    \draw[stateTransition] (z1) to node [midway, sloped, above&#x3D;-2,xshift&#x3D;-25] &#123;\color&#123;green!60!blue&#125;$\omega_&#123;1k&#125;^&#123;(2)&#125;$&#125; (yk);</span><br><span class="line">    \draw[stateTransition] (zj) to node [midway, sloped, above&#x3D;-2,xshift&#x3D;-15] &#123;\color&#123;green!60!blue&#125;$\omega_&#123;jk&#125;^&#123;(2)&#125;$&#125; (yk);</span><br><span class="line">    \draw[stateTransition] (zJ) to node [midway, sloped, above&#x3D;-2,xshift&#x3D;-15] &#123;\color&#123;green!60!blue&#125;$\omega_&#123;Jk&#125;^&#123;(2)&#125;$&#125; (yk);</span><br><span class="line"></span><br><span class="line">    \draw[stateTransition,opacity&#x3D;0.2] (z0) to node [midway, sloped, above&#x3D;-2,xshift&#x3D;-35] &#123;&#125; (yK);</span><br><span class="line">    \draw[stateTransition,opacity&#x3D;0.2] (z1) to node [midway, sloped, above&#x3D;-2,xshift&#x3D;-25] &#123;&#125; (yK);</span><br><span class="line">    \draw[stateTransition,opacity&#x3D;0.2] (zj) to node [midway, sloped, above&#x3D;-2,xshift&#x3D;-15] &#123;&#125; (yK);</span><br><span class="line">    \draw[stateTransition,opacity&#x3D;0.2] (zJ) to node [midway, sloped, above&#x3D;-2,xshift&#x3D;-15] &#123;&#125; (yK);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    \color&#123;blue&#125;</span><br><span class="line">    \draw[stateTransition] (yk) node [midway,above&#x3D;2cm,xshift&#x3D;6cm] &#123;$\color&#123;green&#125;\alpha^&#123;(j)&#125;\color&#123;black&#125;&#x3D;\color&#123;black&#125;\sum\limits_&#123;i&#x3D;0&#125;^&#123;I&#125;\color&#123;red!60!green&#125;\omega_&#123;ij&#125;^&#123;(1)&#125;\color&#123;red&#125;x^&#123;(i)&#125;\color&#123;black&#125;$&#125;;</span><br><span class="line">        \draw[stateTransition] (yk) node [midway,above&#x3D;1cm,xshift&#x3D;6cm] &#123;$\color&#123;green&#125;z^&#123;(j)&#125;\color&#123;black&#125;&#x3D;\color&#123;black&#125;\sigma\left(\color&#123;green&#125;\alpha^&#123;(j)&#125;\color&#123;black&#125;\right)$&#125;;</span><br><span class="line"></span><br><span class="line">        \draw[stateTransition] (yk) node [midway,above&#x3D;0cm,xshift&#x3D;6cm] &#123;$\color&#123;red&#125;x^&#123;(0)&#125;\color&#123;black&#125;&#x3D;\color&#123;green&#125;z^&#123;(0)&#125;\color&#123;black&#125;&#x3D;1$&#125;;</span><br><span class="line"></span><br><span class="line">    \draw[stateTransition] (yk)  node [midway,below&#x3D;0.25cm,xshift&#x3D;6cm] &#123;$\color&#123;blue&#125;\beta^&#123;(k)&#125;\color&#123;black&#125;&#x3D;\sum\limits_&#123;j&#x3D;0&#125;^&#123;J&#125;\color&#123;green!60!blue&#125;\omega_&#123;jk&#125;^&#123;(2)&#125;\color&#123;green&#125;z^&#123;(j)&#125;\color&#123;black&#125;$&#125;;</span><br><span class="line"></span><br><span class="line">        \draw[stateTransition] (yk)  node [midway,below&#x3D;1.35cm,xshift&#x3D;6cm] &#123;$\color&#123;blue&#125;\hat y^&#123;(k)&#125;\color&#123;black&#125;&#x3D;\color&#123;black&#125;\sigma\left(\color&#123;blue&#125;\beta^&#123;(k)&#125;\color&#123;black&#125;\right)$&#125;;</span><br><span class="line"></span><br><span class="line">\end&#123;tikzpicture&#125;</span><br><span class="line"></span><br><span class="line">\end&#123;document&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>
<hr>
<h2 id="Python绘制函数图像"><a href="#Python绘制函数图像" class="headerlink" title="Python绘制函数图像"></a>Python绘制函数图像</h2><p>Python作图主要使用matplotlib，作图其实比较简单。这里主要是介绍如何作带箭头的坐标系。具体如下：</p>
<p>图6-7是机器学习中常用的激活函数：</p>
<table>
    <tr>
        <td ><center><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20200610/Neural_Networks_fig002.jpg"  >图6</center></td>
        <td ><center><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20200610/Neural_Networks_fig003.jpg"  >图7</center></td>
    </tr>
</table>


<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        图6所对应的Python源代码：
    </div>
    <div class='spoiler-content'>
        <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- encoding: utf-8 -*-</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">@File    : Neural_Networks_001.py</span></span><br><span class="line"><span class="string">@Time    : 2020/6/8 15:06</span></span><br><span class="line"><span class="string">@Author  : tengweitw</span></span><br><span class="line"><span class="string">@Email   : tengweitw@foxmail.com</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> mpl_toolkits.axisartist <span class="keyword">as</span> axisartist</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="comment"># Set the format of labels</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">LabelFormat</span><span class="params">(plt)</span>:</span></span><br><span class="line">    ax = plt.gca()</span><br><span class="line">    plt.tick_params(labelsize=<span class="number">14</span>)</span><br><span class="line">    labels = ax.get_xticklabels() + ax.get_yticklabels()</span><br><span class="line">    [label.set_fontname(<span class="string">'Times New Roman'</span>) <span class="keyword">for</span> label <span class="keyword">in</span> labels]</span><br><span class="line">    font = &#123;<span class="string">'family'</span>: <span class="string">'Times New Roman'</span>,</span><br><span class="line">            <span class="string">'weight'</span>: <span class="string">'normal'</span>,</span><br><span class="line">            <span class="string">'size'</span>: <span class="number">16</span>,</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="keyword">return</span> font</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#Set the figure window square</span></span><br><span class="line">fig = plt.figure(figsize=(<span class="number">6</span>, <span class="number">6</span>))</span><br><span class="line"></span><br><span class="line">ax = axisartist.Subplot(fig, <span class="number">111</span>)</span><br><span class="line"></span><br><span class="line">fig.add_axes(ax)</span><br><span class="line"></span><br><span class="line">ax.axis[:].set_visible(<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">font = LabelFormat(plt)</span><br><span class="line"></span><br><span class="line">ax.axis[<span class="string">"x"</span>] = ax.new_floating_axis(<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#Set properties of X axis and add arrow</span></span><br><span class="line">ax.axis[<span class="string">"x"</span>].major_ticklabels.set_fontsize(<span class="number">14</span>)</span><br><span class="line">ax.axis[<span class="string">"x"</span>].major_ticklabels.set_fontname(<span class="string">'Times New Roman'</span>)</span><br><span class="line">ax.axis[<span class="string">"x"</span>].set_axisline_style(<span class="string">"-&gt;"</span>, size = <span class="number">1.0</span>)</span><br><span class="line">ax.axis[<span class="string">"x"</span>].label.set_fontsize(<span class="number">16</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#Set properties of Y axis and add arrow</span></span><br><span class="line">ax.axis[<span class="string">"y"</span>] = ax.new_floating_axis(<span class="number">1</span>,<span class="number">0</span>)</span><br><span class="line">ax.axis[<span class="string">"y"</span>].major_ticklabels.set_fontsize(<span class="number">14</span>)</span><br><span class="line">ax.axis[<span class="string">"y"</span>].major_ticklabels.set_fontname(<span class="string">'Times New Roman'</span>)</span><br><span class="line">ax.axis[<span class="string">"y"</span>].set_axisline_style(<span class="string">"-&gt;"</span>, size = <span class="number">1.0</span>)</span><br><span class="line">ax.axis[<span class="string">"y"</span>].label.set_fontsize(<span class="number">16</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#Set the ticks' locations</span></span><br><span class="line">ax.axis[<span class="string">"x"</span>].set_axis_direction(<span class="string">"bottom"</span>)</span><br><span class="line">ax.axis[<span class="string">"y"</span>].set_axis_direction(<span class="string">"left"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#Create Datas</span></span><br><span class="line">x=np.linspace(<span class="number">-10</span>,<span class="number">10</span>,<span class="number">1000</span>)</span><br><span class="line">y_sigmoid=<span class="number">1</span>/(<span class="number">1</span>+np.exp(-x))</span><br><span class="line">y_sgn=np.zeros((len(x),<span class="number">1</span>))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(x)):</span><br><span class="line">    <span class="keyword">if</span> x[i]&gt;=<span class="number">0</span>:</span><br><span class="line">        y_sgn[i]=<span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        y_sgn[i]=<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Plot figures</span></span><br><span class="line">plt.plot(x,y_sigmoid,linewidth=<span class="number">3</span>)</span><br><span class="line">plt.plot(x,y_sgn,linewidth=<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">plt.xlim(<span class="number">-10</span>,<span class="number">10</span>)</span><br><span class="line">plt.ylim(<span class="number">-0.2</span>,<span class="number">1.3</span>)</span><br><span class="line"></span><br><span class="line">plt.legend([<span class="string">r"Sigmoid(x)=$\frac&#123;1&#125;&#123;1+\exp(-x)&#125;$"</span>, <span class="string">r"$Sgn(x)=0,x&lt;0; Sgn(x)=1, otherwise$"</span>],loc=<span class="string">"upper left"</span>)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

    </div>
</div>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        图7对应的Python源代码：
    </div>
    <div class='spoiler-content'>
        <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- encoding: utf-8 -*-</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">@File    : Neural_Networks_002.py</span></span><br><span class="line"><span class="string">@Time    : 2020/6/8 19:29</span></span><br><span class="line"><span class="string">@Author  : tengweitw</span></span><br><span class="line"><span class="string">@Email   : tengweitw@foxmail.com</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> mpl_toolkits.axisartist <span class="keyword">as</span> axisartist</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="comment"># Set the format of labels</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">LabelFormat</span><span class="params">(plt)</span>:</span></span><br><span class="line">    ax = plt.gca()</span><br><span class="line">    plt.tick_params(labelsize=<span class="number">14</span>)</span><br><span class="line">    labels = ax.get_xticklabels() + ax.get_yticklabels()</span><br><span class="line">    [label.set_fontname(<span class="string">'Times New Roman'</span>) <span class="keyword">for</span> label <span class="keyword">in</span> labels]</span><br><span class="line">    font = &#123;<span class="string">'family'</span>: <span class="string">'Times New Roman'</span>,</span><br><span class="line">            <span class="string">'weight'</span>: <span class="string">'normal'</span>,</span><br><span class="line">            <span class="string">'size'</span>: <span class="number">16</span>,</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="keyword">return</span> font</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#Set the figure window square</span></span><br><span class="line">fig = plt.figure(figsize=(<span class="number">6</span>, <span class="number">6</span>))</span><br><span class="line"></span><br><span class="line">ax = axisartist.Subplot(fig, <span class="number">111</span>)</span><br><span class="line"></span><br><span class="line">fig.add_axes(ax)</span><br><span class="line"></span><br><span class="line">ax.axis[:].set_visible(<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">font = LabelFormat(plt)</span><br><span class="line"></span><br><span class="line">ax.axis[<span class="string">"x"</span>] = ax.new_floating_axis(<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#Set properties of X axis and add arrow</span></span><br><span class="line">ax.axis[<span class="string">"x"</span>].major_ticklabels.set_fontsize(<span class="number">14</span>)</span><br><span class="line">ax.axis[<span class="string">"x"</span>].major_ticklabels.set_fontname(<span class="string">'Times New Roman'</span>)</span><br><span class="line">ax.axis[<span class="string">"x"</span>].set_axisline_style(<span class="string">"-&gt;"</span>, size = <span class="number">1.0</span>)</span><br><span class="line">ax.axis[<span class="string">"x"</span>].label.set_fontsize(<span class="number">16</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#Set properties of Y axis and add arrow</span></span><br><span class="line">ax.axis[<span class="string">"y"</span>] = ax.new_floating_axis(<span class="number">1</span>,<span class="number">0</span>)</span><br><span class="line">ax.axis[<span class="string">"y"</span>].major_ticklabels.set_fontsize(<span class="number">14</span>)</span><br><span class="line">ax.axis[<span class="string">"y"</span>].major_ticklabels.set_fontname(<span class="string">'Times New Roman'</span>)</span><br><span class="line">ax.axis[<span class="string">"y"</span>].set_axisline_style(<span class="string">"-&gt;"</span>, size = <span class="number">1.0</span>)</span><br><span class="line">ax.axis[<span class="string">"y"</span>].label.set_fontsize(<span class="number">16</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#Set the ticks' locations</span></span><br><span class="line">ax.axis[<span class="string">"x"</span>].set_axis_direction(<span class="string">"bottom"</span>)</span><br><span class="line">ax.axis[<span class="string">"y"</span>].set_axis_direction(<span class="string">"left"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#Create Datas</span></span><br><span class="line">x=np.linspace(<span class="number">-10</span>,<span class="number">10</span>,<span class="number">1000</span>)</span><br><span class="line">y_tanh=(np.exp(x)-np.exp(-x))/(np.exp(x)+np.exp(-x))</span><br><span class="line">y_relu=np.zeros((len(x),<span class="number">1</span>))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(x)):</span><br><span class="line">    <span class="keyword">if</span> x[i]&gt;=<span class="number">0</span>:</span><br><span class="line">        y_relu[i]=x[i]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        y_relu[i]=<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Plot figures</span></span><br><span class="line">plt.plot(x,y_tanh,linewidth=<span class="number">3</span>)</span><br><span class="line">plt.plot(x,y_relu,linewidth=<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">plt.xlim(<span class="number">-10</span>,<span class="number">10</span>)</span><br><span class="line">plt.ylim(<span class="number">-1.3</span>,<span class="number">1.3</span>)</span><br><span class="line"></span><br><span class="line">plt.legend([<span class="string">r"Tanh(x)=$\frac&#123;\exp(x)-\exp(-x)&#125;&#123;\exp(x)+\exp(-x)&#125;$"</span>, <span class="string">r"$Relu(x)=\max\&#123;0,x\&#125;$"</span>],loc=<span class="string">"upper left"</span>)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

    </div>
</div>
<p>图8-9是异或问题的二分类：</p>
<table>
    <tr>
        <td ><center><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20200610/Neural_Networks_fig006.jpg"  >图8</center></td>
        <td ><center><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20200610/Neural_Networks_fig007.jpg"  >图9</center></td>
    </tr>
</table>


<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        图8对应的Python源代码：
    </div>
    <div class='spoiler-content'>
        <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- encoding: utf-8 -*-</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">@File    : Neural_Networks_003.py</span></span><br><span class="line"><span class="string">@Time    : 2020/6/8 19:44</span></span><br><span class="line"><span class="string">@Author  : tengweitw</span></span><br><span class="line"><span class="string">@Email   : tengweitw@foxmail.com</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> mpl_toolkits.axisartist <span class="keyword">as</span> axisartist</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="comment"># Set the format of labels</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">LabelFormat</span><span class="params">(plt)</span>:</span></span><br><span class="line">    ax = plt.gca()</span><br><span class="line">    plt.tick_params(labelsize=<span class="number">14</span>)</span><br><span class="line">    labels = ax.get_xticklabels() + ax.get_yticklabels()</span><br><span class="line">    [label.set_fontname(<span class="string">'Times New Roman'</span>) <span class="keyword">for</span> label <span class="keyword">in</span> labels]</span><br><span class="line">    font = &#123;<span class="string">'family'</span>: <span class="string">'Times New Roman'</span>,</span><br><span class="line">            <span class="string">'weight'</span>: <span class="string">'normal'</span>,</span><br><span class="line">            <span class="string">'size'</span>: <span class="number">16</span>,</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="keyword">return</span> font</span><br><span class="line"></span><br><span class="line"><span class="comment">#Set the figure window square</span></span><br><span class="line">fig = plt.figure(figsize=(<span class="number">6</span>, <span class="number">6</span>))</span><br><span class="line"></span><br><span class="line">ax = axisartist.Subplot(fig, <span class="number">111</span>)</span><br><span class="line"></span><br><span class="line">fig.add_axes(ax)</span><br><span class="line"></span><br><span class="line">ax.axis[:].set_visible(<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">font = LabelFormat(plt)</span><br><span class="line"></span><br><span class="line">ax.axis[<span class="string">"x"</span>] = ax.new_floating_axis(<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#Set properties of X axis and add arrow</span></span><br><span class="line">ax.axis[<span class="string">"x"</span>].major_ticklabels.set_fontsize(<span class="number">14</span>)</span><br><span class="line">ax.axis[<span class="string">"x"</span>].major_ticklabels.set_fontname(<span class="string">'Times New Roman'</span>)</span><br><span class="line">ax.axis[<span class="string">"x"</span>].set_axisline_style(<span class="string">"-&gt;"</span>, size = <span class="number">1.0</span>)</span><br><span class="line"><span class="comment"># ax.axis["x"].label.set_text('$x^&#123;(1)&#125;$')</span></span><br><span class="line">ax.axis[<span class="string">"x"</span>].label.set_fontsize(<span class="number">16</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#Set properties of Y axis and add arrow</span></span><br><span class="line">ax.axis[<span class="string">"y"</span>] = ax.new_floating_axis(<span class="number">1</span>,<span class="number">0</span>)</span><br><span class="line">ax.axis[<span class="string">"y"</span>].major_ticklabels.set_fontsize(<span class="number">14</span>)</span><br><span class="line">ax.axis[<span class="string">"y"</span>].major_ticklabels.set_fontname(<span class="string">'Times New Roman'</span>)</span><br><span class="line">ax.axis[<span class="string">"y"</span>].set_axisline_style(<span class="string">"-&gt;"</span>, size = <span class="number">1.0</span>)</span><br><span class="line"><span class="comment"># ax.axis["y"].label.set_text('$x^&#123;(2)&#125;$')</span></span><br><span class="line">ax.axis[<span class="string">"y"</span>].label.set_fontsize(<span class="number">16</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#Set the ticks' locations</span></span><br><span class="line">ax.axis[<span class="string">"x"</span>].set_axis_direction(<span class="string">"bottom"</span>)</span><br><span class="line">ax.axis[<span class="string">"y"</span>].set_axis_direction(<span class="string">"left"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#Create Data</span></span><br><span class="line">x1=<span class="number">0</span></span><br><span class="line">y1=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">x2=<span class="number">1</span></span><br><span class="line">y2=<span class="number">0</span></span><br><span class="line"></span><br><span class="line">x3=<span class="number">0</span></span><br><span class="line">y3=<span class="number">0</span></span><br><span class="line"></span><br><span class="line">x4=<span class="number">1</span></span><br><span class="line">y4=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">x11=np.linspace(<span class="number">-0.2</span>,<span class="number">0.7</span>,<span class="number">100</span>)</span><br><span class="line">y11=<span class="number">0.5</span>-x11</span><br><span class="line"></span><br><span class="line">x22=np.linspace(<span class="number">-0.2</span>,<span class="number">1.7</span>,<span class="number">100</span>)</span><br><span class="line">y22=<span class="number">1.5</span>-x22</span><br><span class="line"></span><br><span class="line">x33=np.linspace(<span class="number">-0.2</span>,<span class="number">1.7</span>,<span class="number">100</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(x22)):</span><br><span class="line">    y33=np.linspace(<span class="number">0.5</span>-x33[i],<span class="number">1.5</span>-x33[i],<span class="number">100</span>)</span><br><span class="line">    y33[y33&lt;=<span class="number">-0.2</span>]=np.inf</span><br><span class="line">    plt.plot(x33[i]*np.ones((len(y33),<span class="number">1</span>)),y33,<span class="string">'g+'</span>,alpha=<span class="number">0.2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Plot figures</span></span><br><span class="line">plt.plot(x1,y1,<span class="string">'rs'</span>)</span><br><span class="line">plt.text(x1+<span class="number">0.05</span>,y1+<span class="number">0.1</span>,<span class="string">r'$\mathrm&#123;x&#125;_1$'</span>,fontsize=<span class="number">20</span>)</span><br><span class="line">plt.plot(x2,y2,<span class="string">'rs'</span>)</span><br><span class="line">plt.text(x2+<span class="number">0.05</span>,y2+<span class="number">0.1</span>,<span class="string">r'$\mathrm&#123;x&#125;_2$'</span>,fontsize=<span class="number">20</span>)</span><br><span class="line">plt.plot(x3,y3,<span class="string">'bo'</span>)</span><br><span class="line">plt.text(x3+<span class="number">0.05</span>,y3+<span class="number">0.1</span>,<span class="string">r'$\mathrm&#123;x&#125;_3$'</span>,fontsize=<span class="number">20</span>)</span><br><span class="line">plt.plot(x4,y4,<span class="string">'bo'</span>)</span><br><span class="line">plt.text(x4+<span class="number">0.05</span>,y4+<span class="number">0.1</span>,<span class="string">r'$\mathrm&#123;x&#125;_4$'</span>,fontsize=<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line">plt.plot(x11,y11,<span class="string">'g'</span>)</span><br><span class="line">plt.plot(x22,y22,<span class="string">'g'</span>)</span><br><span class="line"></span><br><span class="line">plt.text(<span class="number">-0.2</span>,<span class="number">1.8</span>,<span class="string">r'$x^&#123;(2)&#125;$'</span>,fontsize=<span class="number">16</span>,rotation=<span class="number">90</span>,color=<span class="string">'k'</span>)</span><br><span class="line">plt.text(<span class="number">1.8</span>,<span class="number">-0.2</span>,<span class="string">r'$x^&#123;(1)&#125;$'</span>,fontsize=<span class="number">16</span>,rotation=<span class="number">0</span>,color=<span class="string">'k'</span>)</span><br><span class="line">plt.xlim(<span class="number">-0.5</span>,<span class="number">2</span>)</span><br><span class="line">plt.ylim(<span class="number">-0.5</span>,<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

    </div>
</div>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        图9对应的Python源代码：
    </div>
    <div class='spoiler-content'>
        <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- encoding: utf-8 -*-</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">@File    : Neural_Networks_004.py</span></span><br><span class="line"><span class="string">@Time    : 2020/6/8 20:11</span></span><br><span class="line"><span class="string">@Author  : tengweitw</span></span><br><span class="line"><span class="string">@Email   : tengweitw@foxmail.com</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> mpl_toolkits.axisartist <span class="keyword">as</span> axisartist</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Set the format of labels</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">LabelFormat</span><span class="params">(plt)</span>:</span></span><br><span class="line">    ax = plt.gca()</span><br><span class="line">    plt.tick_params(labelsize=<span class="number">14</span>)</span><br><span class="line">    labels = ax.get_xticklabels() + ax.get_yticklabels()</span><br><span class="line">    [label.set_fontname(<span class="string">'Times New Roman'</span>) <span class="keyword">for</span> label <span class="keyword">in</span> labels]</span><br><span class="line">    font = &#123;<span class="string">'family'</span>: <span class="string">'Times New Roman'</span>,</span><br><span class="line">            <span class="string">'weight'</span>: <span class="string">'normal'</span>,</span><br><span class="line">            <span class="string">'size'</span>: <span class="number">16</span>,</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="keyword">return</span> font</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Set the figure window square</span></span><br><span class="line">fig = plt.figure(figsize=(<span class="number">6</span>, <span class="number">6</span>))</span><br><span class="line"></span><br><span class="line">ax = axisartist.Subplot(fig, <span class="number">111</span>)</span><br><span class="line"></span><br><span class="line">fig.add_axes(ax)</span><br><span class="line"></span><br><span class="line">ax.axis[:].set_visible(<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">font = LabelFormat(plt)</span><br><span class="line"></span><br><span class="line">ax.axis[<span class="string">"x"</span>] = ax.new_floating_axis(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Set properties of X axis and add arrow</span></span><br><span class="line">ax.axis[<span class="string">"x"</span>].major_ticklabels.set_fontsize(<span class="number">14</span>)</span><br><span class="line">ax.axis[<span class="string">"x"</span>].major_ticklabels.set_fontname(<span class="string">'Times New Roman'</span>)</span><br><span class="line">ax.axis[<span class="string">"x"</span>].set_axisline_style(<span class="string">"-&gt;"</span>, size=<span class="number">1.0</span>)</span><br><span class="line"><span class="comment"># ax.axis["x"].label.set_text('$x^&#123;(1)&#125;$')</span></span><br><span class="line">ax.axis[<span class="string">"x"</span>].label.set_fontsize(<span class="number">16</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Set properties of Y axis and add arrow</span></span><br><span class="line">ax.axis[<span class="string">"y"</span>] = ax.new_floating_axis(<span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line">ax.axis[<span class="string">"y"</span>].major_ticklabels.set_fontsize(<span class="number">14</span>)</span><br><span class="line">ax.axis[<span class="string">"y"</span>].major_ticklabels.set_fontname(<span class="string">'Times New Roman'</span>)</span><br><span class="line">ax.axis[<span class="string">"y"</span>].set_axisline_style(<span class="string">"-&gt;"</span>, size=<span class="number">1.0</span>)</span><br><span class="line"><span class="comment"># ax.axis["y"].label.set_text('$x^&#123;(2)&#125;$')</span></span><br><span class="line">ax.axis[<span class="string">"y"</span>].label.set_fontsize(<span class="number">16</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Set the ticks' locations</span></span><br><span class="line">ax.axis[<span class="string">"x"</span>].set_axis_direction(<span class="string">"bottom"</span>)</span><br><span class="line">ax.axis[<span class="string">"y"</span>].set_axis_direction(<span class="string">"left"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create Data</span></span><br><span class="line">x1 = <span class="number">0</span></span><br><span class="line">y1 = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">x2 = <span class="number">1</span></span><br><span class="line">y2 = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">x3 = <span class="number">0</span></span><br><span class="line">y3 = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">x4 = <span class="number">1</span></span><br><span class="line">y4 = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">x11 = np.linspace(<span class="number">-0.2</span>, <span class="number">0.7</span>, <span class="number">100</span>)</span><br><span class="line">y11 = <span class="number">0.5</span> - x11</span><br><span class="line"></span><br><span class="line"><span class="comment"># Plot figures</span></span><br><span class="line">plt.plot(x1, y1, <span class="string">'rs'</span>)</span><br><span class="line">plt.text(x1 + <span class="number">0.02</span>, y1 + <span class="number">0.05</span>, <span class="string">r'$\mathrm&#123;z&#125;_1$'</span>, fontsize=<span class="number">20</span>)</span><br><span class="line">plt.plot(x2, y2, <span class="string">'rs'</span>)</span><br><span class="line">plt.text(x2 + <span class="number">0.0</span>, y2 + <span class="number">0.05</span>, <span class="string">r'$\mathrm&#123;z&#125;_2$'</span>, fontsize=<span class="number">20</span>)</span><br><span class="line">plt.plot(x3, y3, <span class="string">'bo'</span>)</span><br><span class="line">plt.text(x3 + <span class="number">0.05</span>, y3 + <span class="number">0.1</span>, <span class="string">r'$\mathrm&#123;z&#125;_3,\mathrm&#123;z&#125;_4$'</span>, fontsize=<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line">plt.plot(x11, y11, <span class="string">'g'</span>)</span><br><span class="line"></span><br><span class="line">plt.text(<span class="number">-0.2</span>, <span class="number">1.1</span>, <span class="string">r'$z^&#123;(2)&#125;$'</span>, fontsize=<span class="number">16</span>, rotation=<span class="number">90</span>, color=<span class="string">'k'</span>)</span><br><span class="line">plt.text(<span class="number">1.1</span>, <span class="number">-0.2</span>, <span class="string">r'$z^&#123;(1)&#125;$'</span>, fontsize=<span class="number">16</span>, rotation=<span class="number">0</span>, color=<span class="string">'k'</span>)</span><br><span class="line">plt.xlim(<span class="number">-0.2</span>, <span class="number">1.25</span>)</span><br><span class="line">plt.ylim(<span class="number">-0.2</span>, <span class="number">1.25</span>)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>



    </div>
</div>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>Machine Learning</tag>
      </tags>
  </entry>
  <entry>
    <title>【图解例说机器学习】神经网络 (Neural Networks)</title>
    <url>/2020/06/09/%5B20200609%5D/</url>
    <content><![CDATA[<blockquote>
<p>神经网络是由具有适应性的简单单元组成的广泛并行互连的网络，它的组织能够模拟生物神经系统对真实世界物体所作出的交互反应。    —Kohonen, 1988</p>
</blockquote>
<hr>
<h2 id="一层神经网络：感知机与逻辑回归"><a href="#一层神经网络：感知机与逻辑回归" class="headerlink" title="一层神经网络：感知机与逻辑回归"></a>一层神经网络：感知机与逻辑回归</h2><h4 id="M-P神经元模型"><a href="#M-P神经元模型" class="headerlink" title="M-P神经元模型"></a>M-P神经元模型</h4><p>1943年，McCulloch和Pitts提出了沿用至今的M-P神经元。在这个模型中，神经元接收来自其他$M$个神经元传递过来的<strong>输入信号</strong>$x^{(j)},j=1,2,\cdots,M$， 这些输入信号通过带<strong>权重</strong>$\omega_j$的连接进行传递，神经元接收到总输入值与神经元的阈值进行比较，然后通过<strong>激活函数</strong>处理以产生神经元的输出。</p>
<a id="more"></a>
<p>根据上述M-P神经元模型的定义，我们可以通过图1形象地表示该模型：</p>
<table>
    <tr>
        <td ><center><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20200609/Neural_Networks_fig001.jpg"  ></center>  <center>图1 </center></td>
    </tr>
</table>

<p>M-P神经元的数学表达式也可以表示如下：</p>
<script type="math/tex; mode=display">
y=f(\sum\limits_{j=1}^{M}\omega_jx^{(j)}+\omega_0)\tag{1}</script><p>注意：这里我们假设$x^{(0)}=1, \mathrm w={\omega_1,\omega_2,\cdots,\omega_M}, \bar{\mathrm w}={\omega_0,\mathrm w}$。那么公式(1)也可以写成向量的形式:</p>
<script type="math/tex; mode=display">
y=f(\sum\limits_{j=0}^{M}\omega_jx^{(j)})=f(\bar{\mathrm w}^{\mathrm T}\mathrm x)\tag{2}</script><hr>
<h4 id="感知机与逻辑回归"><a href="#感知机与逻辑回归" class="headerlink" title="感知机与逻辑回归"></a>感知机与逻辑回归</h4><p>前面系列文章中介绍的<a href="https://blog.csdn.net/tengweitw/article/details/105936164" target="_blank" rel="noopener">感知机</a>和<a href="https://blog.csdn.net/tengweitw/article/details/105509575" target="_blank" rel="noopener">逻辑回归</a>就是M-P神经元模型的两个具体实例。这两者的区别在于：</p>
<ul>
<li><p>激活函数：感知机使用的是阶跃函数，逻辑回归使用的Sigmoid函数，如图2所示：</p>
<table>
    <tr>
        <td ><center><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20200609/Neural_Networks_fig002.jpg"  >图2</center></td>
        <td ><center><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20200609/Neural_Networks_fig003.jpg"  >图3</center></td>
    </tr>
</table>

<p>同时，最近比较流行的激活函数还有$tanh$ 和 $Relu$ 函数，如图3所示。</p>
</li>
<li><p>损失函数：感知机使用的是错误分类点到分类超平面距离最小化，逻辑回归使用的交叉熵最小化</p>
</li>
</ul>
<p>感知机和逻辑回归是一个最简单的一层神经网络,只有一个神经元(M-P神经元)，可以看成是所有神经网络的基础。注意：这里对于神经网络的层数有不同的定义，主要区别在于是否将输入层看作一层神经网络。这里我们不把输入层看成一层神经网络，只将具有功能神经元(有激活函数)的输出层看成一层神经网络，因此感知机和逻辑回归是一层神经网络，而不是二层神经网络。</p>
<p>前面文章我们已经介绍过，标准的感知机和逻辑回归模型只能解决线性可分的问题，这是因为它们都只有一个M-P神经元，模型较为简单。为了解决线性不可分问题，我们需要考虑更为复杂的模型，比如考虑使用多层神经网络。下面我们来举例说明通过增加神经网络层数来解决线性不可分的问题(例如：如前面文章<a href="https://blog.csdn.net/tengweitw/article/details/106088030" target="_blank" rel="noopener">SVM</a>中提到的异或问题)。</p>
<table>
    <tr>
        <td ><center><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20200609/Neural_Networks_fig004.jpg"  >图4</center></td>
        <td ><center><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20200609/Neural_Networks_fig005.jpg"  >图5</center></td>
    </tr>
</table>

<p>图4是一个感知机的图解模型，其激活函数为图2所示的符号函数$sgn$。我们知道，感知机只能处理线性可分的情况，比如常见的与、或、非计算。具体实现如下所示：</p>
<ul>
<li>与计算 ($x^{(1)} \land x^{(2)}$)：令$\omega_1=\omega_2=1,\omega_0=-2$，我们有$y=sgn(x^{(1)}+x^{(2)}-2)$。此时，只有当$x^{(1)}=x^{(2)}=1$时，$y=1$</li>
<li>或计算 ($x^{(1)} \lor x^{(2)}$)：令$\omega_1=\omega_2=1,\omega_0=-0.5$，我们有$y=sgn(x^{(1)}+x^{(2)}-0.5)$。此时，当$x^{(1)}=1$或者 $x^{(2)}=1$时，$y=1$</li>
<li>非计算 ($\lnot x^{(1)}$)：令$\omega_1=-0.6$, $\omega_2=0,\omega_0=0.5$，我们有$y=sgn(-0.6x^{(1)}+0.5)$。此时，当$x^{(1)}=0$时，$y=1$; 当$x^{(1)}=1$时，$y=0$</li>
</ul>
<p>当我们需要处理线性不可分的情况时(如异或问题)，我们可以考虑在图4的基础上加入一层神经元，如图5所示。在图5中，我们令$\omega<em>{01}^{(1)}=\omega</em>{02}^{(1)}=\omega<em>2^{(2)}=-0.5$，$\omega</em>{11}^{(1)}=\omega<em>{22}^{(1)}=\omega_1^{(2)}=\omega_2^{(2)}=1$，$\omega</em>{12}^{(1)}=\omega_{21}^{(1)}=-1$, 这时候我们有</p>
<script type="math/tex; mode=display">
y=sgn[sgn(x^{(1)}-x^{(2)}-0.5)+sgn(x^{(2)}-x^{(1)}-0.5)-0.5]\tag{3}</script><p>由公式(3)可以看出，当$x^{(1)}=x^{(2)}$时，$y=0$; 当$x^{(1)}\neq x^{(2)}$时，$y=1$。我们可以根据公式(3)，画出其分类区域，如下图6所示：</p>
<table>
    <tr>
        <td ><center><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20200609/Neural_Networks_fig006.jpg"  >图6</center></td>
        <td ><center><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20200609/Neural_Networks_fig007.jpg"  >图7</center></td>
    </tr>
</table>

<p>在图6中，位于两条绿色直线之间所有区域 (例如：绿色区域) 都被归于同一类。我们发现通过添加一层神经元，我们就可以处理线性不可分的情况。实际上，这一层神经元的功能就是将输入的特征空间$x^{(1)},x^{(2)}$映射到了新的特征空间$z^{(1)},z^{(2)}$，而新的特征空间线性可分，如图7所示。其中这4个样例点映射到新的特征空间，其映射关系为 $\mathrm x<em>1\rightarrow\mathrm z_1, \mathrm x_2\rightarrow\mathrm z_2, \mathrm x</em>{3,4}\rightarrow\mathrm z_{3,4} (0,0)$。可见，在该新的特征空间，样例点线性可分。</p>
<h2 id="两层神经网络—BP-神经网络"><a href="#两层神经网络—BP-神经网络" class="headerlink" title="两层神经网络—BP 神经网络"></a>两层神经网络—BP 神经网络</h2><p>实际上，理论证明，两层神经网络可以拟合任何复杂形式的函数表达上。为此，本文主要介绍经典的两层前馈神经网络 (相邻层神经元全连接，神经元之间不存在同层连接，也不存在夸层连接)，如图8所示。</p>
<table>
    <tr>
        <td ><center><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20200609/Neural_Networks_fig008.jpg"  ></center>  <center>图8 </center></td>
    </tr>
</table>
在图8中，经典的神经网络由输入层、隐藏层、输出层组成，其中隐藏层和输出层的每一个神经元都是我们前面介绍的M-P神经元。我们发现，神经网络由多层多个神经元构成，其学习算法肯定比感知机和逻辑回归复杂。下面我们介绍神经网络中最常用的BP (BackPropagation) 算法。


#### 信号前向传播

在介绍BP算法时，我们需要了解神经网络的结构所决定的输入与输出间的关系表达式，即所谓的输入信号如何向前传播的输出端的。这里我们用图9可以完全形象地描述这一信息流的传播过程：

<table>
    <tr>
        <td ><center><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20200609/Neural_Networks_fig009.jpg"  ></center>  <center>图9 </center></td>
    </tr>
</table>

<p>在图9中，我们假设输入层、隐藏层、输出层的神经元个数分别为$I,J,K$，激活函数$\sigma$选择为Sigmoid函数。$\alpha^{(j)},\beta^{(k)}$分别为隐藏层和输出层的第$j,k$个神经元的输入；$z^{(j)},\hat y^{(k)}$分别为隐藏层和输出层的第$j,k$个神经元的输出。注意：这里我们有$x^{(0)}=z^{(0)}=1$是为了让求和的下标从0开始，此时对应的权重就是其他文章所说的阈值。图9的右侧给出了所有可能的输入输出的关系表达式。</p>
<h4 id="误差反向传播"><a href="#误差反向传播" class="headerlink" title="误差反向传播"></a>误差反向传播</h4><p>BP算法的核心就是误差反向传播。这里我们定义一个输入样例$\mathrm x$对应的误差为:</p>
<script type="math/tex; mode=display">
E=\frac{1}{2}\sum\limits_{k=1}^{K}(\hat y^{(k)}-y^{(k)})^2\tag{4}</script><p>公式(4)中$y^{(k)}$为样例$\mathrm x$的实际输出$y$的第$k$个输出。注意：这里的误差是一个样例的误差，而不是所有训练样例的误差。</p>
<p>BP算法的目的是优化权重$\omega<em>{ij}^{(1)},\omega</em>{jk}^{(2)}$来最小化误差$E$。为此，BP算法采用了和梯度下降法一样的思想，以误差对权重的负梯度方向来不断更新权重，降低误差$E$。为此，我们需要计算输出层和隐藏层的$\frac{\partial E}{\partial\omega<em>{ij}^{(1)}}$和$\frac{\partial E}{\partial\omega</em>{jk}^{(2)}}$。</p>
<h6 id="输出层梯度"><a href="#输出层梯度" class="headerlink" title="输出层梯度"></a>输出层梯度</h6><p>利用链式法则，我们有：</p>
<script type="math/tex; mode=display">
\frac{\partial E}{\partial\omega_{jk}^{(2)}}=\frac{\partial E}{\partial \hat y^{(k)}}\frac{\partial\hat y^{(k)}}{\partial\beta^{(k)}}\frac{\partial\beta^{(k)}}{\partial \omega_{jk}^{(2)}}\tag{4}</script><p>对于公式(4)中等式右边的每一项，我们有：</p>
<script type="math/tex; mode=display">
\frac{\partial E}{\partial\hat y^{(k)}}=\frac{\partial \frac{1}{2}\sum\limits_{k=1}^{K}(\hat y^{(k)}-y^{(k)})^2}{\partial\hat y^{(k)}}=\hat y^{(k)}-y^{(k)}\tag{5}</script><script type="math/tex; mode=display">
\frac{\partial\hat y^{(k)}}{\partial\beta^{(k)}}=\frac{\partial sigmoid(\beta^{(k)})}{\partial\beta^{(k)}}=\hat y^{(k)}(1-\hat y^{(k)})\tag{6}</script><script type="math/tex; mode=display">
\frac{\partial\beta^{(k)}}{\partial\omega_{jk}^{(2)}}=\frac{\partial\sum\limits_{j=0}^{J}\omega_{jk}^{(2)}z^{(j)}}{\partial\omega_{jk}^{(2)}}=z^{(j)}\tag{7}</script><p>在公式(6)中，第二个等式成立是因为对于sigmoid函数，例如$y=f(x)$，其导数为$y^\prime=y(1-y)$。综合(5)-(7)，公式(4)可以写为：</p>
<script type="math/tex; mode=display">
\frac{\partial E}{\partial\omega_{jk}^{(2)}}=\hat y^{(k)}(1-\hat y^{(k)})(\hat y^{(k)}-y^{(k)})z^{(j)}=g^{(k)}z^{(j)}\tag{8}</script><p>在公式(8)中，为了简便起见，我们令</p>
<script type="math/tex; mode=display">
g^{(k)}=\hat y^{(k)}(1-\hat y^{(k)})(\hat y^{(k)}-y^{(k)})\tag{9}</script><hr>
<h6 id="隐藏层梯度"><a href="#隐藏层梯度" class="headerlink" title="隐藏层梯度"></a>隐藏层梯度</h6><p>与上面计算过程类似，下面我们计算$\frac{\partial E}{\partial\omega_{ij}^{(1)}}$。同样地，利用链式法则，我们有：</p>
<script type="math/tex; mode=display">
\frac{\partial E}{\partial\omega_{ij}^{(1)}}=\frac{\partial E}{\partial z^{(j)}}\frac{\partial z^{(j)}}{\partial\alpha^{(j)}}\frac{\partial\alpha^{(j)}}{\partial\omega_{ij}^{(1)}}\tag{10}</script><p>对于公式(10)中等式右边的每一项，我们有：</p>
<script type="math/tex; mode=display">
\frac{\partial E}{\partial z^{(j)}}=\sum\limits_{k=0}^{K}\frac{\partial E}{\partial\beta^{(k)}}\frac{\partial\beta^{(k)}}{\partial z^{(j)}}=\sum\limits_{k=0}^{K}\frac{\partial E}{\partial\hat y^{(k)}}\frac{\partial\hat y^{(k)}}{\partial\beta^{(k)}}\frac{\partial\beta^{(k)}}{\partial z^{(j)}}=\sum\limits_{k=0}^{K}g^{(k)}\omega_{jk}^{(2)}\tag{11}</script><script type="math/tex; mode=display">
\frac{\partial z^{(j)}}{\partial\alpha^{(j)}}=\frac{\partial Sigmoid(\alpha^{(j)})}{\partial\alpha^{(j)}}=z^{(j)}(1-z^{(j)})\tag{12}</script><script type="math/tex; mode=display">
\frac{\partial\alpha^{(j)}}{\partial\omega_{ij}^{(1)}}=\frac{\partial\sum\limits_{i=1}^{I}\omega_{ij}^{(1)}x^{(i)}}{\partial\omega_{ij}^{(1)}}=x^{(i)}\tag{13}</script><p>综合(11)-(13)，公式(10)可以写成：</p>
<script type="math/tex; mode=display">
\frac{\partial E}{\partial\omega_{ij}^{(1)}}=x^{(i)}z^{(j)}(1-z^{(j)})\sum\limits_{k=0}^{K}g^{(k)}\omega_{jk}^{(2)}\tag{14}</script><hr>
<h6 id="梯度迭代法则"><a href="#梯度迭代法则" class="headerlink" title="梯度迭代法则"></a>梯度迭代法则</h6><p>求得输出层和隐藏层的梯度(8)和(14)后，我们就可以利用最常见的负梯度迭代法来更新权重：</p>
<script type="math/tex; mode=display">
\omega_{ij}^{(1)}=\omega_{ij}^{(1)}-\eta\frac{\partial E}{\partial\omega_{ij}^{(1)}}\tag{15}</script><script type="math/tex; mode=display">
\omega_{jk}^{(2)}=\omega_{ij}^{(2)}-\eta\frac{\partial E}{\partial\omega_{jk}^{(2)}}\tag{16}</script><hr>
<p>至此，标准的BP算法就已经介绍完成了：不断地根据(15)-(16)更新权值，直到不再改变。注意：我们前面已经提到，这里的误差$E$是对于单个训练样例的，即每来一次新的样例，我们就得更新权值。当然，我们可以一次性考虑所有的训练样例，即此时的误差函数为所有训练样例的误差加和，这时的算法称为累积BP算法。</p>
<h2 id="多层神经网络—深度学习"><a href="#多层神经网络—深度学习" class="headerlink" title="多层神经网络—深度学习"></a>多层神经网络—深度学习</h2><p>从理论上来说，神经网络的神经元越多，层数越多，模型的复杂度越高，能完成更加复杂的学习任务。但是一般情况下，模型的复杂度高意味着训练效率低，容易出现过拟合。随着计算能力的提高，以深度学习为代表的复杂神经网络开始变得越来越流行。深度学习模型就是一个深层的神经网络。关于深度学习，会在后续系列文章中介绍，这里不再展开。</p>
<hr>
<h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>Machine Learning</tag>
      </tags>
  </entry>
  <entry>
    <title>【图解例说机器学习】参数估计 (MLE and MAP)</title>
    <url>/2020/05/31/%5B20200531%5D/</url>
    <content><![CDATA[<p>参数估计：给定一个数据集，我们希望用一个给定的分布去拟合该数据集的分布，确定该分布的参数的过程就是参数估计。例如，我们用二项分布去拟合多次投掷硬币的情况，计算该二项分布的最优参数（出现正面的概率 $\theta$）就是参数估计。</p>
<a id="more"></a>
<p>下面，我们介绍在机器学习中常用的参数估计：极大似然估计 (Maximum Likelihood Estimation, MLE)，最大后验概率估计 (Maximum A Posteriori, MAP)，贝叶斯估计 (Bayesian Estimation, BE)。在此之前，我们介绍一下参数估计中常用的一些概念.</p>
<hr>
<ul>
<li><p>频率学派 VS. 贝叶斯学派</p>
<ul>
<li>频率学派：事件本身是服从某种参数$\theta$固定的分布。频率学派认为概率即是频率，某次得到的样本$\mathrm x$只是无数次可能的试验结果的一个具体实现，样本中未出现的结果不是不可能出现，只是这次抽样没有出现而已。在参数估计中，频率学派的代表是最大似然估计 MLE。</li>
<li>贝叶斯学派：参数$\theta$也是随机分布的。贝叶斯学派认为只能依靠得到的样本$\mathrm x$去做推断，而不能考虑那些有可能出现而未出现的结果。同时，贝叶斯学派引入了主观的概念，认为一个事件在发生之前，人们应该对它是有所认知，即先验概率$p(\theta)$，然后根据样本$\mathrm x$ 通过贝叶斯定理来得到后验概率$p(\theta\mid\mathrm x)$。在参数估计中，贝叶斯学派的代表是最大后验概率估计 MAP。</li>
</ul>
</li>
</ul>
<ul>
<li><p>概率 VS. 统计</p>
<p>概率与统计可以看成是互逆的概念。在<a href="http://stanford.edu/~lanhuong/refresher/notes/probstat-section3.pdf中对概念与统计推断作了简要概述：" target="_blank" rel="noopener">http://stanford.edu/~lanhuong/refresher/notes/probstat-section3.pdf中对概念与统计推断作了简要概述：</a></p>
<blockquote>
<p>• The basic problem of probability is: Given the distribution of the data, what are the properties (e.g. its expectation) of the outcomes (i.e. the data)? </p>
<p>• The basic problem of statistical inference is the inverse of probability: Given the outcomes, what can we say about the process that generated the data?</p>
</blockquote>
<p>对于在机器学习中的常见问题，这里的data就是我们的训练样例，且机器学习的目的就是 say about the process that generated the data, 即学习生成训练样例的模型。</p>
</li>
</ul>
<ul>
<li><p>似然函数 VS. 概率函数<br>似然函数和概率函数的数学表达式一样，只是以不同的角度看待该函数表达式：</p>
<ul>
<li>若$\theta$已知，$\mathrm x$是变量，$P(\mathrm x\mid\theta)$ 被称为概率函数；</li>
<li>若$\mathrm x$已知，$\theta$是变量，$P(\mathrm x\mid\theta)$ 被称为似然函数；</li>
</ul>
</li>
</ul>
<p>​        一般为了保持符号的一致性，似然函数也经常写作$L(\theta\mid\mathrm x)$。</p>
<hr>
<h2 id="极大似然估计-MLE"><a href="#极大似然估计-MLE" class="headerlink" title="极大似然估计 (MLE)"></a>极大似然估计 (MLE)</h2><p>最大似然估计MLE的思想是，寻找使得观测到的数据出现概率最大的参数$\theta$。</p>
<p>对于抛硬币来说，在一次抛硬币时，其结果的概率分布如下：</p>
<script type="math/tex; mode=display">
\begin{aligned}
P(\mathrm x_i\mid\theta)&=\begin{cases}
\theta,\quad\quad\hspace{4mm}\mathrm x_i=1\\
1-\theta,\quad\mathrm x_i=0
\end{cases}\\
&=\theta^{\mathrm x_i}(1-\theta)^{1-\mathrm x_i}
\end{aligned}\tag{1}</script><p>其中$\mathrm x_i=1$表示第$i$抛硬币时正面朝上。那么抛$N$次硬币，其结果为${\mathrm x_1,\mathrm x_2,\cdots,\mathrm x_N}$的概率为</p>
<script type="math/tex; mode=display">
P(\mathrm x_1,\mathrm x_2,\cdots,\mathrm x_N\mid\theta)=\prod\limits_{i=1}^{N}\theta^{\mathrm x_i}(1-\theta)^{1-\mathrm x_i}\tag{2}</script><p>MLE就是寻找最优的$\theta$最大化公式(2)的概率，即求解</p>
<script type="math/tex; mode=display">
\theta^\star=\arg\max_{\theta}\prod\limits_{i=1}^{N}\theta^{\mathrm x_i}(1-\theta)^{1-\mathrm x_i}\tag{3}</script><p>对于优化问题(3)，我们一般考虑将其转为对数目标函数，一方面可以将连乘转化为加和，防止计算溢出；另一方面使得目标函数更加精炼，便于通过求导求解最优解(连乘的导数不易计算)。为此，优化问题(3)可以转化为：</p>
<script type="math/tex; mode=display">
\theta^\star=\arg\max_{\theta}\sum\limits_{i=1}^{N}\log{\theta^{\mathrm x_i}(1-\theta)^{1-\mathrm x_i}}=\arg\max_{\theta}\sum\limits_{i=1}^{N}\mathrm x_i\log{\theta}+(1-\mathrm x_i)\log{(1-\theta)}\tag{4}</script><p>对(4)的目标函数对$\theta$求导，并令导数为0 (目标函数为凹函数，在导数为0点取得极值)，我们有：</p>
<script type="math/tex; mode=display">
\sum\limits_{i=1}^{N}\mathrm x_i\frac{1}{\theta}+(1-\mathrm x_i)\frac{-1}{1-\theta}=0\rightarrow\theta=\frac{\sum\nolimits_{i=1}^{N}\mathrm x_i}{\sum\nolimits_{i=1}^{N}1}\tag{5}</script><p>公式(5)的结果比较符合直观：比如抛硬币10次，发现5次正面朝上，我们就说出现正面朝上的概率为0.5. 但是，也可能出现7次正面朝上的情况，这时我们说出现正面朝上的概率为0.7，显然这时与实际情况不符合(假定硬币是均匀的)。也就是说，当试验次数较少时，使用最大似然函数时的误差会较大。</p>
<hr>
<p>上式(1)-(5)详细推导了离散的二项分布的最大似然估计(5)。对于常用的连续分布正态分布$\mathcal N(\mu,\sigma^2)$，我们只需要将公式(2)中的连乘项改为正态分布的概率密度函数，然后通过对数、求导为零，可以得到其最大似然估计为：</p>
<script type="math/tex; mode=display">
\mu=\frac{1}{N}\sum\limits_{i=1}^{N}x_i\tag{6}</script><script type="math/tex; mode=display">
\sigma^2=\frac{1}{N}\sum\limits_{i=1}^{N}(x_i-\mu^\star)^2\tag{7}</script><p>其中，我们这里假设总共有$N$个样本，$x_1,x_2,\cdots,x_N$。</p>
<hr>
<h2 id="最大后验概率估计-MAP"><a href="#最大后验概率估计-MAP" class="headerlink" title="最大后验概率估计 (MAP)"></a>最大后验概率估计 (MAP)</h2><p>在最大后验概率MAP中，参数$\theta$被看作为一个随机变量，服从某种概率分布，被称为先验概率$P(\theta)$。</p>
<p>还是以上述抛硬币为例，考虑到先验概率，优化问题(3)被改写为：</p>
<script type="math/tex; mode=display">
\theta^\star=\arg\max_{\theta}\prod\limits_{i=1}^{N}\theta^{\mathrm x_i}(1-\theta)^{1-\mathrm x_i}p(\theta)\tag{8}</script><p>同样地，将公式(8)进行对数化可得：</p>
<script type="math/tex; mode=display">
\theta^\star=\arg\max_{\theta}\sum\limits_{i=1}^{N}\log{\theta^{\mathrm x_i}(1-\theta)^{1-\mathrm x_i}}p(\theta)=\arg\max_{\theta}\sum\limits_{i=1}^{N}\mathrm x_i\log{\theta}+(1-\mathrm x_i)\log{(1-\theta)}+\log p(\theta)\tag{9}</script><p>一般地，我们假设硬币是均匀地，即$p(\theta=\frac{1}{2})=1$，即此时参数$\theta$时一个固定的未知量。此时，对(8)的目标函数对$\theta$求导，并令导数为0，我们可以得到和公式(5)一样的结果。这说明，当先验分布为均匀分布时，MLE等价于MAP。但是，在最大后验概率中，我们可以假设$\theta$是服从某一概率分布的。这里我们假设$\theta\sim N(\mu,\sigma)$，即</p>
<script type="math/tex; mode=display">
p(\theta)=\frac{1}{\sqrt{2\pi}\sigma}e^{-\frac{(\theta-\mu)^2}{2\sigma^2}}\tag{10}</script><p>将公式(10)带入公式(9)可得：</p>
<script type="math/tex; mode=display">
\theta^\star=\arg\max_{\theta}\sum\limits_{i=1}^{N}\mathrm x_i\log{\theta}+(1-\mathrm x_i)\log{(1-\theta)}+\log{\frac{1}{\sqrt{2\pi}\sigma}}-\frac{(\theta-\mu)^2}{2\sigma^2}\tag{11}</script><p>注意：由于正态分布的概率密度函数(10)是关于$\theta$ 的凹函数，公式(4)也是凹函数，所以公式(11)中的目标函数也是凹函数，所以我们可以利用导数为0取得最优的参数值$\theta^\star$。但是此时，我们一般无法得到如公式(5)一样简洁的解析表达式。在下面的具体实例中，我们直接给出目标函数的图像，从而可以形象地直接确定其最优解。对于比较复杂的目标函数，我们就需要借助其他迭代算法来求解了。</p>
<p>对于一个具体实例 ($\mu=0.5,\sigma=0.1$，事件$\mathrm x$为10次试验有7次为正面朝上)，此时问题(8)中的目标函数为：</p>
<script type="math/tex; mode=display">
P(\theta\mid\mathrm x)=P(\mathrm x\mid\theta)P(\theta)=\theta^7(1-\theta)^3\frac{10}{\sqrt{2\pi}}e^{-50(\theta-0.5)^2}\tag{12}</script><p>我们可以画出其函数曲线如下：</p>
<table>
    <tr>
        <td ><center><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20200531/Parameter_Estimation_fig001.jpg"  ></center>  <center>图1 </center></td>
    </tr>
</table>



<p>从图1中可以看出，当我们采用不同的先验概率分布时 ($\mu=0.5,\mu=0.8$)，最终得到的参数也不同 ($\theta^\star=0.56,\theta^\star=0.76$)。在这里，我们假设硬币是均匀的，即正面朝上的概率为$\theta=0.5$，此时与MLE相比 ($\theta=0.7$)，MAP的性能时好时坏，也就是说，MAP的性能与先验概率分布的选取有关。</p>
<hr>
<h2 id="等效情况"><a href="#等效情况" class="headerlink" title="等效情况"></a>等效情况</h2><p>如前面所提及的，<strong>当先验概率为均匀分布时</strong>，MLE和MAP等效，因为此时$\theta$服从均匀分布，没有提供有效的关于$\theta$的先验信息。MLE和MAP等效的另一种情况就是：在频率学派所代表的MLE，<strong>当观测数据变大时(例子中对应抛硬币次数)</strong>，这时观测数据的本身就提供了足够的信息，先验概率的影响变得微不足道，此时MLE和MAP等效，即最终估计的参数值$\theta^\star$相同。如下图2和3，表示了当100次抛硬币70次为正面，和1000次抛硬币700次为正面时，对应的似然函数和后验概率函数：</p>
<table>
    <tr>
        <td ><center><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20200531/Parameter_Estimation_fig002.jpg"  >图2</center></td>
        <td ><center><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20200531/Parameter_Estimation_fig003.jpg"  >图3</center></td>
    </tr>
</table>

<hr>
<h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><p>下面给出图1-3的python源代码，由于代码简单，所以就没有注释</p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        图1的python源代码：
    </div>
    <div class='spoiler-content'>
        <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- encoding: utf-8 -*-</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">@File    : Parameter_Estimation_fig001.py</span></span><br><span class="line"><span class="string">@Time    : 2020/5/31 14:46</span></span><br><span class="line"><span class="string">@Author  : tengweitw</span></span><br><span class="line"><span class="string">@Email   : tengweitw@foxmail.com</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># Set the format of labels</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">LabelFormat</span><span class="params">(plt)</span>:</span></span><br><span class="line">    ax = plt.gca()</span><br><span class="line">    plt.tick_params(labelsize=<span class="number">14</span>)</span><br><span class="line">    labels = ax.get_xticklabels() + ax.get_yticklabels()</span><br><span class="line">    [label.set_fontname(<span class="string">'Times New Roman'</span>) <span class="keyword">for</span> label <span class="keyword">in</span> labels]</span><br><span class="line">    font = &#123;<span class="string">'family'</span>: <span class="string">'Times New Roman'</span>,</span><br><span class="line">            <span class="string">'weight'</span>: <span class="string">'normal'</span>,</span><br><span class="line">            <span class="string">'size'</span>: <span class="number">16</span>,</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="keyword">return</span> font</span><br><span class="line"></span><br><span class="line">sigma=<span class="number">0.1</span></span><br><span class="line">mu1=<span class="number">0.5</span></span><br><span class="line">mu2=<span class="number">0.8</span></span><br><span class="line"></span><br><span class="line">theta=np.linspace(<span class="number">0</span>,<span class="number">1</span>,<span class="number">1000</span>)</span><br><span class="line">p_theta_x1=theta**<span class="number">7</span>*(<span class="number">1</span>-theta)**<span class="number">3</span>/(np.sqrt(<span class="number">2</span>*np.pi)*sigma)*np.exp(-np.square(theta-mu1)/<span class="number">2</span>/np.square(sigma))</span><br><span class="line">p_theta_x2=theta**<span class="number">7</span>*(<span class="number">1</span>-theta)**<span class="number">3</span>/(np.sqrt(<span class="number">2</span>*np.pi)*sigma)*np.exp(-np.square(theta-mu2)/<span class="number">2</span>/np.square(sigma))</span><br><span class="line"></span><br><span class="line">p_theta_x0=theta**<span class="number">7</span>*(<span class="number">1</span>-theta)**<span class="number">3</span>/(np.sqrt(<span class="number">2</span>*np.pi)*sigma)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p_max_ind0=np.argmax(p_theta_x0)</span><br><span class="line">print(theta[p_max_ind0])</span><br><span class="line"></span><br><span class="line">p_max_ind1=np.argmax(p_theta_x1)</span><br><span class="line">print(theta[p_max_ind1])</span><br><span class="line"></span><br><span class="line">p_max_ind2=np.argmax(p_theta_x2)</span><br><span class="line">print(theta[p_max_ind2])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">plt.figure()</span><br><span class="line">plt.plot(theta,p_theta_x0,<span class="string">'r-'</span>)</span><br><span class="line">plt.plot(theta,p_theta_x1,<span class="string">'g-'</span>)</span><br><span class="line">plt.plot(theta,p_theta_x2,<span class="string">'b-'</span>)</span><br><span class="line"></span><br><span class="line">plt.plot([theta[p_max_ind0],theta[p_max_ind0]],[<span class="number">0</span>,p_theta_x0[p_max_ind0]],<span class="string">'r--'</span>)</span><br><span class="line">plt.plot([theta[p_max_ind1],theta[p_max_ind1]],[<span class="number">0</span>,p_theta_x1[p_max_ind1]],<span class="string">'g--'</span>)</span><br><span class="line">plt.plot([theta[p_max_ind2],theta[p_max_ind2]],[<span class="number">0</span>,p_theta_x2[p_max_ind2]],<span class="string">'b--'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">plt.legend([<span class="string">"MLE"</span>,<span class="string">r"MAP, $\mu=0.5$"</span>,<span class="string">r"MAP, $\mu=0.8$"</span>])</span><br><span class="line"></span><br><span class="line">font = LabelFormat(plt)</span><br><span class="line">plt.xlabel(<span class="string">r'$\theta$'</span>, font)</span><br><span class="line">plt.ylabel(<span class="string">r'$P(\theta\mid\mathrm&#123;x&#125;)$'</span>, font)</span><br><span class="line">plt.xlim(<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line">plt.ylim(<span class="number">0</span>,<span class="number">0.01</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

    </div>
</div>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        图2-3的python源代码：
    </div>
    <div class='spoiler-content'>
        <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- encoding: utf-8 -*-</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">@File    : Parameter_Estimation_fig002.py</span></span><br><span class="line"><span class="string">@Time    : 2020/5/31 16:01</span></span><br><span class="line"><span class="string">@Author  : tengweitw</span></span><br><span class="line"><span class="string">@Email   : tengweitw@foxmail.com</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># Set the format of labels</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">LabelFormat</span><span class="params">(plt)</span>:</span></span><br><span class="line">    ax = plt.gca()</span><br><span class="line">    plt.tick_params(labelsize=<span class="number">14</span>)</span><br><span class="line">    labels = ax.get_xticklabels() + ax.get_yticklabels()</span><br><span class="line">    [label.set_fontname(<span class="string">'Times New Roman'</span>) <span class="keyword">for</span> label <span class="keyword">in</span> labels]</span><br><span class="line">    font = &#123;<span class="string">'family'</span>: <span class="string">'Times New Roman'</span>,</span><br><span class="line">            <span class="string">'weight'</span>: <span class="string">'normal'</span>,</span><br><span class="line">            <span class="string">'size'</span>: <span class="number">16</span>,</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="keyword">return</span> font</span><br><span class="line"></span><br><span class="line">sigma=<span class="number">0.1</span></span><br><span class="line">mu1=<span class="number">0.5</span></span><br><span class="line">mu2=<span class="number">0.8</span></span><br><span class="line"></span><br><span class="line">theta=np.linspace(<span class="number">0</span>,<span class="number">1</span>,<span class="number">1000</span>)</span><br><span class="line"><span class="comment"># Here to change 700 300 to 70 30 vice verse</span></span><br><span class="line">p_theta_x1=theta**<span class="number">70</span>*(<span class="number">1</span>-theta)**<span class="number">30</span>/(np.sqrt(<span class="number">2</span>*np.pi)*sigma)*np.exp(-np.square(theta-mu1)/<span class="number">2</span>/np.square(sigma))</span><br><span class="line">p_theta_x2=theta**<span class="number">70</span>*(<span class="number">1</span>-theta)**<span class="number">30</span>/(np.sqrt(<span class="number">2</span>*np.pi)*sigma)*np.exp(-np.square(theta-mu2)/<span class="number">2</span>/np.square(sigma))</span><br><span class="line">p_theta_x0=theta**<span class="number">70</span>*(<span class="number">1</span>-theta)**<span class="number">30</span>/(np.sqrt(<span class="number">2</span>*np.pi)*sigma)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p_max_ind0=np.argmax(p_theta_x0)</span><br><span class="line">print(theta[p_max_ind0])</span><br><span class="line"></span><br><span class="line">p_max_ind1=np.argmax(p_theta_x1)</span><br><span class="line">print(theta[p_max_ind1])</span><br><span class="line"></span><br><span class="line">p_max_ind2=np.argmax(p_theta_x2)</span><br><span class="line">print(theta[p_max_ind2])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">plt.figure()</span><br><span class="line">plt.plot(theta,p_theta_x0,<span class="string">'r-'</span>)</span><br><span class="line">plt.plot(theta,p_theta_x1,<span class="string">'g-'</span>)</span><br><span class="line">plt.plot(theta,p_theta_x2,<span class="string">'b-'</span>)</span><br><span class="line"></span><br><span class="line">plt.plot([theta[p_max_ind0],theta[p_max_ind0]],[<span class="number">0</span>,p_theta_x0[p_max_ind0]],<span class="string">'r--'</span>)</span><br><span class="line">plt.plot([theta[p_max_ind1],theta[p_max_ind1]],[<span class="number">0</span>,p_theta_x1[p_max_ind1]],<span class="string">'g--'</span>)</span><br><span class="line">plt.plot([theta[p_max_ind2],theta[p_max_ind2]],[<span class="number">0</span>,p_theta_x2[p_max_ind2]],<span class="string">'b--'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">plt.legend([<span class="string">"MLE"</span>,<span class="string">r"MAP, $\mu=0.5$"</span>,<span class="string">r"MAP, $\mu=0.8$"</span>])</span><br><span class="line"></span><br><span class="line">font = LabelFormat(plt)</span><br><span class="line">plt.xlabel(<span class="string">r'$\theta$'</span>, font)</span><br><span class="line">plt.ylabel(<span class="string">r'$P(\theta\mid\mathrm&#123;x&#125;)$'</span>, font)</span><br><span class="line">plt.xlim(<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line">plt.ylim(ymin=<span class="number">0</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>



    </div>
</div>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>Machine Learning</tag>
      </tags>
  </entry>
  <entry>
    <title>【图解例说机器学习】朴素贝叶斯 (Naive Bayes)</title>
    <url>/2020/05/28/%5B20200528%5D/</url>
    <content><![CDATA[<p>朴素贝叶斯分类法是基于<strong>贝叶斯定理</strong>与<strong>特征条件独立假设</strong>的分类方法。其<strong>主要思想</strong>为：对于给定的训练数据集 $\mathcal D$ ，首先基于特征条件独立假设学习输入 $\mathrm x$ 与输出 $y$ 的联合概率分布 $P(\mathrm x, y)$ ; 然后通过先验概率 $P(y)$ ，利用贝叶斯定理求出后验概率 $P(y\mid\mathrm x)$ 最大对应的输出 $y$ 。</p>
<hr>
<a id="more"></a>
<h2 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h2><p>由于朴素贝叶斯分类比较简单，这里直接先给出一个例子来演示如何进行分类。相信大多数有概率论基础的同学都能依据这个例子来实现一个朴素贝叶斯分类器。而对于其理论部感兴趣的同学，可以阅读本文后续理论部分。</p>
<p>如下表所示，我们假设有 $15$个训练样例 $\mathrm x_i, i=1,2,\cdots,15$，$2$个特征 $x^{(1)},x^{(2)}$，每个特征分别有 $3$个取值 $x^{(1)}\in{1,2,3}$ ， $x^{(2)}\in{\mathrm{S,M,L}}$，两个类别 $y\in{-1,1}$。对于一个新的样例 $\mathrm x={2,\mathrm S}$，我们需要确定其分类。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">$\mathrm x_1$</th>
<th style="text-align:center">$\mathrm x_2$</th>
<th style="text-align:center">$\mathrm x_3$</th>
<th style="text-align:center">$\mathrm x_4$</th>
<th style="text-align:center">$\mathrm x_5$</th>
<th style="text-align:center">$\mathrm x_6$</th>
<th style="text-align:center">$\mathrm x_7$</th>
<th style="text-align:center">$\mathrm x_8$</th>
<th style="text-align:center">$\mathrm x_9$</th>
<th style="text-align:center">$\mathrm x_{10}$</th>
<th style="text-align:center">$\mathrm x_{11}$</th>
<th style="text-align:center">$\mathrm x_{12}$</th>
<th style="text-align:center">$\mathrm x_{13}$</th>
<th style="text-align:center">$\mathrm x_{14}$</th>
<th style="text-align:center">$\mathrm x_{15}$</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">$x^{(1)}$</td>
<td style="text-align:center">$1$</td>
<td style="text-align:center">$1$</td>
<td style="text-align:center">$1$</td>
<td style="text-align:center">$1$</td>
<td style="text-align:center">$1$</td>
<td style="text-align:center">$2$</td>
<td style="text-align:center">$2$</td>
<td style="text-align:center">$2$</td>
<td style="text-align:center">$2$</td>
<td style="text-align:center">$2$</td>
<td style="text-align:center">$3$</td>
<td style="text-align:center">$3$</td>
<td style="text-align:center">$3$</td>
<td style="text-align:center">$3$</td>
<td style="text-align:center">$3$</td>
</tr>
<tr>
<td style="text-align:center">$x^{(2)}$</td>
<td style="text-align:center">$\mathrm S$</td>
<td style="text-align:center">$\mathrm M$</td>
<td style="text-align:center">$\mathrm M$</td>
<td style="text-align:center">$\mathrm S$</td>
<td style="text-align:center">$\mathrm S$</td>
<td style="text-align:center">$\mathrm S$</td>
<td style="text-align:center">$\mathrm M$</td>
<td style="text-align:center">$\mathrm M$</td>
<td style="text-align:center">$\mathrm L$</td>
<td style="text-align:center">$\mathrm L$</td>
<td style="text-align:center">$\mathrm L$</td>
<td style="text-align:center">$\mathrm M$</td>
<td style="text-align:center">$\mathrm M$</td>
<td style="text-align:center">$\mathrm L$</td>
<td style="text-align:center">$\mathrm L$</td>
</tr>
<tr>
<td style="text-align:center">$y$</td>
<td style="text-align:center">$-1$</td>
<td style="text-align:center">$-1$</td>
<td style="text-align:center">$1$</td>
<td style="text-align:center">$1$</td>
<td style="text-align:center">$-1$</td>
<td style="text-align:center">$-1$</td>
<td style="text-align:center">$-1$</td>
<td style="text-align:center">$1$</td>
<td style="text-align:center">$1$</td>
<td style="text-align:center">$1$</td>
<td style="text-align:center">$1$</td>
<td style="text-align:center">$1$</td>
<td style="text-align:center">$1$</td>
<td style="text-align:center">$1$</td>
<td style="text-align:center">$-1$</td>
</tr>
</tbody>
</table>
</div>
<p>根据上表，我们很容易求出各种概率：</p>
<script type="math/tex; mode=display">
P(y=1)=\frac{9}{15}, P(y=-1)=\frac{6}{15}\tag{1}</script><script type="math/tex; mode=display">
P(x^{(1)}=1\mid y=1)=\frac{2}{9},P(x^{(1)}=2\mid y=1)=\frac{3}{9},P(x^{(1)}=3\mid y=1)=\frac{4}{9}\tag{2}</script><script type="math/tex; mode=display">
P(x^{(2)}=\mathrm S\mid y=1)=\frac{1}{9},P(x^{(2)}=\mathrm M\mid y=1)=\frac{4}{9},P(x^{(2)}=\mathrm L\mid y=1)=\frac{4}{9}\tag{3}</script><script type="math/tex; mode=display">
P(x^{(1)}=1\mid y=-1)=\frac{3}{6},P(x^{(1)}=2\mid y=-1)=\frac{2}{6},P(x^{(1)}=3\mid y=-1)=\frac{1}{6}\tag{4}</script><script type="math/tex; mode=display">
P(x^{(2)}=\mathrm S\mid y=-1)=\frac{3}{6},P(x^{(2)}=\mathrm M\mid y=-1)=\frac{2}{6},P(x^{(2)}=\mathrm L\mid y=-1)=\frac{1}{6}\tag{5}</script><p>对于新的样例$\mathrm x={2,\mathrm S}$ ，我们有</p>
<script type="math/tex; mode=display">
P(y=1)P(x^{(1)}=2\mid y=1)P(x^{(2)}=\mathrm S\mid y=1)=\frac{9}{15}\times\frac{3}{9}\times\frac{1}{9}=\frac{1}{45}\tag{6}</script><script type="math/tex; mode=display">
P(y=-1)P(x^{(1)}=2\mid y=-1)P(x^{(2)}=\mathrm S\mid y=-1)=\frac{6}{15}\times\frac{2}{6}\times\frac{3}{6}=\frac{1}{15}\tag{7}</script><p>比较公式(6)和(7)，我们判断新的样例$\mathrm x={2,\mathrm S}$的输出类别为$y=-1$ 。</p>
<hr>
<h2 id="朴素贝叶斯分类模型"><a href="#朴素贝叶斯分类模型" class="headerlink" title="朴素贝叶斯分类模型"></a>朴素贝叶斯分类模型</h2><h4 id="生成模型与判别模型"><a href="#生成模型与判别模型" class="headerlink" title="生成模型与判别模型"></a>生成模型与判别模型</h4><p>与前面文章介绍过的判别模型 (KNN， 线性回归，逻辑斯特回归，决策树，感知机，SVM) 不同， 朴素贝叶斯分类模型属于生成模型。在这些监督学习(训练样例同时有输入 $\mathrm x$ 和输出 $y$)中，目标都是学习一个模型，应用这一个模型，对给定的输入预测相应的输出。这个模型的一般形式为决策函数：</p>
<script type="math/tex; mode=display">
y=f(\mathrm x)\tag{8}</script><p>或者，从概率的角度上(8)可以写成条件概率：</p>
<script type="math/tex; mode=display">
P(y\mid\mathrm x)\tag{9}</script><p>根据求解(9)的方式，我们可以将模型分为判别模型(discriminative model)和生成模型(generation model)：</p>
<ul>
<li><p>判别模型：直接学习$P(y\mid\mathrm x)$。例如，在线性回归中，直接将模型设为$y=f(\mathrm x)=P(y\mid\mathrm x)=\omega_0+\mathrm w^{\mathrm T}\mathrm x$。然后通过正规方程或梯度下降求解最优的参数$\bar{\mathrm w}={\omega_0,\mathrm w}$。判别方式是直接学习条件概率$P(y\mid\mathrm x)$，因此学习的准确率更高。</p>
</li>
<li><p>生成模型：间接学习$P(y\mid\mathrm x)$。通过贝叶斯定理：</p>
<script type="math/tex; mode=display">
P(y\mid\mathrm x)=\frac{P(\mathrm x,y)}{P(\mathrm x)}\tag{10}</script><p>间接求解我们的目标$P(y\mid\mathrm x)$。生产模型需要估计其联合概率分布$P(\mathrm x,y)$，其学习收敛速度较快，但样本数量增加时，学习的模型可以更快地收敛到真实模型。当存在隐变量时，仍然可以用生成模型，此时判别模型不再适用，具体可以参考隐马尔科夫模型。</p>
</li>
</ul>
<hr>
<h2 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h2><p>当给定模型(8)或(9)时，我们的目标是通过损失函数最小来求解模型(8)，(9)中的优化参数。例如在线性回归中，模型为$\hat y=\omega<em>0+\mathrm w^{\mathrm T}\mathrm x$，我们通过损失函数$\sum\nolimits</em>{i}(\hat y_i-y_i)^2$来寻求最优的参数 $\bar{\mathrm w}={\omega_0,\mathrm w}$。对于朴素贝叶斯来说，我们首先定义对于一个样本$\mathrm x$ 被判别为类别$k\in\mathcal K$ 时的损失函数为：</p>
<script type="math/tex; mode=display">
E(\hat y=k\mid\mathrm x)=\sum\limits_{k^\prime\in\mathcal K}\gamma_{kk^\prime}P(y=k^\prime\mid\mathrm x)\tag{11}</script><p>这里 $\gamma_{kk^\prime}$表示的是真实类别为$y=k^\prime$的样例点$\mathrm x$被分类为$\hat y=k$时所产生的损失，一般来说，我们有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\gamma_{kk^\prime}=\begin{cases}
1,\quad k\neq k^\prime\\
0, \quad k=k^\prime
\end{cases}
\end{aligned}\tag{12}</script><p>那么对于整个训练数据集，我们可以定义损失函数为:</p>
<script type="math/tex; mode=display">
E(\mathcal D)=\mathbb E_{\mathrm x}[E(\hat y\mid\mathrm x)]\tag{13}</script><p>为了最小化损失函数(13)，我们直观地可以使得对于每一个样例，使其损失函数(11)最小，这样就产生了贝叶斯判定准则：</p>
<script type="math/tex; mode=display">
k^\star=argmin_{k\in\mathcal K}\quad E(\hat y=k\mid\mathrm x)=argmin_{k\in\mathcal K}\quad P(\hat y=k\mid\mathrm x)\tag{14}</script><p>求解(14)的难度在于计算 $P(y\mid\mathrm x)$。在朴素贝叶斯中，我们一般通过贝叶斯定理求解：</p>
<script type="math/tex; mode=display">
P(y\mid\mathrm x)=\frac{P(\mathrm x,y)}{P(\mathrm x)}=\frac{P(\mathrm x\mid y)P(y)}{P(\mathrm x)}\tag{15}</script><p>对于分类问题来说，我们的目的是求解得到输出$y$。为此，对于$y$来说，我们可以定义$P(y)$为 $y$的先验概率，$P(y\mid\mathrm x)$为已知$\mathrm x$的情况下$y$的后验概率，$P(\mathrm x,y)$为联合概率分布，$P(\mathrm x\mid y)$ 为条件概率。对于一个给定的样例$\mathrm x$，概率$P(\mathrm x)$不变，为此判定准则(14)可以变为：</p>
<script type="math/tex; mode=display">
k^\star=argmin_{k\in\mathcal K}\quad P(\mathrm x\mid y=k)P(y=k)\tag{16}</script><p>为此，我们的目的变为如何根据训练数据集$\mathcal D$来计算$P(\mathrm x\mid y=k)$ 和 $P(y=k)$。下面我们介绍如何通过极大似然估计和贝叶斯估计来计算公式(16)。</p>
<hr>
<h2 id="参数估计：MLE-和-MAP"><a href="#参数估计：MLE-和-MAP" class="headerlink" title="参数估计：MLE 和 MAP"></a>参数估计：MLE 和 MAP</h2><h4 id="极大似然估计-MLE"><a href="#极大似然估计-MLE" class="headerlink" title="极大似然估计 (MLE)"></a>极大似然估计 (MLE)</h4><p>在朴素贝叶斯分类中，学习后验概率$P(y\mid\mathrm x)$意味着估计先验概率$P(y)$ 和 条件概率 $P(\mathrm x\mid y)$。利用极大似然估计法，先验概率$P(y)$可以计算如下：</p>
<script type="math/tex; mode=display">
P(y=k)=\frac{\lvert\mathcal D_k\rvert}{\lvert\mathcal D\rvert}\tag{17}</script><p>其中，$\mathcal D_k$ 为训练数据集中所有类别为$k$的样例集合。同样地，条件概率$P(\mathrm x\mid y)$ 可以展开如下：</p>
<script type="math/tex; mode=display">
P(\mathrm x\mid y=k)=P(x^{(1)},x^{(2)},\cdots,x^{(M)}\mid y=k)\tag{18}</script><p>由于在朴素贝叶斯中，各个特征条件独立，公式(18)可以转化为：</p>
<script type="math/tex; mode=display">
P(\mathrm x\mid y=k)=P(x^{(1)},x^{(2)},\cdots,x^{(M)}\mid y=k)=\prod\limits_{j=1}^{M}P(x^{(j)}\mid y=k)\tag{19}</script><p>我们假定在$\mathcal D_k$中，第$j$个特征取值为$x^{(j)}$的样例集合为$\mathcal D_k^{(j)}$，那么由极大似然估计可得$P(x^{(j)}\mid y=k)$：</p>
<script type="math/tex; mode=display">
P(x^{(j)}\mid y)=\frac{\lvert D_k^{(j)}\rvert}{\lvert\mathcal D_k\rvert}\tag{20}</script><p>将公式(20)带入公式(19)得：</p>
<script type="math/tex; mode=display">
P(\mathrm x\mid y=k)=\prod\limits_{j=1}^{M}P(x^{(j)}\mid y=k)=\prod\limits_{j=1}^{M}\frac{\lvert D_k^{(j)}\rvert}{\lvert\mathcal D_k\rvert}\tag{21}</script><hr>
<p>至此，最基本的朴素贝叶斯分类方法已经介绍完毕。总结：首先根据训练数据集$\mathcal D$计算公式(17)和(21)，然后根据得到的$P(y),P(\mathrm x\mid y)$得到$P(y\mid\mathcal x)$，最后根据(14)进行分类。回到本文最前面的例子：其中公式(1)计算先验概率$P(y)$，公式(2)-(5)计算条件概率$P(\mathrm x\mid y)$，得到(6)-(7)中的后验概率$P(y\mid\mathcal x)$, 最后比较后验概率$P(y=1\mid\mathrm x)$与$P(y=-1\mid\mathrm x)$，样例$\mathrm x$被判别后验概率最大所对应的$y$，即$y=-1$。</p>
<hr>
<h4 id="最大后验概率估计-MAP"><a href="#最大后验概率估计-MAP" class="headerlink" title="最大后验概率估计 (MAP)"></a>最大后验概率估计 (MAP)</h4><p>上述极大似然估计可能会对训练集中未出现的特征出现估计的概率值为0的情况，即条件概率$P(\mathrm x\mid y)=0$。为解决这一问题，我们可以使用贝叶斯估计。那么，先验概率$P(y)$可以表示为</p>
<script type="math/tex; mode=display">
P(y=k)=\frac{\lvert\mathcal D_k\rvert+\alpha}{\lvert\mathcal D\rvert+\alpha K}\tag{22}</script><p>其中$K$为输出$y$可能的取值个数，$\alpha$为一个常数，当$\alpha=0 $时，即为前面所说的极大似然估计；当$\alpha=1$时，这时称为拉普拉斯平滑。同样地，条件概率的贝叶斯估计为：</p>
<script type="math/tex; mode=display">
P(x^{(j)}\mid y=k)=\frac{\lvert D_k^{(j)}\rvert+\alpha}{\lvert\mathcal D_k\rvert+\alpha K_j}\tag{23}</script><p>其中$K_j$为第$j$个特征属性可能的取值个数，根据公式(22)和(23)，我们很容易将公式(1)-(7)改写为：</p>
<script type="math/tex; mode=display">
P(y=1)=\frac{10}{17}, P(y=-1)=\frac{7}{17}\tag{$1^\prime$}</script><script type="math/tex; mode=display">
P(x^{(1)}=1\mid y=1)=\frac{3}{12},P(x^{(1)}=2\mid y=1)=\frac{4}{12},P(x^{(1)}=3\mid y=1)=\frac{5}{12}\tag{$2^\prime$}</script><script type="math/tex; mode=display">
P(x^{(2)}=\mathrm S\mid y=1)=\frac{2}{12},P(x^{(2)}=\mathrm M\mid y=1)=\frac{5}{12},P(x^{(2)}=\mathrm L\mid y=1)=\frac{5}{12}\tag{$3^\prime$}</script><script type="math/tex; mode=display">
P(x^{(1)}=1\mid y=-1)=\frac{4}{9},P(x^{(1)}=2\mid y=-1)=\frac{3}{9},P(x^{(1)}=3\mid y=-1)=\frac{2}{9}\tag{$4^\prime$}</script><script type="math/tex; mode=display">
P(x^{(2)}=\mathrm S\mid y=-1)=\frac{4}{9},P(x^{(2)}=\mathrm M\mid y=-1)=\frac{3}{9},P(x^{(2)}=\mathrm L\mid y=-1)=\frac{2}{9}\tag{$5^\prime$}</script><p>对于新的样例$\mathrm x={2,\mathrm S}$ ，我们有</p>
<script type="math/tex; mode=display">
P(y=1)P(x^{(1)}=2\mid y=1)P(x^{(2)}=\mathrm S\mid y=1)=\frac{10}{17}\times\frac{4}{12}\times\frac{1}{12}=\frac{5}{153}=0.032\tag{$6^\prime$}</script><script type="math/tex; mode=display">
P(y=-1)P(x^{(1)}=2\mid y=-1)P(x^{(2)}=\mathrm S\mid y=-1)=\frac{7}{17}\times\frac{3}{9}\times\frac{4}{9}=\frac{28}{459}=0.061\tag{$7^\prime$}</script><p>比较公式($6^\prime$)和($7^\prime$)，我们判断新的样例$\mathrm x={2,\mathrm S}$的输出类别为$y=-1$ 。</p>
<hr>
<h2 id="连续特征的朴素贝叶斯分类"><a href="#连续特征的朴素贝叶斯分类" class="headerlink" title="连续特征的朴素贝叶斯分类"></a>连续特征的朴素贝叶斯分类</h2><p>在前面的例子中，我们都假设特征取值是离散的，这样我们可以直接通过公式(20)和(23)直接计算条件概率。但是，在实际生活中，很多特征属性的取值是连续的。这时，一般有两种方法：1）最简单直观地就是将连续数据离散化；2）假定该连续特征变量服从一种概率分布(正态分布，二项分布等)，根据训练数据集计算该特征的概率密度函数。对于第一种方法，比较简单，不在赘述。下面主要介绍第二种方法：</p>
<p>对于连续特征$x^{(j)}$，我们假定其服从正态分布，即$P(x^{(j)}\mid y=k)\sim\mathcal N(\mu<em>{kj},\sigma</em>{kj})$ 。对于正态分布，其极大似然估计为：</p>
<script type="math/tex; mode=display">
\mu_{kj}=\frac{1}{\lvert\mathcal D_{k}\rvert}\sum\limits_{i\in\mathcal D_{k}}{x_{i}^{(j)}}\tag{24}</script><script type="math/tex; mode=display">
\sigma_{kj}^2=\frac{1}{\lvert\mathcal D_{k}\rvert}\sum\limits_{i\in\mathcal D_{k}}{(x_{i}^{(j)}-\mu_{kj})^2}\tag{25}</script><p>根据公式(24)和(25)，就可以用正态分布函数的概率密度表达式来计算条件概率：</p>
<script type="math/tex; mode=display">
P(x^{(j)}\mid y=k)=\frac{1}{\sqrt{2\pi}\sigma_{kj}}\exp(-\frac{(x^{(j)}-\mu_{kj})^2}{2\sigma_{kj}^2})\tag{26}</script><p>将公式(26)替换前面公式(20)或(23)，就可以利用上述方式得到贝叶斯分类器了。注意：这里我们假定其服从正态分布，当然也可以假定其服从其他分布。这里概率分布的选取对最后的分类效果影响较大。</p>
<hr>
<h4 id="连续朴素贝叶斯分类实例"><a href="#连续朴素贝叶斯分类实例" class="headerlink" title="连续朴素贝叶斯分类实例"></a>连续朴素贝叶斯分类实例</h4><p>我们这里使用iris数据集(sklearn库中自带)，这里面有150个训练样例，4个feature, 总共分3类。我们只考虑了前2个feature，这么做是为了在下面二维图中展示分类结果。在这150个样例中，我们取出第25,75,125个样例作为测试样例(其label分别为0,1,2)，其他147个作为训练样例。下图为测试结果：</p>
<table>
    <tr>
        <td ><center><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20200528/Naive_Bayes_fig003.jpg"  ></center>  <center>图1 </center></td>
    </tr>
</table>

<p>图1给出了这3三个测试样例的预测结果，其输出的后验概率矩阵就是这3个测试样例属于类别 $0,1,2$ 的后验概率。由于，贝叶斯判别准则为判别为后验概率最大的类，于是可得这3个样例分别判别为类别$0, 2, 2$。图2更加直观地显示了图1的判别结果。其中，填充颜色为我们样例点真正的类别，其中那3个点的轮廓颜色表示的是我们判别的结果，当两种颜色相同时，样例点被正确判别。由图2可知，属于蓝色的那个样例点被错误分类为绿色类别。</p>
<table>
    <tr>
        <td ><center><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20200528/Naive_Bayes_fig001.jpg"  ></center>  <center>图2 </center></td>
    </tr>
</table>

<p>更进一步，我们可以利用上面得到的朴素贝叶斯分类器对所有的可能的样例点 (即，图3中的每一个坐标点)进行分类，由此我们可以得到分类超平面(二维空间中为线条)如下：</p>
<table>
    <tr>
        <td ><center><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20200528/Naive_Bayes_fig002.jpg"  ></center>  <center>图3 </center></td>
    </tr>
</table>


<hr>
<h2 id="附录："><a href="#附录：" class="headerlink" title="附录："></a>附录：</h2><p>所有图片的python源代码如下：</p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        图1-2的python源代码：
    </div>
    <div class='spoiler-content'>
        <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- encoding: utf-8 -*-</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">@File    : Naive_Bayes_fig001.py</span></span><br><span class="line"><span class="string">@Time    : 2020/5/28 11:50</span></span><br><span class="line"><span class="string">@Author  : tengweitw</span></span><br><span class="line"><span class="string">@Email   : tengweitw@foxmail.com</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> datasets</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Set the format of labels</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">LabelFormat</span><span class="params">(plt)</span>:</span></span><br><span class="line">    ax = plt.gca()</span><br><span class="line">    plt.tick_params(labelsize=<span class="number">14</span>)</span><br><span class="line">    labels = ax.get_xticklabels() + ax.get_yticklabels()</span><br><span class="line">    [label.set_fontname(<span class="string">'Times New Roman'</span>) <span class="keyword">for</span> label <span class="keyword">in</span> labels]</span><br><span class="line">    font = &#123;<span class="string">'family'</span>: <span class="string">'Times New Roman'</span>,</span><br><span class="line">            <span class="string">'weight'</span>: <span class="string">'normal'</span>,</span><br><span class="line">            <span class="string">'size'</span>: <span class="number">16</span>,</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="keyword">return</span> font</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Plot the training points:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">PlotTrainPoint</span><span class="params">(train_data, train_target)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(train_target)):</span><br><span class="line">        <span class="keyword">if</span> train_target[i] == <span class="number">0</span>:</span><br><span class="line">            plt.plot(train_data[i][<span class="number">0</span>], train_data[i][<span class="number">1</span>], <span class="string">'rs'</span>, markersize=<span class="number">6</span>, markerfacecolor=<span class="string">"r"</span>)</span><br><span class="line">        <span class="keyword">elif</span> train_target[i] == <span class="number">1</span>:</span><br><span class="line">            plt.plot(train_data[i][<span class="number">0</span>], train_data[i][<span class="number">1</span>], <span class="string">'bo'</span>, markersize=<span class="number">6</span>, markerfacecolor=<span class="string">"b"</span>)</span><br><span class="line">        <span class="keyword">elif</span> train_target[i] == <span class="number">2</span>:</span><br><span class="line">            plt.plot(train_data[i][<span class="number">0</span>], train_data[i][<span class="number">1</span>], <span class="string">'gd'</span>, markersize=<span class="number">6</span>, markerfacecolor=<span class="string">"g"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Plot the testing points and prediction results</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">PlotTestPoint</span><span class="params">(test_data, test_target, y_predict_test)</span>:</span></span><br><span class="line">    <span class="comment"># Plot the testing points</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(test_target)):</span><br><span class="line">        <span class="keyword">if</span> test_target[i] == <span class="number">0</span>:</span><br><span class="line">            plt.plot(test_data[i][<span class="number">0</span>], test_data[i][<span class="number">1</span>], <span class="string">'rs'</span>, markersize=<span class="number">6</span>)</span><br><span class="line">        <span class="keyword">elif</span> test_target[i] == <span class="number">1</span>:</span><br><span class="line">            plt.plot(test_data[i][<span class="number">0</span>], test_data[i][<span class="number">1</span>], <span class="string">'bo'</span>, markersize=<span class="number">6</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            plt.plot(test_data[i][<span class="number">0</span>], test_data[i][<span class="number">1</span>], <span class="string">'gs'</span>, markersize=<span class="number">6</span>)</span><br><span class="line">    <span class="comment"># Plot the prediction results</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(y_predict_test)):</span><br><span class="line">        <span class="keyword">if</span> y_predict_test[i] == <span class="number">0</span>:</span><br><span class="line">            plt.plot(test_data[i][<span class="number">0</span>], test_data[i][<span class="number">1</span>], <span class="string">'rs'</span>, markerfacecolor=<span class="string">'none'</span>, markersize=<span class="number">10</span>)</span><br><span class="line">        <span class="keyword">elif</span> y_predict_test[i] == <span class="number">1</span>:</span><br><span class="line">            plt.plot(test_data[i][<span class="number">0</span>], test_data[i][<span class="number">1</span>], <span class="string">'bs'</span>, markersize=<span class="number">10</span>, markerfacecolor=<span class="string">"none"</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            plt.plot(test_data[i][<span class="number">0</span>], test_data[i][<span class="number">1</span>], <span class="string">'gs'</span>, markersize=<span class="number">10</span>, markerfacecolor=<span class="string">"none"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Compute the conditional probability P(x|y) for the test point x</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Calculate_P_x_y</span><span class="params">(Mean_x, Std_x_square, test_point, M, K)</span>:</span></span><br><span class="line">    P_x_y = np.zeros((M, K))</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>, M):</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">0</span>, K):</span><br><span class="line">            P_x_y[j][k] = <span class="number">1</span> / np.sqrt(<span class="number">2</span> * np.pi * Std_x_square[k][j]) * np.exp(</span><br><span class="line">                -np.square(test_point[j] - Mean_x[k][j]) / <span class="number">2</span> / Std_x_square[k][j])</span><br><span class="line">    <span class="keyword">return</span> P_x_y</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Naive_Bayes_classfier</span><span class="params">(train_data, train_target, test_data, test_target)</span>:</span></span><br><span class="line">    M = np.size(train_data, <span class="number">1</span>)  <span class="comment"># Dimension of features: 2</span></span><br><span class="line">    N = np.size(train_data, <span class="number">0</span>)  <span class="comment"># Number of instances</span></span><br><span class="line">    K = np.size(np.unique(train_target))  <span class="comment"># Number of classes</span></span><br><span class="line"></span><br><span class="line">    cnt = np.zeros((K, M))</span><br><span class="line">    cnt_y = np.zeros((K, <span class="number">1</span>))</span><br><span class="line">    sum_x = np.zeros((K, M))</span><br><span class="line">    x = np.array((K, <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">0</span>, K):  <span class="comment"># for each class</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>, M):  <span class="comment"># for each feature</span></span><br><span class="line">            cnt_y[k] = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, N):  <span class="comment"># for each instance</span></span><br><span class="line">                <span class="keyword">if</span> train_target[i] == k:</span><br><span class="line">                    cnt_y[k] += <span class="number">1</span></span><br><span class="line">                    cnt[k][j] += <span class="number">1</span>  <span class="comment"># The number of feature j in class i</span></span><br><span class="line">                    sum_x[k][j] += train_data[i][j]  <span class="comment"># The sum of x_&#123;kj&#125;</span></span><br><span class="line">    <span class="comment"># Compute the mean of x^j in the training points classified as class k</span></span><br><span class="line">    Mean_x = np.zeros((K, M))</span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">0</span>, K):  <span class="comment"># for each class</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>, M):  <span class="comment"># for each feature</span></span><br><span class="line">            Mean_x[k][j] = sum_x[k][j] / cnt[k][j]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Compute the variances of x^j in the training points classified as class k</span></span><br><span class="line">    Std_x_square = np.zeros((K, M))</span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">0</span>, K):  <span class="comment"># for each class</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>, M):  <span class="comment"># for each feature</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, N):  <span class="comment"># for each instance</span></span><br><span class="line">                <span class="keyword">if</span> train_target[i] == k:</span><br><span class="line">                    Std_x_square[k][j] += np.square(Mean_x[k][j] - train_data[i][j]) / cnt[k][j]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Compute the prior probability P(y)</span></span><br><span class="line">    P_y = np.zeros((K, <span class="number">1</span>))</span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">0</span>, K):</span><br><span class="line">        P_y[k] = cnt_y[k] / sum(cnt_y)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># ------Prediction---------#</span></span><br><span class="line"></span><br><span class="line">    L = len(test_target)  <span class="comment"># number of test_points</span></span><br><span class="line"></span><br><span class="line">    P_y_x = np.ones((K, L)) <span class="comment"># The posteriori probability</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> l <span class="keyword">in</span> range(L):</span><br><span class="line">        temp = Calculate_P_x_y(Mean_x, Std_x_square, test_data[l], M, K)</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> range(K):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(M):</span><br><span class="line">                P_y_x[k][l] = P_y_x[k][l] * temp[j][k]</span><br><span class="line">            P_y_x[k][l] = P_y_x[k][l] * P_y[k]</span><br><span class="line"></span><br><span class="line">    print(<span class="string">"\n The posterior prob. for the instances are:"</span>)</span><br><span class="line">    print(P_y_x)</span><br><span class="line">    y_predict_test = np.argmax(P_y_x, axis=<span class="number">0</span>)  <span class="comment"># find the max according to the column</span></span><br><span class="line">    print(<span class="string">"The instances are classified as"</span>)</span><br><span class="line">    print(y_predict_test)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> y_predict_test</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># import dataset of iris</span></span><br><span class="line">iris = datasets.load_iris()</span><br><span class="line"></span><br><span class="line"><span class="comment"># The first two-dim feature for simplicity</span></span><br><span class="line">data = iris.data[:, :<span class="number">2</span>]</span><br><span class="line"><span class="comment"># The labels</span></span><br><span class="line">label = iris.target</span><br><span class="line"></span><br><span class="line"><span class="comment"># Choose the 25,75,125th instance as testing points</span></span><br><span class="line">test_data = [data[<span class="number">25</span>, :], data[<span class="number">75</span>, :], data[<span class="number">125</span>, :]]</span><br><span class="line">test_target = label[[<span class="number">25</span>, <span class="number">75</span>, <span class="number">125</span>]]</span><br><span class="line"></span><br><span class="line">print(<span class="string">'The testing instances are:'</span>)</span><br><span class="line">print(test_data)</span><br><span class="line">print(<span class="string">"The true classes for each instance are:"</span>)</span><br><span class="line">print(test_target)</span><br><span class="line"></span><br><span class="line">data = np.delete(data, [<span class="number">25</span>, <span class="number">75</span>, <span class="number">125</span>], axis=<span class="number">0</span>)</span><br><span class="line">label = np.delete(label, [<span class="number">25</span>, <span class="number">75</span>, <span class="number">125</span>], axis=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">train_data = data</span><br><span class="line">train_target = label</span><br><span class="line"></span><br><span class="line">y_predict_test = Naive_Bayes_classfier(train_data, train_target, test_data, test_target)</span><br><span class="line"></span><br><span class="line">plt.figure()</span><br><span class="line">PlotTrainPoint(train_data, train_target)</span><br><span class="line">PlotTestPoint(test_data, test_target, y_predict_test)</span><br><span class="line">font = LabelFormat(plt)</span><br><span class="line">plt.xlabel(<span class="string">'$x^&#123;(1)&#125;$'</span>, font)</span><br><span class="line">plt.ylabel(<span class="string">'$x^&#123;(2)&#125;$'</span>, font)</span><br><span class="line">plt.xlim(<span class="number">4</span>,<span class="number">8</span>)</span><br><span class="line">plt.ylim(<span class="number">1.8</span>,<span class="number">4.5</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>



    </div>
</div>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        图3的python源代码：
    </div>
    <div class='spoiler-content'>
        <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- encoding: utf-8 -*-</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">@File    : Naive_Bayes_fig002.py</span></span><br><span class="line"><span class="string">@Time    : 2020/5/28 17:18</span></span><br><span class="line"><span class="string">@Author  : tengweitw</span></span><br><span class="line"><span class="string">@Email   : tengweitw@foxmail.com</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> matplotlib.colors <span class="keyword">import</span> ListedColormap</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> datasets</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Set the format of labels</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">LabelFormat</span><span class="params">(plt)</span>:</span></span><br><span class="line">    ax = plt.gca()</span><br><span class="line">    plt.tick_params(labelsize=<span class="number">14</span>)</span><br><span class="line">    labels = ax.get_xticklabels() + ax.get_yticklabels()</span><br><span class="line">    [label.set_fontname(<span class="string">'Times New Roman'</span>) <span class="keyword">for</span> label <span class="keyword">in</span> labels]</span><br><span class="line">    font = &#123;<span class="string">'family'</span>: <span class="string">'Times New Roman'</span>,</span><br><span class="line">            <span class="string">'weight'</span>: <span class="string">'normal'</span>,</span><br><span class="line">            <span class="string">'size'</span>: <span class="number">16</span>,</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="keyword">return</span> font</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Plot the training points:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">PlotTrainPoint</span><span class="params">(train_data, train_target)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(train_target)):</span><br><span class="line">        <span class="keyword">if</span> train_target[i] == <span class="number">0</span>:</span><br><span class="line">            plt.plot(train_data[i][<span class="number">0</span>], train_data[i][<span class="number">1</span>], <span class="string">'rs'</span>, markersize=<span class="number">6</span>, markerfacecolor=<span class="string">"r"</span>)</span><br><span class="line">        <span class="keyword">elif</span> train_target[i] == <span class="number">1</span>:</span><br><span class="line">            plt.plot(train_data[i][<span class="number">0</span>], train_data[i][<span class="number">1</span>], <span class="string">'bo'</span>, markersize=<span class="number">6</span>, markerfacecolor=<span class="string">"b"</span>)</span><br><span class="line">        <span class="keyword">elif</span> train_target[i] == <span class="number">2</span>:</span><br><span class="line">            plt.plot(train_data[i][<span class="number">0</span>], train_data[i][<span class="number">1</span>], <span class="string">'gd'</span>, markersize=<span class="number">6</span>, markerfacecolor=<span class="string">"g"</span>)</span><br><span class="line"></span><br><span class="line">cmap_light = ListedColormap([<span class="string">'tomato'</span>, <span class="string">'limegreen'</span>, <span class="string">'cornflowerblue'</span>])</span><br><span class="line"><span class="comment"># Plot the contour of classes</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">PlotTestPoint</span><span class="params">(test_data, test_target, y_predict_test)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(y_predict_test)):</span><br><span class="line">        <span class="keyword">if</span> y_predict_test[i] == <span class="number">0</span>:</span><br><span class="line">            plt.plot(test_data[i][<span class="number">0</span>], test_data[i][<span class="number">1</span>], color=<span class="string">'cornflowerblue'</span>,marker=<span class="string">"s"</span>, markersize=<span class="number">6</span>)</span><br><span class="line">        <span class="keyword">elif</span> y_predict_test[i] == <span class="number">1</span>:</span><br><span class="line">            plt.plot(test_data[i][<span class="number">0</span>], test_data[i][<span class="number">1</span>], color=<span class="string">'limegreen'</span>, marker=<span class="string">"s"</span>,markersize=<span class="number">6</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            plt.plot(test_data[i][<span class="number">0</span>], test_data[i][<span class="number">1</span>], color=<span class="string">'tomato'</span>,marker=<span class="string">"s"</span>, markersize=<span class="number">6</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Compute the conditional probability P(x|y) for the test point x</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Calculate_P_x_y</span><span class="params">(Mean_x, Std_x_square, test_point, M, K)</span>:</span></span><br><span class="line">    P_x_y = np.zeros((M, K))</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>, M):</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">0</span>, K):</span><br><span class="line">            P_x_y[j][k] = <span class="number">1</span> / np.sqrt(<span class="number">2</span> * np.pi * Std_x_square[k][j]) * np.exp(</span><br><span class="line">                -np.square(test_point[j] - Mean_x[k][j]) / <span class="number">2</span> / Std_x_square[k][j])</span><br><span class="line">    <span class="keyword">return</span> P_x_y</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Naive_Bayes_classfier</span><span class="params">(train_data, train_target, test_data, test_target)</span>:</span></span><br><span class="line">    M = np.size(train_data, <span class="number">1</span>)  <span class="comment"># Dimension of features: 2</span></span><br><span class="line">    N = np.size(train_data, <span class="number">0</span>)  <span class="comment"># Number of instances</span></span><br><span class="line">    K = np.size(np.unique(train_target))  <span class="comment"># Number of classes</span></span><br><span class="line"></span><br><span class="line">    cnt = np.zeros((K, M))</span><br><span class="line">    cnt_y = np.zeros((K, <span class="number">1</span>))</span><br><span class="line">    sum_x = np.zeros((K, M))</span><br><span class="line">    x = np.array((K, <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">0</span>, K):  <span class="comment"># for each class</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>, M):  <span class="comment"># for each feature</span></span><br><span class="line">            cnt_y[k] = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, N):  <span class="comment"># for each instance</span></span><br><span class="line">                <span class="keyword">if</span> train_target[i] == k:</span><br><span class="line">                    cnt_y[k] += <span class="number">1</span></span><br><span class="line">                    cnt[k][j] += <span class="number">1</span>  <span class="comment"># The number of feature j in class i</span></span><br><span class="line">                    sum_x[k][j] += train_data[i][j]  <span class="comment"># The sum of x_&#123;kj&#125;</span></span><br><span class="line">    <span class="comment"># Compute the mean of x^j in the training points classified as class k</span></span><br><span class="line">    Mean_x = np.zeros((K, M))</span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">0</span>, K):  <span class="comment"># for each class</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>, M):  <span class="comment"># for each feature</span></span><br><span class="line">            Mean_x[k][j] = sum_x[k][j] / cnt[k][j]</span><br><span class="line">    <span class="comment"># Compute the variances of x^j in the training points classified as class k</span></span><br><span class="line">    Std_x_square = np.zeros((K, M))</span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">0</span>, K):  <span class="comment"># for each class</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>, M):  <span class="comment"># for each feature</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, N):  <span class="comment"># for each instance</span></span><br><span class="line">                <span class="keyword">if</span> train_target[i] == k:</span><br><span class="line">                    Std_x_square[k][j] += np.square(Mean_x[k][j] - train_data[i][j]) / cnt[k][j]</span><br><span class="line">    <span class="comment"># Compute the prior probability P(y)</span></span><br><span class="line">    P_y = np.zeros((K, <span class="number">1</span>))</span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">0</span>, K):</span><br><span class="line">        P_y[k] = cnt_y[k] / sum(cnt_y)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># ------Prediction---------#</span></span><br><span class="line"></span><br><span class="line">    L = len(test_target)  <span class="comment"># number of test_points</span></span><br><span class="line">    P_y_x = np.ones((K, L)) <span class="comment"># The posteriori probability</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> l <span class="keyword">in</span> range(L):</span><br><span class="line">        temp = Calculate_P_x_y(Mean_x, Std_x_square, test_data[l], M, K)</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> range(K):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(M):</span><br><span class="line">                P_y_x[k][l] = P_y_x[k][l] * temp[j][k]</span><br><span class="line">            P_y_x[k][l] = P_y_x[k][l] * P_y[k]</span><br><span class="line">    print(<span class="string">"\n The posterior prob. for the instances are:"</span>)</span><br><span class="line">    print(P_y_x)</span><br><span class="line">    y_predict_test = np.argmax(P_y_x, axis=<span class="number">0</span>)  <span class="comment"># find the max according to the column</span></span><br><span class="line">    print(<span class="string">"The instances are classified as"</span>)</span><br><span class="line">    print(y_predict_test)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> y_predict_test</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># import dataset of iris</span></span><br><span class="line">iris = datasets.load_iris()</span><br><span class="line"></span><br><span class="line"><span class="comment"># The first two-dim feature for simplicity</span></span><br><span class="line">data = iris.data[:, :<span class="number">2</span>]</span><br><span class="line"><span class="comment"># The labels</span></span><br><span class="line">label = iris.target</span><br><span class="line"></span><br><span class="line"><span class="comment"># Delete the three instances to keep the same with fig 1-2</span></span><br><span class="line"><span class="comment"># You can also remove the following two sentences</span></span><br><span class="line">data = np.delete(data, [<span class="number">25</span>, <span class="number">75</span>, <span class="number">125</span>], axis=<span class="number">0</span>)</span><br><span class="line">label = np.delete(label, [<span class="number">25</span>, <span class="number">75</span>, <span class="number">125</span>], axis=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">train_data = data</span><br><span class="line">train_target = label</span><br><span class="line"></span><br><span class="line"><span class="comment"># Here use all the points in the considered area as testing points</span></span><br><span class="line">test_data1=[]</span><br><span class="line">test_target1=[]</span><br><span class="line">x=np.linspace(<span class="number">4</span>,<span class="number">8</span>,<span class="number">100</span>)</span><br><span class="line">y=np.linspace(<span class="number">1.8</span>,<span class="number">4.5</span>,<span class="number">100</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> x:</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> y:</span><br><span class="line">        test_data1.append([i,j])</span><br><span class="line">        test_target1.append([<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">y_predict_test = Naive_Bayes_classfier(train_data, train_target, test_data1, test_target1)</span><br><span class="line"></span><br><span class="line">plt.figure()</span><br><span class="line"></span><br><span class="line">PlotTestPoint(test_data1, test_target1, y_predict_test)</span><br><span class="line">PlotTrainPoint(train_data, train_target)</span><br><span class="line">font = LabelFormat(plt)</span><br><span class="line">plt.xlabel(<span class="string">'$x^&#123;(1)&#125;$'</span>, font)</span><br><span class="line">plt.ylabel(<span class="string">'$x^&#123;(2)&#125;$'</span>, font)</span><br><span class="line">plt.xlim(<span class="number">4</span>,<span class="number">8</span>)</span><br><span class="line">plt.ylim(<span class="number">1.8</span>,<span class="number">4.5</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

    </div>
</div>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>Machine Learning</tag>
      </tags>
  </entry>
  <entry>
    <title>【图解例说机器学习】支持向量机 (SVM)</title>
    <url>/2020/05/12/%5B20200512%5D/</url>
    <content><![CDATA[<p>支持向量机(Support Vector Machine, SVM)，是一种常见的有监督的学习模型，通常用来进行模式识别、分类以及回归分析。本文主要介绍SVM在二分类问题的应用。</p>
<hr>
<a id="more"></a>
<h2 id="线性可分支持向量机"><a href="#线性可分支持向量机" class="headerlink" title="线性可分支持向量机"></a>线性可分支持向量机</h2><p>我们还是以【图解例说机器学习】感知机的二分类例子 (Toy Example) 说起。如图1，假设有一个线性可分的训练集，其中有三个样例 ($\mathrm x_1,\mathrm x_2, \mathrm x_3$)，分别标记为正例(红色方块)，反例(蓝色圆圈)。这里的 $x^{(1)},x^{(2)}$为训练样例的$2$个特征。</p>
<table>
    <tr>
        <td ><center><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20200505/Perceptron_fig001.jpg"  ></center>  <center>图1 </center></td>
    </tr>
</table>

<p>感知机的目的就是找到一个超平面 (在二维空间为一条直线) 能够将这三个样例分开。显然，这样的直线有无数条，比如图中的直线 $f(\mathrm x)=x^{(1)}+x^{(2)}-4=0, f(\mathrm x)=2x^{(1)}+x^{(2)}-5=0$ 就是可能得到其中的两条。</p>
<p>感知机的结果，即分类超平面，与参数的初始值有关，也和在每次迭代时选取的误分类样例有关。在上面例子中，得到的两个分类超平面中，直觉上，直线$x^{(1)}+x^{(2)}-4=0$的分类效果要好于$2x^{(1)}+x^{(2)}-5=0$的分类效果好。这是因为，直线$x^{(1)}+x^{(2)}-4=0$位于正负样例的中间位置，其对训练样例的扰动具有较好的鲁棒性。由于训练集的局限性或者噪声，训练集外的样例可能比较接近分类超平面，此时直线$2x^{(1)}+x^{(2)}-5=0$就会使得这些样例错误分类，即泛化能力较差。</p>
<p>为了克服感知机的上述问题，SVM的目的就是找到最佳的分类超平面，而不是仅仅对训练集的样例正确分类，也考虑如何对未见样例具备较强的泛化能力。</p>
<hr>
<h2 id="SVM-分类模型"><a href="#SVM-分类模型" class="headerlink" title="SVM 分类模型"></a>SVM 分类模型</h2><h4 id="间隔"><a href="#间隔" class="headerlink" title="间隔"></a>间隔</h4><p>在中学时，我们学过一个点$x$到一条直线$ax+by+c=0$的距离可以为$\lvert ax+by+c\rvert/\sqrt{a^2+b^2}$。类似地，空间中一点$\mathrm x$ 到一个超平面$\omega_0+\mathrm w^{\mathrm T}\mathrm x=0$的距离为：</p>
<script type="math/tex; mode=display">
d=\frac{\lvert\omega_0+\mathrm w^{\mathrm T}\mathrm x\rvert}{\lvert\mathrm w\rvert}\tag{1}</script><p>关于公式(1)的直观表示如下图2所示：</p>
<table>
    <tr>
        <td ><center><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20200512/SVM_fig002.jpg"  ></center>  <center>图2 </center></td>
    </tr>
</table>

<p>在图2中，$\frac{\mathrm w}{\lvert\mathrm w\rvert}$ 是直线$x^{(1)}+x^{(2)}-3=0$的单位法向量，$\mathrm x_1^\perp, \mathrm x_2^\perp$ 分别为$\mathrm x_1, \mathrm x_2$ 在该直线的投影。此时空间中的任意一点$\mathrm x$可以由其到该直线的投影$\mathrm x^\perp$ 和单位法向量表示：</p>
<script type="math/tex; mode=display">
\mathrm x=\mathrm x^\perp+d\frac{\mathrm w}{\lvert\mathrm w\rvert}\tag{2}</script><p>对于公式(2)，我们将其乘以$\mathrm w$ 加上$\omega_0$ 后有：</p>
<script type="math/tex; mode=display">
\mathrm w^{\mathrm T}\mathrm x+\omega_0=\mathrm w^{\mathrm T}\mathrm x^\perp+d\frac{\mathrm w}{\lvert\mathrm w\rvert}+\omega_0\tag{3}</script><p>由于$\mathrm x^{\mathrm T}$ 是直线$\omega_0+\mathrm w^{\mathrm T}\mathrm x=0$ 上的点，由公式(3)可得：</p>
<script type="math/tex; mode=display">
d=\frac{\mathrm w^{\mathrm T}\mathrm x+\omega_0}{\lvert\mathrm w\rvert}\tag{4}</script><p>结合图2和公式(2)和(3)，我们可以表示$\mathrm x_1,\mathrm x_2$如下：</p>
<script type="math/tex; mode=display">
\mathrm x_1=\mathrm x_1^\perp+\frac{\sqrt{2}}{2}\frac{\mathrm w}{\lvert\mathrm w\rvert}\tag{5}</script><script type="math/tex; mode=display">
\mathrm x_2=\mathrm x_2^\perp-\frac{\sqrt{2}}{4}\frac{\mathrm w}{\lvert\mathrm w\rvert}\tag{6}</script><p>公式(5)和(6)表明：当$\mathrm x$为正例 (例如 $\mathrm x_1$) 时，$d$为正数；当$\mathrm x$为反例 (例如 $\mathrm x_2$) 时，$d$为负数。也就是说，公式(4)中的距离$d$是有方向的。具体来说，对于例子中的样例$\mathrm x_1$，是正例，即$y=+1$ ，其到直线 $\omega_0+\mathrm w^{\mathrm T}\mathrm x=0$ 的距离为$d=\frac{\mathrm w^{\mathrm T}\mathrm x_1+\omega_0}{\lvert\mathrm w\rvert}&gt;0$; 对于例子中的样例$\mathrm x_2$，是反例，即$y=-1$ ，其到直线$\omega_0+\mathrm w^{\mathrm T}\mathrm x=0$的距离为$d=\frac{\mathrm w^{\mathrm T}\mathrm x_2+\omega_0}{\lvert\mathrm w\rvert}&lt;0$.为此，对于任意样例$\mathrm x$ (无论正例还是反例)，其距离分类超平面的无方向距离(始终大于0)为：</p>
<script type="math/tex; mode=display">
\lvert d\rvert=\frac{\omega_0+\mathrm w^{\mathrm T}\mathrm x}{\lvert\mathrm w\rvert} y\tag{7}</script><p>注意：公式(7)是公式(6)在考虑样例分类情况下，将有方向的距离$d$化为无方向距离$\lvert d\rvert$的具体表达式。</p>
<hr>
<h4 id="优化问题"><a href="#优化问题" class="headerlink" title="优化问题"></a>优化问题</h4><p>SVM的中心思想就是找出离分类超平面最近的点(又称支持向量)，然后最大化这些点与分类超平面的距离。对于一个$M$维特征空间，超平面的表达式为：</p>
<script type="math/tex; mode=display">
\hat y=\omega_0+\omega_1x^{(1)}+\cdots+\omega_Mx^{(M)}=\omega_0+\mathrm w^{\mathrm T}\mathrm x\tag{8}</script><p>为此，我们可以得到如下的优化问题:</p>
<script type="math/tex; mode=display">
\max\limits_{\omega_0,\mathrm w}\min\limits_{i}\quad\frac{\omega_0+\mathrm w^{\mathrm T}\mathrm x_i}{\lvert\mathrm w\rvert} y_i\tag{9}</script><p>直接求解问题(9)比较复杂。这里我们发现，对于一个分类超平面 (例如，上面例子中的直线$\hat y=\omega_0+\mathrm w^{\mathrm T}\mathrm x=0$ )，同时对$\omega_0,\mathrm w$进行缩放并不改变该分类超平面，也就不改变任意点到该分类超平面的距离。为此我们可以将$\omega_0,\mathrm w$进行缩放，使得离分类超平面最近的点 (支持向量)满足$(\omega_0+\mathrm w^{\mathrm T}\mathrm x)y=1$。那么此时，训练集中所有其他样例点肯定满足$(\omega_0+\mathrm w^{\mathrm T}\mathrm x)y&gt;1$。这时，优化问题(9)可以转化为SVM优化问题的标准形式：</p>
<script type="math/tex; mode=display">
\begin{aligned}
&\min\limits_{\omega_0,\mathrm w}\quad\frac{1}{2}\lvert\mathrm w\rvert^2\\
&s.t.\quad  (\omega_0+\mathrm w^{\mathrm T}\mathrm x_i)y_i\ge1\quad\forall i=1,2,\cdots,N
\end{aligned}\tag{10}</script><p>注意：问题(9)转为标准形式(10)的主要步骤：1)令支持向量对应的$(\omega_0+\mathrm w^{\mathrm T}\mathrm x)y=1$，从而去掉最小化，并将问题(9)中的分子加入到约束中；2)最小化$\frac{1}{\lvert\mathrm w\rvert}$等效于最大化$\frac{1}{2}{\lvert\mathrm w\rvert^2}$。</p>
<p>从标准化的优化问题可以看出，该问题是凸二次优化问题，可以使用一些已有的工具箱求解，如CVX, Gurobi, CPLEX等。</p>
<hr>
<h4 id="基于CVX的问题求解"><a href="#基于CVX的问题求解" class="headerlink" title="基于CVX的问题求解"></a>基于CVX的问题求解</h4><p>我们还是以本文开始的小例子 (Toy Example) 为例。此时，我们得到的分类超平面应该是一条直线，形式为$\omega_0+\omega_1x^{(1)}+\omega_2x^{(2)}=0$。根据SVM的标准凸优化形式(10)，我们有</p>
<script type="math/tex; mode=display">
\begin{aligned}
&\min\limits_{\omega_0,\omega_1,\omega_2}\quad&&\frac{1}{2}(\omega_1^2+\omega_2^2)\\
&s.t.\quad&&(\omega_0+\omega_1x_1^{(1)}+\omega_2x_1^{(2)})y_1\ge1\\
&\quad&&(\omega_0+\omega_1x_2^{(1)}+\omega_2x_2^{(2)})y_2\ge1\\
&\quad&&(\omega_0+\omega_1x_3^{(1)}+\omega_2x_3^{(2)})y_3\ge1\\
\end{aligned}\tag{11}</script><p>求解该问题，我们可以得到其最优解为$\omega_0=2,\omega_1=\omega_2=\frac{1}{2}$。此时的分离超平面为直线$\frac{1}{2}x^{(1)}+\frac{1}{2}x^{(2)}-2=0$。此时的决定该直线的支持向量为使得$\frac{1}{2}x^{(1)}+\frac{1}{2}x^{(2)}-2=1,-1$的样例点$\mathrm x_1(3,3)$和$\mathrm x_3(1,1)$。下图3具象地表达了这一结果：</p>
<table>
    <tr>
        <td ><center><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20200512/SVM_fig003.jpg"  ></center>  <center>图3 </center></td>
    </tr>
</table>


<hr>
<p>关于CVX算法实现部分，由于这台电脑没有装MATLAB，此部分回学校后再写</p>
<hr>
<p>至此，最基本的SVM算法已经讲完了。由于上述SVM存在一些难点，下面我们对其进行扩展：</p>
<ul>
<li>SVM标准形式的凸优化问题不易求解，往往我们可以通过其对偶问题求解</li>
<li>当训练集的样例线性不可分，而通过投影到高维空间后线性可分时，我们可以在对偶问题中使用核函数</li>
<li>当训练集及其高维映射都不可分时，我们可以考虑容许部分样例分类错误</li>
</ul>
<hr>
<h2 id="对偶问题"><a href="#对偶问题" class="headerlink" title="对偶问题"></a>对偶问题</h2><p>为例求解上述标准形式的凸二次优化问题(10)，我们除了使用工具箱直接求解外，还可以通过其对偶问题求解。一般来说，相对于求解原始问题，求解其对偶问题一般有以下好处：1）即使原始问题不是凸的，对偶函数仍是关于对偶变量的凸函数；2）具有更好的解释性，适用于分布式算法。对于SVM问题，我们发现求解其对偶问题的过程中可以使用核函数 (下一节提及)，可以使用一些启发式算法 (后文提及的SMO) 来加速算法。</p>
<p>对约束引入拉格朗日乘子$\lambda={\lambda_i\ge 0\mid i=1,2,\cdots,N}$，我们得到如下的拉格朗日函数：</p>
<script type="math/tex; mode=display">
L(\lambda,\omega_0,\mathrm w)=\frac{1}{2}\lvert\mathrm w\rvert^2+\sum\limits_{i=1}^{N}\lambda_i[1-(\omega_0+\mathrm w^{\mathrm T}\mathrm x_i)y_i]\tag{12}</script><p>此时对应的对偶问题为：</p>
<script type="math/tex; mode=display">
\max\limits_{\lambda}\min\limits_{\omega_0,\mathrm w}\quad L(\lambda,\omega_0,\mathrm w)\tag{13}</script><p>由于原始问题(10)为凸问题，那么对偶问题与原始问题的解的gap为0. 通过求解对偶问题，我们就能得到原始问题的最优解。</p>
<hr>
<p>求解上述对偶问题 (极大极小问题) 的一般思路为，先固定$\lambda$ ，求解 $\min\nolimits<em>{\omega_0,\mathrm w}\quad L(\omega_0,\mathrm w\mid \lambda)$得到$\omega_0,\mathrm w$，然后一般通过梯度(或次梯度)更新$\lambda$。幸运地是，在求解 $\min\nolimits</em>{\omega<em>0,\mathrm w}\quad L(\omega_0,\mathrm w\mid \lambda)$ 时，我们可以得到其解析解 $\omega_0^\star,\mathrm w^\star$，所以我们不需要迭代，只需要直接求解$\max\nolimits</em>{\lambda}\quad L(\lambda\mid \omega_0^\star,\mathrm w^\star)$。具体步骤如下：</p>
<ul>
<li><p>求解$\min\nolimits_{\omega_0,\mathrm w}\quad L(\omega_0,\mathrm w\mid \lambda)$<br>由于该问题为凸二次规划问题，其最优解为一阶微分为0的点，即：</p>
<script type="math/tex; mode=display">
\frac{\partial L(\omega_0,\mathrm w\mid\lambda)}{\partial\omega_j}=\omega_j-\sum\limits_{i=1}^{N}\lambda_iy_ix_i^{(j)}=0\rightarrow\omega_j^\star=\sum\limits_{i=1}^{N}\lambda_iy_ix_i^{(j)}\tag{14}</script><script type="math/tex; mode=display">
\frac{\partial L(\omega_0,\mathrm w\mid\lambda)}{\partial\omega_0}=-\sum\limits_{i=1}^{N}\lambda_iy_i=0\tag{15}</script><p>将公式(14)和(15)带入公式(10)，我们有：</p>
<script type="math/tex; mode=display">
\begin{aligned}
L(\lambda\mid\omega_0^\star,\mathrm w^\star)&=\frac{1}{2}\lvert\mathrm w\rvert^2+\sum\limits_{i=1}^{N}\lambda_i[1-(\omega_0+\mathrm w^{\mathrm T}\mathrm x_i)y_i]\\
&=\frac{1}{2}\sum\limits_{j=1}^{M}\omega_j^2+\sum\limits_{i=1}^{N}\lambda_i-\sum\limits_{i=1}^{N}\lambda_iy_i(\omega_0+\sum\limits_{j=1}^{M}\omega_jx_i^{(j)})\\
&=\frac{1}{2}\sum\limits_{j=1}^{M}\omega_j^2-\omega_0\sum\limits_{i=1}^{N}\lambda_iy_i-\sum\limits_{i=1}^{N}\lambda_iy_i\sum\limits_{j=1}^{M}\omega_jx_i^{(j)}+\sum\limits_{i=1}^{N}\lambda_i\\
&=\frac{1}{2}\sum\limits_{j=1}^{M}\omega_j^2-\sum\limits_{i=1}^{N}\lambda_iy_i\sum\limits_{j=1}^{M}\omega_jx_i^{(j)}+\sum\limits_{i=1}^{N}\lambda_i\\
&=\frac{1}{2}\sum\limits_{j=1}^{M}(\sum\limits_{i=1}^{N}\lambda_iy_ix_i^{(j)}\sum\limits_{i^\prime=1}^{N}\lambda_{i^\prime}y_{i^\prime}x_{i^\prime}^{(j)})-\sum\limits_{i=1}^{N}\lambda_iy_i\sum\limits_{j=1}^{M}(\sum\limits_{i^\prime=1}^{N}\lambda_{i^\prime}y_{i^\prime}x_{i^\prime}^{(j)})x_i^{(j)}+\sum\limits_{i=1}^{N}\lambda_i\\
&=-\frac{1}{2}\sum\limits_{j=1}^{M}\sum\limits_{i=1}^{N}\sum\limits_{i^\prime=1}^{N}\lambda_i\lambda_{i^\prime}y_iy_{i^\prime}x_i^{(j)}x_{i^\prime}^{(j)}+\sum\limits_{i=1}^{N}\lambda_i
\end{aligned}\tag{16}</script></li>
<li><p>求解$\max\nolimits_{\lambda}\quad L(\lambda\mid \omega_0^\star,\mathrm w^\star)$<br>在求得参数$\mathrm w^\star$后，我们需要求解如下问题：</p>
<script type="math/tex; mode=display">
\begin{aligned}
&\max\limits_{\lambda}\quad L(\lambda\mid\omega_0^\star,\mathrm w^\star)\\
&s.t.\quad  \sum\limits_{i=1}^{N}\lambda_iy_i=0,\lambda_i\ge=0,i=1,2,\cdots,N
\end{aligned}\tag{17}</script><p>由公式(14)和(16)可以等效成如下问题：</p>
</li>
</ul>
<script type="math/tex; mode=display">
\begin{aligned}
&\min\limits_{\lambda}\quad \frac{1}{2}\sum\limits_{j=1}^{M}\sum\limits_{i=1}^{N}\sum\limits_{i^\prime=1}^{N}\lambda_i\lambda_{i^\prime}y_iy_{i^\prime}x_i^{(j)}x_{i^\prime}^{(j)}-\sum\limits_{i=1}^{N}\lambda_i\\
&s.t.\quad  \sum\limits_{i=1}^{N}\lambda_iy_i=0,\lambda_i\ge=0,i=1,2,\cdots,N
\end{aligned}\tag{18}</script><p>将问题(18)向量化可得:</p>
<script type="math/tex; mode=display">
\begin{aligned}
&\min\limits_{\lambda}\quad \frac{1}{2}\sum\limits_{i=1}^{N}\sum\limits_{i^\prime=1}^{N}\lambda_i\lambda_{i^\prime}y_iy_{i^\prime}\mathrm x_i^{\mathrm T}\mathrm x_{i^\prime}-\sum\limits_{i=1}^{N}\lambda_i\\
&s.t.\quad  \sum\limits_{i=1}^{N}\lambda_iy_i=0,\lambda_i\ge=0,i=1,2,\cdots,N
\end{aligned}\tag{19}</script><hr>
<p>最终，我们需要求解问题(19)，当然由于问题(19)也是一个凸二次函数，我们同样可以利用工具箱求解，在此省略。求解问题(19)得到最优的$\lambda$后，我们将(14)带入超平面的表达式(8)中得到:</p>
<script type="math/tex; mode=display">
\hat y=\omega_0+\mathrm w^{\mathrm T}\mathrm x=\omega_0+\sum\limits_{j=1}^{M}\omega_jx^{(j)}=\omega_0+\sum\limits_{j=1}^{M}\sum\limits_{i=1}^{N}\lambda_iy_ix_i^{(j)}x^{(j)}=\omega_0+\sum\limits_{i=1}^{N}\lambda_iy_i\sum\limits_{j=1}^{M}x_i^{(j)}x^{(j)}\tag{20}</script><p>当对一个新的测试样例$\mathrm x$ 进行分类时，可以由上式可以判断：当$\hat y\ge1$ 时，判断为正例；当 $\hat y\le -1$ 时， 判断为反例。当然，上述问题在于$\omega_0$ 的值还无法得知。为此，我们可利用KKT条件(这里不具体描述，有需要会后续单独介绍)可得：</p>
<script type="math/tex; mode=display">
原问题的约束条件：(\omega_0+\mathrm w^{\mathrm T}\mathrm x_i)y_i\ge1\quad\forall i=1,2,\cdots,N\tag{21}</script><script type="math/tex; mode=display">
对偶问题的约束条件：\lambda_i\ge=0, \forall i=1,2,\cdots,N\tag{22}</script><script type="math/tex; mode=display">
互补松弛条件：\lambda_i[y_i(\omega_0+\mathrm w^{\mathrm T}\mathrm x_i)-1]= 0\quad\forall i=1,2,\cdots,N\tag{23}</script><p>由互补松弛条件(23)可知，要么$\lambda_i=0$，要么 $y_i(\omega_0+\mathrm w^{\mathrm T}\mathrm x_i)-1$。从分类超平面的表达式(20)可知，只有当$\lambda_i&gt;0$时，才对分类结果$\hat y$ 有影响，此时的样例点$\mathrm x_i$ 才对决定了分类超平面的表达式，这样的样例点就是我们所说的支持向量。当$\lambda_i&gt;0$时， 由(23)知$y_i(\omega_0+\mathrm w^{\mathrm T}\mathrm x_i)-1=0$，也就是对应了图3所示的支持向量所在的超平面。那么这时，由$y_i(\omega_0+\mathrm w^{\mathrm T}\mathrm x_i)-1=0$ 我们就有</p>
<script type="math/tex; mode=display">
\omega_0=\frac{1}{y_i}-\mathrm w^{\mathrm T}\mathrm x_i\tag{24}</script><hr>
<p>下面我们同样通过上述的小例子来验证对偶算法的可行性：</p>
<p>根据对偶问题的形式(18)或(19)，小例子对应的对偶问题可以写成：</p>
<script type="math/tex; mode=display">
\begin{aligned}
&\min\limits_{\lambda_1,\lambda_2,\lambda_3}&&\quad L(\lambda_1,\lambda_2,\lambda_3)=\frac{1}{2}\sum\limits_{j=1}^{2}\sum\limits_{i=1}^{3}\sum\limits_{i^\prime=1}^{3}\lambda_i\lambda_{i^\prime}y_iy_{i^\prime}x_i^{(j)}x_{i^\prime}^{(j)}-\sum\limits_{i=1}^{3}\lambda_i\\
&&&\quad=\frac{1}{2}(18\lambda_1^2+25\lambda_2^2+2\lambda_3^2+42\lambda_1\lambda_2-12\lambda_1\lambda_3-14\lambda_2\lambda_3)-\lambda_1-\lambda_2-\lambda_3\\
&s.t.&&\quad  \lambda_1+\lambda_2-\lambda_3=0,\lambda_1,\lambda_2,\lambda_3\ge0.
\end{aligned}\tag{25}</script><p>为了求解问题(25)，我们替换变量$\lambda_3=\lambda_1+\lambda_2$可得</p>
<script type="math/tex; mode=display">
L(\lambda_1,\lambda_2)=4\lambda_1^2+\frac{13}{2}\lambda_2^2+10\lambda_1\lambda_2-2\lambda_1-2\lambda_2\tag{26}</script><p>令$L(\lambda_1,\lambda_2)$ 对于$\lambda_1,\lambda_2$ 的偏导为0，可知最优的解为$\lambda_1^\star=\frac{3}{2},\lambda_2^\star=-1$，不满足$\lambda_2\ge 0$。为此，最优解在边界处取得。若$\lambda_1^\star=0$，此时$\lambda_2^\star=\frac{2}{13}$，最优值为$L(\lambda_1^\star,\lambda_2^\star)=-\frac{2}{13}$。若$\lambda_2^\star=0$，此时$\lambda_1^\star=\frac{1}{4}$，最优值为$L(\lambda_1^\star,\lambda_2^\star)=-\frac{1}{4}$。所以，最终得到的最优解为$\lambda_1^\star=\frac{1}{4},\lambda_2^\star=0,\lambda_3^\star=\frac{1}{4}$。</p>
<p>在得到最优解$\lambda^\star={\lambda_1^\star,\lambda_2^\star,\lambda_3^\star}$后，我们可以根据等式(14)求得$\omega_1=\omega_2=\frac{1}{2}$。又由于$\mathrm x_1,\mathrm x_3$为支持向量，由公式(25)我们有：</p>
<script type="math/tex; mode=display">
(\omega_0+\omega_1x_1^{(1)}+\omega_2x_1^{(2)})y_1=1\tag{27}</script><script type="math/tex; mode=display">
(\omega_0+\omega_1x_2^{(1)}+\omega_2x_2^{(2)})y_2=1\tag{28}</script><p>由(27)或者(28)我们可以得到$\omega_0^\star=-2$。那么我们求得的最优分类超平面为直线$\frac{1}{2}x^{(1)}+\frac{1}{2}x^{(2)}-2=1$。</p>
<hr>
<p>我们发现，最后需要求解的对偶问题为(19)，也是一个凸二次优化问题。一般来说，二次优化问题的算法复杂度为$\mathcal O(K)$，其中$K$为变量的个数。在原始问题(10)中，变量为$\omega_0,\mathrm w$，个数为$M+1$；在对偶问题(19)中，变量为$\lambda$，个数为$N$。注意：这里的$M,N$分别为特征维数和样例个数。一般情况下，样例数大于特征维数，即($N&gt;M$)，此时好像更应该直接求解原始问题来降低复杂度。但是由于对偶问题的特性比较适合核函数的使用，我们更倾向于求解对偶问题。</p>
<hr>
<h2 id="核函数"><a href="#核函数" class="headerlink" title="核函数"></a>核函数</h2><p>在上述模型中，我们假设训练集是线性可分的。但一般情况下，原始的特征空间是线性不可分的，如下面的两个例子：</p>
<ul>
<li><p>异或问题：假设我们考虑2个特征$x^{(1)},x^{(2)}$，训练集中有两个正例 $\mathrm x_1 (0,1), \mathrm x_2 (1,0)$ 和两个反例 $\mathrm x_3 (0,0), \mathrm x_4 (1,1)$，如图4所示。显然，我们无法在该二维空间中找到一条直线将训练集正确分类。如果我们将这两个特征$x^{(1)},x^{(2)}$映射到三维空间的三个特征$z^{(1)},z^{(2)},z^{(3)}$, 且映射关系为: $z^{(1)}=x^{(1)}x^{(2)}, z^{(2)}=x^{(1)}, z^{(3)}=x^{(2)}$。那么此时训练样例坐标为：$\mathrm x_1 (0,0,1), \mathrm x_2 (0,1,0), \mathrm x_3 (0,0,0), \mathrm x_4 (1,1,1)$，如图5所示。显然，我们可以找到一个分类超平面将该训练集正确分类。</p>
<table>
    <tr>
        <td ><center><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20200512/SVM_fig004.jpg"  >图4</center></td>
        <td ><center><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20200512/SVM_fig005.jpg"  >图5</center></td>
    </tr>
</table>


</li>
</ul>
<ul>
<li><p>圆环问题：假设我们考虑2个特征 $\mathrm x={x^{(1)}, x^{(2)}}$，训练集由两个通过原点的同心圆 $\lvert \mathrm x\rvert^2=C$ 产生正例 ($C=3$) 和反例 ($C=1$)，如图6所示。显然，我们无法在该二维空间中找到一条直线将训练集正确分类，此时的最佳分类超平面应该是一个圆环 $\lvert \mathrm x\rvert^2=2$ 。此时，若我们将这两个特征映射成两个新的特征 $z^{(1)},z^{(2)}$，且映射关系为 $z^{(1)}=[x^{(1)}]^2,z^{(2)}=[x^{(2)}]^2$，那么此时对应的最优分类超平面为直线$z^{(1)}+z^{(2)}=2$，如图7所示。</p>
<table>
    <tr>
        <td ><center><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20200512/SVM_fig006.jpg"  >图6</center></td>
        <td ><center><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20200512/SVM_fig007.jpg"  >图7</center></td>
    </tr>
</table>

</li>
</ul>
<p>上面的两个例子说明，当原始的特征空间线性不可分时，我们可以将原始特征空间映射为新的特征空间，使其线性可分。这里，我们将上述的映射关系用数学表达式定义为</p>
<script type="math/tex; mode=display">
\mathrm z=\phi(\mathrm x)\tag{29}</script><p>那么此时，经过特征映射后，优化问题(19)转化为：</p>
<script type="math/tex; mode=display">
\begin{aligned}
&\min\limits_{\lambda}\quad \frac{1}{2}\sum\limits_{i=1}^{N}\sum\limits_{i^\prime=1}^{N}\lambda_i\lambda_{i^\prime}y_iy_{i^\prime}\phi(\mathrm x_i)^{\mathrm T}\phi(\mathrm x_{i^\prime})-\sum\limits_{i=1}^{N}\lambda_i\\
&s.t.\quad  \sum\limits_{i=1}^{N}\lambda_iy_i=0,\lambda_i\ge=0,i=1,2,\cdots,N
\end{aligned}\tag{30}</script><p>为简便起见，我们定义</p>
<script type="math/tex; mode=display">
\mathcal k(\mathrm x_i,\mathrm x_{i^\prime})=\phi(\mathrm x_i)^{\mathrm T}\phi(\mathrm x_{i^\prime})\tag{31}</script><p>公式(31)就是我们提到的<strong>核函数</strong>。</p>
<p> 那么这里难点在于如何找到好的映射函数和核函数，也就是公式(31)的表达式？对于上面的例子，由于十分简单，我们可以很容易的定义映射函数。然而，对于实际中比较复杂的训练集，我们一般采用下面几种比较常见的核函数:</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">名称</th>
<th style="text-align:center">表达式</th>
<th style="text-align:center">名称</th>
<th style="text-align:center">表达式</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">线性核</td>
<td style="text-align:center">$\mathcal k(\mathrm x<em>i,\mathrm x</em>{i^\prime})=\mathrm x<em>i^{\mathrm T}\mathrm x</em>{i^\prime}$</td>
<td style="text-align:center">高斯核</td>
<td style="text-align:center">$\mathcal k(\mathrm x<em>i,\mathrm x</em>{i^\prime})=\exp(-\frac{\lvert\mathrm x<em>i-\mathrm x</em>{i^\prime}\rvert^2}{2\sigma^2})$</td>
</tr>
<tr>
<td style="text-align:center">多项式核</td>
<td style="text-align:center">$\mathcal k(\mathrm x<em>i,\mathrm x</em>{i^\prime})=(a\mathrm x<em>i^{\mathrm T}\mathrm x</em>{i^\prime}+b)^c$</td>
<td style="text-align:center">指数核</td>
<td style="text-align:center">$\mathcal k(\mathrm x<em>i,\mathrm x</em>{i^\prime})=\exp(-\frac{\lvert\mathrm x<em>i-\mathrm x</em>{i^\prime}\rvert}{2\sigma^2})$</td>
</tr>
<tr>
<td style="text-align:center">Sigmoid核</td>
<td style="text-align:center">$\mathcal k(\mathrm x<em>i,\mathrm x</em>{i^\prime})=\tanh(a\mathrm x<em>i^{\mathrm T}\mathrm x</em>{i^\prime}+b)$</td>
<td style="text-align:center">拉普拉斯核</td>
<td style="text-align:center">$\mathcal k(\mathrm x<em>i,\mathrm x</em>{i^\prime})=\exp(-\frac{\lvert\mathrm x<em>i-\mathrm x</em>{i^\prime}\rvert}{\sigma})$</td>
</tr>
</tbody>
</table>
</div>
<p>下面我们以一个具体的多项式核 $\mathcal k(\mathrm x<em>i,\mathrm x</em>{i^\prime})=(\mathrm x<em>i^{\mathrm T}\mathrm x</em>{i^\prime}+1)^2$ 来说明核函数的好处。这里我们考虑原始特征空间为二维，即$\mathrm x={x^{(1)},x^{(2)}}$。那么此时核函数可以表示为：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\mathcal k(\mathrm x_i,\mathrm x_{i^\prime})&=(\mathrm x_i^{\mathrm T}\mathrm x_{i^\prime}+1)^2\\
&=(1+x_i^{(1)}x_{i^\prime}^{(1)}+x_i^{(2)}x_{i^\prime}^{(2)})^2\\
&=1+2\mathrm x_{i}^{(1)}\mathrm x_{i^\prime}^{(1)}+2\mathrm x_{i}^{(2)}\mathrm x_{i^\prime}^{(2)}+[\mathrm x_{i}^{(1)}\mathrm x_{i^\prime}^{(1)}]^2+2\mathrm x_{i}^{(1)}\mathrm x_{i^\prime}^{(1)}\mathrm x_{i}^{(2)}\mathrm x_{i^\prime}^{(2)}+[\mathrm x_{i}^{(2)}\mathrm x_{i^\prime}^{(2)}]^2\\
&=[1,\sqrt{2}\mathrm x_{i}^{(1)},\sqrt{2}\mathrm x_{i}^{(2)},[\mathrm x_{i}^{(1)}]^2,\sqrt{2}\mathrm x_{i}^{(1)}\mathrm x_{i}^{(2)},[\mathrm x_{i}^{(2)}]^2][1,\sqrt{2}\mathrm x_{i^\prime}^{(1)},\sqrt{2}\mathrm x_{i^\prime}^{(2)},[\mathrm x_{i^\prime}^{(1)}]^2,\sqrt{2}\mathrm x_{i^\prime}^{(1)}\mathrm x_{i^\prime}^{(2)},[\mathrm x_{i^\prime}^{(2)}]^2]^{\mathrm T}\\
&=\phi(\mathrm x_i)^{\mathrm T}\phi(\mathrm x_{i^\prime})
\end{aligned}\tag{32}</script><p>从公式(31)可以看出我们把原始二维特征空间映射到了六维特征空间。最终计算$\phi(\mathrm x<em>i)^{\mathrm T}\phi(\mathrm x</em>{i^\prime})$是两个六维空间向量的内积，需要6次加法和6次乘法。然而，我们可以直接通过核函数$\mathcal k(\mathrm x<em>i,\mathrm x</em>{i^\prime})=(\mathrm x<em>i^{\mathrm T}\mathrm x</em>{i^\prime}+1)^2$  计算$\phi(\mathrm x<em>i)^{\mathrm T}\phi(\mathrm x</em>{i^\prime})$，此时只需要进行二维空间的内积，总共需要3次加法和3次乘法。也就是说，通过核函数，我们可以直接在原始特征空间计算结果，从而避免在映射后的高维特征空间中计算内积。</p>
<hr>
<h2 id="线性不可分SVM"><a href="#线性不可分SVM" class="headerlink" title="线性不可分SVM"></a>线性不可分SVM</h2><p>最基本的SVM模型可以对原始特征空间线性可分的训练集进行正确分类，如我们开头提到的小例子。利用核函数，我们可以对于原始特征空间，线性不可分，而在映射的特征空间线性可分的训练集进行正确分类，如图4-7提到的例子。然而我们还会遇到原始特征空间线性不可分，映射后的特征空间也线性不可分，或者说我们找不到一个好的核函数使新的特征空间线性可分的情况。下面这部分内容就是考虑线性不可分的情况。</p>
<p>对于线性不可分的情况，一个比较基本的方式，就是不一定需要所有的训练样例都正确分类，我们可以容忍部分样例被错误分类。如图8所示：</p>
<p><table>
    <tr>
        <td ><center><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20200512/SVM_fig008.jpg"  ></center>  <center>图8 </center></td>
    </tr>
</table><br>在图8中，我们假定分类超平面和支持向量和图3一样，即分类超平面为绿色直线$\hat y=\omega<em>0+\mathrm w^{\mathrm T}\mathrm x=\frac{1}{2}x^{(1)}+\frac{1}{2}x^{(2)}-2=0$ ，支持向量为$\mathrm x_1, \mathrm x_3$ 。样例点 $\mathrm x_6,\mathrm x</em>{10},\mathrm x<em>{11},\mathrm x</em>{12}$ 位于直线 $\hat y=+1,-1$ 之间，即不满足我们前面提到的正确分类需要满足(10)中的约束， 其中，样例点 $\mathrm x<em>6,\mathrm x</em>{12}$ 被错误分类。</p>
<p>为了解决这一问题，我们可以为每一个样例点 $\mathrm x_i$ 引入一个松弛变量 $\xi_i\ge 0$ :</p>
<script type="math/tex; mode=display">
\xi_i=\lvert y_i-(\omega_0+\mathrm w^{\mathrm T}\mathrm x)\rvert\tag{33}</script><p>根据公式(33)我们可知：</p>
<ul>
<li>位于 $\hat y=+1,-1$ 之外的样例点$\mathrm x_i,i=2,4,5,7,8,9$ 对应的松弛变量 $\xi_i=0,i=2,4,5,7,8,9$ 。</li>
<li>位于$\hat y=+1,-1$ 之上的样例点 (支持向量) $\mathrm x_i,i=1,3$ 对应的松弛变量 $\xi_i=0,i=1,3$ 。</li>
<li>位于$\hat y=+1,-1$ 之内的样例点$\mathrm x_i,i=6,10,11,12$ ：<ul>
<li>若其能正确分类，其对应的松弛变量 $0&lt;\xi_i&lt;1,i=11,12$ ；</li>
<li>若其被错误分类，其对应的松弛变量$\xi_i&gt;1,i=6,10$ 。</li>
</ul>
</li>
</ul>
<p>此时问题(10)中的约束可变为：</p>
<script type="math/tex; mode=display">
(\omega_0+\mathrm w^{\mathrm T}\mathrm x_i)y_i\ge1-\xi_i\tag{34}</script><p>由公式(34)可以看出，当样例$\mathrm x_i$ 被错误分类时，即 $(\omega_0+\mathrm w^{\mathrm T}\mathrm x_i)y_i\le 0$ ，此时对应的松弛变量为$\xi_i&gt;1$ 。所以，松弛变量 $\xi_i$的引入是为了让所有的样例点都满足约束，使得带松弛的优化问题有解。但是，引入松弛变量容许样例点被错误分类，这并不是我们想要的结果。为此，我们需要在原问题(10)的目标(最大化间隔)基础上，考虑最小化错误分类带来的影响。这里我们一般最直观地，直接地使用 $\xi_i$作为引入松弛变量$\xi_i$ 带来的误差。因此，在原问题(10)的基础上我们有：</p>
<script type="math/tex; mode=display">
\begin{aligned}
&\min\limits_{\omega_0,\mathrm w, \xi_i}\quad\frac{1}{2}\lvert\mathrm w\rvert^2+C\sum\limits_{i=1}^{N}\xi_i\\
&s.t.\quad  (\omega_0+\mathrm w^{\mathrm T}\mathrm x_i)y_i\ge1-\xi_i\quad\forall i=1,2,\cdots,N\\
&\quad\quad\quad\xi_i>0\quad\forall i=1,2,\cdots,N
\end{aligned}\tag{35}</script><p>在优化问题(35)中，$C&gt;0$ 是一个权重因子，用于平衡最大化间隔和最小化训练误差(即样例点被错误分类)。当 $ C \to \infty $  时，相当于我们十分在乎训练误差，不容许训练样例被错误分类，此时所有的$\xi_i=0$。此时，问题(35)退化为问题(10)。</p>
<hr>
<h4 id="求解带松弛变量的优化问题"><a href="#求解带松弛变量的优化问题" class="headerlink" title="求解带松弛变量的优化问题"></a>求解带松弛变量的优化问题</h4><p>问题(35)也是一个凸二次优化问题，所以可以完全按照前面求解问题(10)的方式求解，在此我们只给出解析表达式。同样利用拉格朗日乘子法得到拉格朗日函数并对变量求偏导，令偏导为0，我们有：</p>
<script type="math/tex; mode=display">
\omega_j^\star=\sum\limits_{i=1}^{N}\lambda_iy_ix_i^{(j)}\tag{36}</script><script type="math/tex; mode=display">
\sum\limits_{i=1}^{N}\lambda_iy_i=0\tag{37}</script><script type="math/tex; mode=display">
C=\lambda_i+\mu_i\tag{38}</script><p>在公式(38)中，$\lambda_i,\mu_i$ 分别为(35)中约束对应的拉格朗日乘子。将公式(36), (37)和 (38)带入问题 (35)，我们有如下的对偶问题：</p>
<script type="math/tex; mode=display">
\begin{aligned}
&\min\limits_{\lambda}\quad \frac{1}{2}\sum\limits_{i=1}^{N}\sum\limits_{i^\prime=1}^{N}\lambda_i\lambda_{i^\prime}y_iy_{i^\prime}\mathrm x_i^{\mathrm T}\mathrm x_{i^\prime}-\sum\limits_{i=1}^{N}\lambda_i\\
&s.t.\quad  \sum\limits_{i=1}^{N}\lambda_iy_i=0,0\le\lambda_i\le C,i=1,2,\cdots,N
\end{aligned}\tag{39}</script><p>对比线性可分原问题(10)的对偶问题(19)，这里的对偶问题(39)唯一的差别就是添加了约束 $\lambda_i\le  C$。因此，问题(19)的解法与问题(39)的解法基本一致，并且前面所讲的核函数方法也同样适用。</p>
<p>求解问题(39)得到最优的$\lambda$后，我们将(36)带入超平面的表达式(8)中得到:</p>
<script type="math/tex; mode=display">
\hat y=\omega_0+\mathrm w^{\mathrm T}\mathrm x=\omega_0+\sum\limits_{j=1}^{M}\omega_jx^{(j)}=\omega_0+\sum\limits_{j=1}^{M}\sum\limits_{i=1}^{N}\lambda_iy_ix_i^{(j)}x^{(j)}=\omega_0+\sum\limits_{i=1}^{N}\lambda_iy_i\sum\limits_{j=1}^{M}x_i^{(j)}x^{(j)}\tag{40}</script><p>当对一个新的测试样例$\mathrm x$ 进行分类时，可以由上式可以判断：当$\hat y\ge0$ 时，判断为正例；当 $\hat y\le 0$ 时， 判断为反例。当然，上述问题在于$\omega_0$ 的值还无法得知。为此，我们可利用KKT条件可得：</p>
<script type="math/tex; mode=display">
原问题的约束条件：(\omega_0+\mathrm w^{\mathrm T}\mathrm x_i)y_i\ge1-\xi_i, \xi_i\ge0\quad\forall i=1,2,\cdots,N\tag{41}</script><script type="math/tex; mode=display">
对偶问题的约束条件：\lambda_i\ge 0, \mu_i\ge 0, \forall i=1,2,\cdots,N\tag{42}</script><script type="math/tex; mode=display">
互补松弛条件1：\lambda_i[y_i(\omega_0+\mathrm w^{\mathrm T}\mathrm x_i)-1+\xi_i]= 0\quad\forall i=1,2,\cdots,N\tag{43}</script><script type="math/tex; mode=display">
互补松弛条件2：\mu_i\xi_i= 0\quad\forall i=1,2,\cdots,N\tag{44}</script><p>由互补松弛条件(43)可知，要么$\lambda_i=0$，要么 $y_i(\omega_0+\mathrm w^{\mathrm T}\mathrm x_i)-1+\xi_i=0$ 。从分类超平面的表达式(40)可知，只有当$\lambda_i&gt;0$时，即$y_i(\omega_0+\mathrm w^{\mathrm T}\mathrm x_i)-1+\xi_i=0$，才对分类结果$\hat y$ 有影响，此时的样例点$\mathrm x_i $ 才对决定了分类超平面的表达式，这样的样例点就是我们所说的支持向量，在图8中对应的支持向量为 $\mathrm x_i,i=1,3,6,10,11,12$ 。</p>
<p>当 $0&lt; \lambda_i &lt; C $ 时，由公式(38)知 $ \mu_i &gt; 0 $，又由公式(44)可知，此时$\xi_i=0$，即该样例是位于 $\hat y=+1,-1$ 之上或之外的样例点。当$\lambda_i=C$ 时，有$\mu_i=0$: 此时若$\xi_i&gt;1 $ ，该样例被错误分类，若$\xi_i\le1$，此时样例位于 $\hat y=+1,-1$ 之间，但是被正确分类的样例点. 这里的分析与我们前面对图8的解释一致。当$0&lt;\lambda_i&lt;C$时， 由(43)知 $y_i(\omega_0+\mathrm w^{\mathrm T}\mathrm x_i)-1+\xi_i=0$  ，且$\xi_i=0$。那么这时有 $y_i(\omega_0+\mathrm w^{\mathrm T}\mathrm x_i)-1=0$  我们就有</p>
<script type="math/tex; mode=display">
\omega_0=\frac{1}{y_i}-\mathrm w^{\mathrm T}\mathrm x_i\tag{45}</script><hr>
<h2 id="SMO算法"><a href="#SMO算法" class="headerlink" title="SMO算法"></a>SMO算法</h2><p>虽然对偶问题(19)和(39)都是凸二次函数，我们可以利用工具箱求解，在此省略。但是复杂度与样例成正比。当样例较多时，复杂度很高。为此我们介绍如何利用问题(39)的性质，使用SMO算法进行求解。SMO算法的主要思想本质上与坐标轮询法类似，即以一个变量$\lambda_i$ 为变量，其他$\lambda$ 固定来简化优化问题。也就是说，在参数$\lambda$ 初始化后，不断执行下列步骤直到收敛：</p>
<ul>
<li>按照一定规则选取需要更新的 $\lambda<em>i$ 和 $\lambda</em>{i^\prime}$</li>
<li>固定除$\lambda<em>i,\lambda</em>{i^\prime}$的所有其他参数，求解简化后的问题(39)</li>
</ul>
<p>从上述步骤可以看出，我们的重点在<strong>如何选择$\lambda<em>i,\lambda</em>{i^\prime}$</strong>以及<strong>如何求解问题(39)</strong>。</p>
<h4 id="参数-lambdai-lambda-i-prime-的选择"><a href="#参数-lambdai-lambda-i-prime-的选择" class="headerlink" title="参数$\lambdai,\lambda{i^\prime}$ 的选择"></a>参数$\lambda<em>i,\lambda</em>{i^\prime}$ 的选择</h4><p>对于一个凸二次优化问题，满足KKT条件是最优解的充要条件。为此，我们可以找一个违背该KKT条件的样例点对应的$\lambda<em>i$作为需要更新的参数。对于另一个参数$\lambda</em>{i^\prime}$ ，我们需要选择一个离$\lambda<em>i$对应样例点较远的样例点，这样$\lambda_i$与$\lambda</em>{i^\prime}$ 之间差别较大。这时，算法每次迭代都能有效地减少目标函数值。</p>
<hr>
<h4 id="解析解"><a href="#解析解" class="headerlink" title="解析解"></a>解析解</h4><p>当选择$\lambda<em>i,\lambda</em>{i^\prime}$作为我们的优化变量，问题(39)可以简化为(为表述简单，我们假定选择的变量为$\lambda_1,\lambda_2$ ) ：</p>
<script type="math/tex; mode=display">
\begin{aligned}
&\min\limits_{\lambda_1,\lambda_2}\quad \frac{1}{2}\lambda_1^2\mathrm x_1^{\mathrm T}\mathrm x_1+\frac{1}{2}\lambda_2^2\mathrm x_2^{\mathrm T}\mathrm x_2+\lambda_1\lambda_2y_1y_2\mathrm x_1^{\mathrm T}\mathrm x_2\\&\qquad+\sum\limits_{i=3}^{N}\lambda_iy_i\lambda_1y_1\mathrm x_1^{\mathrm T}\mathrm x_i+\sum\limits_{i=3}^{N}\lambda_iy_i\lambda_2y_2\mathrm x_2^{\mathrm T}\mathrm x_i-\lambda_1-\lambda_2-\sum\limits_{i=3}^{N}\lambda_i\\
&s.t.\quad  \lambda_1y_1+\lambda_2y_2=-\sum\limits_{i=3}^{N}\lambda_iy_i=\eta,0\le\lambda_i\le C,i=1,2
\end{aligned}\tag{46}</script><p>对于优化问题(46)，我们首先分析其约束条件。由于只有两个变量，我们可以通过图像形象地表示如下：</p>
<p>图9和图10分别表示当$y_1\neq y_2$ 和 $y_1=y_2$时，变量$\lambda_1,\lambda_2$的取值范围和关系。</p>
<ul>
<li>在图9中，即$y_1\neq y_2$，由问题(46)的约束我们有 $\lambda_1-\lambda_2=\eta$ 或 $-\lambda_1+\lambda_2=\eta$ ，此时$\lambda_2$的最小值$L=\max{0,-\eta}$，最大值为$H=\min{C,C-\eta}$ 。</li>
<li>在图10中，即$y_1= y_2$，由问题(46)的约束我们有 $\lambda_1+\lambda_2=\eta$ 或 $-\lambda_1-\lambda_2=\eta$ ，此时$\lambda_2$的最小值$L=\max{0,\eta-C}$，最大值为$H=\min{C,\eta}$ 。</li>
</ul>
<p>综合起来也就是：</p>
<script type="math/tex; mode=display">
\begin{aligned}
L\le\lambda_2\le H\mid \begin{cases}
L=\max\{0,-\eta\}, H=\min\{C,C-\eta\}\quad y_1\neq y_2\\
L=\max\{0,\eta-C\}, H=\min\{C,\eta\}\quad y_1= y_2
\end{cases}
\end{aligned}\tag{47}</script><hr>
<p>将问题(46)中的约束$\lambda_1y_1+\lambda_2y_2=\eta$ 同时乘以 $y_1$，我们有</p>
<script type="math/tex; mode=display">
\lambda_1=(\eta-\lambda_2y_2)y_1\tag{48}</script><p>当我们不考虑问题(46)中的约束 $0\le\lambda_i\le C$，且将变量$\lambda_1$由自变量$\lambda_2$ 表示后，问题(46)可以表示为：</p>
<script type="math/tex; mode=display">
\min\limits_{\lambda_2}\quad \frac{1}{2}[(\eta-\lambda_2y_2)y_1]^2\mathrm x_1^{\mathrm T}\mathrm x_1+\frac{1}{2}\lambda_2^2\mathrm x_2^{\mathrm T}\mathrm x_2+(\eta-\lambda_2y_2)y_1\lambda_2y_1y_2\mathrm x_1^{\mathrm T}\mathrm x_2\\\qquad+\sum\limits_{i=3}^{N}\lambda_iy_i(\eta-\lambda_2y_2)y_1y_1\mathrm x_1^{\mathrm T}\mathrm x_i+\sum\limits_{i=3}^{N}\lambda_iy_i\lambda_2y_2\mathrm x_2^{\mathrm T}\mathrm x_i-(\eta-\lambda_2y_2)y_1-\lambda_2-\sum\limits_{i=3}^{N}\lambda_i\tag{49}</script><p>将问题(49)中的常数项(不含变量$\lambda_2$ 的项 ) 删除不会影响最优解,且$y_1y_1=1$，于是我们有：</p>
<script type="math/tex; mode=display">
\min\limits_{\lambda_2}\quad \frac{1}{2}[(\eta-\lambda_2y_2)y_1]^2\mathrm x_1^{\mathrm T}\mathrm x_1+\frac{1}{2}\lambda_2^2\mathrm x_2^{\mathrm T}\mathrm x_2+(\eta-\lambda_2y_2)\lambda_2y_2\mathrm x_1^{\mathrm T}\mathrm x_2\\\quad\quad-\sum\limits_{i=3}^{N}\lambda_iy_i\lambda_2y_2\mathrm x_1^{\mathrm T}\mathrm x_i+\sum\limits_{i=3}^{N}\lambda_iy_i\lambda_2y_2\mathrm x_2^{\mathrm T}\mathrm x_i-(\eta-\lambda_2y_2)y_1-\lambda_2\tag{50}</script><p>问题(50)是一个无约束的凸优化问题，为此，其最优解$\lambda_2^\star$满足: 目标函数关于$\lambda_2$ 导数为0，在此省略求导过程，直接给出最优解的解析表达式：</p>
<script type="math/tex; mode=display">
\lambda_2^\star=\lambda_2+\frac{y_2(E_1-E_2)}{\mathrm x_1^{\mathrm T}\mathrm x_1+\mathrm x_2^{\mathrm T}\mathrm x_2-2\mathrm x_1^{\mathrm T}\mathrm x_2}\tag{51}</script><p>其中，训练样例误差$E<em>1=\omega_0+\sum\limits</em>{i=1}^{N}\lambda<em>iy_i\sum\limits</em>{j=1}^{M}x<em>i^{(j)}x_1^{(j)}-y_1, E_2=\omega_0+\sum\limits</em>{i=1}^{N}\lambda<em>iy_i\sum\limits</em>{j=1}^{M}x_i^{(j)}x_2^{(j)}-y_2$ 。</p>
<p>注意：公式(51)表明当最优的$\lambda_2^\star $ 与当前参数$\lambda_2$ 有关。换句话说，当$\lambda_2$ 不同时，得到的最优解$\lambda_2^\star $ 。这样我们可以通过不断迭代(51)可以最终使得$\lambda_2^\star $不变，即收敛。即，在第$t$ 次迭代初，我们知道所有的参数值$\lambda$ ，然后根据(51)更新$\lambda_2$，重复该迭代过程，直至收敛。另一方面，当我们考虑(47)中$\lambda_2$ 的取值范围，我们有</p>
<script type="math/tex; mode=display">
\lambda_2^\star=\begin{cases}
H,\quad\lambda_2^\star>H\\
\lambda_2^\star,\quad L\le\lambda_2^\star\le H\\
L,\quad\lambda_2^\star<L\\
\end{cases}\tag{52}</script><p>在每次迭代中，得到最优$\lambda_2^\star$ , 根据问题(46)的等式约束，我们可以得到该次迭代中最优的$\lambda_1^\star$:</p>
<script type="math/tex; mode=display">
\lambda_1^\star=\lambda_1+y_1y_2(\lambda_2-\lambda_2^\star)\tag{53}</script><p>当在某次迭代中得到最优的解$\lambda_1^\star,\lambda_2^\star$ 后，根据公式(36)得到最优的$\mathrm w$ ，那么我们只需要更新$\omega_0$的值，从而可以确定分类超平面。我们更新$\omega_0$的宗旨就是使得$\lambda_1,\lambda_2$ 对应的KKT条件(42)满足。当$0&lt;\lambda_i&lt;C,i=1,2$ 时，此时 $\xi_i=0$，$(\omega_0+\mathrm w^{\mathrm T}\mathrm x_i)-1+\xi_i=0$。于是，我们有:</p>
<script type="math/tex; mode=display">
\omega_0=\omega_{0,1}=\omega_{0,2}=\frac{1}{y_i}-\mathrm w^{\mathrm T}\mathrm x_i\tag{54}</script><p>当$\lambda<em>i=0, C, i=1,2$时，此时$\omega</em>{0,1},\omega<em>{0,2}$之间的值都满足KKT条件，为简便起见，我们取两者的中间值$\omega_0=\frac{\omega</em>{0,1}+\omega_{0,2}}{2}$ 。</p>
<hr>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>Machine Learning</tag>
      </tags>
  </entry>
  <entry>
    <title>【图解例说机器学习】感知机 (Perceptron)</title>
    <url>/2020/05/05/%5B20200505%5D/</url>
    <content><![CDATA[<p>感知机是二分类的线性分类模型，是神经网络和支持向量机的基础。</p>
<hr>
<h2 id="引例"><a href="#引例" class="headerlink" title="引例"></a>引例</h2><p>一个常见的线性二分类问题如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20200505/Perceptron_fig001.jpg" width="400" height="300" title="图1" alt="图1" ></p>
<p>如图1，假设有一个线性可分的训练集，其中有三个样例 ($\mathrm x_1,\mathrm x_2, \mathrm x_3$)，分别标记为正例(红色方块)，反例(蓝色圆圈)。这里的 $x^{(1)},x^{(2)}$为训练样例的$2$个特征。我们的目的就是找到一个超平面 (在二维空间为一条直线) 能够将这三个样例分开。显然，这样的直线有无数条，比如图中的直线 $f(\mathrm x)=x^{(1)}+x^{(2)}-3=0, f(\mathrm x)=2x^{(1)}+x^{(2)}-5=0$ 就是其中的两条。我们发现$f(\mathrm x_1)&gt;0,f(\mathrm x_2&gt;0),f(\mathrm x_3)&lt;0$，于是乎，我们可以用函数表达式$f(\mathrm x)$输出值的正负来判断新的样例$\mathrm x$属于哪一类。</p>
<hr>
<a id="more"></a>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>由上面的例子，我们可以得到下面关于感知机的数学表达式：</p>
<script type="math/tex; mode=display">
f(\mathrm x)=\mathbb I(\omega_0+\mathrm w^{\mathrm T}\mathrm x)\tag{1}</script><p>其中，$\mathbb I$是指示函数，定义为：</p>
<script type="math/tex; mode=display">
\mathbb I(x)=\begin{cases}
-1\quad x<0\\
+1\quad x>0
\end{cases}\tag{2}</script><p>由公式(1),(2)可知，上面例子中，$f(\mathrm x_1)=f(\mathrm x_2=1&gt;0),f(\mathrm x_3)=-1&lt;0$。 注意：上述指示函数的取值为$-1,+1$是用来区分正例，反例。使用其它的值也是可以的。</p>
<hr>
<h2 id="误差函数"><a href="#误差函数" class="headerlink" title="误差函数"></a>误差函数</h2><p>分类好坏的依据是能够将训练样例正确地分类，一个自然而然的误差函数就是分类错误数。但是，这样的误差函数不是连续的，不利于我们求解最优的。为此，我们考虑误分类点到分类超平面的距离，作为我们的误差函数。在中学时，我们学过一个点$x$到一条直线$ax+by+c=0$的距离可以为$\lvert ax+by+c\rvert/\sqrt{a^2+b^2}$。类似地，空间中一点$\mathrm x$ 到一个超平面$\omega_0+\mathrm w^{\mathrm T}\mathrm x=0$的距离为：</p>
<script type="math/tex; mode=display">
d=\frac{\lvert\omega_0+\mathrm w^{\mathrm T}\mathrm x\rvert}{\lvert\mathrm w\rvert}\tag{3}</script><p>那么，对于误分类的样例$\mathrm x_i$，其预测的输出为$\hat y_i=f(\mathrm x_i)$。假定预测输出为负例，即$\hat y_i=-1$，由于被错误分类，其实际的输出为$y_i=+1$，其输入为$\omega_0+\mathrm w^{\mathrm T}\mathrm x_i&gt;0$。为此，我们根据公式(3)，可以计算当$\mathrm x_i$被误分类时，该点到分类超平面的距离为：</p>
<script type="math/tex; mode=display">
d(\mathrm x_i)=-\frac{\omega_0+\mathrm w^{\mathrm T}\mathrm x_i}{\lvert\mathrm w\rvert} y_i\tag{4}</script><p>注意：公式(4)是公式(3)在误分类情况下的具体表达式。在误分类的情况下，输入$\omega<em>0+\mathrm w^{\mathrm T}\mathrm x_i$ 与实际输出$y_i$ 异号。那么对于所有误分类的样例集合$\mathcal D</em>{error}$，误差函数可以表示为：</p>
<script type="math/tex; mode=display">
E=\sum\limits_{\mathrm x_i\in\mathcal D_{error}}{d(\mathrm x_i)}=-\sum\limits_{i=1}^{\lvert\mathcal D_{error}\rvert}\frac{\omega_0+\mathrm w^{\mathrm T}\mathrm x_i}{\lvert\mathrm w\rvert}y_i\tag{5}</script><p>一般来说，为了使用梯度下降求解最小化损失函数$E$方便，我们可以添加约束$\lvert\mathrm w\rvert=1$ 将公式(5)转化为：</p>
<script type="math/tex; mode=display">
E=\sum\limits_{\mathrm x_i\in\mathcal D_{error}}{d(\mathrm x_i)}=-\sum\limits_{i=1}^{\lvert\mathcal D_{error}\rvert}(\omega_0+\mathrm w^{\mathrm T}\mathrm x_i)y_i\tag{6}</script><p>然而，我们发现，约束$\lvert\mathrm w\rvert=1$ 对最终优化结果 (得到最优的分类超平面) 没有影响。以上面给的例子来说，比如对于一个给定的训练集$\mathrm x_1,\mathrm x_2,\mathrm x_3$，其最优的分类超平面为$f(\mathrm x)=x^{(1)}+x^{(2)}-3=0, \lvert\mathrm w\rvert=\sqrt{2}$ 。当添加约束$\lvert\mathrm w\rvert=1$ 后，此时可以求得最优的超平面一样，只是需要将参数归一化：$f(\mathrm x)/\sqrt{2}=x^{(1)}/\sqrt{2}+x^{(2)}/\sqrt{2}-3/\sqrt{2}=0, \lvert\mathrm w\rvert=\sqrt{2}$ 。为此，我们可以不用考虑约束$\lvert\mathrm w\rvert=1$。</p>
<hr>
<h2 id="梯度下降法求解问题"><a href="#梯度下降法求解问题" class="headerlink" title="梯度下降法求解问题"></a>梯度下降法求解问题</h2><h4 id="算法理论"><a href="#算法理论" class="headerlink" title="算法理论"></a>算法理论</h4><p>为了找到最优的分类超平面$\hat y=f(\mathrm x)$， 我们需要最小化误差函数$E$来求得最佳的参数$\mathrm{\bar w}={\omega_0,\mathrm w}$。这里我们采用梯度下降法。分别求$E$关于$\omega_0,\omega_j$的偏导数：</p>
<script type="math/tex; mode=display">
\frac{\partial E}{\partial\omega_0}=-\sum\limits_{i=1}^{\lvert\mathcal D_{error}\rvert}{y}_i\tag{7}\\</script><script type="math/tex; mode=display">
\frac{\partial E}{\partial\omega_j}=-\sum\limits_{i=1}^{\lvert\mathcal D_{error}\rvert}x_i^{(j)}{y}_i\tag{8}</script><p>由于偏导数只与被错误分类的样例有关，我们可以采用随机梯度下降法，即每次只用一个被错误分类的训练样例 (e.g., $\mathrm x_i$ ) 来更新参数：</p>
<script type="math/tex; mode=display">
\omega_0^{t+1}=\omega_0^t+\eta^ty_i\tag{9}</script><script type="math/tex; mode=display">
\omega_j^{t+1}=\omega_j^{t}+\eta^tx_i^{(j)}y_i\tag{10}</script><p>公式(9)和(10)的直观解释：对于每一个被误分类的样例点，我们调整$\omega_0,\mathrm w$的值，使分类超平面朝着该误分类的样例点移动，从而减少该分类点到分界面的距离，即误差。</p>
<hr>
<h4 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h4><p>我们还是以上面的例子来具体说明算法的具体步骤。这例子只考虑了2个特征$x^{(1)},x^{(2)}$，于是乎我们要求的分类超平面为一条直线$f(\mathrm x)=\omega_0+\omega_1x^{(1)}+\omega_2x^{(2)}$=0. 那么上述的随机梯度算法步骤如下：</p>
<ol>
<li><p>初始化参数: $\omega_0^0=\omega_1^0=\omega_2^0=0,\eta^t=\eta=1$;</p>
</li>
<li><p>迭代过程：</p>
<ul>
<li><p>根据当前得到的分类直线，从训练集中找到一个会被误分类(即$f(\mathrm x_i)y_i\le 0$)的样例；</p>
</li>
<li><p>比如，在第一次迭代时，$\mathcal x_1$被误分类。我们可以把样例$\mathrm x_1$代入公式(9)和(10)中，我们有:</p>
<script type="math/tex; mode=display">
\omega_0^{1}=\omega_0^1+\eta y_1=0+1*1=1\tag{11}</script><script type="math/tex; mode=display">
\omega_1^{1}=\omega_1^{0}+\eta x_1^{(1)}y_1=0+1*3*1=3\tag{12}</script><script type="math/tex; mode=display">
\omega_2^{1}=\omega_2^{0}+\eta x_1^{(2)}y_1=0+1*3*1=3\tag{13}</script><p>此时得到的分类直线为$1+3x^{(1)}+3x^{(2)}=0$。</p>
</li>
</ul>
</li>
<li><p>重复步骤2，直到训练集中找不到被误分类的训练样例。</p>
</li>
</ol>
<p>最后得到该训练集的分类超平面为:</p>
<script type="math/tex; mode=display">
-3+x^{(1)}+x^{(2)}=0\tag{14}</script><p>此时所求的表达式为:</p>
<script type="math/tex; mode=display">
f(\mathrm x)=\mathbb I(-3+x^{(1)}+x^{(2)})\tag{15}</script><p>注意：这里的分类超平面有很多，与初始化的值和在步骤2中选取被误分类样例的不同有关。例如，$-5+x^{(1)}+2x^{(2)}=0$也是一个分类超平面。</p>
<hr>
<h2 id="具体算法实现"><a href="#具体算法实现" class="headerlink" title="具体算法实现"></a>具体算法实现</h2><p>这里我们以上面的例子以及iris数据集(sklearn库中自带)进行感知机二分类算法实现。</p>
<ul>
<li><p>简单的例子</p>
<p>在上述的小例子中，输入为${\mathrm x_1=(3,3),\mathrm x_2=(3,4),\mathrm x_3=(1,1)}$ ，其类别为${y_1=+1,y_2=+1,y_3=-1}$。我们假定一个新的测试样例为$\mathrm x=(4,4)$，其实际类别为$y=+1$。采用上面提及的随机梯度算法，我们可以得到如图2的实验结果 (具体实现的python源代码见附录)：</p>
<table>
    <tr>
        <td ><center><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20200505/Perceptron_fig002.jpg"  ></center>  <center>图2 </center></td>
    </tr>
</table>
</li>
<li><p>Iris数据集<br>在iris数据集中，有150个训练样例，4个feature, 总共分3类。我们只考虑了前2个feature，这么做是为了在二维图3和图4中展示分类结果。并且将类别2和类别3划分为同一类别，这样我们考虑的是一个二分类问题。</p>
</li>
</ul>
<p><table>
    <tr>
        <td ><center><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20200505/Perceptron_fig003.jpg"  >图3</center></td>
        <td ><center><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20200505/Perceptron_fig004.jpg"  >图4</center></td>
    </tr>
</table><br>从图3和图4中可以看出，我们找到了一个分类直线$99-62.6x^{(1)}+79.5x^{(2)}=0$，可以正确对iris数据集正确分类。</p>
<hr>
<h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        图1的python源代码：
    </div>
    <div class='spoiler-content'>
        <figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time : 2020/5/3 14:48</span></span><br><span class="line"><span class="comment"># @Author : tengweitw</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="comment"># Set the format of labels</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">LabelFormat</span><span class="params">(plt)</span>:</span></span><br><span class="line">    ax = plt.gca()</span><br><span class="line">    plt.tick_params(labelsize=<span class="number">14</span>)</span><br><span class="line">    labels = ax.get_xticklabels() + ax.get_yticklabels()</span><br><span class="line">    [label.set_fontname(<span class="string">'Times New Roman'</span>) <span class="keyword">for</span> label <span class="keyword">in</span> labels]</span><br><span class="line">    font = &#123;<span class="string">'family'</span>: <span class="string">'Times New Roman'</span>,</span><br><span class="line">            <span class="string">'weight'</span>: <span class="string">'normal'</span>,</span><br><span class="line">            <span class="string">'size'</span>: <span class="number">16</span>,</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="keyword">return</span> font</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">x = [<span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>]</span><br><span class="line">y = [<span class="number">3</span>, <span class="number">3</span>, <span class="number">1</span>]</span><br><span class="line">c = [<span class="string">r'$\mathrm&#123;x&#125;_1$'</span>,<span class="string">r'$\mathrm&#123;x&#125;_2$'</span>,<span class="string">r'$\mathrm&#123;x&#125;_3$'</span>]</span><br><span class="line"></span><br><span class="line">x1=np.linspace(<span class="number">0</span>,<span class="number">2.5</span>,<span class="number">10</span>)</span><br><span class="line">y1=<span class="number">5</span><span class="number">-2</span>*x1</span><br><span class="line"></span><br><span class="line">x2=np.linspace(<span class="number">0</span>,<span class="number">3</span>,<span class="number">10</span>)</span><br><span class="line">y2=<span class="number">3</span>-x2</span><br><span class="line"></span><br><span class="line">plt.figure()</span><br><span class="line"></span><br><span class="line">plt.plot(x[:<span class="number">2</span>],y[:<span class="number">2</span>],<span class="string">'rs'</span>)</span><br><span class="line">plt.plot(x[<span class="number">-1</span>],y[<span class="number">-1</span>],<span class="string">'bo'</span>)</span><br><span class="line"></span><br><span class="line">plt.plot(x1,y1,<span class="string">'k-'</span>)</span><br><span class="line">plt.plot(x2,y2,<span class="string">'k-'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(x)):</span><br><span class="line">    plt.annotate(c[i], xy=(x[i], y[i]), xytext=(x[i] + <span class="number">0.05</span>, y[i] + <span class="number">0.05</span>),fontsize=<span class="number">16</span>)</span><br><span class="line">plt.annotate(<span class="string">'$2x^&#123;(1)&#125;+x^&#123;(2)&#125;-5=0$'</span>, xy=(<span class="number">1</span>, <span class="number">3</span>), xycoords=<span class="string">'data'</span>,</span><br><span class="line">             xytext=(<span class="number">0</span>, <span class="number">60</span>), textcoords=<span class="string">'offset points'</span>, color=<span class="string">'g'</span>, fontsize=<span class="number">16</span>, arrowprops=dict(arrowstyle=<span class="string">"-&gt;"</span>,</span><br><span class="line">             connectionstyle=<span class="string">"arc,rad=0"</span>, color=<span class="string">'k'</span>))</span><br><span class="line">plt.annotate(<span class="string">'$x^&#123;(1)&#125;+x^&#123;(2)&#125;-3=0$'</span>, xy=(<span class="number">2.5</span>, <span class="number">0.5</span>), xycoords=<span class="string">'data'</span>,</span><br><span class="line">             xytext=(<span class="number">30</span>, <span class="number">30</span>), textcoords=<span class="string">'offset points'</span>, color=<span class="string">'g'</span>, fontsize=<span class="number">16</span>, arrowprops=dict(arrowstyle=<span class="string">"-&gt;"</span>,</span><br><span class="line">             connectionstyle=<span class="string">"arc,rad=0"</span>, color=<span class="string">'k'</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Set the labels</span></span><br><span class="line">font = LabelFormat(plt)</span><br><span class="line">plt.xlabel(<span class="string">'$x^&#123;(1)&#125;$'</span>, font)</span><br><span class="line">plt.ylabel(<span class="string">'$y^&#123;(2)&#125;$'</span>, font)</span><br><span class="line"></span><br><span class="line">plt.xlim(<span class="number">0</span>,<span class="number">6</span>)</span><br><span class="line">plt.ylim(<span class="number">0</span>,<span class="number">6</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
    </div>
</div>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        图2的python源代码:
    </div>
    <div class='spoiler-content'>
        <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time : 2020/5/5 11:40</span></span><br><span class="line"><span class="comment"># @Author : tengweitw</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Perceptron_gradient_descend</span><span class="params">(train_data, train_target, test_data)</span>:</span></span><br><span class="line">    <span class="comment"># learning rate</span></span><br><span class="line">    eta = <span class="number">1</span></span><br><span class="line">    M = np.size(train_data, <span class="number">1</span>) <span class="comment"># number of features</span></span><br><span class="line">    N = np.size(train_data, <span class="number">0</span>) <span class="comment"># number of instances</span></span><br><span class="line">    w_bar = np.zeros((M + <span class="number">1</span>, <span class="number">1</span>)) <span class="comment">#initialization</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># the 1st column is 1 i.e., x_0=1</span></span><br><span class="line">    temp = np.ones([N, <span class="number">1</span>])</span><br><span class="line">    <span class="comment"># X is a N*(1+M)-dim matrix</span></span><br><span class="line">    X = np.concatenate((temp, train_data), axis=<span class="number">1</span>)</span><br><span class="line">    train_target = np.array(train_target).reshape(N,<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    iter = <span class="number">0</span></span><br><span class="line">    num_iter = <span class="number">10</span></span><br><span class="line">    <span class="keyword">while</span> iter &lt; num_iter:</span><br><span class="line">        print(<span class="string">'The %s-th iteration:'</span>%(iter+<span class="number">1</span>))</span><br><span class="line">        <span class="comment"># Compute f(x_i)y_i and find a wrongly-classified instance</span></span><br><span class="line">        z = np.matmul(X, w_bar)</span><br><span class="line">        fxy=z*train_target</span><br><span class="line">        index_instance=np.argwhere(fxy&lt;=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> index_instance.size:</span><br><span class="line">            <span class="comment"># Get the first instance, you can also pick the instance randomly</span></span><br><span class="line">            index_x_selected=index_instance[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">'There is no instance that is classified by mistake.\n'</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        x_selected=X[index_x_selected]</span><br><span class="line">        <span class="comment"># update w according to eqs. (9) and (10)</span></span><br><span class="line">        w_bar=w_bar+eta*x_selected.reshape(M+<span class="number">1</span>,<span class="number">1</span>)*train_target[index_x_selected]</span><br><span class="line">        print(np.transpose(w_bar))</span><br><span class="line"></span><br><span class="line">        iter += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Predicting, let x0=1 to be multiplied by \omega_0</span></span><br><span class="line">    x0 = np.ones((np.size(test_data, <span class="number">0</span>), <span class="number">1</span>))</span><br><span class="line">    test_data1 = np.concatenate((x0, test_data), axis=<span class="number">1</span>)</span><br><span class="line">    y_predict_test_temp = np.matmul(test_data1, w_bar)</span><br><span class="line">    <span class="keyword">if</span> y_predict_test_temp&gt;<span class="number">0</span>: <span class="comment">#Note that here is only one test data, otherwise changes needed</span></span><br><span class="line">        y_predict_test=<span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        y_predict_test=<span class="number">-1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> y_predict_test,w_bar</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># x1 x2 x3</span></span><br><span class="line">data = [[<span class="number">3</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">3</span>],[<span class="number">1</span>,<span class="number">1</span>]]</span><br><span class="line"><span class="comment"># The labels</span></span><br><span class="line">label = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># testing points [4,4]</span></span><br><span class="line">test_data = np.array([<span class="number">4</span>,<span class="number">4</span>]).reshape(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">test_target = [<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">train_data = data</span><br><span class="line">train_target = label</span><br><span class="line"></span><br><span class="line">y_predict_test,w_bar=Perceptron_gradient_descend(train_data, train_target, test_data)</span><br><span class="line">print(<span class="string">'The point x=&#123;&#125; whose true class is &#123;&#125;, is grouped as class &#123;&#125;.'</span>.format(test_data,test_target,y_predict_test))</span><br></pre></td></tr></table></figure>
    </div>
</div>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        图3-图4的python源代码：
    </div>
    <div class='spoiler-content'>
        <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time : 2020/5/5 11:42</span></span><br><span class="line"><span class="comment"># @Author : tengweitw</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> matplotlib.colors <span class="keyword">import</span> ListedColormap</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> datasets</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create color maps for three types of labels</span></span><br><span class="line">cmap_light = ListedColormap([<span class="string">'tomato'</span>, <span class="string">'limegreen'</span>, <span class="string">'cornflowerblue'</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Set the format of labels</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">LabelFormat</span><span class="params">(plt)</span>:</span></span><br><span class="line">    ax = plt.gca()</span><br><span class="line">    plt.tick_params(labelsize=<span class="number">14</span>)</span><br><span class="line">    labels = ax.get_xticklabels() + ax.get_yticklabels()</span><br><span class="line">    [label.set_fontname(<span class="string">'Times New Roman'</span>) <span class="keyword">for</span> label <span class="keyword">in</span> labels]</span><br><span class="line">    font = &#123;<span class="string">'family'</span>: <span class="string">'Times New Roman'</span>,</span><br><span class="line">            <span class="string">'weight'</span>: <span class="string">'normal'</span>,</span><br><span class="line">            <span class="string">'size'</span>: <span class="number">16</span>,</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="keyword">return</span> font</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Plot the training points:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">PlotTrainPoint</span><span class="params">(train_data, train_target)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(train_target)):</span><br><span class="line">        <span class="keyword">if</span> train_target[i] == <span class="number">1</span>:</span><br><span class="line">            plt.plot(train_data[i][<span class="number">0</span>], train_data[i][<span class="number">1</span>], <span class="string">'rs'</span>, markersize=<span class="number">6</span>, markerfacecolor=<span class="string">"r"</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            plt.plot(train_data[i][<span class="number">0</span>], train_data[i][<span class="number">1</span>], <span class="string">'bs'</span>, markersize=<span class="number">6</span>, markerfacecolor=<span class="string">"b"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Plot the testing points:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">PlotTestPoint</span><span class="params">(test_data, y_predict_test)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(y_predict_test)):</span><br><span class="line">        <span class="keyword">if</span> y_predict_test[i] == <span class="number">1</span>:</span><br><span class="line">            plt.plot(test_data[i][<span class="number">0</span>], test_data[i][<span class="number">1</span>], <span class="string">'rs'</span>, markerfacecolor=<span class="string">'none'</span>, markersize=<span class="number">6</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            plt.plot(test_data[i][<span class="number">0</span>], test_data[i][<span class="number">1</span>], <span class="string">'bs'</span>, markersize=<span class="number">6</span>, markerfacecolor=<span class="string">"none"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Plot the super plane</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Plot_segment_plane</span><span class="params">(w_bar)</span>:</span></span><br><span class="line">    x0 = <span class="number">1</span></span><br><span class="line">    x1 = np.linspace(<span class="number">4</span>, <span class="number">8</span>, <span class="number">100</span>)</span><br><span class="line">    x2 = -(w_bar[<span class="number">0</span>] * x0 + w_bar[<span class="number">1</span>] * x1) / w_bar[<span class="number">2</span>]</span><br><span class="line">    plt.plot(x1, x2, <span class="string">'k-'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Perceptron_stochastic_gradient_descend</span><span class="params">(train_data, train_target, test_data)</span>:</span></span><br><span class="line">    <span class="comment"># learning rate</span></span><br><span class="line">    eta = <span class="number">1</span></span><br><span class="line">    M = np.size(train_data, <span class="number">1</span>)  <span class="comment"># number of features</span></span><br><span class="line">    N = np.size(train_data, <span class="number">0</span>)  <span class="comment"># number of instances</span></span><br><span class="line">    w_bar = np.zeros((M + <span class="number">1</span>, <span class="number">1</span>))  <span class="comment"># initialization</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># the 1st column is 1 i.e., x_0=1</span></span><br><span class="line">    temp = np.ones([N, <span class="number">1</span>])</span><br><span class="line">    <span class="comment"># X is a N*(1+M)-dim matrix</span></span><br><span class="line">    X = np.concatenate((temp, train_data), axis=<span class="number">1</span>)</span><br><span class="line">    train_target = np.array(train_target).reshape(N, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    iter = <span class="number">0</span></span><br><span class="line">    num_iter = <span class="number">10000</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> iter &lt; num_iter:</span><br><span class="line">        <span class="comment"># print('The %s-th iteration:'%(iter+1))</span></span><br><span class="line">        <span class="comment"># Compute f(x_i)y_i and find a wrongly-classified instance</span></span><br><span class="line">        z = np.matmul(X, w_bar)</span><br><span class="line">        fxy = z * train_target</span><br><span class="line">        index_instance = np.argwhere(fxy &lt;= <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> index_instance.size:</span><br><span class="line">            <span class="comment"># Get the first instance, you can also pick the instance randomly</span></span><br><span class="line">            index_x_selected = index_instance[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">'There is no instance that is classified by mistake.\n'</span>)</span><br><span class="line">            print(<span class="string">'The derived parameters w='</span>, np.transpose(w_bar))</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        x_selected = X[index_x_selected]</span><br><span class="line">        <span class="comment"># update w</span></span><br><span class="line">        w_bar = w_bar + eta * x_selected.reshape(M + <span class="number">1</span>, <span class="number">1</span>) * train_target[index_x_selected]</span><br><span class="line"></span><br><span class="line">        iter += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Predicting</span></span><br><span class="line">    x0 = np.ones((np.size(test_data, <span class="number">0</span>), <span class="number">1</span>))</span><br><span class="line">    test_data1 = np.concatenate((x0, test_data), axis=<span class="number">1</span>)</span><br><span class="line">    y_predict_test = np.matmul(test_data1, w_bar)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(y_predict_test)):</span><br><span class="line">        <span class="keyword">if</span> y_predict_test[i] &gt; <span class="number">0</span>:</span><br><span class="line">            y_predict_test[i] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            y_predict_test[i] = <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> y_predict_test, w_bar</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># import dataset of iris</span></span><br><span class="line">iris = datasets.load_iris()</span><br><span class="line"></span><br><span class="line"><span class="comment"># The first two-dim feature for simplicity</span></span><br><span class="line">data = iris.data[:, :<span class="number">2</span>]</span><br><span class="line"><span class="comment"># Group 1 (labeled 0 initially) is labeled as +1</span></span><br><span class="line">label = iris.target + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Group 2 and 3 as one group, and label them as -1</span></span><br><span class="line">label[<span class="number">50</span>:] = <span class="number">-1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Choose the 25,75,125th instance as testing points</span></span><br><span class="line">test_data = [data[<span class="number">25</span>, :], data[<span class="number">75</span>, :], data[<span class="number">125</span>, :]]</span><br><span class="line">test_target = label[[<span class="number">25</span>, <span class="number">75</span>, <span class="number">125</span>]]</span><br><span class="line"></span><br><span class="line">data = np.delete(data, [<span class="number">25</span>, <span class="number">75</span>, <span class="number">125</span>], axis=<span class="number">0</span>)</span><br><span class="line">label = np.delete(label, [<span class="number">25</span>, <span class="number">75</span>, <span class="number">125</span>], axis=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">train_data = data</span><br><span class="line">train_target = label</span><br><span class="line"></span><br><span class="line">y_predict_test, w_bar = Perceptron_stochastic_gradient_descend(train_data, train_target, test_data)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'The point x=&#123;&#125; \n whose true class is &#123;&#125;, is grouped as class &#123;&#125;.'</span>.format(test_data, test_target, np.transpose(y_predict_test)))</span><br><span class="line"></span><br><span class="line">plt.figure()</span><br><span class="line">PlotTrainPoint(train_data, train_target)</span><br><span class="line">PlotTestPoint(test_data, y_predict_test)</span><br><span class="line">Plot_segment_plane(w_bar)</span><br><span class="line">plt.annotate(<span class="string">'$99-62.6x^&#123;(1)&#125;+79.5x^&#123;(2)&#125;=0$'</span>, xy=(<span class="number">7.5</span>, <span class="number">4.7</span>), xycoords=<span class="string">'data'</span>,</span><br><span class="line">             xytext=(<span class="number">-300</span>, <span class="number">20</span>), textcoords=<span class="string">'offset points'</span>, color=<span class="string">'g'</span>, fontsize=<span class="number">16</span>, arrowprops=dict(arrowstyle=<span class="string">"-&gt;"</span>,</span><br><span class="line">             connectionstyle=<span class="string">"arc,rad=0"</span>, color=<span class="string">'k'</span>))</span><br><span class="line">font = LabelFormat(plt)</span><br><span class="line">plt.xlabel(<span class="string">'$x^&#123;(1)&#125;$'</span>, font)</span><br><span class="line">plt.ylabel(<span class="string">'$x^&#123;(2)&#125;$'</span>, font)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
    </div>
</div>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>Machine Learning</tag>
      </tags>
  </entry>
  <entry>
    <title>【图解例说机器学习】决策树 (Decision Tree)</title>
    <url>/2020/04/30/%5B20200430%5D/</url>
    <content><![CDATA[<p>决策树是一种非参数的有监督的学习方法，可以用来分类和回归，即分类决策树，回归决策树。分类决策树，可以看成是if—then规则的集合，树的每一个中间节点就是一个特征，用来if—then规则的判断，树的每一个叶子节点就是最终的分类结果。</p>
<p>基本思想：决策树就是一个，递归地选择最优特征，并根据该特征对训练数据集进行划分，使得对各个子数据集有一个最好的分类，的过程。训练数据集的划分过程就是决策树的构建过程。在开始时，所有训练数据都在根节点，然后选择一个最优特征，根据这一特征将训练数据集划分成不同的子数据集到不同的子节点中，最后递归地对各个子节点继续划分数据集，直到每个叶子节点都被分为一类。</p>
<hr>
<a id="more"></a>
<h2 id="决策树的特征选择"><a href="#决策树的特征选择" class="headerlink" title="决策树的特征选择"></a>决策树的特征选择</h2><p>在进行特征选择时，我们总希望选取的特征能够最大程度地降低数据集的不确定性。为此，我们需要引进信息论中常用的熵的概念。</p>
<h4 id="信息熵"><a href="#信息熵" class="headerlink" title="信息熵"></a>信息熵</h4><p>在大三时学过信息论基础，其中就提到了信息熵的定义。在信息论中，信息熵表示了随机变量的不确定性度量。设$X$ 是一个离散随机变量，其概率分布为:</p>
<script type="math/tex; mode=display">
P(X=x_i)=p_i\tag{1}\quad\forall i=1,2,\cdots\,\lvert X\rvert</script><p>那么随机变量$X$ 的熵定义为：</p>
<script type="math/tex; mode=display">
H(X)=-\sum\limits_{i=1}^{\lvert X\rvert}p_i\log{p_i}\tag{2}</script><p>当随机变量$X$ 只有两个取值$0, 1$，即$\lvert X\rvert=2$时，此时$X$ 的分布为:</p>
<script type="math/tex; mode=display">
P(X=0)=p,P(X=1)=1-p\tag{3}</script><p>那么此时公式(2)可以写为：</p>
<script type="math/tex; mode=display">
H(X)=-p\log{p}-(1-p)\log{(1-p)}\tag{4}</script><p>公式(4)的图像如下所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20200430/Decision_tree_fig001.jpg" width="600" height="450" title="图1" alt="图1" ></p>
<p>由图1可以看出，当$p=0,1$时，此时随机变量$X$的取值时确定性的。当$p=0.5$时，此时$X$取值的不确定性最大，熵最大。</p>
<hr>
<h4 id="条件熵"><a href="#条件熵" class="headerlink" title="条件熵"></a>条件熵</h4><p>条件熵表示的是在已知随机变量$X$的情况下，随机变量$Y$的不确定性，其定义为：</p>
<script type="math/tex; mode=display">
H(Y\mid X)=\sum\limits_{i=1}^{\lvert X\rvert}P(X=x_i)H(Y\mid X=x_i)\tag{5}</script><p>一般来说，公式(4)和(5)中的概率$P(X=x_i)$都是由训练样例得到的估计值，此时，我们把熵和条件熵又称为经验熵和经验条件熵。一般地，当$P(X=x_i)=p_i=0$时，我们假设$p_i\log{p_i}=0$.</p>
<hr>
<h4 id="信息增益"><a href="#信息增益" class="headerlink" title="信息增益"></a>信息增益</h4><p>信息增益指的是信息熵与条件熵之间的互信息。根据公式(2)和(5), 信息增益可以表示为：</p>
<script type="math/tex; mode=display">
Gain(Y,X)=H(Y)-H(Y\mid X)\tag{6}</script><p>由公式(6)可以看出，信息增益指的是知道$X$后，对$Y$的取值不确定性的减少程度。</p>
<hr>
<p>我们可以将信息熵的概念应用到决策树问题中的特征选择问题上。假设训练数据集为$\mathcal D$, 其中有$N$个训练样本，$M$ 个特征，$L$个标签类别($\mathcal D<em>1,\mathcal D_2,\cdots,\mathcal D_N$)，那么我们有$\sum\nolimits</em>{l=1}^{L}\lvert\mathcal D<em>{l}\rvert=N$。假定特征$m$有$m_K$个特征取值，根据特征$m$ 的取值我们可以将数据集$D$划分为$m_K$个子数据集$\mathcal D_1^m,\mathcal D_2^m,\cdots D</em>{m<em>K}^m$。我们将子数据集$\mathcal D_k^m$中属于类别$l$的数据集合记为$\mathcal D</em>{kl}^m$。此时公式(2), (5), (6)可以写为：</p>
<script type="math/tex; mode=display">
H(\mathcal D)=-\sum\limits_{l=1}^{L}\frac{\lvert\mathcal D_l\rvert}{\lvert\mathcal D\rvert}\log{\frac{\lvert\mathcal D_l\rvert}{\lvert\mathcal D\rvert}}\tag{7}</script><script type="math/tex; mode=display">
H(\mathcal D\mid m)=-\sum\limits_{i=1}^{m_K}\frac{\lvert\mathcal D_{i}^m\rvert}{\lvert\mathcal D\rvert}H(\mathcal D_{i}^m)=-\sum\limits_{i=1}^{m_K}\frac{\lvert\mathcal D_{i}^m\rvert}{\lvert\mathcal D\rvert}\sum\limits_{l=1}^{L}\frac{\lvert\mathcal D_{il}^m\rvert}{\lvert\mathcal D_{i}^m\rvert}\log{\frac{\lvert\mathcal D_{il}^m\rvert}{\lvert\mathcal D_{i}^m\rvert}}\tag{8}</script><script type="math/tex; mode=display">
Gain(\mathcal D,m)=H(\mathcal D)-H(\mathcal D\mid m)\tag{9}</script><hr>
<p>一般来说，信息增益$Gain(\mathcal D,m)$越大，意味着使用特征$m$对数据集$\mathcal D$进行分类后，数据集的不确定性越小。因此，我们可以利用信息增益来对决策树进行特征选择。那么特征选择的表达式即为：</p>
<script type="math/tex; mode=display">
m^\star=\arg\max\limits_{m}{\quad Gain(\mathcal D,m)}\tag{10}</script><p>由于$H(\mathcal D)$相同，特征选择的表达式也可以由条件熵来表示：</p>
<script type="math/tex; mode=display">
m^\star=\arg\min\limits_{m}{\quad H(\mathcal D\mid m)}\tag{11}</script><hr>
<h4 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h4><p>这里我们以小明吃早餐是否打包带走为例来说说特征选择与决策树的生成。我有个同学叫小明，我们记录了他每天早餐是否打包带走与课程类型( $course$ )、时间( $time$ )是否充裕、以及天气( $weather$ )好坏的关系。如下表所示：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">是否必修课</th>
<th style="text-align:center">是否有时间</th>
<th style="text-align:center">是否好天气</th>
<th style="text-align:center">打包带走</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
</tr>
</tbody>
</table>
</div>
<p>其中，$0,1$分别代表是和不是。我们的目的是估计当是必修课($course=1$)，有时间($time=1$)，好天气($weather=1$)的情况下，小明是否打包带走？</p>
<p>首先，我们求关于其三个属性的条件熵，分别为：</p>
<script type="math/tex; mode=display">
\begin{aligned}
H(\mathcal D\mid course)&=-\frac{4}{7}*0-\frac{3}{7}(\frac{2}{3}\log{\frac{2}{3}}+\frac{1}{3}\log{\frac{1}{3}})=0.3936\\
H(\mathcal D\mid time)&=-\frac{4}{7}(\frac{1}{2}\log{\frac{1}{2}}+\frac{1}{2}\log{\frac{1}{2}})-\frac{3}{7}*0=0.5714\\
H(\mathcal D\mid weather)&=-\frac{4}{7}(\frac{1}{4}\log{\frac{1}{4}}+\frac{3}{4}\log{\frac{3}{4}})-\frac{3}{7}*(\frac{1}{3}\log{\frac{1}{3}}+\frac{2}{3}\log{\frac{2}{3}})=0.8571\\
\end{aligned}</script><p>因此，我们选择是否是必修课($course$ )作为我们的第一个分类特征。我们发现，当$course=0$，不管是否有时间，天气咋样，小明都选择在食堂吃完再去上课，即此时归为一类；下面我们考虑当$course=1$时，如何进行特征选择？ 当$course=1$时，子数据集记为$\mathcal D^1_1$包含第$5,6,7$三个训练样例。这时我们计算条件熵：</p>
<script type="math/tex; mode=display">
\begin{aligned}
H(\mathcal D_1^1\mid time)&=-\frac{2}{3}*0-\frac{1}{3}*0=0\\
H(\mathcal D_1^1\mid weather)&=-\frac{2}{3}*(\frac{1}{2}\log{\frac{1}{2}}+\frac{1}{2}\log{\frac{1}{2}})-\frac{1}{3}*0=0.6667
\end{aligned}</script><p>我们发现$H(\mathcal D_1^1\mid time)=0$，说明在已知$time$的情况下，数据集$D_1^1$时完全确定的，也就是说，我们只需要$weather$和$time$ 两个特征属性，就可以得到正确的标签，不需要考虑天气这个属性。此时的决策树如下：</p>
<pre class="mermaid">graph TD;
    A[是否必修课]-->|否| B[在食堂吃];
    A-->|是|C[是否有时间];
    C-->|否|D[打包带走];
    C-->|是|E[在食堂吃];</pre>

<p>从我们得到的决策树可以看出，当课程不是必修课时，小明总是慢悠悠地在食堂吃完再去上课，不在乎迟不迟到。只有当课程是必修课，且已经快要上课时，小明才会选择打包带走。</p>
<hr>
<h2 id="决策树的生成"><a href="#决策树的生成" class="headerlink" title="决策树的生成"></a>决策树的生成</h2><p>在上面小明的例子中，我们已经基本描述了如何选择特征来生成决策树: 选择使得条件熵最大的特征，将数据集划分为子数据集，递归地对子数据集进行相同操作，直至子数据集都属于同一类。当所有特征都无法使得子数据集的样例属于同一类时，我们采用多数表决来使其归为一类。</p>
<p>上述提到的决策树生成过程就是最基本的ID3算法。但是，我们从公式(8)可以看出，经过特征选择后划分的子数据集中样本数量对特征选择影响很大。还是以小明吃早餐为例，如果上述7个样例是在1-7号获得的。假定我们考虑这个日期特征，那么如果选择日期为我们选择的特征，那么将划分为7个子数据集，每个子数据集只有一个样例，此时的不确定性为0。那么此时根据公式(8)，可以得到的条件熵也为0, 为此日期就会作为分类特征，且为唯一的特征。也就是说，根据日期可以直接确定是否打包带走。显然，这不是我们想要的结果。原因在于样例不够多，可能需要收集每个月1-7号的样例，这样才合理。</p>
<hr>
<p>另一个方法就是使用其它规则来进行特征选择，比如说<strong>C4.5中的信息增益率</strong>，其定义如下：</p>
<script type="math/tex; mode=display">
Gain\_ratio(\mathcal D\mid m)=\frac{Gain(\mathcal D\mid m)}{H(m;\mathcal D)}\tag{12}</script><p>其中，$H(m;\mathcal D)$可以看成是数据集$\mathcal D$在$m$特征划分下，每一个子数据集的样例数分布的不确定性：</p>
<script type="math/tex; mode=display">
H(m;\mathcal D)=-\sum\limits_{i=1}^{m_K}\frac{\lvert\mathcal D_{i}^m\rvert}{\lvert\mathcal D\rvert}\log{\frac{\lvert\mathcal D_{i}^m\rvert}{\lvert\mathcal D\rvert}}\tag{13}</script><p>公式(13)表明，当每个子数据集$\mathcal D_i^m$中的样例数差不多时，$H(m;\mathcal D)$最大，此时对应的信息增益率变小$Gain_ratio(\mathcal D\mid m)$变小。以日期特征为例，每个子数据集只有一个样例，此时$H(m;\mathcal D)$取得最大值，信息增益率变小，为此，我们可能不会选择该特征进行分类。</p>
<hr>
<p>除此之外，还有一个比较常用的特征选择的规则，即<strong>CART算法的基尼指数</strong>：</p>
<script type="math/tex; mode=display">
Gini(\mathcal D)=\sum\limits_{l=1}^{L}{p_l(1-p_l)}\tag{14}</script><p>其中，$p_l$是类别$l$所占样本数的概率。类似公式(8)，对每个类别进行加权，可以得到特征$m$条件基尼指数:</p>
<script type="math/tex; mode=display">
Gini(\mathcal D\mid m)=-\sum\limits_{i=1}^{m_K}\frac{\lvert\mathcal D_{i}^m\rvert}{\lvert\mathcal D\rvert}Gini(\mathcal D_{i}^m)\tag{15}</script><hr>
<p>ID3, C4.5以及CART的算法流程大致相同，只是在进行特征选择的时候，分别采用了规则(11), (13) 和(15)。 本文以ID3算法为例进行决策树算法实践。由于算法较为简单，注释也比较详细，在此不予具体说明。算法中，我们以上面小明吃早餐例子和下面的统计机器学习的例子来作为具体实现。</p>
<p>下表由15个训练数据组成，有4个特征：{年龄：青年，中年，老年}；{是否有工作：有，否}；{是否有房子：有，否}；{信贷情况：一般，好，非常好}。输出为 {贷款：是，否}。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">年龄</th>
<th style="text-align:center">有工作</th>
<th style="text-align:center">有房子</th>
<th style="text-align:center">信贷情况</th>
<th style="text-align:center">类别</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">青年</td>
<td style="text-align:center">否</td>
<td style="text-align:center">否</td>
<td style="text-align:center">一般</td>
<td style="text-align:center">否</td>
</tr>
<tr>
<td style="text-align:center">青年</td>
<td style="text-align:center">否</td>
<td style="text-align:center">否</td>
<td style="text-align:center">好</td>
<td style="text-align:center">否</td>
</tr>
<tr>
<td style="text-align:center">青年</td>
<td style="text-align:center">有</td>
<td style="text-align:center">否</td>
<td style="text-align:center">好</td>
<td style="text-align:center">有</td>
</tr>
<tr>
<td style="text-align:center">青年</td>
<td style="text-align:center">有</td>
<td style="text-align:center">有</td>
<td style="text-align:center">一般</td>
<td style="text-align:center">有</td>
</tr>
<tr>
<td style="text-align:center">青年</td>
<td style="text-align:center">否</td>
<td style="text-align:center">否</td>
<td style="text-align:center">一般</td>
<td style="text-align:center">否</td>
</tr>
<tr>
<td style="text-align:center">中年</td>
<td style="text-align:center">否</td>
<td style="text-align:center">否</td>
<td style="text-align:center">一般</td>
<td style="text-align:center">否</td>
</tr>
<tr>
<td style="text-align:center">中年</td>
<td style="text-align:center">否</td>
<td style="text-align:center">否</td>
<td style="text-align:center">好</td>
<td style="text-align:center">否</td>
</tr>
<tr>
<td style="text-align:center">中年</td>
<td style="text-align:center">有</td>
<td style="text-align:center">有</td>
<td style="text-align:center">好</td>
<td style="text-align:center">有</td>
</tr>
<tr>
<td style="text-align:center">中年</td>
<td style="text-align:center">否</td>
<td style="text-align:center">有</td>
<td style="text-align:center">非常好</td>
<td style="text-align:center">有</td>
</tr>
<tr>
<td style="text-align:center">中年</td>
<td style="text-align:center">否</td>
<td style="text-align:center">有</td>
<td style="text-align:center">非常好</td>
<td style="text-align:center">有</td>
</tr>
<tr>
<td style="text-align:center">老年</td>
<td style="text-align:center">否</td>
<td style="text-align:center">有</td>
<td style="text-align:center">非常好</td>
<td style="text-align:center">有</td>
</tr>
<tr>
<td style="text-align:center">老年</td>
<td style="text-align:center">否</td>
<td style="text-align:center">有</td>
<td style="text-align:center">好</td>
<td style="text-align:center">有</td>
</tr>
<tr>
<td style="text-align:center">老年</td>
<td style="text-align:center">有</td>
<td style="text-align:center">否</td>
<td style="text-align:center">好</td>
<td style="text-align:center">有</td>
</tr>
<tr>
<td style="text-align:center">老年</td>
<td style="text-align:center">有</td>
<td style="text-align:center">否</td>
<td style="text-align:center">非常好</td>
<td style="text-align:center">有</td>
</tr>
<tr>
<td style="text-align:center">老年</td>
<td style="text-align:center">否</td>
<td style="text-align:center">否</td>
<td style="text-align:center">一般</td>
<td style="text-align:center">否</td>
</tr>
</tbody>
</table>
</div>
<p>和计算小明吃早餐的例子一样，我们可以得到如下的决策树：</p>
<pre class="mermaid">graph TD;
    A[是否有房子]-->|否| B[是否有工作];
    A-->|是|C[同意贷款];
    B-->|否|D[不同意贷款];
    B-->|是|E[同意贷款];</pre>

<p>具体python源代码见附录，实验结果如下图2：</p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20200430/Decision_tree_fig002.jpg" width="600" height="300" title="图2" alt="图2" ></p>
<ul>
<li><p>在小明吃早餐的例子中，生成的决策树为(用字典表示)：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">'0'</span>: &#123;<span class="number">0</span>: <span class="string">'n'</span>, <span class="number">1</span>: &#123;<span class="string">'1'</span>: &#123;<span class="number">0</span>: <span class="string">'y'</span>, <span class="number">1</span>: <span class="string">'n'</span>&#125;&#125;&#125;&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>​       当我们输入测试样例{必修课: 是，是否有时间：是，是否好天气：是}时，根据上面的生成的决策树，我们预测小明不会选择打包带走。</p>
<ul>
<li><p>在是否同意贷款的例子中，生成的决策树为(用字典表示):</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">'2'</span>: &#123;<span class="number">0</span>: &#123;<span class="string">'1'</span>: &#123;<span class="number">0</span>: <span class="string">'n'</span>, <span class="number">1</span>: <span class="string">'y'</span>&#125;&#125;, <span class="number">1</span>: <span class="string">'y'</span>&#125;&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>​       当我们输入测试样例(年龄: 中年，是否有工作：是，是否有房子：是，信贷情况：一般)时，根据上面生成的决策树，我们预测银行会同意贷款。</p>
<h2 id="决策树的剪枝"><a href="#决策树的剪枝" class="headerlink" title="决策树的剪枝"></a>决策树的剪枝</h2><p>剪枝的目的就是为了防止过拟合。在生成决策树的过程中，为了尽量正确对训练样本进行分类，会导致决策树分支过多，决策树变得复杂。生成的决策树可能会把训练集中特征与输出的特有关系当成所有数据的一般关系，这样导致决策树的范化能力较差。为了避免过拟合，一般我们可以降低模型的复杂度，见【图解例说机器学习】模型的选择：偏差与方差。对于决策树来说，降低模型的复杂度意味着减少树的分支，即剪枝。</p>
<p>决策树的剪枝可能分为预剪枝和后剪枝。顾名思义，预剪枝指的是在生成决策树的过程中，对选定的特征进行划分数据集的时候进行预先估计，估计按照此特征进行划分后是否能提高对验证集的分类能力，即泛化能力。而后剪枝指的是在决策树生成后，自底向上地对每一个父节点进行判断，若删除该父节点对应的子节点使其变成叶子节点后，能够提高对验证集的分类能力，则对该父节点进行剪枝。</p>
<p>具体用于剪枝的算法有很多，我们只介绍常见的两种：错误率降低剪枝 和 损失函数降低剪枝：</p>
<ul>
<li><p>错误率降低剪枝: 对比剪枝前后对验证集的分类错误率，选择使得错误率降低的操作：剪枝或者不剪枝</p>
</li>
<li><p>损失函数降低剪枝：对比剪枝前后，选择使得损失函数降低的操作：剪枝或者不剪枝<br>其中，损失函数定义为：</p>
<script type="math/tex; mode=display">
E=H(\mathcal D\mid m)+\alpha m_K\tag{16}</script><p>公式(16)中的第一项即公式(8)，表示的是选择特征$m$进行训练数据集划分后的不确定性；$m_K$是划分后的子数据集个数，在一定程度上可以代表决策树的复杂度；$\alpha$是权重因子，较大的$\alpha$生成较高复杂度的决策树，较小的$\alpha$生成较低复杂度的决策树。当$\alpha=0$时，相当于不考虑剪枝，即只考虑模型与训练数据集的误差，不考虑模型的复杂程度。</p>
</li>
</ul>
<p>篇幅有限，这里我们只介绍了剪枝的思想，就不在算法实现剪枝操作。</p>
<hr>
<h2 id="一些说明"><a href="#一些说明" class="headerlink" title="一些说明"></a>一些说明</h2><h4 id="连续值与缺失值"><a href="#连续值与缺失值" class="headerlink" title="连续值与缺失值"></a>连续值与缺失值</h4><ul>
<li>连续值处理<br>上述我们都是以离散特征为例介绍决策树，实际生活中，我们肯定会遇到特征取连续值的情况。在已经介绍离散特征的前提下，一个自然而然的想法就是将连续特征离散化。其<strong>基本思想</strong>为：将特征的取值范围划分为$n$个相邻的区间，并以每个小区间的中间值作为候选的划分点，也就是相当于是离散特征的取值。这样我们就可以利用前面的决策树生成算法来选择候选划分点，并进行数据集划分。</li>
<li>缺失值处理<br>在实际中，有些样例的某些特征的值是缺失的。在这种情况下，一种简单的方法就是舍弃这个样例。但是在样例较少的情况下，这样做显然没有利用好已知信息(一个样例的部分特征)。其基本思想为：当一个样例的某个特征的值是缺失时，我们在以特征进行划分时，我们以概率将这个样本划分到不同的子数据集中。详细步骤请参考C4.5算法。</li>
</ul>
<hr>
<h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><p>在<a href="https://scikit-learn.org/stable/modules/tree.html#tree" target="_blank" rel="noopener">skl-learn的决策树</a>中，一开始就介绍了其优缺点。主要优缺点具体如下：</p>
<ul>
<li>优点<ul>
<li>决策树可以通过图像显示出来，逻辑清晰，简单直观</li>
<li>基本不需要对数据进行预处理：归一化，去除空值样本</li>
<li>适用于多变量输出问题</li>
<li>由于决策树是一组if-then规则的集合，模型具有很好的解释型</li>
</ul>
</li>
<li>缺点<ul>
<li>容易出现过拟合，但是可以通过剪枝来处理</li>
<li>对训练集比较敏感。当训练数据改变一点点时，决策树可能完全不同。这时可以通过后续文章会介绍的集成学习来处理。</li>
<li>生成最优的决策树是一个NP完全问题。一般采用的都是贪婪算法来寻求局部最优解，贪婪体现在每次选择是当前划分最优的特征上。同样地，我们可以通过集成学习来处理。</li>
<li>有些比较复杂的关系，决策树比较难以学习，比如异或。此时考虑将特征空间进行变换，即用新的特征代替现有特征。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        图1的python源代码：
    </div>
    <div class='spoiler-content'>
        <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time : 2020/4/22 23:09</span></span><br><span class="line"><span class="comment"># @Author : tengweitw</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># Set the format of labels</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">LabelFormat</span><span class="params">(plt)</span>:</span></span><br><span class="line">    ax = plt.gca()</span><br><span class="line">    plt.tick_params(labelsize=<span class="number">14</span>)</span><br><span class="line">    labels = ax.get_xticklabels() + ax.get_yticklabels()</span><br><span class="line">    [label.set_fontname(<span class="string">'Times New Roman'</span>) <span class="keyword">for</span> label <span class="keyword">in</span> labels]</span><br><span class="line">    font = &#123;<span class="string">'family'</span>: <span class="string">'Times New Roman'</span>,</span><br><span class="line">            <span class="string">'weight'</span>: <span class="string">'normal'</span>,</span><br><span class="line">            <span class="string">'size'</span>: <span class="number">16</span>,</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="keyword">return</span> font</span><br><span class="line"></span><br><span class="line">p = np.linspace(<span class="number">0.001</span>, <span class="number">0.999</span>, <span class="number">100</span>)</span><br><span class="line">H_X = -p * np.log2(p) - (<span class="number">1</span> - p) * np.log2(<span class="number">1</span> - p)</span><br><span class="line"></span><br><span class="line">plt.figure()</span><br><span class="line">plt.plot(p, H_X, <span class="string">'b-'</span>)</span><br><span class="line"><span class="comment"># Set the labels</span></span><br><span class="line">font = LabelFormat(plt)</span><br><span class="line">plt.xlabel(<span class="string">'$p$'</span>, font)</span><br><span class="line">plt.ylabel(<span class="string">'$H(X)$'</span>, font)</span><br><span class="line">plt.grid()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>


    </div>
</div>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        图2的python源代码：
    </div>
    <div class='spoiler-content'>
        <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time : 2020/4/27 14:24</span></span><br><span class="line"><span class="comment"># @Author : tengweitw</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loadDataSet_xiaoming</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    @ return training data</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    train_data = [[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">                  [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">                  [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>],</span><br><span class="line">                  [<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line">                  [<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">                  [<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">                  [<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>]]</span><br><span class="line">    num_value_feature = [<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>]</span><br><span class="line">    train_label = [<span class="string">'n'</span>, <span class="string">'n'</span>, <span class="string">'n'</span>, <span class="string">'n'</span>, <span class="string">'y'</span>, <span class="string">'y'</span>, <span class="string">'n'</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> train_data, train_label, num_value_feature</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loadDataSet_loan</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    @ return training data</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    train_data =[ [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">                  [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">                  [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">                  [<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>],</span><br><span class="line">                  [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">                  [<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">                  [<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">                  [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line">                  [<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">                  [<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">                  [<span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">                  [<span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line">                  [<span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">                  [<span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>],</span><br><span class="line">                  [<span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">    ]</span><br><span class="line">    num_value_feature = [<span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">    train_label = [<span class="string">'n'</span>, <span class="string">'n'</span>, <span class="string">'y'</span>, <span class="string">'y'</span>, <span class="string">'n'</span>, <span class="string">'n'</span>, <span class="string">'n'</span>, <span class="string">'y'</span>, <span class="string">'y'</span>, <span class="string">'y'</span>, <span class="string">'y'</span>, <span class="string">'y'</span>, <span class="string">'y'</span>, <span class="string">'y'</span>, <span class="string">'n'</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> train_data, train_label, num_value_feature</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Cal_entropy</span><span class="params">(train_data, train_label)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Calculate entropy of dataset</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    len_train_data = len(train_data)</span><br><span class="line">    <span class="comment"># counter the number of each class</span></span><br><span class="line">    dict_classes = Counter(train_label)</span><br><span class="line">    prob = []</span><br><span class="line">    Entropy = <span class="number">0</span></span><br><span class="line">    <span class="comment"># For each class, compute its possibility</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> dict_classes:</span><br><span class="line">        prob.append(dict_classes[i] / len_train_data)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(prob)):</span><br><span class="line">        Entropy = Entropy - (prob[i] * np.log2(prob[i]))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Entropy</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Split_dataSets</span><span class="params">(train_data, train_label, selected_feature, value_feature)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Split datasets according to the selected_feature</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    new_dataSet = []</span><br><span class="line">    new_dataLabel = []</span><br><span class="line">    <span class="comment"># for each training instance</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(train_label)):</span><br><span class="line">        <span class="keyword">if</span> train_data[i][int(selected_feature)] == value_feature:</span><br><span class="line">            new_dataSet.append(train_data[i])</span><br><span class="line">            new_dataLabel.append(train_label[i])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> new_dataSet, new_dataLabel</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Select_feature</span><span class="params">(train_data, train_label, num_value_feature)</span>:</span></span><br><span class="line">    <span class="comment"># Select the feature that minimize the conditional entropy</span></span><br><span class="line"></span><br><span class="line">    num_feature = np.size(train_data, axis=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    Entropy = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(num_feature):</span><br><span class="line">        selected_feature_temp = i</span><br><span class="line">        Entropy_temp = []</span><br><span class="line">        Entropy_temp2 = <span class="number">0</span></span><br><span class="line">        cnt_temp = []</span><br><span class="line">        <span class="comment"># for each sub dataset to compute the entropy</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(num_value_feature[i]):</span><br><span class="line">            value_feature = j</span><br><span class="line">            new_dataSet, new_dataLabel = Split_dataSets(train_data, train_label, selected_feature_temp, value_feature)</span><br><span class="line">            cnt_temp.append(len(new_dataLabel))</span><br><span class="line">            Entropy_temp.append(Cal_entropy(new_dataSet, new_dataLabel))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Compute the desired entropy by weights</span></span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> range(len(cnt_temp)):</span><br><span class="line">            Entropy_temp2 += cnt_temp[k] * Entropy_temp[k] / sum(cnt_temp)</span><br><span class="line">        Entropy.append(Entropy_temp2)</span><br><span class="line">    <span class="comment"># find the minimum conditional entropy</span></span><br><span class="line">    selected_feature = Entropy.index(min(Entropy))</span><br><span class="line">    <span class="keyword">return</span> str(selected_feature)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Decision_tree</span><span class="params">(train_data, train_label, num_value_feature)</span>:</span></span><br><span class="line">    <span class="comment"># Create decision tree</span></span><br><span class="line"></span><br><span class="line">    dict_classes = Counter(train_label)</span><br><span class="line">    temp = sorted(dict_classes.items(), key=<span class="keyword">lambda</span> item: item[<span class="number">1</span>], reverse=<span class="literal">True</span>)</span><br><span class="line">    <span class="comment"># all trainning data in the set are grouped into the same class</span></span><br><span class="line">    <span class="keyword">if</span> len(dict_classes) == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> train_label[<span class="number">0</span>]</span><br><span class="line">    <span class="comment"># We are still able to classify the dataset into the same class</span></span><br><span class="line">    <span class="comment"># Thus, we resort to major ruler</span></span><br><span class="line">    <span class="keyword">elif</span> <span class="keyword">not</span> train_data:</span><br><span class="line">        <span class="comment"># find the major class</span></span><br><span class="line">        temp=sorted(dict_classes.items(), key=<span class="keyword">lambda</span> item: item[<span class="number">1</span>], reverse=<span class="literal">True</span>)</span><br><span class="line">        <span class="keyword">return</span> temp.keys()[<span class="number">0</span>]</span><br><span class="line">    <span class="comment"># recursion</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        selected_feature = Select_feature(train_data, train_label, num_value_feature)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Use a dict to save the nodes in the tree</span></span><br><span class="line">        Tree = &#123;selected_feature: &#123;&#125;&#125;</span><br><span class="line">        <span class="comment"># selected_feature is a str, we use int to transform it.</span></span><br><span class="line">        selected_feature_value = num_value_feature[int(selected_feature)]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(selected_feature_value):</span><br><span class="line">            selected_feature_temp = selected_feature</span><br><span class="line">            value_feature = i</span><br><span class="line">            new_dataSet, new_dataLabel = Split_dataSets(train_data, train_label, selected_feature_temp, value_feature)</span><br><span class="line">            Tree[selected_feature][value_feature] = Decision_tree(new_dataSet, new_dataLabel, num_value_feature)</span><br><span class="line">        <span class="keyword">return</span> Tree</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">classify</span><span class="params">(Tree, test_data)</span>:</span></span><br><span class="line">    <span class="comment"># To get the key and value</span></span><br><span class="line">    Str = list(Tree.keys())[<span class="number">0</span>] <span class="comment">#key</span></span><br><span class="line">    Dict = Tree[Str] <span class="comment">#value: is also a dict, otherwise is a leaf node</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Recursion</span></span><br><span class="line">    <span class="keyword">for</span> key <span class="keyword">in</span> Dict.keys(): <span class="comment"># to get each child node until the leaf node</span></span><br><span class="line">        <span class="keyword">if</span> test_data[int(Str)] == key:</span><br><span class="line">            <span class="keyword">if</span> type(Dict[key]).__name__ == <span class="string">'dict'</span>: <span class="comment"># is a leaf node (i.e., a dict type)</span></span><br><span class="line">                classLabel = classify(Dict[key], test_data)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                classLabel = Dict[key]</span><br><span class="line">    <span class="keyword">return</span> classLabel</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line"></span><br><span class="line">    print(<span class="string">'----The first example: Xiao Ming eating breakfast----'</span>)</span><br><span class="line">    train_data, train_label, num_value_feature = loadDataSet_xiaoming()</span><br><span class="line">    Tree = Decision_tree(train_data, train_label, num_value_feature)</span><br><span class="line">    print(<span class="string">'The decision tree is'</span>,Tree)</span><br><span class="line">    print(<span class="string">'----Course=1, time=1, weather=1----'</span>)</span><br><span class="line">    print(<span class="string">'Does Xiao Ming take away his breakfast?'</span>, classify(Tree, [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]))</span><br><span class="line">    print(<span class="string">'\n'</span>)</span><br><span class="line"></span><br><span class="line">    print(<span class="string">'----The second example: Whether to approve a loan----'</span>)</span><br><span class="line">    train_data, train_label, num_value_feature = loadDataSet_loan()</span><br><span class="line">    Tree = Decision_tree(train_data, train_label, num_value_feature)</span><br><span class="line">    print(<span class="string">'The decision tree is'</span>,Tree)</span><br><span class="line">    print(<span class="string">'\n------age=1, work=1, house=1, reputation=0----'</span>)</span><br><span class="line">    print(<span class="string">'Does the bank approve the loan?'</span>,classify(Tree, [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>]))</span><br></pre></td></tr></table></figure>

    </div>
</div>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>Machine Learning</tag>
      </tags>
  </entry>
  <entry>
    <title>【图解例说机器学习】模型选择：偏差与方差 (Bias vs. Variance)</title>
    <url>/2020/04/17/%5B20200417%5D/</url>
    <content><![CDATA[<p>机器学习的过程大致分为三步：1）模型假设，比如我们假设模型是线性回归，还是多项式回归，以及其阶数的选择；2）误差函数定义，比如我们假设误差函数是均方误差，还是交叉熵；3）参数求解，比如使用正规方程，还是梯度下降等。</p>
<p>这篇文章主要讨论模型的选择问题，下面以多项式回归为例进行说明</p>
<hr>
<a id="more"></a>
<h2 id="一个例子：多项式回归中的阶数选择"><a href="#一个例子：多项式回归中的阶数选择" class="headerlink" title="一个例子：多项式回归中的阶数选择"></a>一个例子：多项式回归中的阶数选择</h2><p>在前面的文章【图解例说机器学习】线性回归中，我们定义了广义的线性回归模型，其表达式为：</p>
<script type="math/tex; mode=display">
\hat y=\omega_0+\sum\limits_{j=1}^{M}\omega_j\phi_j(\mathrm x)=\omega_0+\mathrm w^{\mathrm T}\phi(\mathrm x)\tag{1}</script><p>当$D=1,\phi_j(\mathrm x)=x^j$时，公式(1)可以表示为：</p>
<script type="math/tex; mode=display">
\hat y=\omega_0+\omega_1x+\omega_2x^2+\cdots+\omega_Mx^M\tag{2}</script><p>此时，线性回归就变成了$M$阶多项式回归。</p>
<p>当$M$及误差函数给定时，我们就可以通过梯度下降法求解得到$\mathrm w$。但是，$M$的选择对预测的结果影响较大。从公式可以看出$M$越大，模型越复杂，其函数表达式集合包含了$M$取值较小的情况。从这种角度来看，$M$取值越大越好。但是，一般来说训练数据较少，当$M$取值较大时，复杂的模型会过度学习训练数据间的关系，导致其泛化能力较差。</p>
<hr>
<p>这里我们通过一个实例来形象化$M$对算法的影响。这里我们假设实际的函数表达式为</p>
<script type="math/tex; mode=display">
y=\sin(2\pi x)+\epsilon\tag{3}</script><p>其中，$\epsilon$是一个高斯误差值。通过公式(3)我们产生10个样例点$(x_i,y_i)$。在给定不同$M$值时，我们使用正规方程法或梯度下降法可以得到最佳的函数表达式。在这里，我们采用正规方程法 (见【图解例说机器学习】线性回归中公式(12))，得到最优参数：</p>
<script type="math/tex; mode=display">
\mathrm{\bar w}=[\bar\phi^{\mathrm T}(\mathrm X)\bar\phi(\mathrm X)]^{-1}\bar\phi^{\mathrm T}(\mathrm X)\mathrm y\tag{4}</script><p>其中，这里的$\bar{\phi}^{\mathrm T}(\mathrm X)$根据公式(2)和【图解例说机器学习】线性回归中的公式(12)可得</p>
<script type="math/tex; mode=display">
\bar\phi(\mathrm X)=
\left\{\begin{matrix}
   \phi_0(\mathrm x_1) & \phi_1(\mathrm x_1) & \cdots & \phi_M(\mathrm x_1)\\
   \phi_0(\mathrm x_2) & \phi_1(\mathrm x_2) & \cdots & \phi_M(\mathrm x_2)\\
   \vdots & \vdots & \cdots &\vdots \\
   \phi_0(\mathrm x_N) & \phi_1(\mathrm x_N) & \cdots & \phi_M(\mathrm x_N)
  \end{matrix} 
  \right\}=
  \left\{\begin{matrix}
   1 & \mathrm x_1^1 & \cdots & \mathrm x_1^{M}\\
   1 & \mathrm x_2^1 & \cdots & \mathrm x_2^{M}\\
   \vdots & \vdots & \cdots &\vdots \\
   1 & \mathrm x_N & \cdots &\mathrm x_N^M
  \end{matrix} 
  \right\}\tag{5}</script><p>利用正规方程法，即公式(5)，我们可以得到如下$M$取不同值时的函数表达式：</p>
<table>
    <tr>
        <td ><center><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20200417/Mode_selection_fig001.jpg"  >图1 </center></td>
        <td ><center><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20200417/Mode_selection_fig002.jpg"  >图2 </center></td>
    </tr>
</table>

<table>
    <tr>
        <td ><center><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20200417/Mode_selection_fig003.jpg"  >图3 </center></td>
        <td ><center><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20200417/Mode_selection_fig004.jpg"  >图4 </center></td>
    </tr>
</table>

<hr>
<p>图1-图4表明，随着$M$的增大，函数图像对训练样本的拟合越来越好，即训练误差越来越小。但是很明显图3的图像与原始的正弦函数图像最相似，即预测误差最小。 下表给出了图1-图4对应的最优的$\mathrm w$ 的取值：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>w</th>
<th style="text-align:center">$M=0$</th>
<th style="text-align:center">$M=1$</th>
<th style="text-align:center">$M=3$</th>
<th style="text-align:center">$M=9$</th>
</tr>
</thead>
<tbody>
<tr>
<td>$\omega_0$</td>
<td style="text-align:center">$-0.0379$</td>
<td style="text-align:center">$0.8309$</td>
<td style="text-align:center">$-0.2655$</td>
<td style="text-align:center">$-6.5887*10^{-2}$</td>
</tr>
<tr>
<td>$\omega_1$</td>
<td style="text-align:center"></td>
<td style="text-align:center">$-1.9631$</td>
<td style="text-align:center">$13.1817$</td>
<td style="text-align:center">$-1.9234*10^1$</td>
</tr>
<tr>
<td>$\omega_2$</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">$-38.3154$</td>
<td style="text-align:center">$5.2109*10^2$</td>
</tr>
<tr>
<td>$\omega_3$</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">$25.9214$</td>
<td style="text-align:center">$-3.8321*10^3$</td>
</tr>
<tr>
<td>$\omega_4$</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">$1.3080*10^4$</td>
</tr>
<tr>
<td>$\omega_5$</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">$-2.1917*10^4$</td>
</tr>
<tr>
<td>$\omega_6$</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">$1.2754*10^4$</td>
</tr>
<tr>
<td>$\omega_7$</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">$1.1027*10^4$</td>
</tr>
<tr>
<td>$\omega_8$</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">$-1.8864*10^4$</td>
</tr>
<tr>
<td>$\omega_9$</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">$7.2725*10^3$</td>
</tr>
</tbody>
</table>
</div>
<p>机器学习的目的就是选取最优的$M$值，最小化预测误差。但是实际值中，预测误差是在算法之后才能得到的(不然的话，预测有什么用)，我们都是通过验证误差来模拟预测误差。也就是说，我们一般把已经标记的数据集分为训练集和验证集，通过训练集来得到给定不同$M$时最小验证误差，从而选择最佳的$M$。图5和图6给出了$M$取值不同情况下的训练误差和验证误差：</p>
<table>
    <tr>
        <td ><center><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20200417/Mode_selection_fig005.jpg"  >图5 10个训练样例</center></td>
        <td ><center><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20200417/Mode_selection_fig006.jpg"  >图6 100个训练样例</center></td>
    </tr>
</table>


<p>在图5和图6中，训练样例和验证样例都是由公式(3)给出，但是图5只有10个训练样例，图6有100个训练样例，验证样例都为100。从图中可知，训练误差都是随$M$增加而下降。图5中，当训练样例为10个时，此时我们可以选择$M=3$或者$M=6$得到较小的验证误差。当训练样例足够多时，如图6所示，此时$M$越大，验证误差越好。</p>
<p>根据上述讨论，我们可以总结如下：</p>
<p>当训练样例较少时，我们需要选择合适的模型的复杂度，即这里的$M$值；当训练样例较多时，我们选择的模型越复杂越好，即选择较大的$M$值。</p>
<hr>
<h4 id="防止过拟合"><a href="#防止过拟合" class="headerlink" title="防止过拟合"></a>防止过拟合</h4><p>当训练数据较少，而模型较为复杂时，容易出现过拟合。如在图1-图6中，只有$10$ 个训练数据，当$M=9$时，误差变大，这时出现过拟合现象。因此，我们可以通过增加训练数据和正则化来防止过拟合。</p>
<h6 id="增加训练数据"><a href="#增加训练数据" class="headerlink" title="增加训练数据"></a>增加训练数据</h6><p>图7和图8给出了，在$M=9$情况下，不同训练样例对函数表达式的模拟情况。可见，当训练样例较多时，得到的模型与原始模型(正选函数)更接近。</p>
<table>
    <tr>
        <td ><center><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20200417/Mode_selection_fig007.jpg"  >图7 50个训练样例</center></td>
        <td ><center><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20200417/Mode_selection_fig008.jpg"  >图8 100个训练样例</center></td>
    </tr>
</table>



<h6 id="正则化"><a href="#正则化" class="headerlink" title="正则化"></a>正则化</h6><p>从上面的表格中可以看出，当过拟合时($M=9$)，输入变量$\mathrm x$的系数$\mathrm{w}$的系数变得特别大.此时，当$\mathrm{x}$变动十分小时，输出$\hat y$也变得很大，这就导致了预测时误差变大。此时，我们可以对误差函数加入<strong>惩罚项</strong>，来限制$\mathrm{w}$的取值：</p>
<script type="math/tex; mode=display">
E=\sum\limits_{i=1}^N{(\hat y_i-y_i)^2}+\frac{\lambda}{2}\lvert\mathrm{w}\rvert^2\tag{6}</script><p>公式(6)中的$\lambda$可以自己调节来选取合适的值。</p>
<p>同样地，我们可以使用正规方程来使得新的误差函数(6)最小。此时的解析解可以表示为：</p>
<script type="math/tex; mode=display">
\mathrm{\bar w}=[\bar\phi^{\mathrm T}(\mathrm X)\bar\phi(\mathrm X)+\lambda\mathrm I_0]^{-1}\bar\phi^{\mathrm T}(\mathrm X)\mathrm y\tag{7}</script><p>其中$\mathrm I_0$是一个$(M+1)\times(M+1)$的对角矩阵，且第一个对角元素为0(因为我们一般在正则项中不考虑$\omega_0$，见P10, <a href="https://www.microsoft.com/en-us/research/people/cmbishop/prml-book/" target="_blank" rel="noopener">PRML</a>)，其他对角元素为$1$。</p>
<p>注意：公式(7)可以对$E$求导，使其为零得到，这里就不详细推导。</p>
<table>
    <tr>
        <td ><center><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20200417/Mode_selection_fig009.jpg"  >图9 </center></td>
        <td ><center><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20200417/Mode_selection_fig010.jpg"  >图10 </center></td>
    </tr>
</table>

<hr>
<p>图9和图10给出了当测试样例为10，$\lambda$取不同值的函数拟合情况。可以看出，$\lambda$越小，对训练样例的拟合越好，即训练误差越小，但是此时图像与原始的正弦函数差别较大。当$\lambda=0$时，即不考虑正则化，此时对应的是图4。图9和图10说明，我们可以通过加入正则项来避免过拟合的情况。</p>
<hr>
<h2 id="偏差与方差"><a href="#偏差与方差" class="headerlink" title="偏差与方差"></a>偏差与方差</h2><h4 id="理论推导"><a href="#理论推导" class="headerlink" title="理论推导"></a>理论推导</h4><p>机器学习的目的就是最小化误差。一般采用的误差，如线性回归的平方和误差，逻辑回归的交叉熵误差。这些误差都是假定训练样例的权重一样，但是实际中，每个样例出现的概率是不同的。因此，我们这里定义一个平均误差函数:</p>
<script type="math/tex; mode=display">
\mathbb E[E]=\int\int E(\hat y,y)p(\mathrm x,y)d\mathrm xdy\tag{8}</script><p>这里的$E(\hat y,y)$就是我们常用的误差函数,如下：</p>
<script type="math/tex; mode=display">
E(\hat y, y)=(\hat y_i-y_i)^2\tag{9}</script><script type="math/tex; mode=display">
E(\hat y, y)=-[y_i\log{\hat y_i}+(1-y_i)\log{(1-\hat y_i)}]\tag{10}</script><p>可见，公式(8)是一个广义的误差函数。这里我们平方和误差函数为例，将公式(9)带入公式(8)中，我们有</p>
<script type="math/tex; mode=display">
\mathbb E[E]=\int\int (\hat y-y)^2p(\mathrm x,y)d\mathrm xdy\tag{11}</script><p>通过求导，令导数为0，我们可以得到最佳的函数表达式：</p>
<script type="math/tex; mode=display">
\frac{\partial\mathbb E(E)}{\partial\hat y}=2\int(\hat y-y)p(\mathrm x,y)dy=0\tag{12}</script><script type="math/tex; mode=display">
\hat y=\frac{\int yp(\mathrm x,y)dy}{p(\mathrm x)}=\int yp(y\mid\mathrm x)dy=\mathbb E_y[y\mid\mathrm x]=y^\star\tag{13}</script><p>根据公式(13)我们可以重写(11)</p>
<script type="math/tex; mode=display">
\begin{align}
\mathbb E(E)&=\int\int(\hat y-y^\star+y^\star-y)^2p(\mathrm x,y)d\mathrm xdy\nonumber\\
            &=\int\int[(\hat y-y^\star)^2+2(\hat y-y^\star)(y^\star-y)+(y^\star-y)^2]d\mathrm xdy\nonumber\\
            &=\int(\hat y-y^\star)^2p(\mathrm x)d\mathrm x+\int(y^\star-y)^2p(\mathrm x)d\mathrm x\tag{14}
\end{align}</script><p>公式(14)中的第二项与我们要求的函数表达式$\hat y$没有关系。因此，当我们得到最优的函数表达式($\hat y=y^\star$)，即公式第一项为0，第二项即为我们得到的最小误差值。然而，由于训练数据有限(一般假定训练数据集为$\mathcal D={\mathrm x_i\mid i=1,2,\cdots,N}$)，得到最优解($\hat y=y^\star=\mathbb E(y\mid\mathrm x)$)一般是比较困难的。但我们有充足的训练数据$\mathrm x$, 我们理论上可以得到条件期望$\mathbb E(y\mid\mathrm x)=\int yp(y\mid\mathrm x)dy$, 也就是最优的函数表达式$\hat y$。</p>
<p>真实的$y$ 与$\mathrm x$的关系由$p(\mathrm x,y)$决定，假定由$p(\mathrm x,y)$产生很多不同训练数据集 $\mathcal D$ 。对于每一个数据集$\mathcal D$, 我们都能通过机器学习算法得到一个函数表达式$\hat y<em>{\mathcal D}$。那么，我们需要在所有可能的训练数据集来评价$\hat y</em>{\mathcal D}$的好坏，即我们需要计算$\hat y_{\mathcal D}$在所以训练集上的平均误差。那么公式(14)可以写成：</p>
<script type="math/tex; mode=display">
\begin{align}
\mathbb E(E)&=\int\mathbb E_{\mathcal D}[(\hat y-y^\star)^2]p(\mathrm x)d\mathrm x+\int(y^\star-y)^2p(\mathrm x)d\mathrm x\nonumber\\
&=\int\{(\mathbb E_{\mathcal D}[\hat y_{\mathcal D}]-y^\star)^2+\mathbb E_{\mathcal D}[(\hat y_{\mathcal D}-\mathbb E_{\mathcal D}[\hat y_{\mathcal D}])^2]\}p(\mathrm x)d\mathrm x+\int(y^\star-y)^2p(\mathrm x)d\mathrm x\nonumber\\
&=\underbrace{\int(\mathbb E_{\mathcal D}[\hat y_{\mathcal D}]-y^\star)^2p(\mathrm x)d\mathrm x}_{(bias)^2}+\underbrace{\int\mathbb E_{\mathcal D}[(\hat y_{\mathcal D}-\mathbb E_{\mathcal D}[\hat y_{\mathcal D}])^2]p(\mathrm x)d\mathrm x}_{variance}+\underbrace{\int(y^\star-y)^2p(\mathrm x)d\mathrm x}_{noise}\tag{15}
\end{align}</script><p>可见，误差由bias (偏差)，variance (方差)，和noise (噪声)三部分组成。其中，bias和variance都和我们的模型选择$\hat y<em>{\mathcal D}$ 有关。第三项noise可以表示为$\int(\mathbb E</em>{\mathcal D}[y\mid\mathrm x]-y)^2p(\mathrm x)d\mathrm x$, 即可以看成是训练数据自身的特征：$y$的方差。对于公式(15)，我们可以计算各部分值如下：</p>
<ul>
<li><p>$\mathbb E<em>{\mathcal D}[\hat y</em>{\mathcal D}]$ 指的是对$\hat y$在$L$个数据集上求平均值，那么我们有：</p>
<script type="math/tex; mode=display">
\mathbb E_{\mathcal D}[\hat y_{\mathcal D}(\mathrm x)]=\frac{1}{L}\sum\limits_{l=1}^{L}\hat y_l(\mathrm x)\tag{16}</script></li>
<li><p>将公式(16)带入公式(15)中，我们有：</p>
</li>
</ul>
<script type="math/tex; mode=display">
(bias)^2=\frac{1}{N}\sum\limits_{i=1}^{N}\{\mathbb E_{\mathcal D}[\hat y_{\mathcal D}(\mathrm x_i)]-y^\star(\mathrm x_i)\}^2\tag{17}</script><script type="math/tex; mode=display">
variance=\frac{1}{N}\sum\limits_{i=1}^{N}\frac{1}{L}\sum\limits_{l=1}^{L}\{\hat y_l(\mathrm x_i)-\mathbb E_{\mathcal D}[\hat y_{\mathcal D}(\mathrm x_i)]\}^2\tag{18}</script><p>注意：在计算公式(15)的积分项$\int p(\mathrm x)d\mathrm x$ 时，我们采用的是将所有的 $\mathrm x$ 所得到的结果加和求平均，即$\sum/N$。因为这里我们假定所有训练样例都是均匀采样的。</p>
<p>一般来说，模型($\hat y(\mathrm x)$)越复杂，偏差越小，方差越大。因为模型越复杂，对于我们训练样例集的每一个样例$\mathrm x_i$的拟合较好，也就是说$\hat y_l(\mathrm x_i)$与$y^\star(\mathrm x_i)$比较接近，即公式(17)的值较小(偏差较小)；而此时，不同训练样例集产生的$\hat y_l(\mathrm x_i)$之间值存在较大波动，即公式(18)的值较大(方差较大)。换句话说，公式(17)，即偏差，针对的是$\hat y_l(\mathrm x_i)$与真实函数$y^\star(\mathrm x_i)$之间的误差；而公式(18)，即方差，针对的是不同数据集所得到的函数$\hat y_l(\mathrm x_i)$之间的误差。</p>
<hr>
<h4 id="偏差与方差的折中关系"><a href="#偏差与方差的折中关系" class="headerlink" title="偏差与方差的折中关系"></a>偏差与方差的折中关系</h4><p>我们通过函数表达式(3)来产生$L=100$个训练数据集，每个数据集包含$N=30$个训练样例。那么此时，我们有$y^\star=\sin(2\pi\mathrm x)$且此时公式(15)的第三项noise可以由$\epsilon$的分布求出。我们假定用$M=9$的多项式函数(2)来作为$\hat y$的表达式。当正则项的系数分别为$\lambda=10^{-3},10^{-12}$时，我们可以分别得到图11-12，和图13-14：</p>
<table> 
    <tr>
        <td ><center><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20200417/Mode_selection_fig011.jpg"  >图11 </center></td>
        <td ><center><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20200417/Mode_selection_fig012.jpg"  >图12 </center></td>
    </tr>
</table>

<table>
    <tr>
        <td ><center><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20200417/Mode_selection_fig013.jpg"  >图13 </center></td>
        <td ><center><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20200417/Mode_selection_fig014.jpg"  >图14 </center></td>
    </tr>
</table>

<p>图11和图13表示的是在这100个训练数据集下$\hat y$关于$\mathrm x$ 的函数图像。图12和图14表示的是在左图100条函数取平均情况下的函数图像，其中红色曲线是我们最优的函数$y^\star$。左图可以反映各个函数表达式间的差别，公式(18)， 即方差，右图表示的是预测函数$\mathbb E<em>{\mathcal D}[\hat y</em>{\mathcal D}]$与最优函数$y^\star$的差别，公式(17)，即偏差。通过图11-14，我们可以看出偏差与方差的折中关系。</p>
<hr>
<p>经过上面的分析，我们可以看出误差主要由偏差、方差和噪声组成，并从中可以看出模型的选择(e.g.,这里$M,\lambda$的选择)对误差的本质影响，从而指导模型的选择。由公式(16)-(18)可以看出，误差的分析是建立在很多数据集上的统计平均值。但是在实际中，训练数据集很少。当我们有很多的数据集，我们可以把它们看出一个大的数据集，这样我们就可以防止过拟合现象(见图7-8)。</p>
<hr>
<h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><p>下面我们给出图1-图14的python源代码。注意，在运行代码时，可以自行调整自变量$M,N,\lambda$等。</p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        图1-4的python源代码：
    </div>
    <div class='spoiler-content'>
        <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time : 2020/4/16 23:40</span></span><br><span class="line"><span class="comment"># @Author : tengweitw</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> matplotlib.colors <span class="keyword">import</span> ListedColormap</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> datasets</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Set the format of labels</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">LabelFormat</span><span class="params">(plt)</span>:</span></span><br><span class="line">    ax = plt.gca()</span><br><span class="line">    plt.tick_params(labelsize=<span class="number">14</span>)</span><br><span class="line">    labels = ax.get_xticklabels() + ax.get_yticklabels()</span><br><span class="line">    [label.set_fontname(<span class="string">'Times New Roman'</span>) <span class="keyword">for</span> label <span class="keyword">in</span> labels]</span><br><span class="line">    font = &#123;<span class="string">'family'</span>: <span class="string">'Times New Roman'</span>,</span><br><span class="line">            <span class="string">'weight'</span>: <span class="string">'normal'</span>,</span><br><span class="line">            <span class="string">'size'</span>: <span class="number">16</span>,</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="keyword">return</span> font</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Polynomial_regression_normal_equation</span><span class="params">(train_data, train_target, test_data, test_target)</span>:</span></span><br><span class="line">    <span class="comment"># the 1st column is 1 i.e., x_0=1</span></span><br><span class="line">    X = np.ones([np.size(train_data, <span class="number">0</span>), <span class="number">1</span>])</span><br><span class="line">    X_test = np.ones([np.size(test_data, <span class="number">0</span>), <span class="number">1</span>])</span><br><span class="line">    <span class="comment"># Here to change M !!!!!!!</span></span><br><span class="line">    M = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, M + <span class="number">1</span>):</span><br><span class="line">        temp = train_data ** i</span><br><span class="line">        temp_test = test_data ** i</span><br><span class="line">        X = np.concatenate((X, temp), axis=<span class="number">1</span>)</span><br><span class="line">        X_test = np.concatenate((X_test, temp_test), axis=<span class="number">1</span>)</span><br><span class="line">    <span class="comment"># X is a 10*M-dim matrix</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Normal equation</span></span><br><span class="line">    w_bar = np.matmul(np.linalg.pinv(np.matmul(X.T, X)), np.matmul(X.T, train_target))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Training Error</span></span><br><span class="line">    y_predict_train = np.matmul(X, w_bar)</span><br><span class="line">    E_train = np.linalg.norm(y_predict_train - train_target) / len(y_predict_train)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Predicting</span></span><br><span class="line">    y_predict_test = np.matmul(X_test, w_bar)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Prediction Error</span></span><br><span class="line">    E_test = np.linalg.norm(y_predict_test - test_target) / len(y_predict_test)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> y_predict_test, E_train, E_test</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># keep the same random training data</span></span><br><span class="line">    seed_num = <span class="number">100</span></span><br><span class="line">    np.random.seed(seed_num)</span><br><span class="line">    <span class="comment"># 10 training data</span></span><br><span class="line">    train_data = np.random.uniform(<span class="number">0</span>, <span class="number">1</span>, (<span class="number">10</span>, <span class="number">1</span>))</span><br><span class="line">    train_data = np.sort(train_data, axis=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    np.random.seed(seed_num)</span><br><span class="line">    train_target = np.sin(<span class="number">2</span> * np.pi * train_data) + <span class="number">0.1</span> * np.random.randn(<span class="number">10</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    test_data = np.linspace(<span class="number">0</span>, <span class="number">1</span>, <span class="number">100</span>).reshape(<span class="number">100</span>, <span class="number">1</span>)</span><br><span class="line">    np.random.seed(seed_num)</span><br><span class="line">    test_target = np.sin(<span class="number">2</span> * np.pi * test_data) + <span class="number">0.01</span> * np.random.randn(<span class="number">100</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    y_predict_test, E_train, E_test = Polynomial_regression_normal_equation(train_data, train_target, test_data,</span><br><span class="line">                                                                            test_target)</span><br><span class="line"></span><br><span class="line">    plt.figure()</span><br><span class="line">    plt.plot(train_data, train_target, <span class="string">'ro'</span>)</span><br><span class="line">    plt.plot(test_data, y_predict_test, <span class="string">'b-'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Set the labels</span></span><br><span class="line">    font = LabelFormat(plt)</span><br><span class="line">    plt.xlabel(<span class="string">'x'</span>, font)</span><br><span class="line">    plt.ylabel(<span class="string">'y'</span>, font)</span><br><span class="line">    plt.legend([<span class="string">'Training target'</span>, <span class="string">'Predicted target,M=2'</span>])</span><br><span class="line">    plt.ylim([<span class="number">-1</span>, <span class="number">1</span>])</span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure>
    </div>
</div>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        图5-8的python源代码：
    </div>
    <div class='spoiler-content'>
        <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time : 2020/4/18 11:56</span></span><br><span class="line"><span class="comment"># @Author : tengweitw</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Set the format of labels</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">LabelFormat</span><span class="params">(plt)</span>:</span></span><br><span class="line">    ax = plt.gca()</span><br><span class="line">    plt.tick_params(labelsize=<span class="number">14</span>)</span><br><span class="line">    labels = ax.get_xticklabels() + ax.get_yticklabels()</span><br><span class="line">    [label.set_fontname(<span class="string">'Times New Roman'</span>) <span class="keyword">for</span> label <span class="keyword">in</span> labels]</span><br><span class="line">    font = &#123;<span class="string">'family'</span>: <span class="string">'Times New Roman'</span>,</span><br><span class="line">            <span class="string">'weight'</span>: <span class="string">'normal'</span>,</span><br><span class="line">            <span class="string">'size'</span>: <span class="number">16</span>,</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="keyword">return</span> font</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Polynomial_regression_normal_equation</span><span class="params">(train_data, train_target, cv_data, cv_target,test_data,M)</span>:</span></span><br><span class="line">    <span class="comment"># the 1st column is 1 i.e., x_0=1</span></span><br><span class="line">    X = np.ones([np.size(train_data, <span class="number">0</span>), <span class="number">1</span>])</span><br><span class="line">    X_cv = np.ones([np.size(cv_data, <span class="number">0</span>), <span class="number">1</span>])</span><br><span class="line">    X_test = np.ones([np.size(test_data, <span class="number">0</span>), <span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, M + <span class="number">1</span>):</span><br><span class="line">        temp = train_data ** i</span><br><span class="line">        temp_cv = cv_data ** i</span><br><span class="line">        temp_test = test_data ** i</span><br><span class="line">        X = np.concatenate((X, temp), axis=<span class="number">1</span>)</span><br><span class="line">        X_cv = np.concatenate((X_cv, temp_cv), axis=<span class="number">1</span>)</span><br><span class="line">        X_test = np.concatenate((X_test, temp_test), axis=<span class="number">1</span>)</span><br><span class="line">    <span class="comment"># X is a 10*M-dim matrix</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Normal equation</span></span><br><span class="line">    w_bar = np.matmul(np.linalg.pinv(np.matmul(X.T, X)), np.matmul(X.T, train_target))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Training Error</span></span><br><span class="line">    y_predict_train = np.matmul(X, w_bar)</span><br><span class="line">    E_train = np.linalg.norm(y_predict_train - train_target) / len(y_predict_train)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># cross validation</span></span><br><span class="line">    y_predict_cv = np.matmul(X_cv, w_bar)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># prediction</span></span><br><span class="line">    y_predict_test=np.matmul(X_test, w_bar)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Prediction Error</span></span><br><span class="line">    E_cv = np.linalg.norm(y_predict_cv - cv_target) / len(y_predict_cv)</span><br><span class="line">    print(w_bar)</span><br><span class="line">    <span class="keyword">return</span> y_predict_test, y_predict_cv, E_train, E_cv</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># keep the same random training data</span></span><br><span class="line">    seed_num = <span class="number">100</span></span><br><span class="line">    np.random.seed(seed_num)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># training data</span></span><br><span class="line">    num_training=<span class="number">50</span></span><br><span class="line">    train_data = np.random.uniform(<span class="number">0</span>, <span class="number">1</span>, (num_training, <span class="number">1</span>))</span><br><span class="line">    train_data = np.sort(train_data, axis=<span class="number">0</span>)</span><br><span class="line">    np.random.seed(seed_num)</span><br><span class="line">    train_target = np.sin(<span class="number">2</span> * np.pi * train_data) + <span class="number">0.1</span> * np.random.randn(num_training, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 100 cross validation data</span></span><br><span class="line">    num_cv=<span class="number">100</span></span><br><span class="line">    cv_data = np.random.uniform(<span class="number">0</span>, <span class="number">1</span>, (num_cv, <span class="number">1</span>))</span><br><span class="line">    cv_data = np.sort(cv_data, axis=<span class="number">0</span>)</span><br><span class="line">    np.random.seed(seed_num)</span><br><span class="line">    cv_target = np.sin(<span class="number">2</span> * np.pi * cv_data) + <span class="number">0.1</span> * np.random.randn(num_cv, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># testing data</span></span><br><span class="line">    test_data = np.linspace(<span class="number">0</span>, <span class="number">1</span>, <span class="number">100</span>).reshape(<span class="number">100</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    M=<span class="number">9</span>+<span class="number">1</span></span><br><span class="line">    E_train=np.zeros((M,<span class="number">1</span>))</span><br><span class="line">    E_cv=np.zeros((M,<span class="number">1</span>))</span><br><span class="line">    <span class="comment"># change M</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(M):</span><br><span class="line">        y_predict_test,y_predict_cv, E_train[i], E_cv[i] = Polynomial_regression_normal_equation(train_data, train_target, cv_data, cv_target,test_data, i)</span><br><span class="line"></span><br><span class="line">    plt.figure()</span><br><span class="line">    plt.plot(E_train, <span class="string">'r-o'</span>)</span><br><span class="line">    plt.plot(E_cv,<span class="string">'b-s'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Set the labels</span></span><br><span class="line">    font = LabelFormat(plt)</span><br><span class="line">    plt.xlabel(<span class="string">'$M$'</span>, font)</span><br><span class="line">    plt.ylabel(<span class="string">'Error'</span>, font)</span><br><span class="line">    plt.legend([<span class="string">'Training Error'</span>, <span class="string">'Cross Error'</span>],loc=<span class="string">'upper center'</span>)</span><br><span class="line">    plt.grid()</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line">    plt.figure()</span><br><span class="line">    plt.plot(train_data, train_target, <span class="string">'ro'</span>)</span><br><span class="line">    plt.plot(test_data, y_predict_test, <span class="string">'b-'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Set the labels</span></span><br><span class="line">    font = LabelFormat(plt)</span><br><span class="line">    plt.xlabel(<span class="string">'x'</span>, font)</span><br><span class="line">    plt.ylabel(<span class="string">'y'</span>, font)</span><br><span class="line">    plt.legend([<span class="string">'Training target'</span>, <span class="string">'Predicted target,M=9'</span>])</span><br><span class="line">    plt.ylim([<span class="number">-1</span>, <span class="number">1</span>])</span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure>
    </div>
</div>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        图9-10的python源代码：
    </div>
    <div class='spoiler-content'>
        <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time : 2020/4/18 23:12</span></span><br><span class="line"><span class="comment"># @Author : tengweitw</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Set the format of labels</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">LabelFormat</span><span class="params">(plt)</span>:</span></span><br><span class="line">    ax = plt.gca()</span><br><span class="line">    plt.tick_params(labelsize=<span class="number">14</span>)</span><br><span class="line">    labels = ax.get_xticklabels() + ax.get_yticklabels()</span><br><span class="line">    [label.set_fontname(<span class="string">'Times New Roman'</span>) <span class="keyword">for</span> label <span class="keyword">in</span> labels]</span><br><span class="line">    font = &#123;<span class="string">'family'</span>: <span class="string">'Times New Roman'</span>,</span><br><span class="line">            <span class="string">'weight'</span>: <span class="string">'normal'</span>,</span><br><span class="line">            <span class="string">'size'</span>: <span class="number">16</span>,</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="keyword">return</span> font</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Polynomial_regression_normal_equation</span><span class="params">(train_data, train_target, cv_data, cv_target,test_data,M)</span>:</span></span><br><span class="line">    <span class="comment"># the 1st column is 1 i.e., x_0=1</span></span><br><span class="line">    X = np.ones([np.size(train_data, <span class="number">0</span>), <span class="number">1</span>])</span><br><span class="line">    X_cv = np.ones([np.size(cv_data, <span class="number">0</span>), <span class="number">1</span>])</span><br><span class="line">    X_test = np.ones([np.size(test_data, <span class="number">0</span>), <span class="number">1</span>])</span><br><span class="line">    <span class="comment"># Here to change lambda</span></span><br><span class="line">    Lambda=<span class="number">1e-12</span></span><br><span class="line">    I0= np.eye(M+<span class="number">1</span>)</span><br><span class="line">    I0[<span class="number">0</span>]=<span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, M + <span class="number">1</span>):</span><br><span class="line">        temp = train_data ** i</span><br><span class="line">        temp_cv = cv_data ** i</span><br><span class="line">        temp_test = test_data ** i</span><br><span class="line">        X = np.concatenate((X, temp), axis=<span class="number">1</span>)</span><br><span class="line">        X_cv = np.concatenate((X_cv, temp_cv), axis=<span class="number">1</span>)</span><br><span class="line">        X_test = np.concatenate((X_test, temp_test), axis=<span class="number">1</span>)</span><br><span class="line">    <span class="comment"># X is a 10*M-dim matrix</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Normal equation</span></span><br><span class="line">    w_bar = np.matmul(np.linalg.pinv(np.matmul(X.T, X)+Lambda*I0), np.matmul(X.T, train_target))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Training Error</span></span><br><span class="line">    y_predict_train = np.matmul(X, w_bar)</span><br><span class="line">    E_train = np.linalg.norm(y_predict_train - train_target) / len(y_predict_train)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># cross validation</span></span><br><span class="line">    y_predict_cv = np.matmul(X_cv, w_bar)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># prediction</span></span><br><span class="line">    y_predict_test=np.matmul(X_test, w_bar)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Prediction Error</span></span><br><span class="line">    E_cv = np.linalg.norm(y_predict_cv - cv_target) / len(y_predict_cv)</span><br><span class="line">    print(w_bar)</span><br><span class="line">    <span class="keyword">return</span> y_predict_test, y_predict_cv, E_train, E_cv</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># keep the same random training data</span></span><br><span class="line">    seed_num = <span class="number">100</span></span><br><span class="line">    np.random.seed(seed_num)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># training data</span></span><br><span class="line">    num_training=<span class="number">10</span></span><br><span class="line">    train_data = np.random.uniform(<span class="number">0</span>, <span class="number">1</span>, (num_training, <span class="number">1</span>))</span><br><span class="line">    train_data = np.sort(train_data, axis=<span class="number">0</span>)</span><br><span class="line">    np.random.seed(seed_num)</span><br><span class="line">    train_target = np.sin(<span class="number">2</span> * np.pi * train_data) + <span class="number">0.1</span> * np.random.randn(num_training, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 100 cross validation data</span></span><br><span class="line">    num_cv=<span class="number">100</span></span><br><span class="line">    cv_data = np.random.uniform(<span class="number">0</span>, <span class="number">1</span>, (num_cv, <span class="number">1</span>))</span><br><span class="line">    cv_data = np.sort(cv_data, axis=<span class="number">0</span>)</span><br><span class="line">    np.random.seed(seed_num)</span><br><span class="line">    cv_target = np.sin(<span class="number">2</span> * np.pi * cv_data) + <span class="number">0.1</span> * np.random.randn(num_cv, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># testing data</span></span><br><span class="line">    test_data = np.linspace(<span class="number">0</span>, <span class="number">1</span>, <span class="number">100</span>).reshape(<span class="number">100</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    M=<span class="number">9</span></span><br><span class="line"></span><br><span class="line">    y_predict_test,y_predict_cv, E_train, E_cv = Polynomial_regression_normal_equation(train_data, train_target, cv_data, cv_target,test_data, M)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    plt.figure()</span><br><span class="line">    plt.plot(train_data, train_target, <span class="string">'ro'</span>)</span><br><span class="line">    plt.plot(test_data, y_predict_test, <span class="string">'b-'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Set the labels</span></span><br><span class="line">    font = LabelFormat(plt)</span><br><span class="line">    plt.xlabel(<span class="string">'x'</span>, font)</span><br><span class="line">    plt.ylabel(<span class="string">'y'</span>, font)</span><br><span class="line">    plt.legend([<span class="string">'Training target'</span>, <span class="string">'Predicted target,$M=9,\lambda=10^&#123;-12&#125;$'</span>])</span><br><span class="line">    plt.ylim([<span class="number">-1</span>, <span class="number">1</span>])</span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure>

    </div>
</div>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        图11-14的python源代码：
    </div>
    <div class='spoiler-content'>
        <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time : 2020/4/20 10:46</span></span><br><span class="line"><span class="comment"># @Author : tengweitw</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Set the format of labels</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">LabelFormat</span><span class="params">(plt)</span>:</span></span><br><span class="line">    ax = plt.gca()</span><br><span class="line">    plt.tick_params(labelsize=<span class="number">14</span>)</span><br><span class="line">    labels = ax.get_xticklabels() + ax.get_yticklabels()</span><br><span class="line">    [label.set_fontname(<span class="string">'Times New Roman'</span>) <span class="keyword">for</span> label <span class="keyword">in</span> labels]</span><br><span class="line">    font = &#123;<span class="string">'family'</span>: <span class="string">'Times New Roman'</span>,</span><br><span class="line">            <span class="string">'weight'</span>: <span class="string">'normal'</span>,</span><br><span class="line">            <span class="string">'size'</span>: <span class="number">16</span>,</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="keyword">return</span> font</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Polynomial_regression_normal_equation</span><span class="params">(train_data, train_target,test_data,M)</span>:</span></span><br><span class="line">    <span class="comment"># the 1st column is 1 i.e., x_0=1</span></span><br><span class="line">    X = np.ones([np.size(train_data, <span class="number">0</span>), <span class="number">1</span>])</span><br><span class="line">    X_test = np.ones([np.size(test_data, <span class="number">0</span>), <span class="number">1</span>])</span><br><span class="line">    <span class="comment"># Here to change lambda</span></span><br><span class="line">    Lambda=<span class="number">1e-8</span></span><br><span class="line">    I0= np.eye(M+<span class="number">1</span>)</span><br><span class="line">    I0[<span class="number">0</span>]=<span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, M + <span class="number">1</span>):</span><br><span class="line">        temp = train_data ** i</span><br><span class="line">        temp_test = test_data ** i</span><br><span class="line">        X = np.concatenate((X, temp), axis=<span class="number">1</span>)</span><br><span class="line">        X_test = np.concatenate((X_test, temp_test), axis=<span class="number">1</span>)</span><br><span class="line">    <span class="comment"># X is a 10*M-dim matrix</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Normal equation</span></span><br><span class="line">    w_bar = np.matmul(np.linalg.pinv(np.matmul(X.T, X)+Lambda*I0), np.matmul(X.T, train_target))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Training Error</span></span><br><span class="line">    y_predict_train = np.matmul(X, w_bar)</span><br><span class="line">    E_train = np.linalg.norm(y_predict_train - train_target) / len(y_predict_train)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># prediction</span></span><br><span class="line">    y_predict_test=np.matmul(X_test, w_bar)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Prediction Error</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> y_predict_test, E_train</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># L is  the number of training data sets</span></span><br><span class="line">    L=<span class="number">100</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># number of each training data</span></span><br><span class="line">    N=<span class="number">30</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    plt.figure()</span><br><span class="line">    <span class="comment"># For L training datasets</span></span><br><span class="line">    <span class="keyword">for</span> l <span class="keyword">in</span> range(L):</span><br><span class="line"></span><br><span class="line">        train_data = np.random.uniform(<span class="number">0</span>, <span class="number">1</span>, (N, <span class="number">1</span>))</span><br><span class="line">        train_data = np.sort(train_data, axis=<span class="number">0</span>)</span><br><span class="line">        train_target = np.sin(<span class="number">2</span> * np.pi * train_data) + <span class="number">0.1</span>* np.random.randn(N, <span class="number">1</span>)</span><br><span class="line">        <span class="comment"># testing data</span></span><br><span class="line">        test_data = np.linspace(<span class="number">0</span>, <span class="number">1</span>, <span class="number">100</span>).reshape(<span class="number">100</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        M=<span class="number">9</span></span><br><span class="line">        y_predict_test, E_train = Polynomial_regression_normal_equation(train_data, train_target, test_data, M)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> l==<span class="number">0</span>:</span><br><span class="line">            predict_target=y_predict_test</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            predict_target=np.hstack((y_predict_test,predict_target))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># plt.plot(train_data, train_target, 'ro')</span></span><br><span class="line">        plt.plot(test_data, y_predict_test, <span class="string">'b-'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Set the labels</span></span><br><span class="line">    font = LabelFormat(plt)</span><br><span class="line">    plt.xlabel(<span class="string">'x'</span>, font)</span><br><span class="line">    plt.ylabel(<span class="string">'y'</span>, font)</span><br><span class="line">    plt.legend([ <span class="string">'Predicted target,$M=9,\lambda=10^&#123;-3&#125;$'</span>])</span><br><span class="line"></span><br><span class="line">    plt.ylim(<span class="number">-1</span>,<span class="number">1</span>)</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line">    predict_target_avg=np.mean(predict_target,axis=<span class="number">1</span>)</span><br><span class="line">    plt.figure()</span><br><span class="line">    plt.plot(test_data,predict_target_avg,<span class="string">'r-'</span>)</span><br><span class="line">    test_target = np.sin(<span class="number">2</span> * np.pi * test_data)</span><br><span class="line">    plt.plot(test_data,test_target,<span class="string">'b-'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Set the labels</span></span><br><span class="line">    font = LabelFormat(plt)</span><br><span class="line">    plt.xlabel(<span class="string">'x'</span>, font)</span><br><span class="line">    plt.ylabel(<span class="string">'y'</span>, font)</span><br><span class="line">    plt.legend([<span class="string">'True model'</span>, <span class="string">'Predicted model,$M=9,\lambda=10^&#123;-3&#125;$'</span>])</span><br><span class="line"></span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure>
    </div>
</div>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>Machine Learning</tag>
      </tags>
  </entry>
  <entry>
    <title>【图解例说机器学习】逻辑回归(Logistic Regression)</title>
    <url>/2020/04/14/%5B20200414%5D/</url>
    <content><![CDATA[<p>在我们日常生活中，我们经常会遇到使用到预测的事例，而预测的值一般可以是连续的，或离散的。比如，在天气预报中，预测明天的最高温，最低温(连续)，亦或是明天是否下雨(离散)。在机器学习中，预测连续性变量的模型称为回归(Regression)模型，比如标准的线性回归，多项式回归；预测离散型变量的模型称为分类(Classification)模型，比如这里要介绍的逻辑回归和以后要提到的支持向量机(SVM)等。</p>
<hr>
<a id="more"></a>
<h2 id="回归与分类的联系"><a href="#回归与分类的联系" class="headerlink" title="回归与分类的联系"></a>回归与分类的联系</h2><p>根据上面的论述，回归与分类的区别在于预测的变量是否是连续的。具体来说，回归是求得一个函数$y=f(\mathrm x)$进行输入变量 $\mathrm x$ 到连续型输出变量 $y_r$ 的映射；分类是是求得一个函数$y=f(\mathrm x)$进行输入变量 $\mathrm x$ 到离散型输出变量 $y_c$ 的映射，可以将其看成是一个分段函数。</p>
<p>一个直觉的想法是，通过一个函数$y_c=g(y_r)$可以把回归模型转化为分类模型，即$y=g(f(x))$。逻辑回归正是用到了这一思想：逻辑回归是在回归模型的基础上，将回归模型的输出$y_r$映射成离散输出$y_c$，我想这也是为什么取名逻辑回归而不是逻辑分类吧。 需要注意，逻辑回归是用来解决分类问题的。</p>
<hr>
<h4 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h4><p>如图1所示，假定我们有6个样本点，3个正例($y=1$)和3个反例($y=0$)。我们对其进行线性回归。当使用最简单的线性回归模型(即$\hat y=\omega_0+\omega_1x$)时，我们可以得到其最佳函数表达式为$\hat y=x$，如图中虚线所示。当我们使用复杂的回归模型时(比如考虑$x$的高阶项)时，此时我们可以得到一个十分接近$\hat y=\frac{1}{1+e^{-x}}$的函数表达式。显然，后者的效果更好，但是复杂度十分高。</p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20200414/20200414_fig001.jpg" width="400" height="300" title="图1" alt="图1" ></p>
<p>从分类问题的角度来看，我们并不关心每一个样例点的预测值，只是关心最终每个样例点属于哪一类。分类问题就是找到一个好的分段函数，使得输入$x$在不同区间的时候，输出$\hat y$分成不同类。比如图1中，当$x<0$时，判别为类别$0$；当$x>0$时，判别为类别$1$，于是我们有如下分段函数表达式：</p>
<script type="math/tex; mode=display">
\hat y=\begin{cases}
0\quad x<0\\
1\quad x>0
\end{cases}\tag{1}</script><p>分段函数(1)虽然形式简单，但是在$x=0$处不可导，不利于后面使用梯度下降法。为此，一般通过图1中的Sigmoid函数$\hat y=\frac{1}{1+e^{-x}}$来近似。</p>
<h2 id="模型描述"><a href="#模型描述" class="headerlink" title="模型描述"></a>模型描述</h2><p>在逻辑回归中，输入 $\mathrm x$ 与输出 $\hat y$ 的函数表达式为</p>
<script type="math/tex; mode=display">
\hat y=g(h(\mathrm x))\tag{1}</script><p>其中，$\mathrm z=h(\mathrm x)=\omega_0+\mathrm{w^T}\phi(\mathrm x)$ 是线性回归的函数表达式，$g(\mathrm z)=[1+e^{-\mathrm z}]^{-1}$ 是Sigmoid函数。</p>
<p>注意：Sigmoid函数$g(\mathrm z)$的作用是将线性回归的输出$\mathrm z=h(\mathrm x)$映射到$0$到$1$的取值范围。</p>
<hr>
<h2 id="误差函数"><a href="#误差函数" class="headerlink" title="误差函数"></a>误差函数</h2><p>损失函数有很多种选择：在线性回归中，我们一般采用的是最小均方误差，即$E=\sum_i{(\hat y_i-y_i)^2}$ 。然而在逻辑回归中，使用最小均方误差后，误差函数$E$对于变量$\mathrm w$不一定是凸函数，不利于求解。为此，有人提出了使用<strong>交叉熵</strong>作为误差函数：</p>
<script type="math/tex; mode=display">
E=-\sum\limits_{i=1}^{N}{[y_i\log{\hat y_i}+(1-y_i)\log{(1-\hat y_i)}]}\tag{2}</script><hr>
<h2 id="问题求解"><a href="#问题求解" class="headerlink" title="问题求解"></a>问题求解</h2><p>逻辑回归就是寻找一组参数 $\bar{\mathrm w}={\omega_0,\mathrm w}$ 使得误差函数值最小，即：</p>
<script type="math/tex; mode=display">
\min\limits_{\mathrm w}\quad E=-\sum\limits_{i=1}^{N}{[y_i\log{\hat y_i}+(1-y_i)\log{(1-\hat y_i)}]}\tag{8}</script><p>这是一个凸优化问题，和线性回归类似，我们可以考虑的方法有正规方程法和梯度下降法。但是由于该函数表达式比较复杂，正规方程法一般无法得到其解析解。为此，下面我们采用梯度下降法进行求解。</p>
<h4 id="梯度下降法"><a href="#梯度下降法" class="headerlink" title="梯度下降法"></a>梯度下降法</h4><p>梯度下降法的一般表达式如下：</p>
<script type="math/tex; mode=display">
\bar{\mathrm w}^{t+1}=\bar{\mathrm w}^{t}-\eta\frac{\partial{E}}{\partial{\mathrm{\bar w}}}</script><p>对于每一个训练样例$\mathrm x_i$采用求导的链式法则，我们有：</p>
<script type="math/tex; mode=display">
\frac{\partial}{\partial{\omega_j}}=\frac{\partial E}{\partial \hat y_i}\frac{\partial\hat y_i }{\partial z_i}\frac{\partial z_i}{\partial\omega_j}</script><p>将公式(1)和(2)带入可得</p>
<script type="math/tex; mode=display">
\frac{\partial E}{\partial \hat y_i}=\frac{1-y_i}{1-\hat y_i}-\frac{y_i}{\hat y_i},\quad \frac{\partial \hat y_i}{\partial z_i}=\hat y_i(1-\hat y_i),\quad \frac{\partial z_i}{\omega_j}=x_i^{(j)}</script><script type="math/tex; mode=display">
\frac{\partial}{\partial{\omega_j}}=(\hat y_i-y_i)x_i^{(j)}</script><p>最终，逻辑回归问题的迭代表达式为</p>
<script type="math/tex; mode=display">
\omega_j^{t+1}=\omega_j^{t}-\eta\sum\limits_{i=1}^N{(\hat y_i-y_i)x_i^{(j)}}</script><hr>
<h2 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h2><p>我们这里使用iris数据集(sklearn库中自带)，这里面有150个训练样例，4个feature, 总共分3类。我们只考虑了前2个feature，这么做是为了在二维图中展示分类结果。并且将类别2和类别3划分为同一类别，这样我们考虑的是一个二分类问题。</p>
<p>图2给出了使用梯度下降法时，误差的收敛情况。这里我们假设学习率 $\eta=1e^{-3}$，算法差不多需要迭代3000次左右收敛。</p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20200414/20200414_fig002.jpg" width="400" height="300" title="图2" alt="图2" ></p>
<p>在这150个样例中，我们取出第25,75,125个样例作为测试样例(其label分别为0,1,1)，其他147个作为训练样例。下图为测试结果：</p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20200414/20200414_fig003.jpg" width="500" height="150" title="图3" alt="图3" ></p>
<p>图4给出了这3三个测试样例的预测结果，其输出$\hat y$就是这3个测试样例属于类别 $1$ 的概率。当$\hat y&gt;0.5$时，判别为$1$，否则判别为$0$。图5更加直观地显示了图4的判别结果。其中，空心方块即为我们要预测的点，颜色代表所处类别，红色为类别$0$，蓝色为类别$1$，可见，我们对于这个三个点的预测正确。</p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20200414/20200414_fig004.jpg" width="400" height="300" title="图4" alt="图4" ></p>
<hr>
<h2 id="附录："><a href="#附录：" class="headerlink" title="附录："></a>附录：</h2><p>这里我们给出图1-图4的Python源代码</p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        图1的python源代码:
    </div>
    <div class='spoiler-content'>
        <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time : 2020/4/12 14:52</span></span><br><span class="line"><span class="comment"># @Author : tengweitw</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># Set the format of labels</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">LabelFormat</span><span class="params">(plt)</span>:</span></span><br><span class="line">    ax = plt.gca()</span><br><span class="line">    plt.tick_params(labelsize=<span class="number">14</span>)</span><br><span class="line">    labels = ax.get_xticklabels() + ax.get_yticklabels()</span><br><span class="line">    [label.set_fontname(<span class="string">'Times New Roman'</span>) <span class="keyword">for</span> label <span class="keyword">in</span> labels]</span><br><span class="line">    font = &#123;<span class="string">'family'</span>: <span class="string">'Times New Roman'</span>,</span><br><span class="line">            <span class="string">'weight'</span>: <span class="string">'normal'</span>,</span><br><span class="line">            <span class="string">'size'</span>: <span class="number">16</span>,</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="keyword">return</span> font</span><br><span class="line"></span><br><span class="line">x=np.linspace(<span class="number">-10</span>,<span class="number">10</span>,<span class="number">100</span>)</span><br><span class="line">y=<span class="number">1</span>/(<span class="number">1</span>+np.exp(-x))</span><br><span class="line"></span><br><span class="line">x_train0=np.array([<span class="number">-10</span>,<span class="number">-7.5</span>,<span class="number">-5</span>])</span><br><span class="line">y_train0=np.array([<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>])</span><br><span class="line">x_train1=np.array([<span class="number">5</span>,<span class="number">7.5</span>,<span class="number">10</span>])</span><br><span class="line">y_train1=np.array([<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">plt.figure()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p1,=plt.plot(x,y,<span class="string">'k-'</span>)</span><br><span class="line">p2,=plt.plot([<span class="number">-7.5</span>,<span class="number">7.5</span>],[<span class="number">0</span>,<span class="number">1</span>],<span class="string">'k--'</span>)</span><br><span class="line">p3=plt.scatter(x_train0,y_train0,marker = <span class="string">'o'</span>, color=<span class="string">'r'</span>)</span><br><span class="line">p4=plt.scatter(x_train1,y_train1,marker = <span class="string">'D'</span>, color=<span class="string">'r'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Set the labels</span></span><br><span class="line">font = LabelFormat(plt)</span><br><span class="line">plt.xlabel(<span class="string">'$x$'</span>, font)</span><br><span class="line">plt.ylabel(<span class="string">'$\hat y$'</span>, font)</span><br><span class="line"></span><br><span class="line">plt.yticks([<span class="number">0</span>,<span class="number">0.25</span>,<span class="number">0.5</span>,<span class="number">0.75</span>,<span class="number">1.0</span>])</span><br><span class="line">plt.grid()</span><br><span class="line">l1=plt.legend([p1,p2],[<span class="string">'$\hat y=\\frac&#123;1&#125;&#123;1+e^&#123;-x&#125;&#125;$'</span>,<span class="string">'$\hat y=x$'</span>], loc=<span class="string">'upper left'</span>,fontsize=<span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">l2=plt.legend([p3,p4],[<span class="string">'Positive instances'</span>,<span class="string">'Negative instances'</span>], loc=<span class="string">'lower right'</span>,fontsize=<span class="number">14</span>, scatterpoints=<span class="number">1</span>)</span><br><span class="line">plt.gca().add_artist(l1)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

    </div>
</div>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        图2-4的python源代码:
    </div>
    <div class='spoiler-content'>
        <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time : 2020/4/13 15:24</span></span><br><span class="line"><span class="comment"># @Author : tengweitw</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> matplotlib.colors <span class="keyword">import</span> ListedColormap</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span>  datasets</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create color maps for three types of labels</span></span><br><span class="line">cmap_light = ListedColormap([<span class="string">'tomato'</span>, <span class="string">'limegreen'</span>, <span class="string">'cornflowerblue'</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># Set the format of labels</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">LabelFormat</span><span class="params">(plt)</span>:</span></span><br><span class="line">    ax = plt.gca()</span><br><span class="line">    plt.tick_params(labelsize=<span class="number">14</span>)</span><br><span class="line">    labels = ax.get_xticklabels() + ax.get_yticklabels()</span><br><span class="line">    [label.set_fontname(<span class="string">'Times New Roman'</span>) <span class="keyword">for</span> label <span class="keyword">in</span> labels]</span><br><span class="line">    font = &#123;<span class="string">'family'</span>: <span class="string">'Times New Roman'</span>,</span><br><span class="line">             <span class="string">'weight'</span>: <span class="string">'normal'</span>,</span><br><span class="line">             <span class="string">'size'</span>: <span class="number">16</span>,</span><br><span class="line">             &#125;</span><br><span class="line">    <span class="keyword">return</span> font</span><br><span class="line"></span><br><span class="line"><span class="comment"># Plot the training points: different</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">PlotTrainPoint</span><span class="params">(train_data,train_target)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(train_target)):</span><br><span class="line">        <span class="keyword">if</span> train_target[i] == <span class="number">0</span>:</span><br><span class="line">            plt.plot(train_data[i][<span class="number">0</span>], train_data[i][<span class="number">1</span>], <span class="string">'rs'</span>, markersize=<span class="number">6</span>, markerfacecolor=<span class="string">"r"</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            plt.plot(train_data[i][<span class="number">0</span>], train_data[i][<span class="number">1</span>], <span class="string">'bs'</span>, markersize=<span class="number">6</span>, markerfacecolor=<span class="string">"b"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">PlotTestPoint</span><span class="params">(test_data,test_target,y_predict_test)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(test_target)):</span><br><span class="line">        <span class="keyword">if</span> test_target[i] == <span class="number">0</span>:</span><br><span class="line">            plt.plot(test_data[i][<span class="number">0</span>], test_data[i][<span class="number">1</span>], <span class="string">'rs'</span>, markerfacecolor=<span class="string">'none'</span>, markersize=<span class="number">6</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            plt.plot(test_data[i][<span class="number">0</span>], test_data[i][<span class="number">1</span>], <span class="string">'bs'</span>, markersize=<span class="number">6</span>, markerfacecolor=<span class="string">"none"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Logistic_regression_gradient_descend</span><span class="params">(train_data, train_target, test_data, test_target)</span>:</span></span><br><span class="line">    <span class="comment"># learning rate</span></span><br><span class="line">    eta = <span class="number">1e-3</span></span><br><span class="line">    M = np.size(train_data, <span class="number">1</span>)</span><br><span class="line">    N = np.size(train_data, <span class="number">0</span>)</span><br><span class="line">    w_bar = np.zeros((M + <span class="number">1</span>, <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># the 1st column is 1 i.e., x_0=1</span></span><br><span class="line">    temp = np.ones([N, <span class="number">1</span>])</span><br><span class="line">    <span class="comment"># X is a N*(1+M)-dim matrix</span></span><br><span class="line">    X = np.concatenate((temp, train_data), axis=<span class="number">1</span>)</span><br><span class="line">    train_target = np.mat(train_target).T</span><br><span class="line"></span><br><span class="line">    iter = <span class="number">0</span></span><br><span class="line">    num_iter = <span class="number">3000</span></span><br><span class="line">    E_train = np.zeros((num_iter, <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> iter &lt; num_iter:</span><br><span class="line">        <span class="comment"># Predicting training data</span></span><br><span class="line">        z = np.matmul(X, w_bar)</span><br><span class="line">        y_predict_train = <span class="number">1</span> / (<span class="number">1</span> + np.exp(-z))</span><br><span class="line">        <span class="comment"># Update w</span></span><br><span class="line">        temp = np.matmul(X.T, y_predict_train - train_target)</span><br><span class="line">        w_bar = w_bar - eta * temp</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Training Error</span></span><br><span class="line">        E=<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(train_target)):</span><br><span class="line">            <span class="comment"># print(y_predict_train[i])</span></span><br><span class="line">            E=E-train_target[i]*np.log(y_predict_train[i])-(<span class="number">1</span>-train_target[i])*np.log(<span class="number">1</span>-y_predict_train[i])</span><br><span class="line">        E_train[iter] = E</span><br><span class="line">        iter += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Predicting</span></span><br><span class="line">    x0 = np.ones((np.size(test_data, <span class="number">0</span>), <span class="number">1</span>))</span><br><span class="line">    test_data1 = np.concatenate((x0, test_data), axis=<span class="number">1</span>)</span><br><span class="line">    y_predict_test_temp = np.matmul(test_data1, w_bar)</span><br><span class="line"></span><br><span class="line">    y_predict_test=<span class="number">1</span>/(<span class="number">1</span>+np.exp(-y_predict_test_temp))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> y_predict_test,E_train,w_bar</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># import dataset of iris</span></span><br><span class="line">iris = datasets.load_iris()</span><br><span class="line"></span><br><span class="line"><span class="comment"># The first two-dim feature for simplicity</span></span><br><span class="line">data = iris.data[:, :<span class="number">2</span>]</span><br><span class="line"><span class="comment"># The labels</span></span><br><span class="line">label = iris.target</span><br><span class="line"></span><br><span class="line"><span class="comment"># Group 2 and 3 as one group, and label them as 1</span></span><br><span class="line">label[<span class="number">50</span>:]=<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Choose the 25,75,125th instance as testing points</span></span><br><span class="line">test_data = [data[<span class="number">25</span>, :], data[<span class="number">75</span>, :], data[<span class="number">125</span>, :]]</span><br><span class="line">test_target = label[[<span class="number">25</span>, <span class="number">75</span>, <span class="number">125</span>]]</span><br><span class="line"></span><br><span class="line">data = np.delete(data, [<span class="number">25</span>, <span class="number">75</span>, <span class="number">125</span>], axis=<span class="number">0</span>)</span><br><span class="line">label = np.delete(label, [<span class="number">25</span>, <span class="number">75</span>, <span class="number">125</span>], axis=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">train_data = data</span><br><span class="line">train_target = label</span><br><span class="line"></span><br><span class="line">y_predict_test,E_train,w_bar=Logistic_regression_gradient_descend(train_data, train_target, test_data, test_target)</span><br><span class="line">print(<span class="string">'The probability of being class 1 is: '</span>)</span><br><span class="line">print(y_predict_test)</span><br><span class="line"></span><br><span class="line">plt.figure()</span><br><span class="line">plt.plot(E_train, <span class="string">'r-'</span>)</span><br><span class="line"><span class="comment"># Set the labels</span></span><br><span class="line">font = LabelFormat(plt)</span><br><span class="line">plt.xlabel(<span class="string">'Iteration'</span>, font)</span><br><span class="line">plt.ylabel(<span class="string">'Error'</span>, font)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line">plt.figure()</span><br><span class="line">PlotTrainPoint(train_data,train_target)</span><br><span class="line">PlotTestPoint(test_data,test_target,y_predict_test)</span><br><span class="line">font = LabelFormat(plt)</span><br><span class="line">plt.xlabel(<span class="string">'$x^&#123;(1)&#125;$'</span>, font)</span><br><span class="line">plt.ylabel(<span class="string">'$x^&#123;(2)&#125;$'</span>, font)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

    </div>
</div>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>Machine Learning</tag>
      </tags>
  </entry>
  <entry>
    <title>【图解例说机器学习】线性回归</title>
    <url>/2020/04/06/%5B20200406%5D/</url>
    <content><![CDATA[<blockquote>
<p>线性回归之于机器学习，正如Hello World之于编程语言，也如MINST之于深度学习。</p>
</blockquote>
<p>首先，我们先定义一些即将用到的数学符号：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">Notations</th>
<th style="text-align:left">Meaning</th>
<th style="text-align:center">Notations</th>
<th>Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">$M$</td>
<td style="text-align:left">Number of parameters $\mathrm w$</td>
<td style="text-align:center">$N$</td>
<td>Number of instances</td>
</tr>
<tr>
<td style="text-align:center">$\mathrm X={\mathrm x_1,\mathrm x_2,\cdots,\mathrm x_N}^{\mathrm T}$</td>
<td style="text-align:left">$N\times M$ matrix for training</td>
<td style="text-align:center">$D$</td>
<td>Number of features</td>
</tr>
<tr>
<td style="text-align:center">$\mathrm y={y_1,y_2,\cdots,y_N}^\mathrm{T}$</td>
<td style="text-align:left">Set of  targets</td>
<td style="text-align:center">$y_i$</td>
<td>Target of instance $i$</td>
</tr>
<tr>
<td style="text-align:center">$\mathrm{x}_i={x_i^{(1)},x_i^{(2)},\cdots,x_i^{(D)}}^\mathrm{T}$</td>
<td style="text-align:left">Set of features  for instance $i$</td>
<td style="text-align:center">$x_i^{(j)}$</td>
<td>Feature $j$ for instance $i$</td>
</tr>
<tr>
<td style="text-align:center">$\mathrm w={\omega_1,\omega_2,\cdots,\omega_M}^\mathrm{T}$</td>
<td style="text-align:left">Weights of input $\mathrm x$</td>
<td style="text-align:center">$\omega_i$</td>
<td>Weight of  feature $i$</td>
</tr>
<tr>
<td style="text-align:center">$\phi={\phi_1,\phi_2,\cdots,\phi_M}^\mathrm{T}$</td>
<td style="text-align:left">Set of functions</td>
<td style="text-align:center">$\phi_i(\mathrm x)$</td>
<td>Function of features</td>
</tr>
</tbody>
</table>
</div>
<hr>
<a id="more"></a>
<h2 id="模型描述"><a href="#模型描述" class="headerlink" title="模型描述"></a>模型描述</h2><p>在线性回归中，假设目标值与<strong>参数</strong> $\mathrm{w}={\omega_n}$之间<strong>线性相关</strong>，通过构建<strong>损失函数</strong>$E$，求解损失函数最小时的参数。也就是说，线性回归试图学习得到如下函数：</p>
<script type="math/tex; mode=display">
\hat y=\omega_0+\sum\limits_{j=1}^{M}\omega_j\phi_j(\mathrm x)=\omega_0+\mathrm w^{\mathrm T}\phi(\mathrm x)\tag{1}</script><p>公式(1)是线性回归模型的一般形式，看起来不是那么直观。其常见的形式如下：</p>
<ul>
<li><p>当$D=1,\phi_j(x)=x^j$时，公式(1)可以表示为：</p>
<script type="math/tex; mode=display">
\hat y=\omega_0+\omega_1x+\omega_2x^2+\cdots+\omega_Mx^M\tag{2}</script><p>此时，线性回归就变成了多项式回归。</p>
</li>
<li><p>当$D=M,\phi_j(\mathrm x)=x^{(j)}$时，公式(1)可以表示为：</p>
<script type="math/tex; mode=display">
\hat y=\omega_0+\omega_1x^{(1)}+\omega_2x^{(2)}+\cdots+\omega_Mx^{(M)}\tag{3}</script><p>此时，线性回归就变成了我们通常所说的线性回归—-多元一次方程。当只有一维特征($M=1$) 时，可以得到我们初中就学过的一元一次方程</p>
</li>
</ul>
<script type="math/tex; mode=display">
\hat y=\omega_1x+\omega_0\tag{4}</script><p>为使本文通俗易懂，除非作特别说明，本文仿真都以这个一元一次方程为例介绍线性回归</p>
<hr>
<h2 id="代价函数"><a href="#代价函数" class="headerlink" title="代价函数"></a>代价函数</h2><p>线性回归的目的就是使得我们预测得到的$\hat y$与真实值$y$之间的误差最小。这里的误差可以用不同的<a href="https://blog.csdn.net/tengweitw/article/details/103950425" target="_blank" rel="noopener">距离度量</a>，这里我们使用平方和。此时，代价函数就可以表示为</p>
<script type="math/tex; mode=display">
E=\sum\limits_{i=1}^N{(\hat y_i-y_i)^2}=\sum\limits_{i=1}^N{(\omega_0+\mathrm w^{\mathrm T}\phi(\mathrm x_i)-y_i)^2}=\sum\limits_{i=1}^{N}{[\omega_0+\sum\limits_{j=1}^{M}{\omega_j\phi_j(\mathrm{x}_i)-y_i]^2}}\tag{5}</script><p>下面我们在二维空间($M=1$)和三维空间($M=2$)画出代价函数图像。这里我们假定$\phi_i(\mathrm x)=x^{(i)}$，$\omega_0,\omega_1,\omega_2$已知，则公式(1)可以分别表示为：</p>
<script type="math/tex; mode=display">
\hat y=\omega_0+\omega_1x^{(1)}\tag{6}</script><script type="math/tex; mode=display">
\hat y=\omega_0+\omega_1x^{(1)}+\omega_2x^{(2)}\tag{7}</script><p>根据公式(6),(7)，我们可以得到图1和图2中的直线和二维平面：</p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20200406/20200406_fig001.jpg" width="600" height="450" title="图1" alt="图1" ></p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20200406/20200406_fig002.jpg" width="600" height="450" title="图2" alt="图2" ></p>
<p>图1和图2中的红色的点是 $\mathrm x$ 对应的真实值 $\mathrm y$ ，红色线段即为误差值。</p>
<hr>
<h2 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h2><p>图1和图2展示的是给定参数$\omega_0,\omega_1,\omega_2$下的真实值$y$与预测值$\hat { y}$的误差。不同的参数可以得到不同的误差值，线性回归的目的就是寻找一组参数是的误差最小。下面我们通过图3和图4来说明：</p>
<p>我们假设训练集有3组数据$(x, y)$：$(1, 0.8) (2, 2) (3, 3.1)$ 。我们这里使用一元线性回归，即公式(6)，此时线性回归的目的就是找到一条直线$\hat y=\omega_1x+\omega_0$使得这3组数据点离直线最近。 </p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20200406/20200406_fig003.jpg" width="600" height="450" title="图3" alt="图3" ></p>
<p>图3画出了当$\omega_0=0,\omega_1=0.5\sim1.5$时，直线$\hat y=\omega_1x+\omega_0$的图像。图4给出了当$\omega_1$取不同值时，代价函数值的变化。从图3和图4可以看出，当$\omega_1=1$时，代价最小。 </p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20200406/20200406_fig004.jpg" width="600" height="450" title="图4" alt="图4" ></p>
<hr>
<h2 id="正规方程与梯度下降"><a href="#正规方程与梯度下降" class="headerlink" title="正规方程与梯度下降"></a>正规方程与梯度下降</h2><p>线性回归的本质就是解如下优化问题：</p>
<script type="math/tex; mode=display">
\min\limits_{\mathrm w}\quad E=\sum\limits_{i=1}^{N}{[\omega_0+\sum\limits_{j=1}^{M}{\omega_j\phi_j(\mathrm{x}_i)-y_i]^2}}\tag{8}</script><p>令$\bar{\mathrm w}={\omega_0,\mathrm w},\bar{\phi}={\phi_0,\phi},\phi_0(\mathrm x)=1$，并将问题(8)表示成向量相乘的形式：</p>
<script type="math/tex; mode=display">
\min\limits_{\mathrm {\bar w}}\quad E=[\bar\phi(\mathrm X)\mathrm{\bar w}-\mathrm y]^{\mathrm T}[\bar\phi(\mathrm X)\mathrm{\bar w}-\mathrm y]\tag{9}</script><p>公式(9)中，$\bar{\phi}(\mathrm X)$是一个$N\times M+1$维的矩阵:</p>
<script type="math/tex; mode=display">
\bar\phi(\mathrm X)=
\left\{\begin{matrix}
   \phi_0(\mathrm x_1) & \phi_1(\mathrm x_1) & \cdots & \phi_M(\mathrm x_1)\\
   \phi_0(\mathrm x_2) & \phi_1(\mathrm x_2) & \cdots & \phi_M(\mathrm x_2)\\
   \vdots & \vdots & \cdots &\vdots \\
   \phi_0(\mathrm x_N) & \phi_1(\mathrm x_N) & \cdots & \phi_M(\mathrm x_N)
  \end{matrix} 
  \right\}\tag{10}</script><p>通过求表达式(8)的Hessian矩阵，可以知道这是一个凸优化问题。那么问题就变得十分简单了，可以用现成的工具来求解：比如CVX, CPLEX, MATLAB等等。这些解法器一般都是通过梯度法(后面会讲解)来求解问题的。当然我们也可以通过凸问题的性质，得到其解析解。</p>
<hr>
<h4 id="正规方程法"><a href="#正规方程法" class="headerlink" title="正规方程法"></a>正规方程法</h4><p>由于误差函数(8)是一个凸函数，所以其导数为0的点就是最优点。为此，我们将$E$对$\mathrm{\bar w}$进行微分求导入下：</p>
<script type="math/tex; mode=display">
\frac{\partial{E}}{\partial{\mathrm{\bar w}}}=\bar\phi^{\mathrm T}(X)[\bar\phi(\mathrm X)\mathrm{\bar w}-\mathrm y]=0\tag{11}</script><script type="math/tex; mode=display">
\bar\phi^{\mathrm T}(X)\bar\phi(\mathrm X)\mathrm{\bar w}=\bar\phi^{\mathrm T}(\mathrm X)\mathrm y\rightarrow\mathrm{\bar w}=[\bar\phi^{\mathrm T}(X)\bar\phi(\mathrm X)]^{-1}\bar\phi^{\mathrm T}(\mathrm X)\mathrm y\tag{12}</script><p>由公式(11)可知，给定训练数据$\mathrm X$，我们就可以求出最佳的$\mathrm{\bar w}$。需要注意的是，这里需要求矩阵的逆，计算量比较大，不适合当训练数据较大的情况。这时我们可以通过梯度下降法来求解。</p>
<hr>
<h4 id="梯度下降法"><a href="#梯度下降法" class="headerlink" title="梯度下降法"></a>梯度下降法</h4><p>使用梯度下降法，可以对凸问题求得最优解，对非凸问题，可以找到局部最优解。梯度下降法的算法思想如下图5和图6所示：</p>
<ul>
<li>在左图(图5)中，梯度为$\frac{d\hat y}{d x}=x-2$。当$x<2$时，梯度小于零，此时$x$应当向右移动来减小函数值(负梯度方向)；当$x>2$时，梯度大于零，此时$x$应当向左移动来减小函数值(负梯度方向)。<br><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20200406/20200406_fig005.jpg" width="600" height="450" title="图5" alt="图5" ></li>
<li>在右图(图6)中，函数不是凸函数的情况下，使用梯度下降法会得到局部最优解(假定初始值为$x=0$)。当初始值$x=7$时，我们可以得到最优解。因此，初始值对梯度下降法影响较大，我们可以通过随机选择初始值来克服陷入局部最优解的情况。<br><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20200406/20200406_fig006.jpg" width="600" height="450" title="图6" alt="图6" ></li>
</ul>
<p>根据(10)得到的梯度表达式，梯度下降的每一次迭代过程如下：</p>
<script type="math/tex; mode=display">
\bar{\mathrm w}^{t+1}=\bar{\mathrm w}^{t}-\eta\frac{\partial{E}}{\partial{\mathrm{\bar w}}}=\bar{\mathrm w}^{t}-\eta\bar\phi^{\mathrm T}(X)[\bar\phi(\mathrm X)\mathrm{\bar w}-\mathrm y]\tag{13}</script><p>将公式(13)的矩阵相乘展开可以得到</p>
<script type="math/tex; mode=display">
\omega_j^{t+1}=\omega_j^t-\eta\sum\limits_{i=1}^{N}{[\omega_0+\sum\limits_{j=1}^{M}{\omega_j\phi_j(\mathrm{x}_i)-y_i]}\phi_j(\mathrm x_i)}\tag{14}</script><p>公式(13)或(14)就是标准的梯度下降法，其中$\eta$是每次迭代的步长大小。</p>
<ul>
<li>$\eta$较小时，迭代较慢，当时可以保证收敛到最优解(凸函数的情况下)；$\eta$较大时，函数值下降较快，但容易发生震荡。</li>
<li>每次迭代时，需要使用所有的样本点$\mathrm x_i,i=1,2,\cdots,N$。当数据样本点非常大时，开销十分大。</li>
</ul>
<p>为此，有人提出了<strong>随机梯度下降</strong>，其迭代公式如下：</p>
<script type="math/tex; mode=display">
\omega_j^{t+1}=\omega_j^t-\eta{[\omega_0+\sum\limits_{j=1}^{M}{\omega_j\phi_j(\mathrm{x_i})-y_i]}\phi_j(\mathrm x_i)}\tag{15}</script><p>随机梯度下降又称连续梯度下降，比较适合于实时系统，即整个数据集$\mathrm x_i$不是可以一次性获得的，但是我们需要作出预测的场景。相较于梯度下降法(14)，随机梯度只根据当前样本更新迭代，随机性较大。因此有可能跳出标准梯度下降法的局部最优解。</p>
<hr>
<h2 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h2><p>这里我们使用sklearn中波士顿房价的数据集，该数据集有13维特征，506个样例。为简便起见，我们只取前2维特征作为输入($M=D=2,\hat y=\omega_0+\omega_1<em>x^{(1)}+\omega_2</em>x^{(2)}$)，前500个作为输入样例，后6个作为预测样例。在算法实现中，我们分别考虑了<strong>正规方程法</strong>和<strong>梯度下降法</strong>。并且，考虑到$x^{(1)}$和$x^{(2)}$的取值范围差距较大，我们还考虑了<strong>特征值缩放</strong>。为此，我们实现了上述四种算法的组合[特征不缩放(特征缩放)+正规方程法(梯度下降法)]。</p>
<hr>
<h4 id="算法结果"><a href="#算法结果" class="headerlink" title="算法结果"></a>算法结果</h4><p>图7给出了上述4种算法的结果：</p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20200406/20200406_fig007.jpg" width="600" height="550" title="图7" alt="图7" ></p>
<p>图7中，E_train为训练误差，即前500个样例的真实值与预测值的误差，E_test为预测误差，即最后6个样例的真实值与预测值的误差。由于误差函数对于参数w是凸函数，我们总能得到最优解，即最小的训练误差，所以上述四种方法的训练误差相同。</p>
<hr>
<h4 id="特征缩放与梯度下降法"><a href="#特征缩放与梯度下降法" class="headerlink" title="特征缩放与梯度下降法"></a>特征缩放与梯度下降法</h4><p>图7能得到最小误差函数值，是因为目标函数$E$是参数$\omega_1$和$\omega_2$的凸函数。为方便起见，对于具体实例，我们给出$E$的表达式：</p>
<script type="math/tex; mode=display">
E(\omega_0,\omega_1,\omega_2)=\sum\limits_{i=1}^{500}(\omega_0+\omega_1*x^{(1)}+\omega_2*x^{(2)}-y_i)^2\tag{16}</script><p>公式(16)中，$\omega_0$与具体样例无关，$\omega_0$的值不改变$E$的图像形状，改变$\omega_0$相当于进行位移，我们这里假定$\omega_0=0$。为此，当给定波士顿房价数据集，即$x^{(1)},x^{(2)},y_i$ 给定时，我们可以画出公式(16)对应的等高线图，图8。</p>
<ul>
<li><p>从图8可以看出，当改变$\omega_2$时，$E$变的较快(等高线在$\omega_2$方向较为稀疏)。这是因为$\omega_2$的系数为$x^{(2)}$，而$x^{(2)}$相对于$x^{(1)}$有较大的取值。在这种情况下，对梯度下降法就十分不友好—很容易跳过最优解。也就是说，步长设置要十分小，这就会导致收敛速度慢。在我们这个实例中，步长最大只能设置为$\eta=5e^{-6}$，此时需要差不多30000次迭代才能收敛到最优，如图10所示。<br><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20200406/20200406_fig008.jpg" width="600" height="450" title="图8" alt="图8" ></p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20200406/20200406_fig009.jpg" width="600" height="450" title="图9" alt="图9" ></p>
</li>
<li><p>特征缩放是一种解决上述情况下，梯度下降法收敛慢的方法。特征缩放的表达式都十分简单，这里不再赘述，我们这里是直接使用的sklearn库中的preprocessing.StandardScaler()函数对样例进行特征缩放。对$x^{(1)},x^{(2)}$缩放后，我们可以用相同的方式画出对应的等高线图，图9，以及收敛图，图11。经过特征缩放后，图9中等高线在$\omega_1,\omega_2$方向上的稀疏程度差不多。图11中，步长可以设置得较大($\eta=1e^{-3}$)，收敛速度变得极快，只需要迭代8次左右就达到最优。<br><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20200406/20200406_fig010.jpg" width="600" height="450" title="图10" alt="图10" ></p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20200406/20200406_fig011.jpg" width="600" height="450" title="图11" alt="图11" ></p>
<hr>
<h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><p>下面给出图1—图11的Python源代码如下：</p>
<ul>
<li><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        图1和图2的python源代码:
    </div>
    <div class='spoiler-content'>
        <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> mpl_toolkits.mplot3d <span class="keyword">import</span> Axes3D</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Set the format of labels</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">LabelFormat</span><span class="params">(plt)</span>:</span></span><br><span class="line">    ax = plt.gca()</span><br><span class="line">    plt.tick_params(labelsize=<span class="number">14</span>)</span><br><span class="line">    labels = ax.get_xticklabels() + ax.get_yticklabels()</span><br><span class="line">    [label.set_fontname(<span class="string">'Times New Roman'</span>) <span class="keyword">for</span> label <span class="keyword">in</span> labels]</span><br><span class="line">    font = &#123;<span class="string">'family'</span>: <span class="string">'Times New Roman'</span>,</span><br><span class="line">            <span class="string">'weight'</span>: <span class="string">'normal'</span>,</span><br><span class="line">            <span class="string">'size'</span>: <span class="number">16</span>,</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="keyword">return</span> font</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2-d case</span></span><br><span class="line">omega_0 = <span class="number">0</span></span><br><span class="line">omega_1 = <span class="number">1</span></span><br><span class="line">data_train = [[<span class="number">0.5</span>, <span class="number">0.2</span>], [<span class="number">1</span>, <span class="number">0.8</span>], [<span class="number">1.5</span>, <span class="number">1.2</span>], [<span class="number">2</span>, <span class="number">2</span>], [<span class="number">2.5</span>, <span class="number">2.8</span>], [<span class="number">3</span>, <span class="number">3.1</span>], [<span class="number">3.5</span>, <span class="number">3.8</span>]]</span><br><span class="line">x_train = [d[<span class="number">0</span>] <span class="keyword">for</span> d <span class="keyword">in</span> data_train]</span><br><span class="line">y_train = [d[<span class="number">1</span>] <span class="keyword">for</span> d <span class="keyword">in</span> data_train]</span><br><span class="line"></span><br><span class="line">x = np.linspace(<span class="number">0</span>, <span class="number">4</span>, <span class="number">30</span>).reshape(<span class="number">30</span>, <span class="number">1</span>)</span><br><span class="line">y = omega_1 * x + omega_0</span><br><span class="line"></span><br><span class="line">x_test = x_train</span><br><span class="line">y_test = y_train</span><br><span class="line">y_hat = omega_1 * x_test</span><br><span class="line"></span><br><span class="line">plt.figure()</span><br><span class="line">plt.plot(x, y, <span class="string">'k-'</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(x_test)):</span><br><span class="line">    plt.stem([x_test[i], ], [y_test[i], ], linefmt=<span class="string">'rx'</span>, bottom=y_hat[i], basefmt=<span class="string">'ko'</span>, markerfmt=<span class="string">'C3o'</span>,</span><br><span class="line">             use_line_collection=<span class="literal">True</span>)</span><br><span class="line"><span class="comment"># Set the labels</span></span><br><span class="line">font = LabelFormat(plt)</span><br><span class="line">plt.xlabel(<span class="string">'$x$'</span>, font)</span><br><span class="line">plt.ylabel(<span class="string">'$\hat y$'</span>, font)</span><br><span class="line">plt.title(<span class="string">'$M=1,\omega_0=0,\omega_1=1$'</span>)</span><br><span class="line">plt.xlim(<span class="number">0</span>, <span class="number">4</span>)</span><br><span class="line">plt.ylim(<span class="number">0</span>, <span class="number">4</span>)</span><br><span class="line">plt.grid()</span><br><span class="line"></span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3-d case</span></span><br><span class="line">omega_0 = <span class="number">2</span></span><br><span class="line">omega_1 = <span class="number">0.25</span></span><br><span class="line">omega_2 = <span class="number">0.5</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">x1 = np.linspace(<span class="number">0</span>, <span class="number">4</span>, <span class="number">30</span>).reshape(<span class="number">30</span>, <span class="number">1</span>)</span><br><span class="line">x2 = np.linspace(<span class="number">0</span>, <span class="number">4</span>, <span class="number">30</span>).reshape(<span class="number">30</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">X1, X2 = np.meshgrid(x1, x2)</span><br><span class="line">y_hat = omega_0 + omega_1 * X1 + omega_2 * X2</span><br><span class="line">fig = plt.figure()</span><br><span class="line">ax = fig.gca(projection=<span class="string">'3d'</span>)</span><br><span class="line"></span><br><span class="line">x1_test=np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line">x2_test=np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line">X1_test, X2_test = np.meshgrid(x1_test, x2_test)</span><br><span class="line"></span><br><span class="line">y_test = omega_0 + omega_1 * X1_test + omega_2 * X2_test+<span class="number">8</span>*np.random.rand(<span class="number">3</span>,<span class="number">3</span>)<span class="number">-4</span></span><br><span class="line"></span><br><span class="line">ax.plot_surface(X1, X2, y_hat, cmap=<span class="string">'rainbow'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(x1_test)):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(len(x2_test)):</span><br><span class="line">        y_predict= omega_0 + omega_1 * x1_test[i] + omega_2 * x2_test[j]</span><br><span class="line">        ax.plot([x1_test[i],x1_test[i]],[x2_test[j],x2_test[j]],[y_test[i][j],y_predict],<span class="string">'r-o'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Set the labels</span></span><br><span class="line">font = LabelFormat(plt)</span><br><span class="line">ax.set_xlabel(<span class="string">'$x^&#123;(1)&#125;$'</span>, font)</span><br><span class="line">ax.set_ylabel(<span class="string">'$x^&#123;(2)&#125;$'</span>, font)</span><br><span class="line">ax.set_zlabel(<span class="string">'$\hat y$'</span>, font)</span><br><span class="line">ax.set_xlim(<span class="number">0</span>, <span class="number">4</span>)</span><br><span class="line">ax.set_ylim(<span class="number">0</span>, <span class="number">4</span>)</span><br><span class="line">ax.set_zlim(<span class="number">0</span>, <span class="number">8</span>)</span><br><span class="line">ax.set_xticks([<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])</span><br><span class="line">ax.set_yticks([<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])</span><br><span class="line">ax.set_title(<span class="string">'$M=2,\omega_0=2,\omega_1=0.25,\omega_2=0.5$'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Customize the view angle so it's easier to see that the scatter points lie</span></span><br><span class="line">ax.view_init(elev=<span class="number">5.</span>, azim=<span class="number">-25</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>



    </div>
</div>
</li>
</ul>
<ul>
<li><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        图3和图4的python源代码:
    </div>
    <div class='spoiler-content'>
        <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> matplotlib.colors <span class="keyword">import</span> ListedColormap</span><br><span class="line"><span class="keyword">import</span> matplotlib <span class="keyword">as</span> mpl</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Set the format of labels</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">LabelFormat</span><span class="params">(plt)</span>:</span></span><br><span class="line">    ax = plt.gca()</span><br><span class="line">    plt.tick_params(labelsize=<span class="number">14</span>)</span><br><span class="line">    labels = ax.get_xticklabels() + ax.get_yticklabels()</span><br><span class="line">    [label.set_fontname(<span class="string">'Times New Roman'</span>) <span class="keyword">for</span> label <span class="keyword">in</span> labels]</span><br><span class="line">    font = &#123;<span class="string">'family'</span>: <span class="string">'Times New Roman'</span>,</span><br><span class="line">             <span class="string">'weight'</span>: <span class="string">'normal'</span>,</span><br><span class="line">             <span class="string">'size'</span>: <span class="number">16</span>,</span><br><span class="line">             &#125;</span><br><span class="line">    <span class="keyword">return</span> font</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Plot the training points: different</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">PlotTrainPoint</span><span class="params">(X)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(X)):</span><br><span class="line">        plt.plot(X[i][<span class="number">0</span>], X[i][<span class="number">1</span>], <span class="string">'rs'</span>, markersize=<span class="number">6</span>, markerfacecolor=<span class="string">"r"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Loss function--Square Error function</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">LossFunction</span><span class="params">(Y, predictedY)</span>:</span></span><br><span class="line">    lengthY = len(Y)</span><br><span class="line">    error = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(lengthY):</span><br><span class="line">        error += pow(Y[i] - predictedY[i], <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> math.sqrt(error)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">trainData = [[<span class="number">1</span>, <span class="number">0.8</span>], [<span class="number">2</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">3.1</span>]]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Predicted function: y=\omega_1*x+\omega_0 Here \omega_0 is assumed to be 0 for simplifcity</span></span><br><span class="line"></span><br><span class="line">x = np.linspace(<span class="number">0</span>, <span class="number">4</span>, <span class="number">30</span>).reshape(<span class="number">30</span>, <span class="number">1</span>)</span><br><span class="line">omega_1 = np.linspace(<span class="number">0.5</span>, <span class="number">1.5</span>, <span class="number">41</span>).reshape(<span class="number">41</span>, <span class="number">1</span>)</span><br><span class="line">omega_0 = <span class="number">0</span></span><br><span class="line">y_hat = []</span><br><span class="line"><span class="comment">#Get the value of x and y in the trainData</span></span><br><span class="line">x_train = [d[<span class="number">0</span>] <span class="keyword">for</span> d <span class="keyword">in</span> trainData]</span><br><span class="line">y_train = [d[<span class="number">1</span>] <span class="keyword">for</span> d <span class="keyword">in</span> trainData]</span><br><span class="line">error_all = []</span><br><span class="line"></span><br><span class="line"><span class="comment"># Plot the figure to show the function: y=\omega_1*x+\omega_0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(omega_1)):</span><br><span class="line">    y_hat.append(omega_1[i] * x)</span><br><span class="line">    <span class="keyword">if</span> omega_1[i]==<span class="number">0.5</span>:</span><br><span class="line">        plt.plot(x, y_hat[i],  color=<span class="string">'cyan'</span>, alpha=<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">elif</span> omega_1[i]==<span class="number">1</span>:</span><br><span class="line">        plt.plot(x, y_hat[i], color=<span class="string">'blue'</span>, alpha=<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">elif</span> omega_1[i]==<span class="number">1.5</span>:</span><br><span class="line">        plt.plot(x, y_hat[i], color=<span class="string">'orange'</span>, alpha=<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        plt.plot(x, y_hat[i], color=<span class="string">'black'</span>, alpha=<span class="number">0.3</span>)</span><br><span class="line">    <span class="comment"># Compute the errors for each omega_1</span></span><br><span class="line">    error_all.append(LossFunction(y_train, omega_1[i].T*x_train+omega_0))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Set the axis</span></span><br><span class="line">font=LabelFormat(plt)</span><br><span class="line">PlotTrainPoint(trainData)</span><br><span class="line"><span class="comment"># Label the critical points</span></span><br><span class="line">plt.annotate(<span class="string">'$\omega_1=1.5$'</span>, xy=(<span class="number">2.5</span>, <span class="number">2.5</span>*<span class="number">1.5</span>), xycoords=<span class="string">'data'</span>,</span><br><span class="line">             xytext=(<span class="number">-35</span>, <span class="number">35</span>), textcoords=<span class="string">'offset points'</span>, color=<span class="string">'orange'</span>, fontsize=<span class="number">12</span>, arrowprops=dict(arrowstyle=<span class="string">"-&gt;"</span>,</span><br><span class="line">             connectionstyle=<span class="string">"arc,rad=90"</span>, color=<span class="string">'orange'</span>))</span><br><span class="line">plt.annotate(<span class="string">'$\omega_1=1$'</span>, xy=(<span class="number">2.5</span>, <span class="number">2.5</span>*<span class="number">1</span>), xycoords=<span class="string">'data'</span>,</span><br><span class="line">             xytext=(<span class="number">-45</span>, <span class="number">95</span>), textcoords=<span class="string">'offset points'</span>, color=<span class="string">'b'</span>, fontsize=<span class="number">12</span>, arrowprops=dict(arrowstyle=<span class="string">"-&gt;"</span>,</span><br><span class="line">             connectionstyle=<span class="string">"arc,rad=90"</span>, color=<span class="string">'b'</span>))</span><br><span class="line">plt.annotate(<span class="string">'$\omega_1=0.5$'</span>, xy=(<span class="number">2.5</span>, <span class="number">2.5</span>*<span class="number">0.5</span>), xycoords=<span class="string">'data'</span>,</span><br><span class="line">             xytext=(<span class="number">-75</span>, <span class="number">155</span>), textcoords=<span class="string">'offset points'</span>, color=<span class="string">'cyan'</span>, fontsize=<span class="number">12</span>, arrowprops=dict(arrowstyle=<span class="string">"-&gt;"</span>,</span><br><span class="line">             connectionstyle=<span class="string">"arc,rad=90"</span>, color=<span class="string">'cyan'</span>))</span><br><span class="line"></span><br><span class="line">plt.annotate(<span class="string">'$\omega_1=0.5\sim 1.5$'</span>, xy=(<span class="number">1</span>, <span class="number">2.2</span>), xycoords=<span class="string">'data'</span>,</span><br><span class="line">             xytext=(<span class="number">8</span>, <span class="number">-125</span>), textcoords=<span class="string">'offset points'</span>, color=<span class="string">'k'</span>, fontsize=<span class="number">12</span>, arrowprops=dict(arrowstyle=<span class="string">"-&gt;"</span>,</span><br><span class="line">             connectionstyle=<span class="string">"arc,rad=90"</span>, color=<span class="string">'k'</span>))</span><br><span class="line">plt.xlabel(<span class="string">'$x$'</span>,font)</span><br><span class="line">plt.ylabel(<span class="string">'$\hat y$'</span>,font)</span><br><span class="line">plt.xlim([<span class="number">0</span>,<span class="number">3.2</span>])</span><br><span class="line">plt.ylim([<span class="number">0</span>,<span class="number">4.5</span>])</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Show the error when omega_1 changes</span></span><br><span class="line">plt.figure()</span><br><span class="line">font=LabelFormat(plt)</span><br><span class="line">plt.plot(omega_1,error_all, <span class="string">'k-s'</span>)</span><br><span class="line">error_min=min(error_all)</span><br><span class="line">index_min=error_all.index(error_min)</span><br><span class="line">print(index_min)</span><br><span class="line"><span class="comment"># plot the error at the given three point</span></span><br><span class="line">plt.plot(omega_1[index_min],error_min,<span class="string">'bs'</span>)</span><br><span class="line">plt.plot(omega_1[<span class="number">0</span>],error_all[<span class="number">0</span>],<span class="string">'cyan'</span>,marker=<span class="string">'s'</span>)</span><br><span class="line">plt.plot(omega_1[<span class="number">-1</span>],error_all[<span class="number">-1</span>],<span class="string">'orange'</span>,marker=<span class="string">'s'</span>)</span><br><span class="line"></span><br><span class="line">plt.xlabel(<span class="string">'$\omega_1$'</span>, font)</span><br><span class="line">plt.ylabel(<span class="string">'Value of loss function'</span>, font)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
    </div>
</div>
</li>
<li><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        图5和图6的python源代码:
    </div>
    <div class='spoiler-content'>
        <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># Set the format of labels</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">LabelFormat</span><span class="params">(plt)</span>:</span></span><br><span class="line">    ax = plt.gca()</span><br><span class="line">    plt.tick_params(labelsize=<span class="number">14</span>)</span><br><span class="line">    labels = ax.get_xticklabels() + ax.get_yticklabels()</span><br><span class="line">    [label.set_fontname(<span class="string">'Times New Roman'</span>) <span class="keyword">for</span> label <span class="keyword">in</span> labels]</span><br><span class="line">    font = &#123;<span class="string">'family'</span>: <span class="string">'Times New Roman'</span>,</span><br><span class="line">            <span class="string">'weight'</span>: <span class="string">'normal'</span>,</span><br><span class="line">            <span class="string">'size'</span>: <span class="number">16</span>,</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="keyword">return</span> font</span><br><span class="line"></span><br><span class="line">x = np.linspace(<span class="number">0</span>, <span class="number">4</span>, <span class="number">30</span>).reshape(<span class="number">30</span>, <span class="number">1</span>)</span><br><span class="line">y=(x<span class="number">-2</span>)**<span class="number">2</span>/<span class="number">2</span></span><br><span class="line"></span><br><span class="line">plt.figure()</span><br><span class="line">plt.plot(x,y,<span class="string">'k-'</span>)</span><br><span class="line">plt.plot(<span class="number">3.5</span>,<span class="number">1.5</span>**<span class="number">2</span>/<span class="number">2</span>,<span class="string">'ro'</span>)</span><br><span class="line">plt.annotate(<span class="string">'$\\frac&#123;dE&#125;&#123;dx&#125;$'</span>, xy=(<span class="number">3.5</span>, <span class="number">1.5</span>**<span class="number">2</span>/<span class="number">2</span>), xycoords=<span class="string">'data'</span>,</span><br><span class="line">             xytext=(<span class="number">-60</span>, <span class="number">-125</span>), textcoords=<span class="string">'offset points'</span>,color=<span class="string">'r'</span>, fontsize=<span class="number">14</span>, arrowprops=dict(arrowstyle=<span class="string">"&lt;-"</span>,</span><br><span class="line">             connectionstyle=<span class="string">"arc,rad=90"</span>, color=<span class="string">'r'</span>))</span><br><span class="line"></span><br><span class="line">plt.plot(<span class="number">0.5</span>,<span class="number">1.5</span>**<span class="number">2</span>/<span class="number">2</span>,<span class="string">'ro'</span>)</span><br><span class="line">plt.annotate(<span class="string">'$\\frac&#123;dE&#125;&#123;dx&#125;$'</span>, xy=(<span class="number">0.5</span>, <span class="number">1.5</span>**<span class="number">2</span>/<span class="number">2</span>), xycoords=<span class="string">'data'</span>,</span><br><span class="line">             xytext=(<span class="number">48</span>, <span class="number">-125</span>), textcoords=<span class="string">'offset points'</span>,color=<span class="string">'r'</span>, fontsize=<span class="number">14</span>, arrowprops=dict(arrowstyle=<span class="string">"&lt;-"</span>,</span><br><span class="line">             connectionstyle=<span class="string">"arc,rad=90"</span>, color=<span class="string">'r'</span>))</span><br><span class="line"></span><br><span class="line">plt.annotate(<span class="string">'$\hat y=\\frac&#123;1&#125;&#123;2&#125;(x-2)^2$'</span>, xy=(<span class="number">0.25</span>, <span class="number">1.75</span>**<span class="number">2</span>/<span class="number">2</span>), xycoords=<span class="string">'data'</span>,</span><br><span class="line">             xytext=(<span class="number">108</span>, <span class="number">0</span>), textcoords=<span class="string">'offset points'</span>,color=<span class="string">'k'</span>, fontsize=<span class="number">14</span>, arrowprops=dict(arrowstyle=<span class="string">"&lt;-"</span>,</span><br><span class="line">             connectionstyle=<span class="string">"arc,rad=90"</span>, color=<span class="string">'w'</span>))</span><br><span class="line"><span class="comment"># Set the labels</span></span><br><span class="line">font = LabelFormat(plt)</span><br><span class="line">plt.xlabel(<span class="string">'$x$'</span>, font)</span><br><span class="line">plt.ylabel(<span class="string">'$\hat y$'</span>, font)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"><span class="comment"># To plot figure 6</span></span><br><span class="line">x1 = np.linspace(<span class="number">0</span>, <span class="number">5</span>/<span class="number">4.0</span>*np.pi, <span class="number">50</span>).reshape(<span class="number">50</span>, <span class="number">1</span>)</span><br><span class="line">y1=np.cos(x1)</span><br><span class="line"></span><br><span class="line">x2 = np.linspace(<span class="number">5</span>/<span class="number">4.0</span>*np.pi, <span class="number">8</span>, <span class="number">50</span>).reshape(<span class="number">50</span>, <span class="number">1</span>)</span><br><span class="line">y2=<span class="number">0.5</span>*np.cos(<span class="number">2</span>*x2+<span class="number">1</span>*np.pi)<span class="number">-0.71</span></span><br><span class="line"></span><br><span class="line">plt.figure()</span><br><span class="line">plt.plot(x1,y1,<span class="string">'k-'</span>)</span><br><span class="line">plt.plot(x2,y2,<span class="string">'k-'</span>)</span><br><span class="line">plt.plot(np.pi,<span class="number">-1</span>,<span class="string">'ro'</span>)</span><br><span class="line">plt.annotate(<span class="string">'Local optimal'</span>, xy=(np.pi, <span class="number">-1</span>), xycoords=<span class="string">'data'</span>,</span><br><span class="line">             xytext=(<span class="number">-48</span>, <span class="number">125</span>), textcoords=<span class="string">'offset points'</span>,color=<span class="string">'r'</span>, fontsize=<span class="number">14</span>, arrowprops=dict(arrowstyle=<span class="string">"-&gt;"</span>,</span><br><span class="line">             connectionstyle=<span class="string">"arc,rad=90"</span>, color=<span class="string">'r'</span>))</span><br><span class="line"></span><br><span class="line">plt.plot(np.pi*<span class="number">2</span>,<span class="number">-1.21</span>,<span class="string">'ro'</span>)</span><br><span class="line">plt.annotate(<span class="string">'Global optimal'</span>, xy=(<span class="number">2</span>*np.pi, <span class="number">-1.21</span>), xycoords=<span class="string">'data'</span>,</span><br><span class="line">             xytext=(<span class="number">-48</span>, <span class="number">125</span>), textcoords=<span class="string">'offset points'</span>,color=<span class="string">'r'</span>, fontsize=<span class="number">14</span>, arrowprops=dict(arrowstyle=<span class="string">"-&gt;"</span>,</span><br><span class="line">             connectionstyle=<span class="string">"arc,rad=90"</span>, color=<span class="string">'r'</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Set the labels</span></span><br><span class="line">font = LabelFormat(plt)</span><br><span class="line">plt.xlabel(<span class="string">'$x$'</span>, font)</span><br><span class="line">plt.ylabel(<span class="string">'$\hat y$'</span>, font)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
    </div>
</div>
</li>
<li><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        图7和图11的python源代码:
    </div>
    <div class='spoiler-content'>
        <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time : 2020/4/7 11:28</span></span><br><span class="line"><span class="comment"># @Author : tengweitw</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_boston</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> mpl_toolkits.mplot3d <span class="keyword">import</span> Axes3D</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> preprocessing</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Linear_regression_normal_equation</span><span class="params">(train_data, train_target, test_data, test_target)</span>:</span></span><br><span class="line">    <span class="comment"># the 1st column is 1 i.e., x_0=1</span></span><br><span class="line">    temp = np.ones([np.size(train_data, <span class="number">0</span>), <span class="number">1</span>])</span><br><span class="line">    <span class="comment"># X is a 500*(1+2)-dim matrix</span></span><br><span class="line">    X = np.concatenate((temp, train_data), axis=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Normal equation</span></span><br><span class="line">    w_bar = np.matmul(np.linalg.inv(np.matmul(X.T, X)), np.matmul(X.T, train_target))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Training Error</span></span><br><span class="line">    y_predict_train = np.matmul(X, w_bar)</span><br><span class="line">    E_train = np.linalg.norm(y_predict_train - train_target)/len(y_predict_train)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Predicting</span></span><br><span class="line">    x0 = np.ones((np.size(test_data, <span class="number">0</span>), <span class="number">1</span>))</span><br><span class="line">    test_data1 = np.concatenate((x0, test_data), axis=<span class="number">1</span>)</span><br><span class="line">    y_predict_test = np.matmul(test_data1, w_bar)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Prediction Error</span></span><br><span class="line">    E_test = np.linalg.norm(y_predict_test - test_target)/len(y_predict_test)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> y_predict_test, E_train, E_test</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Linear_regression_normal_equation_scale</span><span class="params">(train_data, train_target, test_data, test_target)</span>:</span></span><br><span class="line">    <span class="comment"># Data processing: scaling</span></span><br><span class="line">    <span class="comment"># For training data</span></span><br><span class="line">    ss = preprocessing.StandardScaler()</span><br><span class="line">    ss.partial_fit(train_data)</span><br><span class="line">    train_data_scale = ss.fit_transform(train_data)</span><br><span class="line">    <span class="comment"># For testing data</span></span><br><span class="line">    ss.partial_fit(test_data)</span><br><span class="line">    test_data_scale = ss.fit_transform(test_data)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># the 1st column is 1 i.e., x_0=1</span></span><br><span class="line">    temp = np.ones([np.size(train_data_scale, <span class="number">0</span>), <span class="number">1</span>])</span><br><span class="line">    <span class="comment"># X is a 500*(1+2)-dim matrix</span></span><br><span class="line">    X = np.concatenate((temp, train_data_scale), axis=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Normal equation</span></span><br><span class="line">    w_bar = np.matmul(np.linalg.inv(np.matmul(X.T, X)), np.matmul(X.T, train_target))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Training Error</span></span><br><span class="line">    y_predict_train = np.matmul(X, w_bar)</span><br><span class="line">    E_train = np.linalg.norm(y_predict_train - train_target) / len(y_predict_train)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Predicting</span></span><br><span class="line">    x0 = np.ones((np.size(test_data_scale, <span class="number">0</span>), <span class="number">1</span>))</span><br><span class="line">    test_data1 = np.concatenate((x0, test_data_scale), axis=<span class="number">1</span>)</span><br><span class="line">    y_predict_test = np.matmul(test_data1, w_bar)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Prediction Error</span></span><br><span class="line">    E_test = np.linalg.norm(y_predict_test - test_target) / len(y_predict_test)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> y_predict_test, E_train, E_test</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Linear_regression_gradient_descend</span><span class="params">(train_data, train_target, test_data, test_target)</span>:</span></span><br><span class="line">    <span class="comment"># learning rate</span></span><br><span class="line">    eta = <span class="number">5e-6</span></span><br><span class="line">    M = np.size(train_data, <span class="number">1</span>)</span><br><span class="line">    N = np.size(train_data, <span class="number">0</span>)</span><br><span class="line">    w_bar = np.zeros((M + <span class="number">1</span>, <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># the 1st column is 1 i.e., x_0=1</span></span><br><span class="line">    temp = np.ones([N, <span class="number">1</span>])</span><br><span class="line">    <span class="comment"># X is a N*(1+M)-dim matrix</span></span><br><span class="line">    X = np.concatenate((temp, train_data), axis=<span class="number">1</span>)</span><br><span class="line">    train_target = np.mat(train_target).T</span><br><span class="line"></span><br><span class="line">    iter = <span class="number">0</span></span><br><span class="line">    num_iter = <span class="number">5000</span></span><br><span class="line">    E_train = np.zeros((num_iter, <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> iter &lt; num_iter:</span><br><span class="line">        temp = np.matmul(X, w_bar) - train_target</span><br><span class="line">        w_bar = w_bar - eta * np.matmul(X.T, temp)</span><br><span class="line">        <span class="comment"># Predicting training data</span></span><br><span class="line">        y_predict_train = np.matmul(X, w_bar)</span><br><span class="line">        <span class="comment"># Training Error</span></span><br><span class="line">        E_train[iter]=np.linalg.norm(y_predict_train - train_target)/len(y_predict_train)</span><br><span class="line">        iter += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Predicting</span></span><br><span class="line">    x0 = np.ones((np.size(test_data, <span class="number">0</span>), <span class="number">1</span>))</span><br><span class="line">    test_data1 = np.concatenate((x0, test_data), axis=<span class="number">1</span>)</span><br><span class="line">    y_predict_test = np.matmul(test_data1, w_bar)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Prediction Error</span></span><br><span class="line">    E_test = np.linalg.norm(y_predict_test.ravel()- test_target)/len(y_predict_test)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> y_predict_test, E_train, E_test</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Linear_regression_gradient_descend_scale</span><span class="params">(train_data, train_target, test_data, test_target)</span>:</span></span><br><span class="line">    <span class="comment"># Data processing: scaling</span></span><br><span class="line">    <span class="comment"># For training data</span></span><br><span class="line">    ss = preprocessing.StandardScaler()</span><br><span class="line">    ss.partial_fit(train_data)</span><br><span class="line">    train_data_scale = ss.fit_transform(train_data)</span><br><span class="line">    <span class="comment"># For testing data</span></span><br><span class="line">    ss.partial_fit(test_data)</span><br><span class="line">    test_data_scale = ss.fit_transform(test_data)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># learning rate</span></span><br><span class="line">    eta = <span class="number">1e-3</span></span><br><span class="line">    M = np.size(train_data_scale, <span class="number">1</span>)</span><br><span class="line">    N = np.size(train_data_scale, <span class="number">0</span>)</span><br><span class="line">    w_bar = np.zeros((M + <span class="number">1</span>, <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># the 1st column is 1 i.e., x_0=1</span></span><br><span class="line">    temp = np.ones([N, <span class="number">1</span>])</span><br><span class="line">    <span class="comment"># X is a N*(1+M)-dim matrix</span></span><br><span class="line">    X = np.concatenate((temp, train_data_scale), axis=<span class="number">1</span>)</span><br><span class="line">    train_target = np.mat(train_target).T</span><br><span class="line"></span><br><span class="line">    iter = <span class="number">0</span></span><br><span class="line">    num_iter = <span class="number">10</span></span><br><span class="line">    E_train = np.zeros((num_iter, <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> iter &lt; num_iter:</span><br><span class="line">        temp = np.matmul(X, w_bar) - train_target</span><br><span class="line">        w_bar = w_bar - eta * np.matmul(X.T, temp)</span><br><span class="line">        <span class="comment"># Predicting training data</span></span><br><span class="line">        y_predict_train = np.matmul(X, w_bar)</span><br><span class="line">        <span class="comment"># Training Error</span></span><br><span class="line">        E_train[iter]=np.linalg.norm(y_predict_train - train_target)/len(y_predict_train)</span><br><span class="line">        iter += <span class="number">1</span></span><br><span class="line">    <span class="comment"># Predicting</span></span><br><span class="line">    x0 = np.ones((np.size(test_data_scale, <span class="number">0</span>), <span class="number">1</span>))</span><br><span class="line">    test_data1 = np.concatenate((x0, test_data_scale), axis=<span class="number">1</span>)</span><br><span class="line">    y_predict_test = np.matmul(test_data1, w_bar)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Prediction Error</span></span><br><span class="line">    E_test = np.linalg.norm(y_predict_test.ravel()- test_target)/len(y_predict_test)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> y_predict_test, E_train, E_test</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Set the format of labels</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">LabelFormat</span><span class="params">(plt)</span>:</span></span><br><span class="line">    ax = plt.gca()</span><br><span class="line">    plt.tick_params(labelsize=<span class="number">14</span>)</span><br><span class="line">    labels = ax.get_xticklabels() + ax.get_yticklabels()</span><br><span class="line">    [label.set_fontname(<span class="string">'Times New Roman'</span>) <span class="keyword">for</span> label <span class="keyword">in</span> labels]</span><br><span class="line">    font = &#123;<span class="string">'family'</span>: <span class="string">'Times New Roman'</span>,</span><br><span class="line">            <span class="string">'weight'</span>: <span class="string">'normal'</span>,</span><br><span class="line">            <span class="string">'size'</span>: <span class="number">16</span>,</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="keyword">return</span> font</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Plot_error_vs_omega</span><span class="params">(train_data,train_target)</span>:</span></span><br><span class="line">    <span class="comment"># ---------Show the contour of E with respect to omegas---------------------</span></span><br><span class="line">    x1 = train_data[:, <span class="number">0</span>]</span><br><span class="line">    x2 = train_data[:, <span class="number">1</span>]</span><br><span class="line">    omega_1 = np.linspace(<span class="number">-30</span>, <span class="number">30</span>, <span class="number">30</span>)</span><br><span class="line">    omega_2 = np.linspace(<span class="number">-30</span>, <span class="number">30</span>, <span class="number">30</span>)</span><br><span class="line"></span><br><span class="line">    Y_hat = np.zeros((len(omega_1),len( omega_2)))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(omega_1)):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(len(omega_2)):</span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> range(len(train_data)):</span><br><span class="line">                temp=train_target[k] - (omega_1[i] * x1[k] + omega_2[j] * x2[k])</span><br><span class="line">                Y_hat[i][j] = Y_hat[i][j] + np.square(temp)</span><br><span class="line"></span><br><span class="line">    fig = plt.figure()</span><br><span class="line"></span><br><span class="line">    plt.contour(omega_2,omega_1,Y_hat,<span class="number">20</span>)</span><br><span class="line">    <span class="comment"># Set the labels</span></span><br><span class="line">    font = LabelFormat(plt)</span><br><span class="line">    plt.xlabel(<span class="string">'$\omega_1$'</span>, font)</span><br><span class="line">    plt.ylabel(<span class="string">'$\omega_2$'</span>, font)</span><br><span class="line"></span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Plot_error_vs_omega_scale</span><span class="params">(train_data, train_target)</span>:</span></span><br><span class="line">    <span class="comment"># ---------Show the contour of E with respect to omegas---------------------</span></span><br><span class="line">    <span class="comment"># Data processing: scaling</span></span><br><span class="line">    <span class="comment"># For training data</span></span><br><span class="line">    ss = preprocessing.StandardScaler()</span><br><span class="line">    ss.partial_fit(train_data)</span><br><span class="line">    train_data_scale = ss.fit_transform(train_data)</span><br><span class="line"></span><br><span class="line">    x1 = train_data_scale[:, <span class="number">0</span>]</span><br><span class="line">    x2 = train_data_scale[:, <span class="number">1</span>]</span><br><span class="line">    omega_1 = np.linspace(<span class="number">-30</span>, <span class="number">30</span>, <span class="number">30</span>)</span><br><span class="line">    omega_2 = np.linspace(<span class="number">-30</span>, <span class="number">30</span>, <span class="number">30</span>)</span><br><span class="line"></span><br><span class="line">    Y_hat = np.zeros((len(omega_1), len(omega_2)))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(omega_1)):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(len(omega_2)):</span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> range(len(train_data_scale)):</span><br><span class="line">                temp = train_target[k] - (omega_1[i] * x1[k] + omega_2[j] * x2[k])</span><br><span class="line">                Y_hat[i][j] = Y_hat[i][j] + np.square(temp)</span><br><span class="line"></span><br><span class="line">    fig = plt.figure()</span><br><span class="line"></span><br><span class="line">    plt.contour(omega_2, omega_1, Y_hat, <span class="number">20</span>)</span><br><span class="line">    <span class="comment"># Set the labels</span></span><br><span class="line">    font = LabelFormat(plt)</span><br><span class="line">    plt.xlabel(<span class="string">'$\omega_1$'</span>, font)</span><br><span class="line">    plt.ylabel(<span class="string">'$\omega_2$'</span>, font)</span><br><span class="line"></span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment"># load house price of Boston</span></span><br><span class="line">    data, target = load_boston(return_X_y=<span class="literal">True</span>)</span><br><span class="line">    <span class="comment"># The number of selected features</span></span><br><span class="line">    M = <span class="number">2</span></span><br><span class="line">    <span class="comment"># The first 500 data for training</span></span><br><span class="line">    train_data = data[<span class="number">0</span>:<span class="number">500</span>, <span class="number">0</span>:<span class="number">0</span> + M]</span><br><span class="line">    train_target = target[<span class="number">0</span>:<span class="number">500</span>]</span><br><span class="line">    train_target.reshape(len(train_data), <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># ------------------------------</span></span><br><span class="line">    <span class="comment"># The last 6 data for testing</span></span><br><span class="line">    test_data = data[<span class="number">500</span>:, <span class="number">0</span>:<span class="number">0</span> + M]</span><br><span class="line">    test_target = target[<span class="number">500</span>:]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># To show the contour of error function E with respect to omega</span></span><br><span class="line">    <span class="comment"># We can see that it's a convex function, not easy for gradient descend</span></span><br><span class="line">    Plot_error_vs_omega(train_data, train_target)</span><br><span class="line">    Plot_error_vs_omega_scale(train_data, train_target)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#---------------------------------#</span></span><br><span class="line">    y_predict_normal_equation, E_train,E_test = Linear_regression_normal_equation(train_data, train_target, test_data,</span><br><span class="line">                                                                         test_target)</span><br><span class="line">    print(<span class="string">"Linear Regression Using Normal Equation: E_train=%f, E_test=%f"</span> % (E_train,E_test))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(test_data)):</span><br><span class="line">        print(<span class="string">"True value: %f    Predicted value: %f"</span> % (test_target[i], y_predict_normal_equation[i]))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># ---------------------------------#</span></span><br><span class="line">    y_predict_normal_equation_scale, E_train,E_test = Linear_regression_normal_equation_scale(train_data, train_target,</span><br><span class="line">                                                                                     test_data, test_target)</span><br><span class="line">    print(<span class="string">"Linear Regression Using Normal Equation with scaling: E_train=%f, E_test=%f"</span> % (E_train,E_test))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(test_data)):</span><br><span class="line">        print(<span class="string">"True value: %f    Predicted value: %f"</span> % (test_target[i], y_predict_normal_equation_scale[i]))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># ---------------------------------#</span></span><br><span class="line">    y_predict_gradient_descent, E_train,E_test = Linear_regression_gradient_descend(train_data, train_target, test_data,</span><br><span class="line">                                                                           test_target)</span><br><span class="line">    print(<span class="string">"Linear Regression Using Gradient Descend: E_train=%f, E_test=%f"</span> % (E_train[<span class="number">-1</span>],E_test))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(test_data)):</span><br><span class="line">        print(<span class="string">"True value: %f    Predicted value: %f"</span> % (test_target[i], y_predict_gradient_descent[i]))</span><br><span class="line"></span><br><span class="line">    plt.figure()</span><br><span class="line">    plt.plot(E_train,<span class="string">'r-'</span>)</span><br><span class="line">    <span class="comment"># Set the labels</span></span><br><span class="line">    font = LabelFormat(plt)</span><br><span class="line">    plt.xlabel(<span class="string">'Iteration'</span>, font)</span><br><span class="line">    plt.ylabel(<span class="string">'Average error: $E/N$'</span>, font)</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># ---------------------------------#</span></span><br><span class="line">    y_predict_gradient_descent_scale, E_train,E_test = Linear_regression_gradient_descend_scale(train_data, train_target,</span><br><span class="line">                                                                                       test_data, test_target)</span><br><span class="line">    print(<span class="string">"Linear Regression Using Gradient Descend with scaling: E_train=%f, E_test=%f"</span> % (E_train[<span class="number">-1</span>],E_test))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(test_data)):</span><br><span class="line">        print(<span class="string">"True value: %f    Predicted value: %f"</span> % (test_target[i], y_predict_gradient_descent_scale[i]))</span><br><span class="line">    plt.figure()</span><br><span class="line">    plt.plot(E_train,<span class="string">'r-'</span>)</span><br><span class="line">    <span class="comment"># Set the labels</span></span><br><span class="line">    font = LabelFormat(plt)</span><br><span class="line">    plt.xlabel(<span class="string">'Iteration'</span>, font)</span><br><span class="line">    plt.ylabel(<span class="string">'Average error: $E/N$'</span>, font)</span><br><span class="line"></span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure>
    </div>
</div>
</li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>Machine Learning</tag>
      </tags>
  </entry>
  <entry>
    <title>【漫漫科研路\LaTeX】使用Sublime Text3撰写科研论文</title>
    <url>/2020/03/18/%5B20200318%5D/</url>
    <content><![CDATA[<p>在之前的一篇文章《<a href="https://blog.csdn.net/tengweitw/article/details/103759321" target="_blank" rel="noopener">使用Vim撰写科研论文</a>》中，我提到了曾经在Windows系统中使用Sublime+TexLive+SumatraPDF的组合来进行科研工作。现在介绍如何使用sublime来编辑LaTeX论文，真是恰逢其时。由于疫情原因在家隔离(家在湖北)，只能使用我淘汰已久，赋闲在家的windows笔记本来进行科研工作。为此，在配置编辑环境的同时，我顺便来介绍其流程。毕竟，使用IDE来编写科研论文的人占绝大多数，使用Vim编写LaTeX的可能是凤毛麟角。因此，使用Sublime编写LaTeX可以看成两者的一个折中选择。</p>
<a id="more"></a>
<hr>
<h2 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a>软件安装</h2><p>软件的安装都比较简单，下面只给出其下载链接：</p>
<p>Texlive：<a href="http://www.tug.org/texlive/" target="_blank" rel="noopener">http://www.tug.org/texlive/</a></p>
<p>Sublime Text3:  <a href="http://www.sublimetext.cn/" target="_blank" rel="noopener">http://www.sublimetext.cn/</a></p>
<p>Sumatra PDF: <a href="https://www.sumatrapdfreader.org/download-free-pdf-viewer.html" target="_blank" rel="noopener">https://www.sumatrapdfreader.org/download-free-pdf-viewer.html</a></p>
<hr>
<h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><h4 id="Sublime-Text3的配置"><a href="#Sublime-Text3的配置" class="headerlink" title="Sublime Text3的配置"></a>Sublime Text3的配置</h4><ol>
<li><p><strong>安装Package Control</strong><br>首先通过组合键 Ctrl+`或者在菜单栏点击View-&gt;Show Console来打开控制台，然后将下面的代码输入，按enter即可。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib.request,os,hashlib; h = <span class="string">'2915d1851351e5ee549c20394736b442'</span> + <span class="string">'8bc59f460fa1548d1514676163dafc88'</span>; pf = <span class="string">'Package Control.sublime-package'</span>; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( <span class="string">'http://packagecontrol.io/'</span> + pf.replace(<span class="string">' '</span>, <span class="string">'%20'</span>)).read(); dh = hashlib.sha256(by).hexdigest(); print(<span class="string">'Error validating download (got %s instead of %s), please try manual install'</span> % (dh, h)) <span class="keyword">if</span> dh != h <span class="keyword">else</span> open(os.path.join( ipp, pf), <span class="string">'wb'</span> ).write(by)</span><br></pre></td></tr></table></figure>
<p>如若安装不成功，一般是因为packagecontrol.io容易被墙，解决办法请参考<a href="http://packagecontrol.cn/installation。" target="_blank" rel="noopener">http://packagecontrol.cn/installation。</a></p>
<p>安装成功后，重启Sublime就可以在Preference下拉菜单中看到Package Control选项了。</p>
</li>
<li><p><strong>安装LaTeXTools插件</strong></p>
<p>在Sublime界面按下快捷键Ctrl+Shift+p，搜索Package Control: Install Package, 如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20200318/20200318_fig001.jpg" width="600" height="450" title="图1" alt="图1" ></p>
</li>
</ol>
<p>按下回车键后，稍等一会，就可以搜索LaTeXTools回车进行安装。</p>
<p>​    安装完成后我们需要对LaTeXTools进行配置，告知其Texlive和Sumatra PDF的目录，<strong>具体操作如下：</strong>  </p>
<ul>
<li>首先打开LaTeXTools的setting文件：<br><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20200318/20200318_fig002.jpg" width="600" height="450" title="图2" alt="图2" ></li>
</ul>
<ul>
<li>然后更改windows系统(按下Ctrl+F搜索windows,在209行)中Texlive和sumatra的内容如下：<br><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20200318/20200318_fig003.jpg" width="600" height="450" title="图3" alt="图3" ></li>
</ul>
<p>其中，texpath和sumatra的值分别改为你Texlive和SumatraPDF的安装目录，distro的值改为texlive。</p>
<ul>
<li>最后定位到builder(第379行)，改builder的值为simple，如下图所示：<br><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20200318/20200318_fig004.jpg" width="600" height="450" title="图4" alt="图4" ></li>
</ul>
<hr>
<h4 id="Sumatra-PDF的配置"><a href="#Sumatra-PDF的配置" class="headerlink" title="Sumatra PDF的配置"></a>Sumatra PDF的配置</h4><p>配置Sumatra的目的是为了实现<strong>正向搜索</strong>(从源码跳转到pdf)与<strong>反向搜索</strong>(从pdf跳转到源码)。具体操作如下：</p>
<p>1.使用快捷键win+r打开cmd.exe，cd到SumatraPDF的目录下，执行以下命令：</p>
<p><code>sumatrapdf.exe -inverse-search &quot;\&quot;D:\Sublime Text 3\sublime_text.exe\&quot; \&quot;%f:%l\&quot;</code></p>
<p>其中后面的目录为sublime的安装目录。</p>
<p>2.打开SumatraPDF软件，点击菜单设置如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20200318/20200318_fig005.jpg" width="600" height="400" title="图5" alt="图5" ></p>
<p>在<strong>设置反向搜索命令行</strong>输入命令如下：(根据自己的安装目录作相应修改)</p>
<p><code>&quot;D:\Sublime Text 3\sublime_text.exe&quot; &quot;%f:%l&quot;</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20200318/20200318_fig006.jpg" width="400" height="450" title="图6" alt="图6" ></p>
<p>至此，SumatraPDF配置完成，在pdf中双击就可以跳转到Sublime中对应的LaTeX源码。</p>
<hr>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>在Sublime中新建一个.tex文件，输入如下简单的LaTeX代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">%!TEX program &#x3D; xelatex</span><br><span class="line">\documentclass&#123;article&#125;</span><br><span class="line">\begin&#123;document&#125;</span><br><span class="line">Hello World!</span><br><span class="line">\end&#123;document&#125;</span><br></pre></td></tr></table></figure>
<p>使用快捷键<code>Ctrl+B</code>进行编译，编译成功会自动打开SumatraPDF进行预览。</p>
<hr>
<h2 id="有用的插件"><a href="#有用的插件" class="headerlink" title="有用的插件"></a>有用的插件</h2><h4 id="自动补全"><a href="#自动补全" class="headerlink" title="自动补全"></a>自动补全</h4><p>  在Sublime中，选择菜单Preference-&gt;Settings，添加如下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;auto_complete&quot;:true,</span><br><span class="line">&quot;auto_complete_selector&quot;: &quot;source, text&quot;,</span><br><span class="line">&quot;auto_match_enabled&quot;:true,</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20200318/20200318_fig007.jpg" width="600" height="250" title="图7" alt="图7" ></p>
<p>设置后即可实现自动补全，如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20200318/20200318_fig008.jpg" width="600" height="350" title="图8" alt="图8" ></p>
<hr>
<h4 id="公式、图片预览"><a href="#公式、图片预览" class="headerlink" title="公式、图片预览"></a>公式、图片预览</h4><ul>
<li><p>下载并安装<a href="https://www.ghostscript.com/download/gsdnld.html" target="_blank" rel="noopener">Ghostscript</a>和<a href="https://www.imagemagick.org/script/download.php#windows" target="_blank" rel="noopener">ImageMagick</a>。安装完成后，将这两个安装目录添加进系统环境变量。</p>
</li>
<li><p>在Sublime的菜单Preferences-&gt;Package Settings-&gt;LaTexTools-&gt;Check System,检查Ghostscript和ImageMagick是否安装成功。若安装成功，会如下图所示：<br><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20200318/20200318_fig009.jpg" width="600" height="550" title="图9" alt="图9" ></p>
<p>下面我们就可以测试是否能够预览公式和图片了，如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20200318/20200318_fig010.jpg" width="600" height="450" title="图10" alt="图10" ><br><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20200318/20200318_fig011.jpg" width="600" height="450" title="图11" alt="图11" ></p>
</li>
</ul>
<p>其中这里面的test.png为你自己选择的一张图片。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>Research</tag>
      </tags>
  </entry>
  <entry>
    <title>【图解例说机器学习】K最近邻 (KNN)</title>
    <url>/2020/01/12/%5B20200122%5D/</url>
    <content><![CDATA[<h2 id="kNN-k-nearest-neighbor-的定义"><a href="#kNN-k-nearest-neighbor-的定义" class="headerlink" title="kNN (k-nearest neighbor)的定义"></a>kNN (k-nearest neighbor)的定义</h2><blockquote>
<p>针对一个测试实例，在给定训练集中，基于<strong>某种距离度量</strong>找到与之<strong>最近的k个实例点</strong>，然后基于这k个最邻近实例点的信息，以<strong>某种决策规则</strong>来对该测试实例进行分类或回归。</p>
</blockquote>
<p>由定义可知，$kNN$模型包含三个基本要素：距离度量、k值选择以及决策规则。再详细描述这三要素之前，我们先用一个样图来简单描述$kNN$分类模型的效果。</p>
<p>我们以二维平面为例，假设输入的训练集格式为$(x_1,x_2,l)$，其中$x_1, x_2$为横纵坐标，$l$为标签。这里我们考虑$k=1,3$的情况，决策规则为多数投票规则，即测试实例与k个实例中的多数属于同一类。图$1,2$分别是$k=1,3$时，二维特征空间划分图。</p>
<p>​    <img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20200122/20200122_fig001.jpg" width="600" height="450" title="图1" alt="图1" ></p>
<a id="more"></a>
<hr>
<h2 id="距离度量"><a href="#距离度量" class="headerlink" title="距离度量"></a>距离度量</h2><p>$kNN$的本质是“近朱者赤近墨者黑”，即测试点的类别由其最邻近的$k$个实例点决定。这里“最邻近”的意义根据距离度量的不同而不同。一般来说，我们最常见的便是欧氏距离。这里我们介绍包含欧氏距离，但比欧氏距离更普适的Minkowski距离。</p>
<blockquote>
<p>假定训练集中,每个实例包含$n$个特征，那么实例$x$可以分别表示为$x=(x_1,\cdots,x_n)$。假定测试实例为$y=(y_1,\cdots,y_n)$，那么$x, y$之间的Minkowski距离可以表示为：</p>
</blockquote>
<script type="math/tex; mode=display">
L(x,y)=\left(\sum\limits_{i=1}^{n}{\lvert x_i-y_i\rvert}^p\right)^{\frac{1}{p}},</script><p>其中，$p&gt;0$是一个可变参数：</p>
<script type="math/tex; mode=display">
L(x,y)=
\begin{cases}
\sum\limits_{i=1}^{n}{\lvert x_i-y_i\rvert},\quad p=1\quad\text{(曼哈顿距离)}\\
\left(\sum\limits_{i=1}^{n}{\lvert x_i-y_i\rvert}^2\right)^{\frac{1}{2}},\quad p=2\quad\text{(欧氏距离)}\\
\max\limits_{i=1}^{n}{\lvert x_i-y_i\rvert},\quad p\to\infty,\quad\text{(切比雪夫距离)}
\end{cases}</script><p>当然$p$也可以取小于$1$的值，如$p=\frac{1}{2}$。图$3$给出了当$p$取不同值时，与原点距离为$1$的图形：</p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20200122/20200122_fig002.jpg" width="600" height="450" title="图3" alt="图3" ></p>
<p>Note: 这里只是介绍了较常用的Minkowski距离，</p>
<hr>
<h2 id="k-值的选择"><a href="#k-值的选择" class="headerlink" title="$k$值的选择"></a>$k$值的选择</h2><p>调参是机器学习算法的重要一环。在$kNN$算法中，$k$值的选取对结果的影响较大。下面以图$4$来具体说明：</p>
<p>（a）当$k$取值较小时，此时是根据测试实例周围较少的训练样例信息来进行分类。由于训练样例离测试样例比较近，因此训练误差比较小。当这些邻近的训练样例是噪声时，会严重影响分类结果，即泛化误差变大。<br>（b）当$k$取值较大时，此时是根据测试实例周围较多的训练样例信息来进行分类。这时与测试实例相距较远（相关性较小）的训练样例也对分类结果有影响，使得泛化误差较大。一个极端的例子就是以考虑所有的训练样例，这时测试样例被归为训练样例数最大的一类。</p>
<p>Note: 模型复杂度的理解：对于有参模型来说（例如线性拟合），模型复杂度一般可以用参数的多少来判断。对于无参模型来说（例如这里的$kNN$），这里还需思考。可能的情况？考虑极端情况，当$k$取值为整个训练样例数时，这时的模型最简单，即测试样例被归为训练样例数最大的一类。当$k$取值为$1$时，每个测试样例都需要根据其最邻近节点来进行分类，这时模型变得很复杂。</p>
<p>通常来说，我们可以通过交叉验证来选取$k$值。同时，我们也可以对这$k$个训练样例进行距离加权，来克服（b）的影响。</p>
<hr>
<h2 id="决策规则"><a href="#决策规则" class="headerlink" title="决策规则"></a>决策规则</h2><p>$kNN$既可进行分类，也可用于回归。</p>
<ul>
<li>对于分类问题来说，一般采用的是投票法，即测试样例被归为最邻近$k$个训练样例数中最大的一类。</li>
<li>对于回归问题来说，一般采用的是平均法。顾名思义，测试样例的取值为这$k$个训练样例取值的平均值。</li>
<li>最后，我们可以对这两种方法进行改进，即对这$k$个训练样例进行加权，离测试样例较近的训练样例一般具有更大的影响权重。</li>
</ul>
<hr>
<h3 id="kNN-优缺点："><a href="#kNN-优缺点：" class="headerlink" title="$kNN$优缺点："></a>$kNN$优缺点：</h3><p>优点：</p>
<p>最近更新于20-01-20，明早就回家过年了，年后再更新。<br><strong>未完待续。。。</strong><br>最近更新于20-03-30，优缺点还需用图示说明。</p>
<hr>
<h3 id="算法实践"><a href="#算法实践" class="headerlink" title="算法实践"></a>算法实践</h3><p>下面我们给出两种方式实现KNN分类算法：一、自己编程实现KNN算法；二、使用更加简单的scikit-learn库。<br>注意：数据集为iris数据集，有150个训练集，4个feature, 总共分3类。在方法一中，我们考虑了所有4个feature，将所有150个训练数据作为训练(即在程序中设置split=1)，读者可以通过设置split的值来获取测试集用于交叉检验得到最佳的k值。在方法二中，我们只考虑了前2个feature，这么做是为了在二维图中展示分类结果。</p>
<h4 id="自写KNN算法"><a href="#自写KNN算法" class="headerlink" title="自写KNN算法"></a>自写KNN算法</h4><ul>
<li>算法思路：</li>
</ul>
<ol>
<li>计算已知数据集中的点与当前点之间的距离  </li>
<li>按照距离递增次序进行排序  </li>
<li>选取与当前点距离最小的K个点  </li>
<li>确定这K个点所在类别的出现次数</li>
<li>返回这K个点出现次数最多的类别作为当前点的预测分类</li>
</ol>
<ul>
<li>代码实现 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> datasets, neighbors</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># Divide the original dataset into training data and test data</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">LoadDataSet</span><span class="params">(irisData, split, trainData, testData, trainLabel, testLabel)</span>:</span></span><br><span class="line">    allData = irisData.data</span><br><span class="line">    allLabel = irisData.target</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(allData)):</span><br><span class="line">        <span class="keyword">if</span> random.random() &lt; split:  <span class="comment">#</span></span><br><span class="line">            trainData.append(allData[i])</span><br><span class="line">            trainLabel.append(allLabel[i])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            testData.append(allData[i])</span><br><span class="line">            testLabel.append(allLabel[i])</span><br><span class="line"></span><br><span class="line"><span class="comment"># Calculate the distance between two instance</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">CalDist</span><span class="params">(instance1, instance2)</span>:</span></span><br><span class="line">    dist = <span class="number">0</span></span><br><span class="line">    length = len(instance1)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(length):</span><br><span class="line">        dist += pow((instance1[i] - instance2[i]), <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> math.sqrt(dist)</span><br><span class="line"></span><br><span class="line"><span class="comment"># The KNN algorithm</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">knn</span><span class="params">(instance, k, trainData, trainLabel)</span>:</span></span><br><span class="line">    allDist = []</span><br><span class="line">    <span class="comment"># Calculate distances from all training data</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(trainData)):</span><br><span class="line">        allDist.append([CalDist(instance, trainData[i]), i])</span><br><span class="line">    allDist.sort()</span><br><span class="line">    <span class="comment"># Determine the neighbors</span></span><br><span class="line">    neighbors = []</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(k):</span><br><span class="line">        neighbors.append(allDist[j][<span class="number">1</span>])</span><br><span class="line">    numLabels = len(np.unique(trainLabel))</span><br><span class="line">    vote = [<span class="number">0</span>] * numLabels</span><br><span class="line">    <span class="comment"># Vote to decide the resultant label</span></span><br><span class="line">    <span class="keyword">for</span> kk <span class="keyword">in</span> range(k):</span><br><span class="line">        vote[trainLabel[neighbors[kk]]] += <span class="number">1</span></span><br><span class="line">    <span class="comment"># print the result</span></span><br><span class="line">    print(vote.index(max(vote)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># load dataset of iris</span></span><br><span class="line">irisData = datasets.load_iris()</span><br><span class="line"></span><br><span class="line"><span class="comment"># All data are used for training</span></span><br><span class="line">split = <span class="number">1</span></span><br><span class="line"><span class="comment"># Number of neighbors</span></span><br><span class="line">k = <span class="number">3</span></span><br><span class="line">trainData = []</span><br><span class="line">trainLabel = []</span><br><span class="line">testData = []</span><br><span class="line">testLabel = []</span><br><span class="line">LoadDataSet(irisData, split, trainData, testData, trainLabel, testLabel)</span><br><span class="line"></span><br><span class="line">predictPoint=[<span class="number">7.6</span>, <span class="number">3.</span>, <span class="number">6.6</span>, <span class="number">2.1</span>]</span><br><span class="line"></span><br><span class="line">knn(predictPoint, k, trainData, trainLabel)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h4 id="使用scikit-learn库"><a href="#使用scikit-learn库" class="headerlink" title="使用scikit-learn库"></a>使用scikit-learn库</h4><ul>
<li>代码实现</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> matplotlib.colors <span class="keyword">import</span> ListedColormap</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> neighbors, datasets</span><br><span class="line"></span><br><span class="line"><span class="comment"># The number of neighbors</span></span><br><span class="line">k = <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># import dataset of iris</span></span><br><span class="line">iris = datasets.load_iris()</span><br><span class="line"></span><br><span class="line"><span class="comment"># The first two-dim feature for simplicity</span></span><br><span class="line">X = iris.data[:, :<span class="number">2</span>]</span><br><span class="line"><span class="comment"># The labels</span></span><br><span class="line">y = iris.target</span><br><span class="line"></span><br><span class="line">h = <span class="number">.02</span>  <span class="comment"># step size in the mesh</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Create color maps for three types of labels</span></span><br><span class="line">cmap_light = ListedColormap([<span class="string">'tomato'</span>, <span class="string">'limegreen'</span>, <span class="string">'cornflowerblue'</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># we create an instance of Neighbours Classifier and fit the data.</span></span><br><span class="line">clf = neighbors.KNeighborsClassifier(k, <span class="string">'uniform'</span>)</span><br><span class="line">clf.fit(X, y)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Plot the decision boundary. Assign a color to each point in the mesh.</span></span><br><span class="line">x_min, x_max = X[:, <span class="number">0</span>].min() - <span class="number">1</span>, X[:, <span class="number">0</span>].max() + <span class="number">1</span></span><br><span class="line">y_min, y_max = X[:, <span class="number">1</span>].min() - <span class="number">1</span>, X[:, <span class="number">1</span>].max() + <span class="number">1</span></span><br><span class="line">xx, yy = np.meshgrid(np.arange(x_min, x_max, h),</span><br><span class="line">                     np.arange(y_min, y_max, h))</span><br><span class="line">Z = clf.predict(np.c_[xx.ravel(), yy.ravel()])</span><br><span class="line"></span><br><span class="line"><span class="comment"># Z is a matrix (values) for the two-dim space</span></span><br><span class="line">Z = Z.reshape(xx.shape)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Plot the training points: different</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">PlotTrainPoint</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(X)):</span><br><span class="line">        <span class="keyword">if</span> y[i] == <span class="number">0</span>:</span><br><span class="line">            plt.plot(X[i][<span class="number">0</span>], X[i][<span class="number">1</span>], <span class="string">'rs'</span>, markersize=<span class="number">6</span>, markerfacecolor=<span class="string">"r"</span>)</span><br><span class="line">        <span class="keyword">elif</span> y[i] == <span class="number">1</span>:</span><br><span class="line">            plt.plot(X[i][<span class="number">0</span>], X[i][<span class="number">1</span>], <span class="string">'gs'</span>, markersize=<span class="number">6</span>, markerfacecolor=<span class="string">"g"</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            plt.plot(X[i][<span class="number">0</span>], X[i][<span class="number">1</span>], <span class="string">'bs'</span>, markersize=<span class="number">6</span>, markerfacecolor=<span class="string">"b"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Set the format of labels</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">LabelFormat</span><span class="params">(plt)</span>:</span></span><br><span class="line">    ax = plt.gca()</span><br><span class="line">    plt.tick_params(labelsize=<span class="number">14</span>)</span><br><span class="line">    labels = ax.get_xticklabels() + ax.get_yticklabels()</span><br><span class="line">    [label.set_fontname(<span class="string">'Times New Roman'</span>) <span class="keyword">for</span> label <span class="keyword">in</span> labels]</span><br><span class="line">    font1 = &#123;<span class="string">'family'</span>: <span class="string">'Times New Roman'</span>,</span><br><span class="line">             <span class="string">'weight'</span>: <span class="string">'normal'</span>,</span><br><span class="line">             <span class="string">'size'</span>: <span class="number">16</span>,</span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Plot the boundary lines (contour figure)</span></span><br><span class="line">fig = plt.figure()</span><br><span class="line">plt.contour(xx, yy, Z, <span class="number">3</span>, colors=<span class="string">'black'</span>, linewidths=<span class="number">1</span>, linestyles=<span class="string">'solid'</span>)</span><br><span class="line">PlotTrainPoint()</span><br><span class="line">plt.title(<span class="string">"3-Class classification (k = %i, weights = '%s')"</span> % (k, <span class="string">'uniform'</span>), LabelFormat(plt))</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Plot the boundary maps (mesh figure)</span></span><br><span class="line">plt.figure()</span><br><span class="line">plt.pcolormesh(xx, yy, Z, cmap=cmap_light)</span><br><span class="line">PlotTrainPoint()</span><br><span class="line">plt.xlim(xx.min(), xx.max())</span><br><span class="line">plt.ylim(yy.min(), yy.max())</span><br><span class="line">plt.title(<span class="string">"3-Class classification (k = %i, weights = '%s')"</span> % (k, <span class="string">'uniform'</span>), LabelFormat(plt))</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<ul>
<li>仿真结果<br>图4和图5没有本质区别，不同之处在于图4只画了分类的轮廓，图5是将整个空间的点进行了分类。从图中可以看出，kNN适合于非线性分类。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20200122/20200122_fig003.jpg" width="600" height="450" title="图4" alt="图4" ></p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20200122/20200122_fig004.jpg" width="600" height="450" title="图5" alt="图5" ></p>
<hr>
<h3 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h3><p>图1的python 源代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> matplotlib <span class="keyword">as</span> mpl</span><br><span class="line"><span class="keyword">from</span> scipy.spatial <span class="keyword">import</span> Voronoi, voronoi_plot_2d, cKDTree</span><br><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"></span><br><span class="line"><span class="comment"># The number of test points and train points</span></span><br><span class="line">Num_test = <span class="number">3</span></span><br><span class="line">Num_train = <span class="number">50</span></span><br><span class="line"><span class="comment"># Generate the two-dimension feature (x,y), Here x,y are coordinates</span></span><br><span class="line">Loc_x_train = <span class="number">1000</span> * np.random.rand(Num_train, <span class="number">1</span>)</span><br><span class="line">Loc_y_train = <span class="number">1000</span> * np.random.rand(Num_train, <span class="number">1</span>)</span><br><span class="line">Label_train = np.round(np.random.rand(Num_train, <span class="number">1</span>))</span><br><span class="line">Loc_train = <span class="number">1000</span> * np.random.rand(Num_train, <span class="number">2</span>)</span><br><span class="line">filename = <span class="string">'Loc_x_train'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Generate the test points</span></span><br><span class="line">Loc_x_test = <span class="number">1000</span> * np.random.rand(Num_test, <span class="number">1</span>)</span><br><span class="line">Loc_y_test = <span class="number">1000</span> * np.random.rand(Num_test, <span class="number">1</span>)</span><br><span class="line">Loc_test = <span class="number">1000</span> * np.random.rand(Num_test, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(Loc_x_train)):</span><br><span class="line">    Loc_train[i] = [Loc_x_train[i], Loc_y_train[i]]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(Loc_x_test)):</span><br><span class="line">    Loc_test[i] = [Loc_x_test[i], Loc_y_test[i]]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Use the scipy.spatial packets to form voronoi</span></span><br><span class="line">vor = Voronoi(Loc_train)</span><br><span class="line">fig = voronoi_plot_2d(vor, show_points=<span class="literal">False</span>, show_vertices=<span class="literal">False</span>,</span><br><span class="line">                      line_colors=<span class="string">'black'</span>, line_width=<span class="number">2</span>, line_alpha=<span class="number">1</span>,</span><br><span class="line">                      point_size=<span class="number">15</span>)</span><br><span class="line"><span class="comment"># Plot the train pints</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, Num_train):</span><br><span class="line">    <span class="keyword">if</span> Label_train[i]:</span><br><span class="line">        plt.plot(Loc_x_train[i], Loc_y_train[i], <span class="string">'rs'</span>, markersize=<span class="number">6</span>, markerfacecolor=<span class="string">"w"</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        plt.plot(Loc_x_train[i], Loc_y_train[i], <span class="string">'bs'</span>, markersize=<span class="number">6</span>, markerfacecolor=<span class="string">"w"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Use the kdtree to find the nearest train point for each test point</span></span><br><span class="line">voronoi_kdtree = cKDTree(Loc_train)</span><br><span class="line">test_point_dist, test_point_regions = voronoi_kdtree.query(Loc_test)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Classify the test points, the same color as the nearest train point</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, Num_test):</span><br><span class="line">    <span class="keyword">if</span> Label_train[test_point_regions[i]]:</span><br><span class="line">        plt.plot(Loc_x_test[i], Loc_y_test[i], <span class="string">'ro'</span>, markersize=<span class="number">6</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        plt.plot(Loc_x_test[i], Loc_y_test[i], <span class="string">'bo'</span>, markersize=<span class="number">6</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># The following are typical settings for plotting figures</span></span><br><span class="line">plt.axis([<span class="number">0</span>, <span class="number">1001</span>, <span class="number">0</span>, <span class="number">1001</span>])</span><br><span class="line">ax = plt.gca()</span><br><span class="line">plt.tick_params(labelsize=<span class="number">14</span>)</span><br><span class="line">labels = ax.get_xticklabels() + ax.get_yticklabels()</span><br><span class="line">[label.set_fontname(<span class="string">'Times New Roman'</span>) <span class="keyword">for</span> label <span class="keyword">in</span> labels]</span><br><span class="line">font1 = &#123;<span class="string">'family'</span>: <span class="string">'Times New Roman'</span>,</span><br><span class="line">         <span class="string">'weight'</span>: <span class="string">'normal'</span>,</span><br><span class="line">         <span class="string">'size'</span>: <span class="number">16</span>,</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">plt.xlabel(<span class="string">'X-axis (m)'</span>, font1)</span><br><span class="line">plt.ylabel(<span class="string">'Y-axis (m)'</span>, font1)</span><br><span class="line">plt.title(<span class="string">'k=1'</span>, font1)</span><br><span class="line">plt.savefig(<span class="string">'f2.png'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>图3的python源代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> matplotlib <span class="keyword">as</span> mpl</span><br><span class="line"><span class="keyword">from</span> scipy.spatial <span class="keyword">import</span> Voronoi, voronoi_plot_2d, cKDTree</span><br><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">original_point = [<span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">x = np.linspace(<span class="number">-1</span>, <span class="number">1</span>, <span class="number">10000</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># p=0.5</span></span><br><span class="line">y1 = <span class="number">1</span> + np.abs(x) - <span class="number">2</span> * np.power(np.abs(x), <span class="number">0.5</span>)</span><br><span class="line">y2 = - y1</span><br><span class="line">plt.plot(x, y1, <span class="string">'g'</span>)</span><br><span class="line">plt.plot(x, y2, <span class="string">'g'</span>)</span><br><span class="line"><span class="comment"># p=1</span></span><br><span class="line">y1 = <span class="number">1</span> - np.abs(x)</span><br><span class="line">y2 = np.abs(x) - <span class="number">1</span></span><br><span class="line">plt.plot(x, y1, <span class="string">'r'</span>)</span><br><span class="line">plt.plot(x, y2, <span class="string">'r'</span>)</span><br><span class="line"><span class="comment"># p=2</span></span><br><span class="line">y1 = np.power(<span class="number">1</span> - np.power(x, <span class="number">2</span>), <span class="number">1</span> / <span class="number">2</span>)</span><br><span class="line">y2 = -y1</span><br><span class="line">plt.plot(x, y1, <span class="string">'b-'</span>)</span><br><span class="line">plt.plot(x, y2, <span class="string">'b-'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># p-&gt; infty</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(x)):</span><br><span class="line">    <span class="keyword">if</span> np.abs(x[i]) == <span class="number">1</span>:</span><br><span class="line">        y1[i] = <span class="number">0</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        y1[i] = <span class="number">1</span></span><br><span class="line">y2 = -y1</span><br><span class="line">plt.plot(x, y1, <span class="string">'k-'</span>)</span><br><span class="line">plt.plot(x, y2, <span class="string">'k-'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># To plot figures</span></span><br><span class="line">plt.axis(<span class="string">'equal'</span>)</span><br><span class="line">ax=plt.gca()</span><br><span class="line"></span><br><span class="line">plt.annotate(<span class="string">'$p=0.5$'</span>, xy=(<span class="number">0.25</span>, <span class="number">0.25</span>), xycoords=<span class="string">'data'</span>,</span><br><span class="line">             xytext=(<span class="number">-25</span>, <span class="number">-25</span>), textcoords=<span class="string">'offset points'</span>, color=<span class="string">'g'</span>, fontsize=<span class="number">12</span>, arrowprops=dict(arrowstyle=<span class="string">"-&gt;"</span>,</span><br><span class="line">             connectionstyle=<span class="string">"arc,rad=0"</span>, color=<span class="string">'g'</span>))</span><br><span class="line">plt.annotate(<span class="string">'$p=1$'</span>, xy=(<span class="number">0.5</span>, <span class="number">0.5</span>), xycoords=<span class="string">'data'</span>,</span><br><span class="line">             xytext=(<span class="number">-25</span>, <span class="number">-25</span>), textcoords=<span class="string">'offset points'</span>, color=<span class="string">'r'</span>, fontsize=<span class="number">12</span>, arrowprops=dict(arrowstyle=<span class="string">"-&gt;"</span>,</span><br><span class="line">             connectionstyle=<span class="string">"arc,rad=0"</span>, color=<span class="string">'r'</span>))</span><br><span class="line">plt.annotate(<span class="string">'$p=2$'</span>, xy=(<span class="number">0.7</span>, <span class="number">0.7</span>), xycoords=<span class="string">'data'</span>,</span><br><span class="line">             xytext=(<span class="number">-25</span>, <span class="number">-25</span>), textcoords=<span class="string">'offset points'</span>, color=<span class="string">'b'</span>, fontsize=<span class="number">12</span>, arrowprops=dict(arrowstyle=<span class="string">"-&gt;"</span>,</span><br><span class="line">             connectionstyle=<span class="string">"arc,rad=0"</span>, color=<span class="string">'b'</span>))</span><br><span class="line">plt.annotate(<span class="string">r'$p\to\infty$'</span>, xy=(<span class="number">1</span>, <span class="number">1</span>), xycoords=<span class="string">'data'</span>,</span><br><span class="line">             xytext=(<span class="number">-35</span>, <span class="number">-25</span>), textcoords=<span class="string">'offset points'</span>, color=<span class="string">'k'</span>, fontsize=<span class="number">12</span>, arrowprops=dict(arrowstyle=<span class="string">"-&gt;"</span>,</span><br><span class="line">             connectionstyle=<span class="string">"arc,rad=0"</span>, color=<span class="string">'k'</span>))</span><br><span class="line"></span><br><span class="line">plt.savefig(<span class="string">'f3.png'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>Machine Learning</tag>
      </tags>
  </entry>
  <entry>
    <title>【漫漫科研路\pgfplots】画双Y坐标图</title>
    <url>/2020/01/05/%5B20200105%5D/</url>
    <content><![CDATA[<p>在科研论文写作中，经常会遇到画描述tradeoff的仿真图。比如在5G相关的研究中，经常会出现能效与时延的tradeoff。本文主要介绍如何在论文仿真部分，根据仿真结果（存储于.dat文件中）绘制双Y坐标的曲线。</p>
<a id="more"></a>
<hr>
<p>假定我们有两组仿真数据[x, y1] [x, y2]，分布存储在y1.dat和y2.dat文件中。文件内容如下图所示：</p>
<p>​    <img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20200105/20200105_fig001.jpg" width="220" height="120" title="图1" alt="图1" ></p>
<h2 id=""><a href="#" class="headerlink" title=""></a><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20200105/20200105_fig002.jpg" width="220" height="120" title="图2" alt="图2" ></h2><p>画双Y坐标，主要用到了\pgfplotsset{set layers}命令。在此命令的基础上，分布在两个坐标系画图，就得到了想要的效果。相比于Matlab作图工具，<strong>这里的优势在于，可以用颜色区分两个Y轴。并且，利用pgfplots作图，图中曲线也可以被索引的优势，可以直接在y轴指明曲线类型来区分。</strong></p>
<p><strong>具体源代码如下：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\documentclass[10pt, final, journal, twocolumn, oneside]&#123;IEEEtran&#125;</span><br><span class="line"></span><br><span class="line">%!TEX program &#x3D; xelatex</span><br><span class="line">% !TEX encoding &#x3D; UTF-8  (utf8)</span><br><span class="line">%!TEX spellcheck</span><br><span class="line">%\def\pgfsysdriver&#123;pgfsys-dvipdfmx.def&#125;</span><br><span class="line">\usepackage&#123;tikz&#125;</span><br><span class="line"></span><br><span class="line">\usepackage&#123;pgfplots&#125;</span><br><span class="line">\pgfplotsset&#123;width&#x3D;7cm,compat&#x3D;1.14&#125;\begin&#123;document&#125;</span><br><span class="line">\begin&#123;tikzpicture&#125;</span><br><span class="line">	\pgfplotsset&#123;set layers&#125;</span><br><span class="line">\begin&#123;axis&#125;[scale only axis,</span><br><span class="line">            grid&#x3D;major,</span><br><span class="line">			axis y line*&#x3D;left,</span><br><span class="line">             y axis line style&#x3D;&#123;blue&#125;,</span><br><span class="line">            y tick label style&#x3D;&#123;blue&#125;,</span><br><span class="line">             xlabel&#x3D;x,</span><br><span class="line">			 ylabel&#x3D;\ref&#123;y1&#125;\color&#123;blue&#125;y1,]</span><br><span class="line">			 \addplot [blue,mark&#x3D;square] table[x index&#x3D;0, y index&#x3D;1,red] &#123;y1.dat&#125;;\label&#123;y1&#125;</span><br><span class="line">\end&#123;axis&#125;</span><br><span class="line"></span><br><span class="line">\begin&#123;axis&#125;[scale only axis,</span><br><span class="line">             grid&#x3D;major,</span><br><span class="line">             axis y line*&#x3D;right,</span><br><span class="line">             axis x line&#x3D;none,</span><br><span class="line">             y axis line style&#x3D;&#123;red&#125;,</span><br><span class="line">             y tick label style&#x3D;&#123;red&#125;,</span><br><span class="line">             ylabel&#x3D;\ref&#123;y2&#125;\color&#123;red&#125;y2,</span><br><span class="line">             ]</span><br><span class="line">             \addplot [red,mark&#x3D;asterisk] table[x index&#x3D;0, y index&#x3D;1] &#123;y2.dat&#125;;\label&#123;y2&#125;</span><br><span class="line">\end&#123;axis&#125;</span><br><span class="line"></span><br><span class="line">\end&#123;tikzpicture&#125;</span><br><span class="line"></span><br><span class="line">\end&#123;document</span><br></pre></td></tr></table></figure>
<p><strong>效果图如下：</strong><br><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20200105/20200105_fig003.jpg" width="600" height="450" title="图3" alt="图3" ></p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>Research</tag>
      </tags>
  </entry>
  <entry>
    <title>【漫漫科研路\LaTeX】使用Vim撰写科研论文</title>
    <url>/2019/12/29/%5B20191229%5D/</url>
    <content><![CDATA[<blockquote>
<p>工欲善其事，必先利其器。</p>
</blockquote>
<p>本文介绍如何使用Vim作为编辑器进行科研工作。一般来说，在学术界，使用Vim来写论文的人应该很少。即使是在工程界，大部分也都是使用的是各种IDE，使用Vim来编写代码的也属少数。大多数科研工作者一般都是使用<a href="http://www.winedt.com/" target="_blank" rel="noopener">WinEdt</a>，<a href="https://www.lyx.org/" target="_blank" rel="noopener">Lyx</a>，<a href="http://texstudio.sourceforge.net/" target="_blank" rel="noopener">TeXstudio</a>等集成IDE，其中Lyx所见即所得的效果比较好。</p>
<a id="more"></a>
<p>我最早接触LaTeX是在大二暑假数学建模的时候，当时是使用的WinEdt。后来大四毕业设计的时候，果断选择LaTeX来编写毕业论文。读博之后，实验室普遍推荐用Lyx，我还是用的WinEdt。一方面，用的顺手了比较熟悉；另一方面，论文提交的时候有的要求LaTeX源代码，使用Lyx的话还得转换。又过了一年，偶然间发现了Sublime Text这款比较好的编辑器，于是想着使用Sublime+TexLive+SumatraPDF的组合，并安装了相关插件。相比于WinEdt，使用Sublime Text3写论文有两大好处：</p>
<pre><code>主题可自由选择，语法高亮清晰，可读性好
可视化效果好，鼠标悬停在行间公式或图片处既可以预览
</code></pre><p>又过了两年，决定以后去工程界发展，开始学习熟悉所谓的编辑器之神，便考虑将所有的科研任务使用Vim中使用，这其中就包括了C/C++，LaTeX，Python文件等编辑及运行。下图给出了使用Vim编写论文的基础环境：<br>    <img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20191229/20191229_fig001.jpg" width="600" height="450" title="图1" alt="图1" ></p>
<hr>
<p>下面我通过介绍一些写作比较好用的插件和相关的vimrc配置，来说说使用Vim进行论文编写的一些特点：</p>
<h2 id="lervag-vimtex插件"><a href="#lervag-vimtex插件" class="headerlink" title="lervag/vimtex插件"></a>lervag/vimtex插件</h2><p>vimtex是写LaTeX的主要插件，具体使用可以在Vim中输入命令 <code>:help vimtex</code>，其中最主要的命令如下：</p>
<ul>
<li><p><code>\ll</code> ：编译.tex文件；</p>
</li>
<li><p><code>\lv</code>:  查看生成的pdf文件，正向索引，即会用黄色高亮PDF中对应光标在源文件的位置。反向索引：鼠标焦点在PDF，按下快捷键<code>command(Ctrl)+shift</code>，单机或者双击鼠标；<br><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20191229/20191229_fig002.jpg" width="600" height="200" title="图2" alt="图2" ><br><strong>正向索引</strong>：输入<code>:\lv</code>即可得下图：<br><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20191229/20191229_fig003.jpg" width="600" height="250" title="图3" alt="图3" ></p>
</li>
<li><p><code>\lc</code>: 清除编译过程中产生的中间文件，有时编译错误的时候需要清除这类文件</p>
</li>
<li><p><code>\lt</code>: 打开论文中的label目录，继而可以根据label进行跳转，如下图所示：<br><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20191229/20191229_fig004.jpg" width="600" height="450" title="图4" alt="图4" ><br>具体在.vimrc的配置如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">"----------------Configuration for LaTeX---------------"</span><br><span class="line">"Type help vimtex for detailed information</span><br><span class="line">let g:tex_flavor='latex'</span><br><span class="line">let g:vimtex_view_method='skim' "Use Skim as the pdf viewer</span><br><span class="line">let g:vimtex_view_automatic=1</span><br><span class="line">let g:vimtex_quickfix_mode=2</span><br><span class="line">let g:vimtex_quickfix_autoclose_after_keystrokes=1</span><br><span class="line">set conceallevel=2</span><br><span class="line">let g:tex_conceal='abdmg'</span><br><span class="line">let g:vimtex_quickfix_autojump=1</span><br><span class="line">let g:vimtex_compiler_latexmk = &#123;</span><br><span class="line">    \ 'options' : [</span><br><span class="line">    \   '-xelatex',</span><br><span class="line">    \   '-verbose',</span><br><span class="line">    \   '-file-line-error',</span><br><span class="line">    \   '-synctex=1',</span><br><span class="line">    \   '-interaction=nonstopmode',</span><br><span class="line">    \ ],</span><br><span class="line">    \&#125;</span><br><span class="line"></span><br><span class="line">let g:vimtex_complete_ignore_case=1</span><br><span class="line">let g:vimtex_complete_close_braces=1</span><br><span class="line"></span><br><span class="line">"In insert mode show the details, show the math equations othewise</span><br><span class="line">autocmd FileType tex inoremap jk &lt;esc&gt;:set conceallevel=2&lt;cr&gt;</span><br><span class="line">autocmd FileType tex nnoremap i :set conceallevel=0&lt;cr&gt;i</span><br><span class="line">autocmd FileType tex nnoremap s :set conceallevel=0&lt;cr&gt;s</span><br><span class="line">autocmd FileType tex nnoremap a :set conceallevel=0&lt;cr&gt;a</span><br><span class="line">autocmd Filetype tex setlocal nofoldenable</span><br><span class="line"></span><br><span class="line">"-------set the shortcuts for compiling, viewing, and cleaning .tex files</span><br><span class="line">autocmd FileType tex nmap &lt;leader&gt;b  \ll</span><br><span class="line">autocmd FileType tex nmap &lt;leader&gt;v \lv</span><br><span class="line">autocmd FileType tex  nmap &lt;leader&gt;c \lc</span><br><span class="line">autocmd FileType tex nmap &lt;leader&gt;t \lt</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h2 id="xuhdev-vim-latex-live-preview-插件"><a href="#xuhdev-vim-latex-live-preview-插件" class="headerlink" title="xuhdev/vim-latex-live-preview 插件"></a>xuhdev/vim-latex-live-preview 插件</h2><p>该插件可以实现<strong>实时预览</strong>，但是目前来说，我使用skim和zathura阅读器效果都不太好，容易出现卡顿现象。该插件在.vimrc的配置如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">"----------Settings for xuhdev/vim-latex-live-preview</span><br><span class="line">autocmd Filetype tex setl updatetime=15 "To set the update time for live view</span><br><span class="line">let g:livepreview_previewer='open -a skim'</span><br></pre></td></tr></table></figure>
<p>若要使用该功能可以在Vim输入命令 <code>:LLPStarPreview</code></p>
<hr>
<h2 id="sirver-ultisnips-和-honza-vim-snippets自定义代码块插件"><a href="#sirver-ultisnips-和-honza-vim-snippets自定义代码块插件" class="headerlink" title="sirver/ultisnips 和 honza/vim-snippets自定义代码块插件"></a><a href="https://github.com/SirVer/ultisnips" target="_blank" rel="noopener">sirver/ultisnips</a> 和 <a href="https://github.com/honza/vim-snippets" target="_blank" rel="noopener">honza/vim-snippets</a>自定义代码块插件</h2><p>其中，ultisnips需要自己定义替代规则，而vim-snippets提供了常用的一些代码块。安装这两个插件需要在.vimrc中添加相应代码：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Plugin 'sirver/ultisnips'</span><br><span class="line">Plugin 'honza/vim-snippets'</span><br></pre></td></tr></table></figure><br>其中调用补全的快捷键设置如下：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">let g:UltiSnipsExpandTrigger = '&lt;tab&gt;'</span><br><span class="line">let g:UltiSnipsJumpForwardTrigger = '&lt;tab&gt;'</span><br><span class="line">let g:UltiSnipsJumpBackwardTrigger = '&lt;s-tab&gt;'</span><br></pre></td></tr></table></figure></p>
<p>对于不同类型的文件都有不同的.snippets，比如tex.snippets文件中就是关于LateX文件的一些常用代码块，其目录位于/Users/tengweitw/.vim/bundle/vim-snippets/UltiSnips/tex.snippets （MacOS系统）。查看tex.snippets 文件，我们可以看到几个科研写作中比较常用的代码块：</p>
<ul>
<li>在插入模式下，在句首输入b或者begin之后按Tab键，会补全整个\begin….\end环境<br><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20191229/20191229_fig005.jpg" width="400" height="150" title="图5" alt="图5" ></li>
<li>在插入模式下，输入fig后按Tab键，会补全整个插入图片的代码段<br><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20191229/20191229_fig006.jpg" width="400" height="150" title="图6" alt="图6" ></li>
<li>在插入模式下，输入sec或者sub后按Tab键，会补全章节\section{}（\subsection{}）并添加label<br><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20191229/20191229_fig007.jpg" width="400" height="100" title="图7" alt="图7" ><br>该文件中还有一些其他快捷代码块，都比较好理解，可自行查看。当然我们也可以自己在这个文件中添加自定义的代码块，我最常用的就是插入行内公式代码块，添加如下代码即可：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">snippet mk &quot;Math&quot; wA</span><br><span class="line">$$&#123;1&#125;$&#96;!p</span><br><span class="line">if t[2] and t[2][0] not in [&#39;,&#39;, &#39;.&#39;, &#39;?&#39;, &#39;-&#39;, &#39; &#39;]:</span><br><span class="line">    snip.rv &#x3D; &#39; &#39;</span><br><span class="line">else:</span><br><span class="line">    snip.rv &#x3D; &#39;&#39;</span><br><span class="line">&#96;$2</span><br><span class="line">endsnippet</span><br></pre></td></tr></table></figure>
<p>该代码块的作用是，当我们输入<code>mk</code>时，自动添加行内公式环境，并且鼠标位于$$中间。这里不需要按Tab键，因为代码中的A(uto)意味着自动补全。注意这里使用<code>mk</code>是因为以<code>mk</code>为首的英文字母不常见。 关于如何自定义代码块，请读者自行网上搜索。</p>
<hr>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>Research</tag>
      </tags>
  </entry>
  <entry>
    <title>【漫漫科研路\pgfplots】克服绘制色温图时，数据量大出现的内存限制</title>
    <url>/2019/12/22/%5B20191222%5D/</url>
    <content><![CDATA[<p>在科研论文写作中，经常会遇到画色温图，3D图。此时一般输入的数据量比较大，导致在Latex中使用Tikz画图时出现内存不足的情况。常常报错如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">! TeX capacity exceeded, sorry [main memory size&#x3D;5000000].</span><br></pre></td></tr></table></figure>
<p>参考pgfplots手册中的第六章，我们有以下解决方案：</p>
<ul>
<li>使用LuaTex进行编译<br>有些版本不含LuaTex</li>
<li>对输入数据采样降低数据量<br>不是从本质上解决问题，降低了精度</li>
<li>使用其它软件画图，e.g., MATLAB</li>
<li>增大LaTex的编译内存</li>
</ul>
<a id="more"></a>
<hr>
<p>本文主要介绍如何在MacOS系统中Texlive平台下，克服内LaTex内存限制。关于在Linux和MiKTEX环境下，<a href="http://pgfplots.sourceforge.net/" target="_blank" rel="noopener">pgfplots</a>手册已给了说明，这里不再赘述。</p>
<p><strong>解决办法</strong>：在Texlive安装目录中找到texmf.cnf文件并编辑：</p>
<p><em>其安装目录在</em>：</p>
<p>/usr/local/texlive/2018/texmf-dist/web2c/texmf.cnf</p>
<p>注意：/usr/local/texlive/2018/texmf.cnf也有相同的文件，编辑这个文件无法解决问题</p>
<p><em>其内容修改如下：</em><br>    <img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20191222/20191222_fig001.jpg" width="400" height="300" title="图1" alt="图1" ><br>注意：修改的内存大小不能超过实际内存大小，我的是8G.</p>
<p>最后，打开终端进入安装目录下，执行</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">sudo texhash</span><br></pre></td></tr></table></figure>
<p>若发生文件不可写的情况，可以使用<code>chmod 777</code> 来更改文件读写权限。</p>
<hr>
<p>下面，我们通过实例来验证：</p>
<ul>
<li><p>数据产生<br>我们使用Matlab的peaks函数来产生peaks.dat文件用于tikz画图的输入数据。其代码如下：</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clear all</span><br><span class="line">clc</span><br><span class="line">close all</span><br><span class="line"></span><br><span class="line">lambda_total=<span class="number">2</span>;<span class="comment">% the sum of Z</span></span><br><span class="line">[X,Y,Z] = peaks(<span class="number">100</span>);</span><br><span class="line">Z(Z&lt;<span class="number">0</span>)=<span class="number">0</span>;</span><br><span class="line">Z=Z/sum(sum(Z))*lambda_total;</span><br><span class="line"></span><br><span class="line">x_temp=<span class="built_in">repmat</span>(<span class="number">1</span>:<span class="number">100</span>,<span class="number">100</span>,<span class="number">1</span>);<span class="comment">% X-axis</span></span><br><span class="line">x_temp=x_temp(:);  </span><br><span class="line">y_temp=<span class="built_in">repmat</span>(<span class="number">1</span>:<span class="number">100</span>,<span class="number">1</span>,<span class="number">100</span>);<span class="comment">%Y-axis</span></span><br><span class="line"></span><br><span class="line">xyz=[<span class="string">'x y z'</span>];</span><br><span class="line">dlmwrite(<span class="string">'peaks.dat'</span>,xyz,<span class="string">'delimiter'</span>,<span class="string">' '</span>);</span><br><span class="line"><span class="keyword">for</span> x_ind=<span class="number">1</span>:<span class="built_in">size</span>(Z,<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> y_ind=<span class="number">1</span>:<span class="built_in">size</span>(Z,<span class="number">2</span>)</span><br><span class="line">        <span class="comment">% for one point (x,y,z), we use 4 coordinates (x,y,z) (x,y+1,z) (x+1,y+1,z) (x+1,y,z) to form a patch</span></span><br><span class="line">        xyz=[x_ind y_ind Z(x_ind, y_ind);x_ind y_ind+<span class="number">1</span> Z(x_ind, y_ind);x_ind+<span class="number">1</span> y_ind+<span class="number">1</span> Z(x_ind, y_ind);x_ind+<span class="number">1</span> y_ind Z(x_ind, y_ind)];</span><br><span class="line">        <span class="keyword">if</span>(x_ind==<span class="number">1</span>&amp;&amp;y_ind==<span class="number">1</span>)</span><br><span class="line">            dlmwrite(<span class="string">'peaks.dat'</span>,xyz,<span class="string">'delimiter'</span>,<span class="string">' '</span>,<span class="string">'-append'</span>,<span class="string">'roffset'</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            dlmwrite(<span class="string">'peaks.dat'</span>,xyz,<span class="string">'delimiter'</span>,<span class="string">' '</span>,<span class="string">'-append'</span>,<span class="string">'roffset'</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在Tikz中画图<br>本文使用了patch来画图，也可以改用surf, mesh等。完整latex源代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> \documentclass&#123;standalone&#125;</span><br><span class="line">\def\pgfsysdriver&#123;pgfsys-dvipdfmx.def&#125;</span><br><span class="line">\usepackage&#123;tikz&#125;</span><br><span class="line">\usepackage&#123;pgfplots&#125;</span><br><span class="line">\pgfplotsset&#123;width&#x3D;7cm,compat&#x3D;1.14&#125;</span><br><span class="line"></span><br><span class="line">\begin&#123;document&#125;</span><br><span class="line">\begin&#123;tikzpicture&#125; </span><br><span class="line">	\begin&#123;axis&#125;[</span><br><span class="line">		colorbar,</span><br><span class="line">        xmin&#x3D;1,xmax&#x3D;101,</span><br><span class="line">		ymin&#x3D;1,ymax&#x3D;101,</span><br><span class="line">		xlabel&#x3D;&#123;X-axis (m)&#125;,</span><br><span class="line">		ylabel&#x3D;&#123;Y-axis (m)&#125;,</span><br><span class="line">	]</span><br><span class="line">	\addplot [patch,patch type&#x3D;rectangle] </span><br><span class="line">		table [point meta&#x3D;\thisrow&#123;z&#125;]</span><br><span class="line">		&#123;peaks.dat &#125;; </span><br><span class="line">    \end&#123;axis&#125;</span><br><span class="line">\end&#123;tikzpicture&#125;</span><br><span class="line">\end&#123;document&#125;</span><br></pre></td></tr></table></figure>
<p>画图效果如下：<br><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20191222/20191222_fig002.jpg" width="400" height="300" title="图2" alt="图2" ></p>
</li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>Research</tag>
      </tags>
  </entry>
  <entry>
    <title>【漫漫科研路\pgfplots】画局部放大图</title>
    <url>/2019/12/15/%5B20191215%5D/</url>
    <content><![CDATA[<p>在科研论文写作中，我们经常需要放大局部图片来显示细节，即绘制图中图。在Matlab中可以使用magnify或则axes函数，网上有很多例子，这里不再赘述。本文主要讲解如何使用tikz/pgfplots来画局部放大图中图。</p>
<a id="more"></a>
<p>绘制局部放大图，需要使用到spy宏包，本文主要参考<a href="http://pgfplots.sourceforge.net/" target="_blank" rel="noopener">pgfplots</a>手册。下面给出一个最简单的实例，具体代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\documentclass[10pt, final, journal, twocolumn, oneside]&#123;IEEEtran&#125;</span><br><span class="line"></span><br><span class="line">%!TEX program &#x3D; xelatex</span><br><span class="line">% !TEX encoding &#x3D; UTF-8  (utf8)</span><br><span class="line">%!TEX spellcheck</span><br><span class="line">\def\pgfsysdriver&#123;pgfsys-dvipdfmx.def&#125;</span><br><span class="line">\usepackage&#123;tikz&#125;</span><br><span class="line"></span><br><span class="line">\usepackage&#123;pgfplots&#125;</span><br><span class="line">\usetikzlibrary&#123;spy&#125; %</span><br><span class="line">\pgfplotsset&#123;width&#x3D;7cm,compat&#x3D;1.14&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">\begin&#123;document&#125;</span><br><span class="line"></span><br><span class="line">\begin&#123;tikzpicture&#125;[spy using outlines&#x3D; &#123;circle, magnification&#x3D;6, connect spies&#125;]</span><br><span class="line">% define the shape of spy: circle or rectangle</span><br><span class="line">\begin&#123;axis&#125;[no markers,grid&#x3D;major, every axis plot post&#x2F;.append style&#x3D;&#123;thick&#125;]</span><br><span class="line">	\addplot coordinates &#123;(0, 0) (0, 0.9) (1, 0.9) (2, 1) (3, 0.9) (80, 0)&#125;; </span><br><span class="line">	\addplot+ [line join&#x3D;round] coordinates &#123;(0, 0) (0, 0.9) (2, 0.9) (3, 1) (4, 0.9) (80, 0)&#125;; </span><br><span class="line">	\addplot+ [line join&#x3D;bevel] coordinates &#123;(0, 0) (0, 0.9) (3, 0.9) (4, 1) (5, 0.9) (80, 0)&#125;;</span><br><span class="line">	\addplot+ [miter limit&#x3D;5] coordinates &#123;(0, 0) (0, 0.9) (4, 0.9) (5, 1) (6, 0.9) (80, 0)&#125;;</span><br><span class="line"></span><br><span class="line">\coordinate (spypoint) at (3,1);% The point to be magnified </span><br><span class="line">\coordinate (magnifyglass) at (60,0.7);% The point where to see  </span><br><span class="line">\end&#123;axis&#125;</span><br><span class="line"></span><br><span class="line">\spy [blue, size&#x3D;2.5cm] on (spypoint) in node[fill&#x3D;white] at (magnifyglass); </span><br><span class="line">\end&#123;tikzpicture&#125;</span><br><span class="line">\end&#123;document&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：<br>    <img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20191215/20191215_fig001.jpg" width="400" height="300" title="图1" alt="图1" ></p>
<hr>
<p>代码简单易懂，也给出了部分注释。为了使得更加个性化，我们可以修改放大图的轮廓，或则背景色，具体代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\documentclass[10pt, final, journal, twocolumn, oneside]&#123;IEEEtran&#125;</span><br><span class="line"></span><br><span class="line">%!TEX program &#x3D; xelatex</span><br><span class="line">% !TEX encoding &#x3D; UTF-8  (utf8)</span><br><span class="line">%!TEX spellcheck</span><br><span class="line">\def\pgfsysdriver&#123;pgfsys-dvipdfmx.def&#125;</span><br><span class="line">\usepackage&#123;tikz&#125;</span><br><span class="line"></span><br><span class="line">\usepackage&#123;pgfplots&#125;</span><br><span class="line">\usetikzlibrary&#123;spy&#125; %</span><br><span class="line">\pgfplotsset&#123;width&#x3D;7cm,compat&#x3D;1.14&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">\begin&#123;document&#125;</span><br><span class="line">\begin&#123;tikzpicture&#125;[spy using overlays&#x3D; &#123;rectangle, magnification&#x3D;6, connect spies&#125;]</span><br><span class="line">% define the shape of spy: circle or rectangle</span><br><span class="line">\begin&#123;axis&#125;[no markers,grid&#x3D;major, every axis plot post&#x2F;.append style&#x3D;&#123;thick&#125;]</span><br><span class="line">	\addplot coordinates &#123;(0, 0) (0, 0.9) (1, 0.9) (2, 1) (3, 0.9) (80, 0)&#125;; </span><br><span class="line">	\addplot+ [line join&#x3D;round] coordinates &#123;(0, 0) (0, 0.9) (2, 0.9) (3, 1) (4, 0.9) (80, 0)&#125;; </span><br><span class="line">	\addplot+ [line join&#x3D;bevel] coordinates &#123;(0, 0) (0, 0.9) (3, 0.9) (4, 1) (5, 0.9) (80, 0)&#125;;</span><br><span class="line">	\addplot+ [miter limit&#x3D;5] coordinates &#123;(0, 0) (0, 0.9) (4, 0.9) (5, 1) (6, 0.9) (80, 0)&#125;;</span><br><span class="line"></span><br><span class="line">\coordinate (spypoint) at (3,1);% The point to be magnified </span><br><span class="line">\coordinate (magnifyglass) at (60,0.7);% The point where to see  </span><br><span class="line">\end&#123;axis&#125;</span><br><span class="line"></span><br><span class="line">\spy [green,size&#x3D;2.5cm] on (spypoint) in node at (magnifyglass); </span><br><span class="line">\end&#123;tikzpicture&#125;</span><br><span class="line">\end&#123;document&#125;</span><br></pre></td></tr></table></figure>
<p>显示效果如下：<br><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20191215/20191215_fig002.jpg" width="400" height="300" title="图2" alt="图2" ></p>
<hr>
<p>由上图可以看到，相比于Matlab，这里局部放大图更加灵活和个性化。但是Matlab的局部放大图一般都有坐标轴，方便查看局部图的值大小。在Tikz/pgfplots中利用Spy宏包实现相同的效果比较困难。但是我们可以另辟蹊径: 只需要利用node，在node中重新画一个图，只是自己设置横纵坐标的值，从而实现局部放大。具体代码实现如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\documentclass[10pt, final, journal, twocolumn, oneside]&#123;IEEEtran&#125;</span><br><span class="line"></span><br><span class="line">%!TEX program &#x3D; xelatex</span><br><span class="line">% !TEX encoding &#x3D; UTF-8  (utf8)</span><br><span class="line">%!TEX spellcheck</span><br><span class="line">\def\pgfsysdriver&#123;pgfsys-dvipdfmx.def&#125;</span><br><span class="line">\usepackage&#123;tikz&#125;</span><br><span class="line"></span><br><span class="line">\usepackage&#123;pgfplots&#125;</span><br><span class="line">\usetikzlibrary&#123;spy&#125; %</span><br><span class="line">\pgfplotsset&#123;width&#x3D;7cm,compat&#x3D;1.14&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">\begin&#123;document&#125;</span><br><span class="line">\begin&#123;tikzpicture&#125;[pin distance&#x3D;1.5cm]</span><br><span class="line">\begin&#123;axis&#125;[no markers,grid&#x3D;major, every axis plot post&#x2F;.append style&#x3D;&#123;thick&#125;]</span><br><span class="line">	\addplot coordinates &#123;(0, 0) (0, 0.9) (1, 0.9) (2, 1) (3, 0.9) (80, 0)&#125;; </span><br><span class="line">	\addplot+ [line join&#x3D;round] coordinates &#123;(0, 0) (0, 0.9) (2, 0.9) (3, 1) (4, 0.9) (80, 0)&#125;; </span><br><span class="line">	\addplot+ [line join&#x3D;bevel] coordinates &#123;(0, 0) (0, 0.9) (3, 0.9) (4, 1) (5, 0.9) (80, 0)&#125;;</span><br><span class="line">	\addplot+ [miter limit&#x3D;5] coordinates &#123;(0, 0) (0, 0.9) (4, 0.9) (5, 1) (6, 0.9) (80, 0)&#125;;</span><br><span class="line">	\coordinate (spy_point) at (axis cs:0,1);</span><br><span class="line">\end&#123;axis&#125;</span><br><span class="line">%plot the magnified figure using a node</span><br><span class="line">\node[pin&#x3D;-5:&#123;%</span><br><span class="line">    \begin&#123;tikzpicture&#125;</span><br><span class="line">    \begin&#123;axis&#125;[no markers, thick,scale&#x3D;0.8,</span><br><span class="line">        tiny,</span><br><span class="line">      xlabel&#x3D;&#123;x&#125;,</span><br><span class="line">      ylabel&#x3D;&#123;y&#125;,</span><br><span class="line">      xmin&#x3D;0,xmax&#x3D;8,</span><br><span class="line">      ymin&#x3D;0.85,ymax&#x3D;1.05,</span><br><span class="line">      enlargelimits,</span><br><span class="line">    ]</span><br><span class="line">    \addplot coordinates &#123;(0, 0) (0, 0.9) (1, 0.9) (2, 1) (3, 0.9) (80, 0)&#125;; </span><br><span class="line">	\addplot+ [line join&#x3D;round] coordinates &#123;(0, 0) (0, 0.9) (2, 0.9) (3, 1) (4, 0.9) (80, 0)&#125;; </span><br><span class="line">	\addplot+ [line join&#x3D;bevel] coordinates &#123;(0, 0) (0, 0.9) (3, 0.9) (4, 1) (5, 0.9) (80, 0)&#125;;</span><br><span class="line">	\addplot+ [miter limit&#x3D;5] coordinates &#123;(0, 0) (0, 0.9) (4, 0.9) (5, 1) (6, 0.9) (80, 0)&#125;;</span><br><span class="line"></span><br><span class="line">    \end&#123;axis&#125;</span><br><span class="line">    \end&#123;tikzpicture&#125;%</span><br><span class="line">&#125;] at (spy_point) &#123;&#125;;</span><br><span class="line">\end&#123;tikzpicture&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：<br><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20191215/20191215_fig003.jpg" width="400" height="300" title="图3" alt="图3" ></p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>Research</tag>
      </tags>
  </entry>
  <entry>
    <title>【漫漫科研路】科研环境软硬件</title>
    <url>/2019/12/08/%5B20191208%5D/</url>
    <content><![CDATA[<p>本文旨在向大家推荐个人在科研过程中觉得还不错的硬件和软件。</p>
<a id="more"></a>
<h2 id="硬件"><a href="#硬件" class="headerlink" title="硬件"></a>硬件</h2><p>与其他专业不同，我所处的科研环境不需要其他外部实验设备，只需要一台电脑，一根网线而已。因此硬件方面，跟大多数程序员大同小异。下面列举硬件清单：</p>
<ul>
<li>Mac mini 2018 mid<br>早在2014年，用的是实验室标配的台式机，主机+显示屏+键盘好像是2500左右。没过多久，我就换成了实验室淘汰的2011购买的think centre服务器，最少还是个酷睿i5的cpu。后来，我自己买了一块120G的Intel系列的SSD，使其重新焕发光彩。用了两年后，SSD居然坏了。于是乎放弃了这台台式机，改用了我自己的笔记本Thinkpad T440（也是我现在正在码字用的笔记本）。 记得这个笔记是于2015年春季购买，后来又自己买了个256G的SSD装上。为了便携方便，我又在咸鱼买了个thinkpad 扩展坞。后来，在苹果在2018秋季发布会的时候，推出了四年才更新的Mac mini，恰好人正在美国访学，于是乎果断入手。当时是在美国亚马逊1049美元购买，discover 有10%的bonus，算下来差不多是950美元入手。相比于国内的8899还是便宜太多。</li>
<li>人体工程学椅<br>记得最开始的时候，坐的是实验室的圆凳子，而且还是破了一角的凳子。后来我自己又在走廊里的垃圾堆放处找了一把可旋转、有靠背的椅子。最后来，在2015的618时期，在京东买了一把五百多的人体工程学椅西昊M16。买了后，感觉的确有点效果，以前腰酸背痛的感觉明显好转。</li>
<li>Dell P系列显示器<br>实验室配置的是三星的显示器，但是我一直都是用的两个显示屏。之前都是随便拿实验室报废的显示器使用，两个显示器存在明显的色差。后来，在2015年双十一的时候，一口气就买了2个19寸左右的实验室。在美国访学期间，也是在实验室找的两个配置更高些的Dell u系列的显示器。</li>
<li>HHKB Type-s 静电容键盘<br>起初，用的是实验室买电脑送的键盘，牌子估计是双飞燕，忘记了。后来在2015年，买了ThinkPad的小红点有线键盘，编号为0B47190。这把键盘是我使用时间最长的键盘，用了四年，期间还随我漂洋过海到美国。后来由于一些失误，不小心把键盘的按键弄坏了两个，随后便买了这款键盘的蓝牙升级版本，编号为4X30K12182。但是由于实验室无线环境复杂，该键盘经常出现按键延迟响应，现在已经沦落为我ipad的备用键盘了。后来实验室同学又推荐机械键盘，我自己又在网上调研了一番，便发现了这款适合于Mac、Vim、程序员的HHKB Type-s的退烧键盘。恰逢双十一，于是一狠心、一跺脚就买了。心里暗暗说服自己，这个键盘可以用个十年，这么算来性价比还可以吧。之所以买这个静音版，一方面是因为实验室环境，不好意思影响他人；另一方面是因为蓝牙版本可能出现前面的无线冲突情况。</li>
<li>Apple Magic Trackpad 2<br>其实我对于鼠标并没有什么追求，之前一直都是用的在普通不过的鼠标。后来使用thinkpad小红点键盘后，就没有使用过鼠标了。后来，在2018年的某一天，我发现长期使用小红点，会出现食指的指甲盖明显的弯曲，估计是常年用食指使用小红点的缘故。于是乎，在有mac mini的前提下，就购买了触摸板，买了之后，发现实在是太香了。之后就是在写论文和编代码的时候使用小红点，看论文的时候就是用触摸板。</li>
<li>小米圈铁耳机2<br>我对于音乐的欣赏，应该处于木耳阶段。完全是因为有事需要听点音乐提神，就随便买了个耳机。其实，如果需要降噪的话，可以考虑Sony的mx 1000系列和bose的qc 35系列，感觉评价都不错。</li>
</ul>
<p>最后附一张实验室的科研环境图：<br>    <img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20191208/20191208_fig001.jpg" width="600" height="450" title="图1" alt="图1" ></p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>Research</tag>
      </tags>
  </entry>
  <entry>
    <title>【漫漫科研路\C&amp;C++】CPLEX解SOCP问题</title>
    <url>/2019/12/01/%5B20191201%5D/</url>
    <content><![CDATA[<p>IBM CPLEX可以解SOCP问题，但是需要先将这个SOCP问题化为指定的格式。本文首先介绍SOCP问题，然后举例介绍如何将SOCP问题转化为CPLEX认可的输入格式并求解。</p>
<a id="more"></a>
<h2 id="SOCP的介绍"><a href="#SOCP的介绍" class="headerlink" title="SOCP的介绍"></a>SOCP的介绍</h2><p>关于SOCP问题的介绍，可以参考Boyd等人写的<a href="http://stanford.edu/~boyd/cvxbook/" target="_blank" rel="noopener">Convex Optimization</a> 或者是<a href="https://en.wikipedia.org/wiki/Second-order_cone_programming" target="_blank" rel="noopener">维基百科的SOCP词条</a> 。这里摘录Convex Optimization一书中关于SOCP的定义：</p>
<p>​    <img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20191201/20191201_fig001.jpg" width="600" height="350" title="图1" alt="图1" ></p>
<h2 id="CPLEX求解SOCP问题"><a href="#CPLEX求解SOCP问题" class="headerlink" title="CPLEX求解SOCP问题"></a>CPLEX求解SOCP问题</h2><p>使用CPLEX求解SOCP问题，一般需要将问题转化为CPLEX可以识别的格式。CPLEX的例子ilosocpex1(位于安装目录的examples文件夹内，例如：C:\Program Files\IBM\ILOG\CPLEX_Enterprise_Server129\CPLEX_Studio\cplex\examples)给予了格式说明：<br><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20191201/20191201_fig002.jpg" width="600" height="550" title="图2" alt="图2" ><br>下面我们首先给一个直接可以使用CPLEX求解的例子，然后在此基础上考虑一个更一般的例子（需要变量替换来符合格式）。</p>
<h4 id="一个简单的例子"><a href="#一个简单的例子" class="headerlink" title="一个简单的例子"></a>一个简单的例子</h4><p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20191201/20191201_fig003.jpg" width="600" height="350" title="图3" alt="图3" ><br>如上图所示，q1, q2可以直接转化为前面提到的CPLEX认可格式。下面给出源代码如下（注意项目需要预先配置好，配置请见<a href="https://tengweitw.blog.csdn.net/article/details/103113392" target="_blank" rel="noopener">上一篇博文</a>）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ilcplex/ilocplex.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">ILOSTLBEGIN <span class="comment">// import namespace std</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Tolerance for testing KKT conditions.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TESTTOL 1e-9</span></span><br><span class="line"><span class="comment">// Tolerance for barrier convergence.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONVTOL 1e-9</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">//  A Simple Example</span></span><br><span class="line"> <span class="comment">//  Minimize</span></span><br><span class="line"> <span class="comment">//   obj: x1 + x2 + x3 + x4 + x5 + x6</span></span><br><span class="line"> <span class="comment">//  Subject To</span></span><br><span class="line"> <span class="comment">//   c1: x1 + x2      + x5      = 8</span></span><br><span class="line"> <span class="comment">//   c2:           x3 + x5 + x6 = 10</span></span><br><span class="line"> <span class="comment">//   q1: x1 &gt;= |(x2, x3)| ----&gt;&gt;&gt;&gt;  q1: [ -x1^2 + x2^2 + x3^2 ] &lt;= 0 and x1 &gt;=0</span></span><br><span class="line"> <span class="comment">//   q2: x4 &gt;= |x5|       ----&gt;&gt;&gt;&gt;  q2: [ -x4^2 + x5^2 ] &lt;= 0 and x4 &gt;=0</span></span><br><span class="line"> <span class="comment">//  Bounds</span></span><br><span class="line"> <span class="comment">//   x2 Free</span></span><br><span class="line"> <span class="comment">//   x3 Free</span></span><br><span class="line"> <span class="comment">//   x5 Free</span></span><br><span class="line"> <span class="comment">//   x6 Free</span></span><br><span class="line"> <span class="comment">//  End</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">createmodel(IloModel&amp; model, IloObjective &amp;obj, IloNumVarArray &amp;x,</span><br><span class="line">	IloRangeArray &amp;rngs, IloIntArray&amp; cone)</span><br><span class="line">&#123;</span><br><span class="line">	IloEnv env = model.getEnv();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Create variables.</span></span><br><span class="line">	x.add(IloNumVar(env, <span class="number">0</span>, IloInfinity));</span><br><span class="line">	x.add(IloNumVar(env, -IloInfinity, IloInfinity));</span><br><span class="line">	x.add(IloNumVar(env, -IloInfinity, IloInfinity));</span><br><span class="line">	x.add(IloNumVar(env, <span class="number">0</span>, IloInfinity));</span><br><span class="line">	x.add(IloNumVar(env, -IloInfinity, IloInfinity));</span><br><span class="line">	x.add(IloNumVar(env, -IloInfinity, IloInfinity));</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Create objective function and immediately store it in return value.</span></span><br><span class="line">	<span class="comment">// obj = IloMinimize(env, x1 + x2 + x3 + x4 + x5 + x6);</span></span><br><span class="line">	obj = IloMinimize(env, x[<span class="number">0</span>]+x[<span class="number">1</span>] + x[<span class="number">2</span>] + x[<span class="number">3</span>] + x[<span class="number">4</span>] + x[<span class="number">5</span>]);</span><br><span class="line">	<span class="comment">// Setup model.</span></span><br><span class="line">	model.add(x[<span class="number">0</span>] + x[<span class="number">1</span>] + x[<span class="number">4</span>]==<span class="number">8</span>);</span><br><span class="line">	model.add(x[<span class="number">2</span>] + x[<span class="number">4</span>] + x[<span class="number">5</span>]==<span class="number">10</span>);</span><br><span class="line">	model.add(-x[<span class="number">0</span>] * x[<span class="number">0</span>] + x[<span class="number">1</span>] * x[<span class="number">1</span>] + x[<span class="number">2</span>] * x[<span class="number">2</span>]&lt;=<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//equal to model.add(-x[3] * x[3] + x[4] * x[4]&lt;=0), useful for lots of variables</span></span><br><span class="line">	<span class="keyword">double</span> a[] = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>, <span class="number">-1</span>,<span class="number">1</span> &#125;;</span><br><span class="line">	<span class="function">IloExpr <span class="title">temp</span><span class="params">(env)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (IloInt i = <span class="number">3</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		temp += a[i] * x[i] * x[i];</span><br><span class="line">	&#125;</span><br><span class="line">	model.add(temp &lt;= <span class="number">0</span>);</span><br><span class="line">	temp.end();</span><br><span class="line"></span><br><span class="line">	model.add(obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">main(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">	IloEnv env;</span><br><span class="line">	<span class="keyword">int</span> retval = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="comment">// Create the model.</span></span><br><span class="line">		<span class="function">IloModel <span class="title">model</span><span class="params">(env)</span></span>;</span><br><span class="line">		<span class="function">IloCplex <span class="title">cplex</span><span class="params">(env)</span></span>;</span><br><span class="line">		<span class="function">IloObjective <span class="title">obj</span><span class="params">(env)</span></span>;</span><br><span class="line">		<span class="function">IloNumVarArray <span class="title">vars</span><span class="params">(env)</span></span>;</span><br><span class="line">		<span class="function">IloRangeArray <span class="title">rngs</span><span class="params">(env)</span></span>;</span><br><span class="line">		<span class="function">IloIntArray <span class="title">cone</span><span class="params">(env)</span></span>;</span><br><span class="line">		createmodel(model, obj, vars, rngs, cone);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Extract model.</span></span><br><span class="line">		cplex.extract(model);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Solve the problem. If we cannot find an _optimal_ solution then</span></span><br><span class="line">		<span class="comment">// there is no point in checking the KKT conditions and we throw an</span></span><br><span class="line">		<span class="comment">// exception.</span></span><br><span class="line">		cplex.setParam(IloCplex::Param::Barrier::QCPConvergeTol, CONVTOL);</span><br><span class="line">		<span class="keyword">if</span> (!cplex.solve() || cplex.getStatus() != IloAlgorithm::Optimal)</span><br><span class="line">			<span class="keyword">throw</span> <span class="built_in">string</span>(<span class="string">"Failed to solve problem to optimality"</span>);</span><br><span class="line"></span><br><span class="line">		<span class="function">IloNumArray <span class="title">vals_x</span><span class="params">(env)</span></span>;</span><br><span class="line">		env.out() &lt;&lt; <span class="string">"Solution status = "</span> &lt;&lt; cplex.getStatus() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		env.out() &lt;&lt; <span class="string">"Solution value  = "</span> &lt;&lt; cplex.getObjValue() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		cplex.getValues(vals_x, vars);</span><br><span class="line">		env.out() &lt;&lt; <span class="string">"Values        = "</span> &lt;&lt; vals_x &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		env.end();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (IloException &amp;e) &#123;</span><br><span class="line">		<span class="built_in">cerr</span> &lt;&lt; <span class="string">"IloException: "</span> &lt;&lt; e &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">if</span> (env.getImpl())</span><br><span class="line">			env.end();</span><br><span class="line">		::<span class="built_in">abort</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (<span class="built_in">string</span>&amp; e) &#123;</span><br><span class="line">		<span class="built_in">cerr</span> &lt;&lt; e &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">if</span> (env.getImpl())</span><br><span class="line">			env.end();</span><br><span class="line">		::<span class="built_in">abort</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20191201/20191201_fig004.jpg" width="600" height="450" title="图4" alt="图4" ></p>
<hr>
<h4 id="一个更一般的例子"><a href="#一个更一般的例子" class="headerlink" title="一个更一般的例子"></a>一个更一般的例子</h4><p>在前面例子的基础上，我们只是改变了约束q1，使其更一般化，如下图所示：<br><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20191201/20191201_fig005.jpg" width="600" height="350" title="图5" alt="图5" ></p>
<p>为了将q1转化为合适的格式，我们使用变量替换  $x_7=x_1+x_2 $ 。因此只需在前面源代码中更改 createmodel 函数中的部分代码。为保持代码完整性，我们依旧给出完整的代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ilcplex/ilocplex.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">ILOSTLBEGIN <span class="comment">// import namespace std</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Tolerance for testing KKT conditions.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TESTTOL 1e-9</span></span><br><span class="line"><span class="comment">// Tolerance for barrier convergence.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONVTOL 1e-9</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">//  A Simple Example</span></span><br><span class="line"> <span class="comment">//  Minimize</span></span><br><span class="line"> <span class="comment">//   obj: x1 + x2 + x3 + x4 + x5 + x6</span></span><br><span class="line"> <span class="comment">//  Subject To</span></span><br><span class="line"> <span class="comment">//   c1: x1 + x2      + x5      = 8</span></span><br><span class="line"> <span class="comment">//   c2:           x3 + x5 + x6 = 10</span></span><br><span class="line"> <span class="comment">//   q1: x1 + x2 &gt;= |(x1, x2, x3)| ----&gt;&gt;&gt;&gt; q1:[-x7^2+x1^2+x2^2+x3^2]&lt;=0 and x7=x1+x2&gt;=0</span></span><br><span class="line"> <span class="comment">//   q2: x4 &gt;= |x5|       ----&gt;&gt;&gt;&gt;  q2: [ -x4^2 + x5^2 ] &lt;= 0 and x4 &gt;=0</span></span><br><span class="line"> <span class="comment">//  Bounds</span></span><br><span class="line"> <span class="comment">//   x1 Free</span></span><br><span class="line"> <span class="comment">//   x2 Free</span></span><br><span class="line"> <span class="comment">//   x3 Free</span></span><br><span class="line"> <span class="comment">//   x5 Free</span></span><br><span class="line"> <span class="comment">//   x6 Free</span></span><br><span class="line"> <span class="comment">//  End</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">createmodel(IloModel&amp; model, IloObjective &amp;obj, IloNumVarArray &amp;x,</span><br><span class="line">	IloRangeArray &amp;rngs, IloIntArray&amp; cone)</span><br><span class="line">&#123;</span><br><span class="line">	IloEnv env = model.getEnv();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Create variables.</span></span><br><span class="line">	x.add(IloNumVar(env, -IloInfinity, IloInfinity));</span><br><span class="line">	x.add(IloNumVar(env, -IloInfinity, IloInfinity));</span><br><span class="line">	x.add(IloNumVar(env, -IloInfinity, IloInfinity));</span><br><span class="line">	x.add(IloNumVar(env, <span class="number">0</span>, IloInfinity));</span><br><span class="line">	x.add(IloNumVar(env, -IloInfinity, IloInfinity));</span><br><span class="line">	x.add(IloNumVar(env, -IloInfinity, IloInfinity));</span><br><span class="line">	x.add(IloNumVar(env, <span class="number">0</span>, IloInfinity));<span class="comment">// x7</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Create objective function and immediately store it in return value.</span></span><br><span class="line">	<span class="comment">// obj = IloMinimize(env, x1 + x2 + x3 + x4 + x5 + x6);</span></span><br><span class="line">	obj = IloMinimize(env, x[<span class="number">0</span>]+x[<span class="number">1</span>] + x[<span class="number">2</span>] + x[<span class="number">3</span>] + x[<span class="number">4</span>] + x[<span class="number">5</span>]);</span><br><span class="line">	<span class="comment">// Setup model.</span></span><br><span class="line">	model.add(x[<span class="number">0</span>] + x[<span class="number">1</span>] + x[<span class="number">4</span>]==<span class="number">8</span>);</span><br><span class="line">	model.add(x[<span class="number">2</span>] + x[<span class="number">4</span>] + x[<span class="number">5</span>]==<span class="number">10</span>);</span><br><span class="line">	model.add(x[<span class="number">6</span>] - x[<span class="number">0</span>] - x[<span class="number">1</span>] == <span class="number">0</span>); <span class="comment">// x7 = x1 + x2</span></span><br><span class="line">	model.add(-x[<span class="number">6</span>] * x[<span class="number">6</span>]+ x[<span class="number">0</span>] * x[<span class="number">0</span>] + x[<span class="number">1</span>] * x[<span class="number">1</span>] + x[<span class="number">2</span>] * x[<span class="number">2</span>]&lt;=<span class="number">0</span>); <span class="comment">//[-x7^2+x1^2+x2^2+x3^2]&lt;=0</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//equal to model.add(-x[3] * x[3] + x[4] * x[4]&lt;=0), useful for lots of variables</span></span><br><span class="line">	<span class="keyword">double</span> a[] = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>, <span class="number">-1</span>,<span class="number">1</span> &#125;;</span><br><span class="line">	<span class="function">IloExpr <span class="title">temp</span><span class="params">(env)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (IloInt i = <span class="number">3</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		temp += a[i] * x[i] * x[i];</span><br><span class="line">	&#125;</span><br><span class="line">	model.add(temp &lt;= <span class="number">0</span>);</span><br><span class="line">	temp.end();</span><br><span class="line"></span><br><span class="line">	model.add(obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">main(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">	IloEnv env;</span><br><span class="line">	<span class="keyword">int</span> retval = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="comment">// Create the model.</span></span><br><span class="line">		<span class="function">IloModel <span class="title">model</span><span class="params">(env)</span></span>;</span><br><span class="line">		<span class="function">IloCplex <span class="title">cplex</span><span class="params">(env)</span></span>;</span><br><span class="line">		<span class="function">IloObjective <span class="title">obj</span><span class="params">(env)</span></span>;</span><br><span class="line">		<span class="function">IloNumVarArray <span class="title">vars</span><span class="params">(env)</span></span>;</span><br><span class="line">		<span class="function">IloRangeArray <span class="title">rngs</span><span class="params">(env)</span></span>;</span><br><span class="line">		<span class="function">IloIntArray <span class="title">cone</span><span class="params">(env)</span></span>;</span><br><span class="line">		createmodel(model, obj, vars, rngs, cone);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Extract model.</span></span><br><span class="line">		cplex.extract(model);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Solve the problem. If we cannot find an _optimal_ solution then</span></span><br><span class="line">		<span class="comment">// there is no point in checking the KKT conditions and we throw an</span></span><br><span class="line">		<span class="comment">// exception.</span></span><br><span class="line">		cplex.setParam(IloCplex::Param::Barrier::QCPConvergeTol, CONVTOL);</span><br><span class="line">		<span class="keyword">if</span> (!cplex.solve() || cplex.getStatus() != IloAlgorithm::Optimal)</span><br><span class="line">			<span class="keyword">throw</span> <span class="built_in">string</span>(<span class="string">"Failed to solve problem to optimality"</span>);</span><br><span class="line"></span><br><span class="line">		<span class="function">IloNumArray <span class="title">vals_x</span><span class="params">(env)</span></span>;</span><br><span class="line">		env.out() &lt;&lt; <span class="string">"Solution status = "</span> &lt;&lt; cplex.getStatus() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		env.out() &lt;&lt; <span class="string">"Solution value  = "</span> &lt;&lt; cplex.getObjValue() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		cplex.getValues(vals_x, vars);</span><br><span class="line">		env.out() &lt;&lt; <span class="string">"Values        = "</span> &lt;&lt; vals_x &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		env.end();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (IloException &amp;e) &#123;</span><br><span class="line">		<span class="built_in">cerr</span> &lt;&lt; <span class="string">"IloException: "</span> &lt;&lt; e &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">if</span> (env.getImpl())</span><br><span class="line">			env.end();</span><br><span class="line">		::<span class="built_in">abort</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (<span class="built_in">string</span>&amp; e) &#123;</span><br><span class="line">		<span class="built_in">cerr</span> &lt;&lt; e &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">if</span> (env.getImpl())</span><br><span class="line">			env.end();</span><br><span class="line">		::<span class="built_in">abort</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下图：<br><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20191201/20191201_fig006.jpg" width="600" height="450" title="图6" alt="图6" ></p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>Research</tag>
      </tags>
  </entry>
  <entry>
    <title>【漫漫科研路\C&amp;C++】Win10 + VS2017 + CUDA10.1 + CPLEX12.9 配置</title>
    <url>/2019/11/24/%5B20191124%5D/</url>
    <content><![CDATA[<h2 id="Win10下搭建VS2017-CUDA10-1-CPLEX12-9开发环境"><a href="#Win10下搭建VS2017-CUDA10-1-CPLEX12-9开发环境" class="headerlink" title="Win10下搭建VS2017+CUDA10.1+CPLEX12.9开发环境"></a>Win10下搭建VS2017+CUDA10.1+CPLEX12.9开发环境</h2><p>想来已经有三、四年没有用过C/C++了，一直都是使用MATLAB进行算法的实现。相比于C/C++, MATLAB更加适合快速地实现算法，可视化仿真结果。但最近想学习并行计算（尽管MATLAB也可以实现并行化），并且实验室的服务器又装有RTX2080Ti的显卡，因此考虑使用CUDA平台实现GPU并行编程。另一方面，我需要使用IBM的CPLEX工具来验证算法的结果，于是乎就有了这篇文章。</p>
<a id="more"></a>
<h2 id="VS2017的安装"><a href="#VS2017的安装" class="headerlink" title="VS2017的安装"></a>VS2017的安装</h2><p>VS2017的安装比较简单，我就不作介绍了。但是有两点需要注意：</p>
<ul>
<li>最好先安装VS2017，然后再安装CUDA和CPLEX，</li>
<li>最好不要安装最新版本VS2019，CPLEX12.9目前支持的是VS2015和VS2017</li>
</ul>
<h2 id="CUDA10-1的安装"><a href="#CUDA10-1的安装" class="headerlink" title="CUDA10.1的安装"></a>CUDA10.1的安装</h2><p>直接从NVIDIA官网下载<a href="https://developer.nvidia.com/cuda-downloads" target="_blank" rel="noopener">最新版本的CUDA</a>进行安装，也可以安装<a href="https://developer.nvidia.com/cuda-toolkit-archive" target="_blank" rel="noopener">历史发行版本</a>。按照默认设置安装即可。</p>
<p><strong>测试是否安装成功</strong><br>最快捷的方法是运行cuda安装完成后自带的样例，默认安装在C:\ProgramData\NVIDIA Corporation\CUDA Samples\v10.1。下面我们介绍一般的方法，方便自己创建cuda项目：</p>
<ul>
<li>在VS2017中创建一个HelloWorld_GPU的项目，如下图所示：<br> <img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20191124/20191124_fig001.jpg" width="600" height="400" title="图1" alt="图1" ><ul>
<li>项目中自带一个kernel.cu的文件，可以直接运行，看是否运行成功。这里，我们依照传统，写一个更为简单的hello world程序来进行测试。删除kernel.cu文件，在项目中添加一个CUDA C/C++文件取名为Hello_World，程序如下：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"cuda_runtime.h"</span></span></span><br><span class="line"></span><br><span class="line">__<span class="function">global__ <span class="keyword">void</span> <span class="title">helloFromGPU</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Hello World from GPU!\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Hello World from CPU.\n\n"</span>);<span class="comment">//Hello from CPU</span></span><br><span class="line"></span><br><span class="line">	helloFromGPU &lt;&lt; &lt;<span class="number">1</span>, <span class="number">10</span> &gt;&gt; &gt; ();<span class="comment">//call for 10 threads</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
运行结果如下：<br><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20191124/20191124_fig002.jpg" width="600" height="400" title="图2" alt="图2" ></li>
</ul>
</li>
</ul>
<hr>
<h2 id="CPLEX12-9的安装"><a href="#CPLEX12-9的安装" class="headerlink" title="CPLEX12.9的安装"></a>CPLEX12.9的安装</h2><p>CPLEX12.9的安装是相对来说比较复杂的，简单来说，分为<strong>CPLEX12.9的下载</strong>、<strong>项目的配置</strong>。具体细节如下：</p>
<h4 id="CPLEX12-9教育版的下载"><a href="#CPLEX12-9教育版的下载" class="headerlink" title="CPLEX12.9教育版的下载"></a>CPLEX12.9教育版的下载</h4><p>普通免费版本支持1000个变量或约束的优化，<a href="https://www.ibm.com/products/ilog-cplex-optimization-studio" target="_blank" rel="noopener">下载地址</a>及网页如下：<br><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20191124/20191124_fig003.jpg" width="600" height="400" title="图3" alt="图3" ><br>为不受限制，我们需要使用学生邮箱进行验证下载(Get student and faculty editions for free).  然后在如下网页注册：<br><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20191124/20191124_fig004.jpg" width="600" height="300" title="图4" alt="图4" ><br>最后选择如下版本进行下载：<br><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20191124/20191124_fig005.jpg" width="600" height="300" title="图5" alt="图5" ></p>
<hr>
<h4 id="CPLEX项目配置"><a href="#CPLEX项目配置" class="headerlink" title="CPLEX项目配置"></a>CPLEX项目配置</h4><h6 id="项目的创建："><a href="#项目的创建：" class="headerlink" title="项目的创建："></a>项目的创建：</h6><p>首先创建一个C/C++项目，在项目中添加一个test.cpp（名称自取）文件，其代码来自于 <a href="https://www.ibm.com/support/knowledgecenter/SSSA5P_12.8.0/ilog.odms.studio.help/pdf/gscplex.pdf?origURL=SSSA5P_12.8.0/ilog.odms.studio.help/Optimization_Studio/topics/PLUGINS_ROOT/ilog.odms.studio.help/pdf/gscplex.pdf" target="_blank" rel="noopener">IBM ILOG CPLEX Optimization Studio Getting Started with CPLEX</a> 的样例，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ilcplex/ilocplex.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line">ILOSTLBEGIN</span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">main(<span class="keyword">void</span> *) &#123;</span><br><span class="line">	IloEnv env;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="function">IloModel <span class="title">model</span><span class="params">(env)</span></span>;</span><br><span class="line">		<span class="function">IloNumVarArray <span class="title">vars</span><span class="params">(env)</span></span>;</span><br><span class="line">		vars.add(IloNumVar(env, <span class="number">0.0</span>, <span class="number">40.0</span>));  <span class="comment">// 0 &lt;= x1 &lt;= 40</span></span><br><span class="line">		vars.add(IloNumVar(env));  <span class="comment">// 0 &lt;= x2</span></span><br><span class="line">		vars.add(IloNumVar(env));  <span class="comment">// 0 &lt;= x3</span></span><br><span class="line">		model.add(IloMaximize(env, vars[<span class="number">0</span>] + <span class="number">2</span> * vars[<span class="number">1</span>] + <span class="number">3</span> * vars[<span class="number">2</span>])); <span class="comment">//maximize x1 + 2 x2 + 3 x3</span></span><br><span class="line">		model.add(-vars[<span class="number">0</span>] + vars[<span class="number">1</span>] + vars[<span class="number">2</span>] &lt;= <span class="number">20</span>);<span class="comment">//subject to -x1 + x2 + x3 &lt;= 20</span></span><br><span class="line">		model.add(vars[<span class="number">0</span>] - <span class="number">3</span> * vars[<span class="number">1</span>] + vars[<span class="number">2</span>] &lt;= <span class="number">30</span>);<span class="comment">//x1 - 3 x2 + x3 &lt;=30</span></span><br><span class="line">		<span class="function">IloCplex <span class="title">cplex</span><span class="params">(model)</span></span>;</span><br><span class="line">		<span class="keyword">if</span> (!cplex.solve()) &#123;</span><br><span class="line">			env.error() &lt;&lt; <span class="string">"Failed to optimize LP."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">			<span class="keyword">throw</span>(<span class="number">-1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function">IloNumArray <span class="title">vals</span><span class="params">(env)</span></span>;</span><br><span class="line">		env.out() &lt;&lt; <span class="string">"Solution status = "</span> &lt;&lt; cplex.getStatus() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		env.out() &lt;&lt; <span class="string">"Solution value = "</span> &lt;&lt; cplex.getObjValue() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		cplex.getValues(vals, vars);</span><br><span class="line">		env.out() &lt;&lt; <span class="string">"Values = "</span> &lt;&lt; vals &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (IloException &amp; e) &#123; <span class="built_in">cerr</span> &lt;&lt; <span class="string">"Concert exception caught: "</span> &lt;&lt; e &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">	<span class="keyword">catch</span> (...) &#123; <span class="built_in">cerr</span> &lt;&lt; <span class="string">"Unknown exception caught"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">	env.end();</span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：VS2017创建C/C++会自带pch.h和pch.cpp文件，我们可以删除这两个文件而不影响程序运行，具体可以通过项目-&gt;属性-&gt; C/C++ -&gt; Precompiled Headers -&gt; Precompiled Header一项中选择Not Using Precompiled Headers 实现。</p>
<hr>
<h6 id="系统环境和项目的配置："><a href="#系统环境和项目的配置：" class="headerlink" title="系统环境和项目的配置："></a>系统环境和项目的配置：</h6><p>本文的配置完全依照 <a href="https://www.ibm.com/support/knowledgecenter/SSSA5P_12.8.0/ilog.odms.studio.help/pdf/gscplex.pdf?origURL=SSSA5P_12.8.0/ilog.odms.studio.help/Optimization_Studio/topics/PLUGINS_ROOT/ilog.odms.studio.help/pdf/gscplex.pdf" target="_blank" rel="noopener">IBM ILOG CPLEX Optimization Studio Getting Started with CPLEX</a> 以及安装完CPLEX后，位于默认安装目录C:\ProgramFiles\IBM\ILOG\CPLEX_Enterprise_Server129\CPLEX_Studio\cplex的c_cpp.html文件</p>
<ul>
<li><strong>电脑的系统环境变量配置</strong>参考<a href="https://www.ibm.com/support/knowledgecenter/SSSA5P_12.8.0/ilog.odms.studio.help/pdf/gscplex.pdf?origURL=SSSA5P_12.8.0/ilog.odms.studio.help/Optimization_Studio/topics/PLUGINS_ROOT/ilog.odms.studio.help/pdf/gscplex.pdf" target="_blank" rel="noopener">IBM ILOG CPLEX Optimization Studio Getting Started with CPLEX</a> 中<em>Setting up CPLEX on Windows</em>一节中的设置：<br><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20191124/20191124_fig006.jpg" width="600" height="300" title="图6" alt="图6" ><br><em>具体操作如下</em>：右击我的电脑-&gt;属性-&gt;高级系统设置-&gt;环境变量，编辑(添加)Path变量如下：<br><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20191124/20191124_fig007.jpg" width="600" height="450" title="图7" alt="图7" ></li>
</ul>
<hr>
<ul>
<li><p><strong>项目的配置</strong>参考前面提及的<strong>c_cpp.html</strong>中<em>Building your own project which links with CPLEX</em>一节的第4点：<br><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20191124/20191124_fig008.jpg" width="600" height="650" title="图8" alt="图8" ><br>根据上图所示，<em>项目具体配置如下</em>：</p>
<ol>
<li>将调试环境改为 release 和 x64:<br><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20191124/20191124_fig009.jpg" width="600" height="150" title="图9" alt="图19" ></li>
<li><p>右击项目、选择属性、然后选择C/C++一项：</p>
<p>1).  在General(常规)一项中，选择Additional Include Directories，添加如下：<br><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20191124/20191124_fig010.jpg" width="600" height="400" title="图10" alt="图10" ><br>2). 在Preprocessor(预处理器)中，选择Preprocessor Definitions, 编辑如下：<br><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20191124/20191124_fig011.jpg" width="600" height="400" title="图11" alt="图11" ><br>3). 选择Code Generation（代码生成），然后选择Runtime Library（运行库）， 设置如下 ：<br><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20191124/20191124_fig012.jpg" width="600" height="400" title="图12" alt="图12" ></p>
</li>
</ol>
</li>
</ul>
<ol>
<li><p>右击项目、选择属性、然后选择Link一项，然后进行如下操作：<br>1).选择  General一项，在 Additional Library Directories中添加如下库目录：<br><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20191124/20191124_fig013.jpg" width="600" height="200" title="图13" alt="图13" ></p>
<p>2). 选择Input，然后选择Additional Dependencies，设置如下：<br><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20191124/20191124_fig014.jpg" width="600" height="150" title="图14" alt="图14" ><br>完成上述项目配置后，注意按下确定按钮。注意：上述配置中的目录都是你CPLEX的安装目录。最后在菜单栏Build选项中选择Configuration Manager也需要选择Release和x64，如图所示：<br><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20191124/20191124_fig015.jpg" width="600" height="200" title="图15" alt="图15" ><br>至此，所有配置完成，运行项目，结果如下：<br><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20191124/20191124_fig016.jpg" width="600" height="250" title="图16" alt="图16" ></p>
</li>
</ol>
<hr>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>Research</tag>
      </tags>
  </entry>
  <entry>
    <title>【漫漫科研路\pgfplots】最小跳数最大权重算法</title>
    <url>/2017/12/17/%5B20171217%5D/</url>
    <content><![CDATA[<p>上周，实验室国际友人让我帮忙实现满足条件的最小跳数最大权重的算法。他的具体问题如下：<br>给定一个权重图（如下图所示），给出节点之间最小跳数最大权重矩阵，其中任意两点之间跳数小于等于$3$，否则权重为inf。<br>    <img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20171217/20171217_fig001.jpg" width="400" height="300" title="图1" alt="图1" ></p>
<a id="more"></a>
<p>如图1所示， A到F的最小跳数为$2$：$A-C-F$和$A-E-F$，权重(这里权重表示为所有路径上的权重乘积，当然也可以稍加修改变成权重和)分别为$4\times1=4$、$3\times 4=12$。因此$A$到$F$的最小跳数最大权重为$12$，路径为$A-E-F$。下面给出了具体的代码实现：<br>主要有两个文件，测试脚本文件main.m和dijkstra_all.m函数文件：<br>1、测试脚本文件main.m</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clear all</span><br><span class="line">clc   </span><br><span class="line">AdjMatrix=[<span class="number">0</span> <span class="built_in">inf</span> <span class="number">4</span> <span class="number">6</span> <span class="number">3</span> <span class="built_in">inf</span>;</span><br><span class="line">           <span class="built_in">inf</span> <span class="number">0</span> <span class="number">3</span> <span class="number">2</span> <span class="built_in">inf</span> <span class="number">4</span>;</span><br><span class="line">           <span class="number">4</span> <span class="number">3</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span>;</span><br><span class="line">           <span class="number">6</span> <span class="number">2</span> <span class="number">1</span> <span class="number">0</span> <span class="built_in">inf</span> <span class="built_in">inf</span>;</span><br><span class="line">           <span class="number">3</span> <span class="built_in">inf</span> <span class="number">1</span> <span class="built_in">inf</span> <span class="number">0</span> <span class="number">4</span>;</span><br><span class="line">           <span class="built_in">inf</span> <span class="number">4</span> <span class="number">1</span> <span class="built_in">inf</span> <span class="number">4</span> <span class="number">0</span>;];</span><br><span class="line">       </span><br><span class="line">AdjMatrix1=AdjMatrix;<span class="comment">% weight matrix</span></span><br><span class="line">IND=AdjMatrix&lt;<span class="built_in">inf</span>&amp;AdjMatrix&gt;<span class="number">0</span>;</span><br><span class="line">AdjMatrix(IND)=<span class="number">1</span>;<span class="comment">% adjacent matrix</span></span><br><span class="line">       </span><br><span class="line">       </span><br><span class="line">ResMatrix=<span class="built_in">zeros</span>(<span class="built_in">size</span>(AdjMatrix));<span class="comment">%ouput matrix: the weights between each pair of nodes</span></span><br><span class="line">N=<span class="built_in">length</span>(AdjMatrix);<span class="comment">% the number of nodes</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:N</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">j</span>=<span class="number">1</span>:N</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">i</span>==<span class="built_in">j</span>)</span><br><span class="line">            ResMatrix(<span class="built_in">i</span>,<span class="built_in">j</span>)=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            [sp, spcost]=dijkstra_all(AdjMatrix, <span class="built_in">i</span>, <span class="built_in">j</span>);<span class="comment">% condition 1: find all the minimum hops    </span></span><br><span class="line">            temp_num=sum(sp(<span class="number">1</span>,:)&gt;<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span>(temp_num&lt;=<span class="number">4</span>)<span class="comment">% condition 2: the number of the minimum hop is less than 3</span></span><br><span class="line">                temp=<span class="built_in">ones</span>(<span class="number">1</span>,<span class="built_in">size</span>(sp,<span class="number">1</span>));<span class="comment">% the number of the minimum hops</span></span><br><span class="line">                <span class="keyword">for</span> m=<span class="number">1</span>:<span class="built_in">size</span>(sp,<span class="number">1</span>)</span><br><span class="line">                    <span class="keyword">for</span> k=<span class="number">1</span>:temp_num<span class="number">-1</span></span><br><span class="line">                        temp(m)=temp(m)*AdjMatrix1(sp(m,k),sp(m,k+<span class="number">1</span>));<span class="comment">% Calculate the weights of all the minimum hops, change * to + for the sum of the weights </span></span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                ResMatrix(<span class="built_in">i</span>,<span class="built_in">j</span>)=<span class="built_in">max</span>(temp);<span class="comment">% condition 3: choose the maximum weight among all the minimum hops</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                ResMatrix(<span class="built_in">i</span>,<span class="built_in">j</span>)=<span class="built_in">inf</span>; <span class="comment">% the number of the minimum hop is larger than 3</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">ResMatrix</span><br></pre></td></tr></table></figure>
<p>2、dijkstra_all.m函数文件（sp为所有的最小跳数路径集合，spcost为最小跳数）</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[sp, spcost]</span> = <span class="title">dijkstra_all</span><span class="params">(AdjMatrix, s, d)</span></span></span><br><span class="line"><span class="comment">% This is an implementation of the dijkstra algorithm, wich finds the </span></span><br><span class="line"><span class="comment">% minimal cost path between two nodes. It is used to solve the problem on </span></span><br><span class="line"><span class="comment">% possitive weighted instances.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% the inputs of the algorithm are:</span></span><br><span class="line"><span class="comment">%AdjMatrix: the adjacent matrix of a graph</span></span><br><span class="line"><span class="comment">% s: source node index;</span></span><br><span class="line"><span class="comment">% d: destination node index;</span></span><br><span class="line">n=<span class="built_in">size</span>(AdjMatrix,<span class="number">1</span>);</span><br><span class="line">S(<span class="number">1</span>:n) = <span class="number">0</span>;     <span class="comment">%s, vector, set of visited vectors</span></span><br><span class="line">dist(<span class="number">1</span>:n) = <span class="built_in">inf</span>;   <span class="comment">% it stores the shortest distance between the source node and any other node;</span></span><br><span class="line">prev = <span class="built_in">zeros</span>(<span class="number">50</span>,n); <span class="comment">% Previous node, informs about the best previous node known to reach each  network node, 50 should be changed when the path is long.</span></span><br><span class="line">count(<span class="number">1</span>:n)=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">dist(s) = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> sum(S)~=n</span><br><span class="line">    candidate=[];</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:n</span><br><span class="line">        <span class="keyword">if</span> S(<span class="built_in">i</span>)==<span class="number">0</span></span><br><span class="line">            candidate=[candidate dist(<span class="built_in">i</span>)];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            candidate=[candidate <span class="built_in">inf</span>];</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    [u_index u]=<span class="built_in">min</span>(candidate);</span><br><span class="line">    S(u)=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:n</span><br><span class="line">        <span class="keyword">if</span>(dist(u)+AdjMatrix(u,u)+AdjMatrix(u,<span class="built_in">i</span>))&lt;dist(<span class="built_in">i</span>)</span><br><span class="line">            dist(<span class="built_in">i</span>)=dist(u)+AdjMatrix(u,u)+AdjMatrix(u,<span class="built_in">i</span>);</span><br><span class="line">            prev(:,<span class="built_in">i</span>)=prev(:,<span class="built_in">i</span>).*<span class="number">0</span>;</span><br><span class="line">            prev(<span class="number">1</span>,<span class="built_in">i</span>)=u;</span><br><span class="line">            count(<span class="built_in">i</span>)=<span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">if</span> ((dist(u)+AdjMatrix(u,u)+AdjMatrix(u,<span class="built_in">i</span>))==dist(<span class="built_in">i</span>))&amp;&amp;(dist(<span class="built_in">i</span>)~=<span class="built_in">inf</span>)&amp;&amp;(u~=<span class="built_in">i</span>)        </span><br><span class="line">                <span class="keyword">if</span> count(<span class="built_in">i</span>)&lt;<span class="number">49</span></span><br><span class="line">                    count(<span class="built_in">i</span>)=count(<span class="built_in">i</span>)+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                prev(count(<span class="built_in">i</span>),<span class="built_in">i</span>)=u;           </span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sp=[];</span><br><span class="line">stack=[];</span><br><span class="line">num=[];</span><br><span class="line"><span class="comment">%backup</span></span><br><span class="line">stack = [d,<span class="built_in">zeros</span>(<span class="number">1</span>,<span class="number">9</span>)];</span><br><span class="line">num=[<span class="number">1</span>,<span class="built_in">zeros</span>(<span class="number">1</span>,<span class="number">9</span>)];</span><br><span class="line">spcost = dist(d);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> stack(<span class="number">1</span>) ~= <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> stack(<span class="number">1</span>)==s</span><br><span class="line">        <span class="comment">%record the path</span></span><br><span class="line">        sp=[sp;stack];</span><br><span class="line">        <span class="comment">%pop</span></span><br><span class="line">        stack=[stack(<span class="number">2</span>:<span class="number">10</span>),<span class="number">0</span>];<span class="comment">% the first element of stack is out</span></span><br><span class="line">        num=[num(<span class="number">2</span>:<span class="number">10</span>),<span class="number">0</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    tmp=prev(num(<span class="number">1</span>),stack(<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">if</span> tmp==<span class="number">0</span></span><br><span class="line">        <span class="comment">%pop</span></span><br><span class="line">        stack=[stack(<span class="number">2</span>:<span class="number">10</span>),<span class="number">0</span>];</span><br><span class="line">        num=[num(<span class="number">2</span>:<span class="number">10</span>),<span class="number">0</span>];</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">%push</span></span><br><span class="line">        num(<span class="number">1</span>)=num(<span class="number">1</span>)+<span class="number">1</span>;</span><br><span class="line">        stack=[tmp,stack(<span class="number">1</span>:<span class="number">9</span>)];</span><br><span class="line">        num=[<span class="number">1</span>,num(<span class="number">1</span>,<span class="number">1</span>:<span class="number">9</span>)];</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">   </span><br><span class="line">    </span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>运行main脚本文件，可得最小跳数最大权重矩阵如下：<br><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20171217/20171217_fig002.jpg" width="400" height="300" title="图2" alt="图2" ></p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>Research</tag>
      </tags>
  </entry>
  <entry>
    <title>【漫漫科研路\pgfplots】子图的多种画法</title>
    <url>/2017/12/10/%5B20171210%5D/</url>
    <content><![CDATA[<p>在科研论文写作中，有时候为了横向、纵向对比或者节省空间，我们需要画子图，在MATLAB中可以通过subplot命令来实现。在Latex中有以下几种方法进行子图的绘制：</p>
<a id="more"></a>
<ul>
<li>使用subfig宏包（有可能与hyperref宏包冲突，推荐使用subcaption宏包），主要格式为：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\begin&#123;figure&#125;</span><br><span class="line">\subfloat[]&#123;&#125;</span><br><span class="line">\subfloat[]&#123;&#125;\\</span><br><span class="line">\subfloat[]&#123;&#125;</span><br><span class="line">\subfloat[]&#123;&#125;</span><br><span class="line">\end&#123;figure&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>使用subcaption宏包，主要格式为：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\begin&#123;figure&#125;</span><br><span class="line">\subcaptionbox&#123;&#125;&#123;&#125;</span><br><span class="line">\subcaptionbox&#123;&#125;&#123;&#125;\\</span><br><span class="line">\subcaptionbox&#123;&#125;&#123;&#125;</span><br><span class="line">\subcaptionbox&#123;&#125;&#123;&#125;</span><br><span class="line">\end&#123;figure&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>使用groupplot宏包，主要格式为：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  \begin&#123;figure&#125;</span><br><span class="line">\centering</span><br><span class="line">\begin&#123;tikzpicture&#125;</span><br><span class="line">\begin&#123;groupplot&#125;</span><br><span class="line">\nextgroupplot</span><br><span class="line">\addplot &#123;x&#125;;</span><br><span class="line">\nextgroupplot</span><br><span class="line">\end&#123;groupplot&#125;</span><br><span class="line">\end&#123;tikzpicture&#125;</span><br><span class="line">\end&#123;figure&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>使用matrix宏包，主要格式为：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    \begin&#123;figure&#125;</span><br><span class="line">\centering</span><br><span class="line">\begin&#123;tikzpicture&#125;</span><br><span class="line">\matrix</span><br><span class="line"> &#123;</span><br><span class="line"> \begin&#123;axis&#125;</span><br><span class="line"> \addplot &#123;x&#125;;</span><br><span class="line"> \end&#123;axis&#125;</span><br><span class="line"> </span><br><span class="line">  \begin&#123;axis&#125;</span><br><span class="line"> \addplot &#123;x&#125;;</span><br><span class="line"> \end&#123;axis&#125;</span><br><span class="line"> &#125;</span><br><span class="line">\end&#123;tikzpicture&#125;</span><br><span class="line">\end&#123;figure&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>下面给出上述各种情况的具体代码实现以及示意图：</p>
<ul>
<li>使用subfig宏包<br>  <img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20171210/20171210_fig001.jpg" width="600" height="450" title="图1" alt="图1" ><br>代码如下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\documentclass&#123;article&#125;</span><br><span class="line">\usepackage[dvipdfm]&#123;graphicx&#125;</span><br><span class="line">\def\pgfsysdriver&#123;pgfsys-dvipdfmx.def&#125;</span><br><span class="line">\usepackage&#123;tikz&#125;</span><br><span class="line">\usepackage&#123;pgfplots&#125;</span><br><span class="line">\usepackage&#123;subfig&#125;%使用子图包，可能与hyperref冲突</span><br><span class="line">\usepackage&#123;float&#125;</span><br><span class="line">\usepackage&#123;cite&#125;</span><br><span class="line">\usepackage[colorlinks,dvipdfm,</span><br><span class="line">            pdfpagemode&#x3D;UseOutlines,</span><br><span class="line">            pdfstartview&#x3D;FitH,</span><br><span class="line">            anchorcolor&#x3D;green,</span><br><span class="line">            citecolor&#x3D;blue,</span><br><span class="line">            linkcolor&#x3D;red,</span><br><span class="line">            hyperindex&#x3D;true,</span><br><span class="line">            pagebackref,</span><br><span class="line">            bookmarksnumbered,</span><br><span class="line">            bookmarksopenlevel&#x3D;2,</span><br><span class="line">            colorlinks]&#123;hyperref&#125;</span><br><span class="line"></span><br><span class="line">\pgfplotsset&#123;width&#x3D;6cm,compat&#x3D;1.15&#125;</span><br><span class="line"></span><br><span class="line">\begin&#123;document&#125;</span><br><span class="line">\begin&#123;figure&#125;</span><br><span class="line">\begin&#123;center&#125;</span><br><span class="line">\subfloat[\label&#123;subfig1&#125;]&#123;</span><br><span class="line">\begin&#123;tikzpicture&#125;</span><br><span class="line">\begin&#123;axis&#125;[</span><br><span class="line">legend columns&#x3D;-1,%the legend are plotted horizontally</span><br><span class="line">legend entries&#x3D;&#123;$x$&#125;,</span><br><span class="line">legend to name&#x3D;named,% stored in named, not plotted in the figure</span><br><span class="line">title&#x3D;&#123;subfig1&#125;,</span><br><span class="line">]</span><br><span class="line">\addplot &#123;x&#125;;\label&#123;curvex&#125;</span><br><span class="line">\end&#123;axis&#125;</span><br><span class="line">\end&#123;tikzpicture&#125;\label&#123;subfig2&#125;&#125;</span><br><span class="line">\subfloat[]&#123;</span><br><span class="line">\begin&#123;tikzpicture&#125;</span><br><span class="line">\begin&#123;axis&#125;[title&#x3D;&#123;subfig2&#125;]</span><br><span class="line">\addplot &#123;x&#125;;</span><br><span class="line">\end&#123;axis&#125;</span><br><span class="line">\end&#123;tikzpicture&#125;\label&#123;subfig2&#125;&#125;</span><br><span class="line">\end&#123;center&#125;</span><br><span class="line">\caption&#123;\hspace&#123;1em&#125;Two subfigures.&#125;\label&#123;f1&#125;</span><br><span class="line">\end&#123;figure&#125;</span><br><span class="line">As depicted in Figures~\ref&#123;subfig1&#125; and \ref&#123;subfig2&#125;, the subfigures of Figure~\ref&#123;f1&#125;, \ref&#123;curvex&#125; represents function $f(x)&#x3D;x$.</span><br><span class="line"></span><br><span class="line">\end&#123;document&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>使用subcaption宏包<br><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20171210/20171210_fig002.jpg" width="600" height="450" title="图2" alt="图2" ><br>代码如下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\documentclass&#123;article&#125;</span><br><span class="line">\usepackage[dvipdfm]&#123;graphicx&#125;</span><br><span class="line">\def\pgfsysdriver&#123;pgfsys-dvipdfmx.def&#125;</span><br><span class="line">\usepackage&#123;tikz&#125;</span><br><span class="line">\usepackage&#123;pgfplots&#125;</span><br><span class="line">%\usepackage&#123;subfig&#125;</span><br><span class="line">\usepackage[hypcap&#x3D;true,labelsep&#x3D;period,font&#x3D;small]&#123;caption&#125;% 图的标题设置Fig.</span><br><span class="line">\usepackage[hypcap&#x3D;true]&#123;subcaption&#125;%用于画子图 可以适配hyperref包</span><br><span class="line">\usepackage&#123;float&#125;</span><br><span class="line">\usepackage[colorlinks,dvipdfm,</span><br><span class="line">            pdfpagemode&#x3D;UseOutlines,</span><br><span class="line">            pdfstartview&#x3D;FitH,</span><br><span class="line">            anchorcolor&#x3D;green,</span><br><span class="line">            citecolor&#x3D;blue,</span><br><span class="line">            linkcolor&#x3D;red,</span><br><span class="line">            hyperindex&#x3D;true,</span><br><span class="line">            pagebackref,</span><br><span class="line">            bookmarksnumbered,</span><br><span class="line">            bookmarksopenlevel&#x3D;2,</span><br><span class="line">            colorlinks]&#123;hyperref&#125;</span><br><span class="line">\pgfplotsset&#123;width&#x3D;6cm,compat&#x3D;1.15&#125;</span><br><span class="line">\begin&#123;document&#125;</span><br><span class="line">\begin&#123;figure&#125;</span><br><span class="line">\begin&#123;center&#125;</span><br><span class="line">\subcaptionbox&#123;\label&#123;subfig1&#125;&#125;&#123;</span><br><span class="line">\begin&#123;tikzpicture&#125;</span><br><span class="line">\begin&#123;axis&#125;[</span><br><span class="line">legend columns&#x3D;-1,%the legend are plotted horizontally</span><br><span class="line">legend entries&#x3D;&#123;$x$&#125;,</span><br><span class="line">legend to name&#x3D;named,% stored in named</span><br><span class="line">title&#x3D;&#123;subfig1&#125;,</span><br><span class="line">]</span><br><span class="line">\addplot &#123;x&#125;;\label&#123;curvex&#125;</span><br><span class="line">\end&#123;axis&#125;</span><br><span class="line">\end&#123;tikzpicture&#125;&#125;</span><br><span class="line">\subcaptionbox&#123;\label&#123;subfig2&#125;&#125;&#123;</span><br><span class="line">\begin&#123;tikzpicture&#125;</span><br><span class="line">\begin&#123;axis&#125;[title&#x3D;&#123;subfig2&#125;]</span><br><span class="line">\addplot &#123;x&#125;;</span><br><span class="line">\end&#123;axis&#125;</span><br><span class="line">\end&#123;tikzpicture&#125;&#125;</span><br><span class="line">\end&#123;center&#125;</span><br><span class="line">\caption&#123;\hspace&#123;1em&#125;Two subfigures.&#125;\label&#123;f1&#125;</span><br><span class="line">\end&#123;figure&#125;</span><br><span class="line"></span><br><span class="line">As depicted in Figures~\ref&#123;subfig1&#125; and \ref&#123;subfig2&#125;, the subfigures of Figure~\ref&#123;f1&#125;, \ref&#123;curvex&#125; represents function $f(x)&#x3D;x$.</span><br><span class="line"></span><br><span class="line">\end&#123;document&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>使用groupplot宏包<br><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20171210/20171210_fig003.jpg" width="600" height="550" title="图3" alt="图3" ><br>代码如下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\documentclass&#123;article&#125;</span><br><span class="line">\usepackage[dvipdfm]&#123;graphicx&#125;</span><br><span class="line">\def\pgfsysdriver&#123;pgfsys-dvipdfmx.def&#125;</span><br><span class="line">\usepackage&#123;tikz&#125;</span><br><span class="line">\usepackage&#123;pgfplots&#125;</span><br><span class="line">\pgfplotsset&#123;width&#x3D;7cm,compat&#x3D;1.15&#125;</span><br><span class="line">\usepgfplotslibrary&#123;groupplots&#125;</span><br><span class="line">\usepackage&#123;caption&#125;</span><br><span class="line">\usepackage&#123;subcaption&#125;</span><br><span class="line">\usepackage[colorlinks,dvipdfm,</span><br><span class="line">            pdfpagemode&#x3D;UseOutlines,</span><br><span class="line">            pdfstartview&#x3D;FitH,</span><br><span class="line">            anchorcolor&#x3D;green,</span><br><span class="line">            citecolor&#x3D;blue,</span><br><span class="line">            linkcolor&#x3D;red,</span><br><span class="line">            hyperindex&#x3D;true,</span><br><span class="line">            pagebackref,</span><br><span class="line">            bookmarksnumbered,</span><br><span class="line">            bookmarksopenlevel&#x3D;2,</span><br><span class="line">            colorlinks]&#123;hyperref&#125;</span><br><span class="line">\begin&#123;document&#125;</span><br><span class="line">\begin&#123;figure&#125;[htb]</span><br><span class="line">\centering</span><br><span class="line">\begin&#123;tikzpicture&#125;</span><br><span class="line">\begin&#123;groupplot&#125;[</span><br><span class="line">group style&#x3D;&#123;</span><br><span class="line">group name&#x3D;my plots,</span><br><span class="line">group size&#x3D;2 by 2,</span><br><span class="line">xlabels at&#x3D;edge bottom,</span><br><span class="line">xlabels at&#x3D;all,</span><br><span class="line">ylabels at&#x3D;edge left,</span><br><span class="line">x descriptions at&#x3D;edge bottom,</span><br><span class="line">&#125;,</span><br><span class="line">footnotesize,</span><br><span class="line">width&#x3D;6cm,</span><br><span class="line">height&#x3D;6cm,</span><br><span class="line">%</span><br><span class="line">xlabel&#x3D;$x$,</span><br><span class="line">ylabel&#x3D;$f(x)$,</span><br><span class="line">]</span><br><span class="line">\nextgroupplot</span><br><span class="line">\addplot &#123;x&#125;;</span><br><span class="line">\node [text width&#x3D;1em,anchor&#x3D;north west] at (rel axis cs: 0,1)</span><br><span class="line">                &#123;\subcaption&#123;\label&#123;f11&#125;&#125;&#125;;%&lt;- changed</span><br><span class="line">\nextgroupplot</span><br><span class="line">\addplot &#123;x^2&#125;;</span><br><span class="line">\nextgroupplot</span><br><span class="line">\addplot &#123;x^3&#125;;</span><br><span class="line">\nextgroupplot</span><br><span class="line">\addplot &#123;x^4&#125;;</span><br><span class="line">\end&#123;groupplot&#125;</span><br><span class="line">\end&#123;tikzpicture&#125;</span><br><span class="line">\caption&#123;\hspace&#123;1em&#125;Four subfigures.&#125;\label&#123;f1&#125;</span><br><span class="line">\end&#123;figure&#125;</span><br><span class="line">How to refer to subfigure~\ref&#123;f11&#125; in Figure~\ref&#123;f1&#125;.</span><br><span class="line"></span><br><span class="line">\end&#123;document&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>使用matrix宏包<br><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20171210/20171210_fig004.jpg" width="600" height="550" title="图4" alt="图4" ><br>代码如下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\documentclass&#123;article&#125;</span><br><span class="line">\usepackage[dvipdfm]&#123;graphicx&#125;</span><br><span class="line">\def\pgfsysdriver&#123;pgfsys-dvipdfmx.def&#125;</span><br><span class="line">\usepackage&#123;tikz&#125;</span><br><span class="line">\usepackage&#123;pgfplots&#125;</span><br><span class="line">\pgfplotsset&#123;width&#x3D;7cm,compat&#x3D;1.15&#125;</span><br><span class="line">\usepgfplotslibrary&#123;groupplots&#125;</span><br><span class="line">\usetikzlibrary&#123;matrix&#125;</span><br><span class="line">\usepackage&#123;caption&#125;</span><br><span class="line">\usepackage&#123;subcaption&#125;</span><br><span class="line">\usepackage[colorlinks,dvipdfm,</span><br><span class="line">            pdfpagemode&#x3D;UseOutlines,</span><br><span class="line">            pdfstartview&#x3D;FitH,</span><br><span class="line">            anchorcolor&#x3D;green,</span><br><span class="line">            citecolor&#x3D;blue,</span><br><span class="line">            linkcolor&#x3D;red,</span><br><span class="line">            hyperindex&#x3D;true,</span><br><span class="line">            pagebackref,</span><br><span class="line">            bookmarksnumbered,</span><br><span class="line">            bookmarksopenlevel&#x3D;2,</span><br><span class="line">            colorlinks]&#123;hyperref&#125;</span><br><span class="line">\begin&#123;document&#125;</span><br><span class="line">\begin&#123;figure&#125;[htb]</span><br><span class="line">\centering</span><br><span class="line">\begin&#123;tikzpicture&#125;</span><br><span class="line">\pgfplotsset&#123;small&#125;</span><br><span class="line">\matrix &#123;</span><br><span class="line">\begin&#123;axis&#125;[ylabel&#x3D;&#123;$f(x)&#x3D;x$&#125;,ylabel style&#x3D;&#123;font&#x3D;\small&#125;]</span><br><span class="line">\addplot &#123;x&#125;;</span><br><span class="line">\node [text width&#x3D;1em,anchor&#x3D;north west] at (rel axis cs: 0,1)</span><br><span class="line">                &#123;\subcaption&#123;\label&#123;f11&#125;&#125;&#125;;%&lt;- changed</span><br><span class="line">\end&#123;axis&#125;</span><br><span class="line">&amp;</span><br><span class="line">% differently large labels are aligned automatically:</span><br><span class="line">\begin&#123;axis&#125;[ylabel&#x3D;&#123;$f(x)&#x3D;x^2$&#125;,ylabel style&#x3D;&#123;font&#x3D;\small&#125;]</span><br><span class="line">\addplot &#123;x^2&#125;;</span><br><span class="line">\end&#123;axis&#125;</span><br><span class="line">\\</span><br><span class="line">\begin&#123;axis&#125;[ylabel&#x3D;&#123;$f(x)&#x3D;x^3$&#125;,ylabel style&#x3D;&#123;font&#x3D;\small&#125;,xlabel&#x3D;$x$,xlabel style&#x3D;&#123;font&#x3D;\small&#125;]</span><br><span class="line">\addplot &#123;x^3&#125;;</span><br><span class="line">\end&#123;axis&#125;</span><br><span class="line">&amp;</span><br><span class="line">\begin&#123;axis&#125;[ylabel&#x3D;&#123;$f(x)&#x3D;x^4$&#125;,ylabel style&#x3D;&#123;font&#x3D;\small&#125;,xlabel&#x3D;$x$,xlabel style&#x3D;&#123;font&#x3D;\small&#125;]</span><br><span class="line">\addplot &#123;x^4&#125;;</span><br><span class="line">\end&#123;axis&#125;</span><br><span class="line">\\</span><br><span class="line">&#125;;</span><br><span class="line">\end&#123;tikzpicture&#125;</span><br><span class="line">\caption&#123;\hspace&#123;1em&#125;Four subfigures.&#125;\label&#123;f1&#125;</span><br><span class="line">\end&#123;figure&#125;</span><br><span class="line">How to refer to subfigure~\ref&#123;f11&#125; in Figure~\ref&#123;f1&#125;.</span><br><span class="line"></span><br><span class="line">\end&#123;document&#125;</span><br></pre></td></tr></table></figure>
<p>Note: 第三种和第四种方法不适合需要单独引用每一个子图的情况，比较适合把四张图看成一个整体的情况。</p>
<hr>
<p>参考文献：<br>[1] pgfplots manual: <a href="http://pgfplots.sourceforge.net/pgfplots.pdf" target="_blank" rel="noopener">http://pgfplots.sourceforge.net/pgfplots.pdf</a></p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>Research</tag>
      </tags>
  </entry>
  <entry>
    <title>【漫漫科研路\pgfplots】多个子图共用一个图例</title>
    <url>/2017/12/02/%5B20171202%5D/</url>
    <content><![CDATA[<p>十月底，投完会议之后，便对科研写作方面遇到的问题进行了探索。问题主要有：</p>
<hr>
<p><em>问题：</em></p>
<ol>
<li>文献管理问题：在写论文的过程中，经常要引用他人文献，这时需要费时去寻找。另一方面，有时想要查看曾经读到的某篇文章提到的方法， 也需要去耗时去寻找。</li>
<li>画图问题：怎样画出好看的图？</li>
</ol>
<p><em>解决方案：</em></p>
<ul>
<li>针对问题1： 使用JabRef</li>
<li>针对问题2：使用Pgfplots</li>
</ul>
<a id="more"></a>
<hr>
<p>后面我将会用一系列文章来记录JabRef和Pgfplots的常用使用方法。本文介绍一下如何让<em>多个子图共用一个图例</em></p>
<ul>
<li><p>Case1: 所有的子图有相同的曲线<br> <img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20171202/20171202_fig001.jpg" width="600" height="350" title="图1" alt="图1" ></p>
<p> 实现代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\documentclass&#123;article&#125;</span><br><span class="line">\usepackage[dvipdfm]&#123;graphicx&#125;</span><br><span class="line">\def\pgfsysdriver&#123;pgfsys-dvipdfmx.def&#125;</span><br><span class="line">\usepackage&#123;tikz&#125;</span><br><span class="line">\usepackage&#123;pgfplots&#125;</span><br><span class="line">\pgfplotsset&#123;width&#x3D;6cm,compat&#x3D;1.15&#125;</span><br><span class="line">\begin&#123;document&#125;</span><br><span class="line">\begin&#123;center&#125;</span><br><span class="line">\ref&#123;named&#125;\\%\pgfplotsplotfromname&#123;named&#125; instead of \ref&#123;named&#125; if the codes doesn&#39;t work </span><br><span class="line">\begin&#123;tikzpicture&#125;</span><br><span class="line">\begin&#123;axis&#125;[</span><br><span class="line">legend columns&#x3D;-1,%the legend are plotted horizontally</span><br><span class="line">legend entries&#x3D;&#123;$x$&#125;,</span><br><span class="line">legend to name&#x3D;named,% stored in named</span><br><span class="line">title&#x3D;&#123;subfig1&#125;,</span><br><span class="line">]</span><br><span class="line">\addplot &#123;x&#125;;</span><br><span class="line">\end&#123;axis&#125;</span><br><span class="line">\end&#123;tikzpicture&#125;</span><br><span class="line">\begin&#123;tikzpicture&#125;</span><br><span class="line">\begin&#123;axis&#125;[title&#x3D;&#123;subfig2&#125;]</span><br><span class="line">\addplot &#123;x&#125;;</span><br><span class="line">\end&#123;axis&#125;</span><br><span class="line">\end&#123;tikzpicture&#125;</span><br><span class="line">\end&#123;center&#125;</span><br><span class="line">\end&#123;document&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Case2: 子图有不同的曲线<br><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20171202/20171202_fig002.jpg" width="600" height="350" title="图2" alt="图2" ></p>
<p> 实现代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\documentclass&#123;article&#125;</span><br><span class="line">\usepackage[dvipdfm]&#123;graphicx&#125;</span><br><span class="line">\def\pgfsysdriver&#123;pgfsys-dvipdfmx.def&#125;</span><br><span class="line">\usepackage&#123;tikz&#125;</span><br><span class="line">\usepackage&#123;pgfplots&#125;</span><br><span class="line">\pgfplotsset&#123;width&#x3D;6cm,compat&#x3D;1.15&#125;</span><br><span class="line">\usetikzlibrary&#123;matrix&#125;</span><br><span class="line">\usepgfplotslibrary&#123;external&#125;</span><br><span class="line">\newcommand*&#123;\refne&#125;[1]&#123;\tikzexternaldisable\pgfplotsplotfromname&#123;#1&#125;\tikzexternalenable&#125;%avoid conflict with the packet hyperref</span><br><span class="line">\begin&#123;document&#125;</span><br><span class="line">\begin&#123;center&#125;</span><br><span class="line">\begin&#123;tikzpicture&#125;</span><br><span class="line">%--define the legend by ourself</span><br><span class="line">  \matrix[</span><br><span class="line">      matrix of nodes,</span><br><span class="line">      draw,</span><br><span class="line">      inner sep&#x3D;0.2em,</span><br><span class="line">      ampersand replacement&#x3D;\&amp;,</span><br><span class="line">      font&#x3D;\scriptsize,</span><br><span class="line">      anchor&#x3D;east</span><br><span class="line">    ]</span><br><span class="line">    &#123; \refne&#123;x&#125;\&amp; $x$\\</span><br><span class="line">      \refne&#123;x2&#125;\&amp; $x^2$\\</span><br><span class="line">      &#125;;</span><br><span class="line">\end&#123;tikzpicture&#125;\\</span><br><span class="line"></span><br><span class="line">\begin&#123;tikzpicture&#125;</span><br><span class="line">\begin&#123;axis&#125;[</span><br><span class="line">legend columns&#x3D;-1,%the legend are plotted horizontally</span><br><span class="line">legend entries&#x3D;&#123;$x$&#125;,</span><br><span class="line">legend to name&#x3D;named,% stored in named</span><br><span class="line">title&#x3D;&#123;subfig1&#125;,</span><br><span class="line">]</span><br><span class="line">\addplot &#123;x&#125;;\label&#123;x&#125;</span><br><span class="line">\end&#123;axis&#125;</span><br><span class="line">\end&#123;tikzpicture&#125;</span><br><span class="line">\begin&#123;tikzpicture&#125;</span><br><span class="line">\begin&#123;axis&#125;[title&#x3D;&#123;subfig2&#125;]</span><br><span class="line">\addplot[red] &#123;x^2&#125;;\label&#123;x2&#125;</span><br><span class="line">\end&#123;axis&#125;</span><br><span class="line">\end&#123;tikzpicture&#125;</span><br><span class="line">\end&#123;center&#125;</span><br><span class="line">\end&#123;document&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<p>参考文献：<br>[1] pgfplots manual: <a href="http://pgfplots.sourceforge.net/pgfplots.pdf" target="_blank" rel="noopener">http://pgfplots.sourceforge.net/pgfplots.pdf</a></p>
<p>[2]<a href="https://tex.stackexchange.com/questions/192729/pgfplots-trying-to-combine-legends" target="_blank" rel="noopener">https://tex.stackexchange.com/questions/192729/pgfplots-trying-to-combine-legends</a></p>
<p>[3]<a href="https://tex.stackexchange.com/questions/383547/refnamed-pgfplot-externalization-and-hyperref-gives-warning-namepgfplotsli" target="_blank" rel="noopener">https://tex.stackexchange.com/questions/383547/refnamed-pgfplot-externalization-and-hyperref-gives-warning-namepgfplotsli</a></p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>Research</tag>
      </tags>
  </entry>
  <entry>
    <title>【漫漫科研路】序言</title>
    <url>/2017/11/19/%5B20171119%5D/</url>
    <content><![CDATA[<p>时间回溯到2015年中秋和国庆期间，那时还在为实验室十二五项目验收而通宵了一晚上。第二天上午结束验收，标志着我硕士生阶段就告一段落。 下午睡了几个小时便赶着火车去青海湖与小伙伴汇合。游玩归来，便开始了我的博士生阶段。 当时还思考了很多，还写了一篇对应的博文《<a href="http://blog.csdn.net/tengweitw/article/details/48953621" target="_blank" rel="noopener">遇见</a>》。从此我便放弃了技术性博文的书写，至今已两年矣。</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><p>时至今日，我将重新开始有关科研方面的写作，包括技术与非技术方面的。尽管两年来，我在科研上尚无建树，我仍旧希望通过博文来记录我科研方面的点点滴滴，表达一些我的拙见。我希望在科研中抽出时间，每个月至少能写上一篇，笔耕不辍。互联网上关于科研的博客非常少，大多数是与编程技术相关的。因此几乎所有的编程上遇到的bug都能很好的通过百度谷歌得到结果。但是关于科研的博客少之又少，这可能与科研的特性有关吧。为此，我将写一系列关于科研的文章，一方面可以记录自己的科研经历，另一方面可能也能给予别人以参考。</p>
<hr>
<p>正如题目所示，这个系列命名为【漫漫科研路】，其中包括以下几个部分（后续可能有补充）：</p>
<ul>
<li>科研工具</li>
<li>科研写作</li>
<li>科研算法</li>
</ul>
<hr>
<p>这周得到噩耗，本科舍友不幸得了黑色素癌。原本我以为只是一个肿瘤，没想到病情发展到了这么严重的境况。作为一个学生，我只能略尽绵薄之力1000元，微不足道，在此恳求大家能给予帮助，在此谢谢大家！以下是水滴筹的链接：<br><a href="https://www.shuidichou.com/cf/contribute/7d975cfc-e508-4549-acb1-5a31ceb759a1?channel=wx_charity_pyq&amp;source=7hEPKZfbC7kzc7ndTKDD6cZriDdYH4TQ&amp;forwardFrom=5&amp;sharedv=2008" target="_blank" rel="noopener">https://www.shuidichou.com/cf/contribute/7d975cfc-e508-4549-acb1-5a31ceb759a1?channel=wx_charity_pyq&amp;source=7hEPKZfbC7kzc7ndTKDD6cZriDdYH4TQ&amp;forwardFrom=5&amp;sharedv=2008</a><br>如果各位嫌麻烦，也可以通过左下角的微信扫码进行捐款，我将悉数给予舍友。再次感谢大家的帮助！</p>
<p>斯人已去（卒于2018年08月17日），念此茫茫，愿他在天堂一切安好! ——2020年09月21日</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>Research</tag>
      </tags>
  </entry>
  <entry>
    <title>【妄言之言】我的2016--困境与选择</title>
    <url>/2017/01/14/%5B20170114%5D/</url>
    <content><![CDATA[<blockquote>
<p>离元旦也已有两星期,忘却的救主快要降临了罢,我正有写一点东西的必要了。</p>
</blockquote>
<p>首先，我要进行自我批评，这一年未写过一篇技术性文章，已经远离编程了。当初选择读博，就料想会这样，着急着是否能够顺利毕业，无暇顾及技术方面的东西。回顾当初写的一百多篇文章，已经生疏了，但总有一天我会回来的，笔耕不辍。</p>
<a id="more"></a>
<p>从2015年秋到现在，已有一年半了，科研好像并没有起色。15年下学期，主要完成了博士课程和十二五项目，并没有阅读多少文献，对于怎么科研还是一头雾水。16年上学期，在通信学报上撰写并发表了一篇综述性文章，但是这并不算在毕业要内。16年下半年，也就是这学期，在十月底投了一篇ICC会议，然后基本上完成了一篇长文。会议本来被录用的概率就不大，居然还在1月27号出结果，真让我过不好年啊。长文能够投出去估计要到2017年上学期了。会议不中，明年出国的计划估计落空了。即使中了，能不能出国也还不好说，还是寄希望于后年吧。</p>
<p>元旦期间，本科舍友来西安相聚，聊了各自的情况，发现只有自己混的不行啊。要不就是北京户口，要不就是20万+的年薪，我都有点犹豫当初选择读博是否是对的。如果当初直接选择硕士毕业的话，现在也能找到一份不错的工作，也没有毕业的压力。但天天上班写代码就是我想要的生活吗？ 显然并不是！实验室今年来了两个新博士生，都是工作后来读的，他们也阐述了去公司工作的各种利弊。我读博士是期望在学术界作出点贡献，但各种原因也只能是小打小闹，也许中国的科研环境就这样。我最近在考虑是否要出国读两年博后，也许这样就能体会什么是真正的科研，也许国外也是一样的。</p>
<p>近些年，深度学习比较火，我也比较感兴趣，但是也没时间学习这方面的东西。我也想把这些技术用到通信上来，但是感觉这些比较流行的技术无法用到我们通信领域上。我想等我先达到毕业指标，再来研究如何将两者结合起来。总有一天，我会涉足深度学习等领域的。</p>
<p>选择了读博士，也就不指望以后能够大富大贵，只希望能过我想过的生活：</p>
<p>《不畏风雨》–宫泽贤治<br>不畏雨<br>不畏风<br>不畏冬寒夏暑<br>保持健壮体魄<br>无欲无求 亦不嗔怒<br>时常闲静微笑<br>一日之食 粗茶淡饭足矣<br>世间诸事不妄断<br>常闻多见细思量<br>且终生铭记<br>荒野松林阴翳处<br>长居小小茅屋里<br>东边孩童若有疾<br>前去给予悉心照顾<br>西边妇女若辛劳<br>前去为之背负稻束<br>南边若有人将故<br>前去安抚慰其勿惧<br>北边若有人争吵<br>前去劝阻无聊之举<br>旱阳之时忧心泪流<br>寒夏之际无措踱步<br>众人谓我痴傻<br>不予褒美<br>亦不施苦楚<br>能成如是之人<br>乃毕生之所愿</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>Life Thought</tag>
      </tags>
  </entry>
  <entry>
    <title>【妄言之言】西南游记</title>
    <url>/2016/09/14/%5B20160914%5D/</url>
    <content><![CDATA[<blockquote>
<p>少不入川，老不出蜀</p>
</blockquote>
<p>三年前，去了趟甘肃：兰州—嘉峪关—敦煌，第一次看到了黄河，见识了天下第一关，体会了“大漠孤烟直、黄河落日圆”的意境。一年前，也是在国庆，环游了青海湖，感受了青藏高原的气候，享受着青海湖粗犷的美，自然的美，质朴的美。我曾经有一个梦想，游遍祖国的名山大川，感受自然界的美。如今梦想只实现了一点点，向着梦想前进，于是乎，便有了今年暑假的重庆、成都之旅。</p>
<a id="more"></a>
<p>去成都的原因大概有以下三点：一、去成都吃正宗的火锅；二、去感受下成都的氛围，提前为以后是否在那里工作实地考察考察；三、当初保研时，放弃了去成电，现在想去看看。</p>
<p>从荆州到成都有直达的动车和高铁，由于蜀道之难，难于上青天，高铁时速只有150，需要七个小时到达。成都的地铁相比西安要发达得多，而且还有到青城山的城际列车，交通很是方便。在市里，去了有名的宽窄巷子、锦里、武侯祠、杜甫草堂、四川博物馆、吃了有名的龙抄手、蜀九香、串串香；在市外，由于时间有限，没能去较远的景区，去了都江堰和青城山，见识了先人的智慧，体会了自然的幽静。暑期放假时间有限，只在重庆待了半天，去了解放碑、洪崖洞、体验了长江索道，专门去上过天天向上的晓宇火锅店吃火锅。第一次感受这种城市结构：江城、山城、不夜城，比武汉有过之而无不及。</p>
<p>从重庆回到家的当晚，导师便要求提前回来写项目，没来得及褪去旅游的倦意，便又踏向了西北的火车。之后便忙了一个月的项目，也便没有时间来记录这一切。恰好，前几日这博客专家群里听闻，博客专家半年不更新博客就会被降级为荣誉专家，于是便抽空在这已经荒芜大半年的平台写了这篇日记。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>Life Thought</tag>
      </tags>
  </entry>
  <entry>
    <title>【概率统计】连续分布的产生</title>
    <url>/2015/11/08/%5B20151108%5D/</url>
    <content><![CDATA[<p>由于篇幅有限，前一篇文章《<a href="http://blog.csdn.net/tengweitw/article/details/45584597" target="_blank" rel="noopener">离散分布的产生</a>》中只讲述了用均匀分布产生离散分布的方法，<strong>那么本文接着讲如何利用均匀分布产生连续分布的方法。</strong></p>
<p>连续分布主要有以下几种：<strong>均匀分布 伽马分布 正态分布 贝塔分布 柯西分布 对数正态分布 双指数分布</strong>。</p>
<p>产生各种连续分布的方法有很多，我把它分为两类：<strong>通用方法、特殊方法</strong>。特殊方法就是根据各个连续分布的特性而特有的方法。</p>
<a id="more"></a>
<hr>
<h2 id="通用方法"><a href="#通用方法" class="headerlink" title="通用方法"></a>通用方法</h2><p>通用方法指的是对于各种连续分布理论上都适用的方法。下面只讲解分布<strong>函数法</strong>、<strong>舍取法这两种通用的方法</strong>。</p>
<h3 id="分布函数法"><a href="#分布函数法" class="headerlink" title="分布函数法"></a><strong>分布函数法</strong></h3><p><strong>概率积分变换定理</strong><br><em>设随机变量$X$有连续累计分布函数$F(x)$，令$U=F(X)$，则$U$服从$(0,1)$上的均匀分布。</em></p>
<p>由概率积分变换定理可知，如果知道一个连续分布函数的累计分布函数$F(x)$，则可以求得随机变量：$X=F^{-1}(U)$，其中$U$服从$0$到$1$内的均匀分布。<strong>下面以指数分布来举例说明：</strong><br>指数分布的累计分布函数$F(x)$可以表示为：</p>
<script type="math/tex; mode=display">F\left( x \right) = \left\{ \begin{array}{l}
1 - {e^{ - \lambda x}},{\kern 1pt} {\kern 1pt} {\kern 1pt} x \ge 0\\
{\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} 0{\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} ,{\kern 3pt}x < 0
\end{array} \right.</script><p>由于$U=F(X)$服从$(0,1)$上的均匀分布，则随机变量：$X=F^{-1}(U) =  - \frac{Ln\left( 1 - U \right)}{\lambda }$。因此只需要产生服从$(0,1)$上的均匀分布的$U$，就可以计算得到服从指数分布的随机变量$X$。</p>
<ul>
<li><strong>指数分布</strong>　</li>
</ul>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%指数分布</span></span><br><span class="line"><span class="comment">%参数：到达率lambda</span></span><br><span class="line"><span class="comment">%mean=1/lamda,  var=1/lambda^2</span></span><br><span class="line">clear all</span><br><span class="line">close all</span><br><span class="line">clc</span><br><span class="line">lambda=<span class="number">1</span>;<span class="comment">%指数分布的产生lambda</span></span><br><span class="line">n=<span class="number">10</span>;<span class="comment">%x的取值为0到无穷大，这里只取前n个</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%------------------------由内置函数直接给出-------------------------%</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%指数分布的产生，即事件发生的时间间隔x,x取值为0到正无穷</span></span><br><span class="line">X=exprnd(<span class="number">1</span>/lambda);<span class="comment">%产生1均值为1/lamda的指数分布</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%指数分布的cdf</span></span><br><span class="line">x=<span class="number">0</span>:<span class="number">.1</span>:n;</span><br><span class="line">Fx=expcdf(x,<span class="number">1</span>/lambda);</span><br><span class="line"><span class="comment">%figure</span></span><br><span class="line"><span class="comment">%plot(x,Fx,'-')</span></span><br><span class="line"><span class="comment">%title('指数分布的cdf')</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%指数分布的pdf</span></span><br><span class="line">x=<span class="number">0</span>:<span class="number">.1</span>:n;</span><br><span class="line">Px=exppdf(x,<span class="number">1</span>/lambda);</span><br><span class="line"><span class="built_in">figure</span></span><br><span class="line"><span class="built_in">plot</span>(x,Px,<span class="string">'r-'</span>)</span><br><span class="line"><span class="built_in">hold</span> on</span><br><span class="line">title(<span class="string">'指数分布的pdf'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">%-------------------------由均匀分布推导出（分布函数法）-------------------------%</span></span><br><span class="line">N=<span class="number">1000</span>;<span class="comment">%样本点数</span></span><br><span class="line">U=<span class="built_in">rand</span>(<span class="number">1</span>,N);<span class="comment">%U服从均匀分布</span></span><br><span class="line"></span><br><span class="line">X2=-(<span class="built_in">log</span>(<span class="number">1</span>-U))/lambda;<span class="comment">%X2服从指数分布，X2由分布函数法得到，对于不同的分布，分布函数不同，这里的表达式需作相应的改变！</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%下面的程序是绘制X2的概率密度函数pdf</span></span><br><span class="line">Max=<span class="built_in">ceil</span>(<span class="built_in">max</span>(X2));</span><br><span class="line">step=<span class="number">1</span>;<span class="comment">%步长</span></span><br><span class="line">range=<span class="number">0</span>:step:Max;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:<span class="built_in">length</span>(range)<span class="number">-1</span></span><br><span class="line">    YY(<span class="built_in">i</span>)=sum(range(<span class="built_in">i</span>)&lt;=X2&amp;X2&lt;=range(<span class="built_in">i</span>+<span class="number">1</span>))/N/step;<span class="comment">%统计落在区间中的点数</span></span><br><span class="line">    XX(<span class="built_in">i</span>)=(range(<span class="built_in">i</span>)+range(<span class="built_in">i</span>+<span class="number">1</span>))/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">plot</span>(XX,YY,<span class="string">'bo'</span>)</span><br><span class="line"><span class="built_in">hold</span> on</span><br><span class="line">title(<span class="string">'指数分布的pdf'</span>)</span><br><span class="line"><span class="built_in">legend</span>(<span class="string">'内置函数产生'</span>,<span class="string">'分布函数法产生'</span>)</span><br></pre></td></tr></table></figure>
<p><strong>结果显示如下：</strong>(指数参数$\lambda=1$的情况)<br><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20151108/20151108_fig001.jpg" width="600" height="500" title="图1" alt="图1" ></p>
<p><strong>分布函数法的局限性</strong>：由于该方法的关键就是求出分布函数的反函数，从而得到随机变量$X$关于均匀分布随机变量$U$的表达式。然而有些分布是不容易求得其反函数的，例如我们常见的正态分布，其分布函数需要用其概率密度函数表示如下：</p>
<script type="math/tex; mode=display">
F\left( x \right) = \frac{1}{\sigma\sqrt{2\pi} }\int_{ - \infty }^x e^{ - \frac{\left( {t - u} \right)^2}{2\sigma ^2}} dt</script><p>其中，$u$和$\sigma$分布为均值和标准差。显然，当得知$F(x)$的取值时，也很难求得此时的$x$的值。因此，当出现上述问题时，我们可以采用舍去法。</p>
<hr>
<h3 id="舍去法"><a href="#舍去法" class="headerlink" title="舍去法"></a><strong>舍去法</strong></h3><p><strong>定理</strong>：<em>设随机变量$Y,V$的概率密度函数分布为$f<em>{Y}(y)、f</em>{V}(v)$，其中，$f<em>{Y}(y)、f</em>{V}(v)$有相同的支撑集且</em><br>$M =\max\left{f<em>{Y}(y)/f</em>{V}(v)\right} &lt;  + \infty $<br><strong>*按下列步骤</strong>可以生成随机变量$Y$服从概率密度为$f_{Y}(y)$的分布：*</p>
<ol>
<li>生成独立的随机变量$U,V$，其中，$U$服从$0$到$1$的均匀分布,$V$服从概率密度函数为$f_{V}(v)$的分布</li>
<li>如果$U &lt;\frac{1}{M}f<em>{Y}(V)/f</em>{V}(V)$,则令$Y=V$，否则返回到步骤1。</li>
</ol>
<p><strong>下面以用舍去法生成正态分布来具体说明</strong>：假设我们要用舍取法生成标准正态分布，标准正态分布的概率密度函数如下所示：<br><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20151108/20151108_fig002.jpg" width="600" height="500" title="图2" alt="图2" ></p>
<ul>
<li><p><strong>确定$V$的分布</strong><br>由舍取法的步骤2可知，生成的正态分布变量$Y$的取值包含于随机变量$V$的取值中。因此，我们需要根据正态分布随机变量的取值范围，来选择$V$应该服从的分布！<strong>我们一般取$V$服从均匀分布</strong>（当然也可以取其他的分布，注意需要满足取值范围）。<br>理论上，正态随机变量的取值在整个实数域中，因此$V$应该服从区间为实数域的均匀分布，显然这个均匀分布我们很难表示出来。但由上图可知，标准正态分布的取值基本在$-5$到$5$之间，因此我们只需要使得$V$服从区间在$-5$到$5$的均匀分布即可以很好的近似。</p>
</li>
<li><p><strong>确定$M$的大小</strong><br> 在公式$M =\max\left{f<em>{Y}(y)/f</em>{V}(v)\right} $中，${f<em>V}(v) = \frac{1}{10}$，$\max\left{f</em>{Y}(y)\right} =f_{Y}(0)=\frac{1}{\sqrt {2\pi } }$。因此$M=\frac{10}{\sqrt {2\pi } }$</p>
</li>
</ul>
<p>在确定了$V$的分布以及$M$的大小之后，便可以根据定理中步骤2的判决方法来生成服从指定分布的随机变量$Y$。具体的程序实现如下：</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%-------------------正态分布-----------------------%</span></span><br><span class="line"><span class="comment">%参数：均值mu，方差sigma2</span></span><br><span class="line"><span class="comment">%mean=mu,  var=sigma2</span></span><br><span class="line">clear all</span><br><span class="line">close all</span><br><span class="line">clc</span><br><span class="line">mu=<span class="number">0</span>;</span><br><span class="line">sigma2=<span class="number">1</span>;</span><br><span class="line">n=<span class="number">10</span>;<span class="comment">%x的取值为正负无穷大，</span></span><br><span class="line"><span class="comment">%-------------------由内置函数直接给出----------------%</span></span><br><span class="line"><span class="comment">%正态分布的产生X</span></span><br><span class="line">X=normrnd(mu,<span class="built_in">sqrt</span>(sigma2));<span class="comment">%产生均值mu，方差sigma2的正态分布</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%正态分布的cdf</span></span><br><span class="line">x=<span class="number">0</span>:<span class="number">.1</span>:n;</span><br><span class="line">Fx=normcdf(x,mu,<span class="built_in">sqrt</span>(sigma2));</span><br><span class="line"><span class="comment">% figure</span></span><br><span class="line"><span class="comment">% plot(x,Fx,'-')</span></span><br><span class="line"><span class="comment">% title('正态分布的cdf')</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%指数分布的pdf</span></span><br><span class="line">x=<span class="number">-5</span>:<span class="number">.1</span>:<span class="number">5</span>;</span><br><span class="line">Px=normpdf(x,mu,<span class="built_in">sqrt</span>(sigma2));</span><br><span class="line"><span class="built_in">figure</span></span><br><span class="line"><span class="built_in">plot</span>(x,Px,<span class="string">'b-'</span>)</span><br><span class="line"><span class="built_in">hold</span> on</span><br><span class="line"></span><br><span class="line"><span class="comment">%------由舍选法推导出--------%</span></span><br><span class="line"></span><br><span class="line">N=<span class="number">100</span>;</span><br><span class="line">A=<span class="number">-5</span>;<span class="comment">%A,B位均匀分布的取值区间</span></span><br><span class="line">B=<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">i</span>=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">i</span>&lt;=N)</span><br><span class="line">    U=unifrnd(<span class="number">0</span>,<span class="number">1</span>);<span class="comment">%服从（0,1）的均匀分布</span></span><br><span class="line">    V=unifrnd(A,B);<span class="comment">%服从（A,B）的均匀分布</span></span><br><span class="line">    M=<span class="number">1</span>/<span class="built_in">sqrt</span>(<span class="number">2</span>*<span class="built_in">pi</span>)*(B-A);<span class="comment">%计算得到M</span></span><br><span class="line">    <span class="keyword">if</span>(U&lt;<span class="number">1</span>/M*<span class="number">1</span>/<span class="built_in">sqrt</span>(<span class="number">2</span>*<span class="built_in">pi</span>*sigma2)*<span class="built_in">exp</span>(-(V-mu)^<span class="number">2</span>/<span class="number">2</span>/sigma2));<span class="comment">%由定理得到的公式来生成随机变量X2</span></span><br><span class="line">        X2(<span class="built_in">i</span>)=V;<span class="comment">%X2就是我们要生成的指定分布的随机变量</span></span><br><span class="line">        <span class="built_in">i</span>=<span class="built_in">i</span>+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">end</span>  </span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%下面的程序是计算通过舍去法生成的正态分布X2的pdf</span></span><br><span class="line">Max=<span class="built_in">ceil</span>(<span class="built_in">max</span>(X2));</span><br><span class="line">step=<span class="number">1</span>;</span><br><span class="line">range=A:step:B;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:<span class="built_in">length</span>(range)<span class="number">-1</span></span><br><span class="line">    YY(<span class="built_in">i</span>)=sum(range(<span class="built_in">i</span>)&lt;=X2&amp;X2&lt;=range(<span class="built_in">i</span>+<span class="number">1</span>))/N/step;</span><br><span class="line">    XX(<span class="built_in">i</span>)=(range(<span class="built_in">i</span>)+range(<span class="built_in">i</span>+<span class="number">1</span>))/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">plot</span>(XX,YY,<span class="string">'ro'</span>)</span><br><span class="line"><span class="built_in">hold</span> on</span><br><span class="line">title(<span class="string">'正态分布的pdf'</span>)</span><br><span class="line"><span class="built_in">legend</span>(<span class="string">'内部函数产生'</span>,<span class="string">'舍取法产生'</span>)</span><br></pre></td></tr></table></figure>
<p><strong>结果显示如下：</strong><br><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20151108/20151108_fig003.jpg" width="600" height="500" title="图3" alt="图3" ></p>
<p><strong>注意</strong>：使用这种方法的时候必须使$V$服从合适的分布来保证$M&lt;+\infty$，如若找不到这样的分布，则可以参考Markov Chain Monte Carlo(MCMC)方法。</p>
<hr>
<h2 id="特殊方法"><a href="#特殊方法" class="headerlink" title="特殊方法"></a>特殊方法</h2><p>上述的两种通用方法基本上可以用均匀分布产生大多数连续分布，不过由于每种分布有着各自的特性，因此也可以通过特殊的方法来生成。下面以生成标准正态分布(<strong>正态分布性质表明：任何正态分布都可以由标准正态分布转化得到</strong>)为例：</p>
<h3 id="中心极限定理法"><a href="#中心极限定理法" class="headerlink" title="中心极限定理法"></a>中心极限定理法</h3><p><strong>中心极限定理</strong>是概率论中的一组定理。中心极限定理说明，大量相互独立的随机变量，其均值的分布以正态分布为极限。这组定理是数理统计学和误差分析的理论基础，<strong>指出了大量随机变量之和近似服从正态分布的条件</strong>。（摘自维基百科）<br>我们由中心极限定理可知，多个独立同分布的随机变量的和服从正态分布，而关于这个正态分布的均值和方差的确定，我们可以依据林德伯格－列维定理：<br><strong>林德伯格－列维(Lindeberg-Levy)定理</strong>：<br>设随机变量$X<em>1,X_2,\cdots,X_n$，且具有有限的数学期望$E({X_i}) = u,D( {X_i}) = {\sigma ^2} = 0\left( {i = 1,2, \cdots ,n} \right)$。记$\bar X = \frac{1}{n}\sum\limits</em>{i = 1}^n {X<em>i} ,Y = \frac{\bar X - u}{\sigma /\sqrt n }$，则$\mathop {\lim }\limits</em>{n \to \infty } P( Y &lt; z ) = \Phi ( z )$，其中$\Phi( z)$是标准正态分布的分布函数。</p>
<p>在程序实现中，我利用$10$个相互独立的服从区间$-5$到$5$的均匀分布来生成标准正态分布$Y$。而由公式可知，区间$0$到$1$的均匀分布的均值为$u=\frac{ - 5 + 5}{2}=0,\sigma^2=(5-(-5))^2/12=100/12$.因此我们需要生成的服从标准正态的随机变量的表达式为：$Y = \frac{\bar X - 0.5}{\sqrt {100/12}/\sqrt n }$。<strong>具体程序实现如下：</strong></p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%-------------------正态分布-----------------------%</span></span><br><span class="line"><span class="comment">%参数：均值mu，方差sigma2</span></span><br><span class="line"><span class="comment">%mean=mu,  var=sigma2</span></span><br><span class="line">clear all</span><br><span class="line">close all</span><br><span class="line">clc</span><br><span class="line">mu=<span class="number">0</span>;</span><br><span class="line">sigma2=<span class="number">1</span>;</span><br><span class="line">n=<span class="number">10</span>;<span class="comment">%x的取值为正负无穷大，</span></span><br><span class="line"><span class="comment">%------------------由内置函数直接给出--------------%</span></span><br><span class="line"><span class="comment">%正态分布的产生X</span></span><br><span class="line">X=normrnd(mu,<span class="built_in">sqrt</span>(sigma2));<span class="comment">%产生均值mu，方差sigma2的正态分布</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%正态分布的cdf</span></span><br><span class="line">x=<span class="number">0</span>:<span class="number">.1</span>:n;</span><br><span class="line">Fx=normcdf(x,mu,<span class="built_in">sqrt</span>(sigma2));</span><br><span class="line"><span class="comment">% figure</span></span><br><span class="line"><span class="comment">% plot(x,Fx,'-')</span></span><br><span class="line"><span class="comment">% title('正态分布的cdf')</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%指数分布的pdf</span></span><br><span class="line">x=<span class="number">-5</span>:<span class="number">.1</span>:<span class="number">5</span>;</span><br><span class="line">Px=normpdf(x,mu,<span class="built_in">sqrt</span>(sigma2));</span><br><span class="line"><span class="built_in">figure</span></span><br><span class="line"><span class="built_in">plot</span>(x,Px,<span class="string">'b-'</span>)</span><br><span class="line"><span class="built_in">hold</span> on</span><br><span class="line"><span class="comment">%-------------------由中心极限定理推导出---------------------%</span></span><br><span class="line">N=<span class="number">1000</span>;<span class="comment">%样本点数</span></span><br><span class="line">A=<span class="number">-5</span>;<span class="comment">%A,B位均匀分布的取值区间</span></span><br><span class="line">B=<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:<span class="number">10</span></span><br><span class="line">U(<span class="built_in">i</span>,<span class="number">1</span>:N)=unifrnd(A,B,<span class="number">1</span>,N);<span class="comment">%U存储10个独立的服从均匀分布的随机变量</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">meanX=<span class="built_in">mean</span>(U);</span><br><span class="line">X2=(meanX-(A+B)/<span class="number">2</span>)/<span class="built_in">sqrt</span>((B-A)^<span class="number">2</span>/<span class="number">12</span>)*<span class="built_in">sqrt</span>(<span class="number">10</span>);<span class="comment">%由林德伯格－列维定理的公式知X2服从正态分布</span></span><br><span class="line"><span class="built_in">mean</span>(X2);</span><br><span class="line"></span><br><span class="line"><span class="comment">%下面的程序是计算通过中心极限定理法生成的正态分布X2的pdf</span></span><br><span class="line">Max=<span class="built_in">ceil</span>(<span class="built_in">max</span>(X2));</span><br><span class="line">step=<span class="number">1</span>;</span><br><span class="line">range=A:step:B;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:<span class="built_in">length</span>(range)<span class="number">-1</span></span><br><span class="line">    YY(<span class="built_in">i</span>)=sum(range(<span class="built_in">i</span>)&lt;=X2&amp;X2&lt;=range(<span class="built_in">i</span>+<span class="number">1</span>))/N/step;</span><br><span class="line">    XX(<span class="built_in">i</span>)=(range(<span class="built_in">i</span>)+range(<span class="built_in">i</span>+<span class="number">1</span>))/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">plot</span>(XX,YY,<span class="string">'ro'</span>)</span><br><span class="line"><span class="built_in">hold</span> on</span><br><span class="line">title(<span class="string">'正态分布的pdf'</span>)</span><br><span class="line"><span class="built_in">legend</span>(<span class="string">'内部函数产生'</span>,<span class="string">'中心极限定理法产生'</span>)</span><br></pre></td></tr></table></figure>
<p><strong>显示结果如下：</strong><br><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20151108/20151108_fig004.jpg" width="600" height="500" title="图4" alt="图4" ></p>
<hr>
<h3 id="Box-Muller法"><a href="#Box-Muller法" class="headerlink" title="Box-Muller法"></a>Box-Muller法</h3><p><strong>基本思想</strong>：假设$U,V$是两个相互独立的且服从区间在$0$到$1$的均匀分布，并且随机变量$X,Y$的表达式如下：</p>
<script type="math/tex; mode=display">X = \sqrt { - 2{\mathop{\rm lnU}\nolimits} } \cos ( 2\pi V ),Y = \sqrt { - 2{\mathop{\rm lnU}\nolimits} } \sin ( 2\pi V)</script><p>则$X,Y$是相互独立的，并且服从标准正态分布。</p>
<p><strong>具体的程序实现如下：</strong></p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%-------------------正态分布-----------------------%</span></span><br><span class="line"><span class="comment">%参数：均值mu，方差sigma2</span></span><br><span class="line"><span class="comment">%mean=mu,  var=sigma2</span></span><br><span class="line">clear all</span><br><span class="line">close all</span><br><span class="line">clc</span><br><span class="line">mu=<span class="number">0</span>;</span><br><span class="line">sigma2=<span class="number">1</span>;</span><br><span class="line">n=<span class="number">10</span>;<span class="comment">%x的取值为正负无穷大，</span></span><br><span class="line"><span class="comment">%--------------------由内置函数直接给出----------------------%</span></span><br><span class="line"><span class="comment">%正态分布的产生X</span></span><br><span class="line">X=normrnd(mu,<span class="built_in">sqrt</span>(sigma2));<span class="comment">%产生均值mu，方差sigma2的正态分布</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%正态分布的cdf</span></span><br><span class="line">x=<span class="number">0</span>:<span class="number">.1</span>:n;</span><br><span class="line">Fx=normcdf(x,mu,<span class="built_in">sqrt</span>(sigma2));</span><br><span class="line"><span class="comment">% figure</span></span><br><span class="line"><span class="comment">% plot(x,Fx,'-')</span></span><br><span class="line"><span class="comment">% title('正态分布的cdf')</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%指数分布的pdf</span></span><br><span class="line">x=<span class="number">-5</span>:<span class="number">.1</span>:<span class="number">5</span>;</span><br><span class="line">Px=normpdf(x,mu,<span class="built_in">sqrt</span>(sigma2));</span><br><span class="line"><span class="built_in">figure</span></span><br><span class="line"><span class="built_in">plot</span>(x,Px,<span class="string">'r-'</span>)</span><br><span class="line"><span class="built_in">hold</span> on</span><br><span class="line"></span><br><span class="line"><span class="comment">%-----------------------Box-Muller法-----------------------%</span></span><br><span class="line">N=<span class="number">1000</span>;</span><br><span class="line">U=<span class="built_in">rand</span>(<span class="number">1</span>,N);<span class="comment">%U,V都是服从(0,1)的均匀分布</span></span><br><span class="line">V=<span class="built_in">rand</span>(<span class="number">1</span>,N);</span><br><span class="line">A=<span class="number">-5</span>;</span><br><span class="line">B=<span class="number">5</span>;</span><br><span class="line">R=<span class="built_in">sqrt</span>(<span class="number">-2.</span>*<span class="built_in">log</span>(U));</span><br><span class="line">theta=<span class="number">2</span>*<span class="built_in">pi</span>*V;</span><br><span class="line"></span><br><span class="line">X2=R.*<span class="built_in">cos</span>(theta);</span><br><span class="line">Y2=R.*<span class="built_in">sin</span>(theta);<span class="comment">%X，Y都是服从n(0,1)的正态分布</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%下面的程序是计算通过Box-Muller法生成的正态分布X的pdf</span></span><br><span class="line">Max=<span class="built_in">ceil</span>(<span class="built_in">max</span>(X2));</span><br><span class="line">step=<span class="number">1</span>;</span><br><span class="line">range=A:step:B;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:<span class="built_in">length</span>(range)<span class="number">-1</span></span><br><span class="line">    YY(<span class="built_in">i</span>)=sum(range(<span class="built_in">i</span>)&lt;=X2&amp;X2&lt;=range(<span class="built_in">i</span>+<span class="number">1</span>))/N/step;</span><br><span class="line">    XX(<span class="built_in">i</span>)=(range(<span class="built_in">i</span>)+range(<span class="built_in">i</span>+<span class="number">1</span>))/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">plot</span>(XX,YY,<span class="string">'bo'</span>)</span><br><span class="line"><span class="built_in">hold</span> on</span><br><span class="line">title(<span class="string">'正态分布的pdf'</span>)</span><br><span class="line"><span class="built_in">legend</span>(<span class="string">'内部函数产生'</span>,<span class="string">'Box-Muller法产生'</span>)</span><br></pre></td></tr></table></figure>
<p><strong>显示结果如下：</strong><br><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20151108/20151108_fig005.jpg" width="600" height="500" title="图5" alt="图5" ></p>
<p>上面我们是以正态分布为例来讲述了特殊法的运用，主要是运用了<strong>正态分布与其他分布的关系</strong>：多个独立同分布的随机变量和服从正态分布；均匀分布与正态分布之间满足Box-Muller法中的关系。因此，当想要由一种分布生成另一种分布的时候，只需要知道它们之间的关系即可！</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>Probability Theory</tag>
      </tags>
  </entry>
  <entry>
    <title>【妄言之言】遇见</title>
    <url>/2015/10/07/%5B20151007%5D/</url>
    <content><![CDATA[<blockquote>
<p>东方欲晓，莫道君行早</p>
</blockquote>
<p>上学期期末的时候，小马哥就问我为什么没写个年中（终）总结。是的，我最近几年都养成了写一些总结性的话语，半年一次或一年一次。不过由于项目忙，暑假都没放，let alone有空闲写点东西。十一又和同学去青海湖玩了一圈，现在终于有时间静下心来写写了。</p>
<p>22岁的我，作了一个比较2的决定，决定读22年书（希望不要延期，阿弥陀佛）。哎，已经延期了。</p>
<a id="more"></a>
<p>小学的时候，老师可能都问过长大后想做什么。很多人都说想做科学家，我也不例外。然而随着时间的推移，这一想法已经早已被遗忘在脑后，取而代之则是，上个好高中，考个好大学，找个好工作。刚上大学的时候，有位老乡正在读博士，那时我是佩服的紧。等到我大四的时候，从没有要读博士的想法。当时我觉得，博士的出路太窄了，基本上也只有留在高校或去研究所了，而且，老师更倾向于招博士。网上也流传着一句话”一流的本科，二流的硕士，三流的博士，不入流的博士后”。看来，我正从二流走向三流了。为何我还是走上读博（赌博）的道路呢？</p>
<p>任何事情都是把双刃剑，有利也有弊。其中的利弊想必大家都清楚，我只是谈谈自己的看法。目前的情形来看，读硕士3年，读博士5年半左右（我们实验室），博士比硕士多2到3年。硕士三年基本上都是纯粹的给老师干活，至少我研一是这样的，当然在此期间也能增长点技术。而博士虽然也要做项目，但毕竟更多的是脑力上的，能够锻炼自己的思维。我感觉，做科研更像脑力劳动中的脑力劳动，做技术更像脑力劳动中的体力劳动。我读博士，也是为了体验一下怎么搞研究的。在之前的学习过程中，基本上和科研不相干，写着一些和专业不相干的代码，也没有体验过怎样看论文，发论文。工作常有，而读博不常有。读博后，仍然可以去当个码农，而工作后，就很难有心思读博了。当然，一个决定的形成，背后有很多种原因，在此就不细说了。</p>
<p>自己选择了这条路，意味着已经规划好以后的人生。记得以前看过由作家余华小说《活着》改编的电视剧，富贵境遇这么惨都坚强的活着。我也一直思考着人为什么活着，至今也得不到一个完美的答案。我只希望平凡的过完这一生，只希望年轻的时候，多出去看看这世界，老的时候，能够晒晒太阳，下下棋。未来总是不可预测，毕业之后，我会在大学教书，或是研究所当研究员，抑或是去企业当程序员，一切都不可预测。当下的我，只能是好好的科研。</p>
<p>之前的我，一直在软件、硬件中摸爬滚打，也算是在技术领域入了门。而如今要从零开始，踏入科学研究的大门了。尽管，大学这几年都是在学专业知识，但是，都是为了应付考试而学的，现在都忘得差不多了。现在又要开始潜心修炼了，正如以前物理老师所说的那样，要厚积薄发。李老师也说过，科研的道路上，没有人会在意你的苦劳，看见的是你的功劳。记得刚上大学那会，连电脑开机都不会，经过大学四年，自己也能写点软件，在csdn混迹两年，也获得了博客专家的称号，还得到过2次csdn发给的礼物。自己也从一个门外汉，晋级为菜鸟。现如今，仿佛又回到了当年，又一次站在了科学研究的门口，看四年以后，我是否能够打开科学的大门，一探究竟，顺利毕业。</p>
<p>遇见更好的自己！</p>
<p>题外话：写完了又发现文不对题了，强行在末尾加上一句来遥相呼应。之前有多个同学问我博客地址，现公布如下：<a href="http://blog.csdn.net/tengweitw?viewmode=contents。博客近两年不再更新，一些博客朋友如有编程问题，尽量不要问我了，因为我今后可能很少涉及了。如果有点偏理论部分，大家可以一起讨论讨论。" target="_blank" rel="noopener">http://blog.csdn.net/tengweitw?viewmode=contents。博客近两年不再更新，一些博客朋友如有编程问题，尽量不要问我了，因为我今后可能很少涉及了。如果有点偏理论部分，大家可以一起讨论讨论。</a></p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>Life Thought</tag>
      </tags>
  </entry>
  <entry>
    <title>【Qt编程】基于Qt的词典开发系列--后序</title>
    <url>/2015/06/23/%5B20150623b%5D/</url>
    <content><![CDATA[<p>从去年八月份到现在，总算完成了词典的编写以及相关技术文档的编辑工作。从整个过程来说，文档的编写比程序的实现耗费的时间更多。<a href="http://blog.csdn.net/column/details/tengwei.html" target="_blank" rel="noopener">基于Qt的词典开发系列文章</a>，大致包含了在编写词典软件过程中遇到的技术重点与难点。每篇文章都完成了一个小的功能，所给的代码都基本上是可以独立运行的。本系列文章对于想要自己动手完成词典软件的程序员来说具有很好的参考价值，对于想要编写其它软件的人来说也具有参考意义。</p>
<hr>
<a id="more"></a>
<h2 id="词典软件制作的初衷"><a href="#词典软件制作的初衷" class="headerlink" title="词典软件制作的初衷"></a>词典软件制作的初衷</h2><p>在<a href="http://blog.csdn.net/tengweitw/article/details/17880055" target="_blank" rel="noopener">2013的年终总结</a>中，我提过想要学习一门界面编程语言，后来就选中了Qt。于是在2014年上半年，陆陆续续学了一些，那时候就想要做个东西出来，来巩固学习的东西，当时还不知道做个什么东西。有一次，我用有道词典时，就想到做一个类似的词典软件。当然了，有的人可能会说，不要重复造轮子，即使你写了一个词典软件，也肯定没有有道词典好。好吧，我承认我写的软件没有有道词典好，毕竟人家是一个专业的团队，而我就是一个刚入手没几个月的菜鸟。我做词典的目的也并不是期望大家都能拿来用，只是用作练练手。当然，也不能把自己的作品说得一文不值，毕竟自己也花心血来完成的，所以我也得强行说说我做的词典的优点。</p>
<hr>
<h2 id="词典软件的优点"><a href="#词典软件的优点" class="headerlink" title="词典软件的优点"></a>词典软件的优点</h2><p>对比于有道词典，我所做的词典软件的优点如下：<br>1、没有广告；2、自带8种本地词典；3、可以本地发音；4、换肤功能；5、自动补全；6、单词本也是扁平化（有道词典的单词本不是，不知道为啥还不改正）</p>
<p>对于缺点来说，还比较多，由于没有经过测试，因此还存在一些隐藏的bug，不过对于基本的使用来说影响不大。<strong>大致的优缺点在软件的帮助菜单中已经说明：</strong><br><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20150623b/20150623_fig001.jpg" width="450" height="500" title="图1" alt="图1" ></p>
<hr>
<h2 id="词典软件的技术文档"><a href="#词典软件的技术文档" class="headerlink" title="词典软件的技术文档"></a>词典软件的技术文档</h2><p> 在词典软件完成半年之后，也就是研一下学期初，我开始动笔写关于词典制作过程中的技术要点。由于时间有限，还得给导师干项目，所以直到今天才得以完成所有的技术文章的撰写。<strong>本系列文章共有16篇</strong>，其中第一篇主要介绍了词典的整体框架与功能，分别描述了各个源文件的功能，而最后一篇（即本文）想当于是这一系列文章的后序。<strong>本系列文章的结构目录如下：</strong></p>
<p><strong><a href="http://blog.csdn.net/column/details/tengwei.html" target="_blank" rel="noopener">基于Qt的词典开发系列</a></strong></p>
<ol>
<li><a href="http://blog.csdn.net/tengweitw/article/details/44757875" target="_blank" rel="noopener">词典框架设计及成品展示</a> </li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/45014771" target="_blank" rel="noopener">本地词典的设计</a></li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/45099867" target="_blank" rel="noopener">开始菜单的设计</a></li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/38758051" target="_blank" rel="noopener">无边框窗口的缩放与拖动</a>  </li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/38817595" target="_blank" rel="noopener">无边框窗口的拖动</a>  </li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/45223931" target="_blank" rel="noopener">界面美化设计</a>  </li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/45484803" target="_blank" rel="noopener">调用网络API</a>  </li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/45932429" target="_blank" rel="noopener">用户登录及API调用的实现</a>  </li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/46506945" target="_blank" rel="noopener">JSON数据解析</a>  </li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/23294533" target="_blank" rel="noopener">国际音标的显示</a>  </li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/38237203" target="_blank" rel="noopener">系统托盘的显示</a>  </li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/38306803" target="_blank" rel="noopener">调用讲述人</a>  </li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/38555787" target="_blank" rel="noopener">音频播放</a>  </li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/38689745" target="_blank" rel="noopener">自动补全功能</a>  </li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/38734201" target="_blank" rel="noopener">HTML特殊字符及正则表达式</a>  </li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/46563781" target="_blank" rel="noopener">后序</a></li>
</ol>
<p>作品下载地址（发布版）：<a href="http://download.csdn.net/detail/tengweitw/8548767" target="_blank" rel="noopener">http://download.csdn.net/detail/tengweitw/8548767</a><br>作品下载地址（绿色版）：<a href="http://download.csdn.net/detail/tengweitw/8830495" target="_blank" rel="noopener">http://download.csdn.net/detail/tengweitw/8830495</a><br>源码下载地址：<a href="http://download.csdn.net/detail/tengweitw/8830503" target="_blank" rel="noopener">http://download.csdn.net/detail/tengweitw/8830503</a></p>
<hr>
<h2 id="词典软件的成品及源码"><a href="#词典软件的成品及源码" class="headerlink" title="词典软件的成品及源码"></a>词典软件的成品及源码</h2><p>   本着开源精神，我将软件成品和源码的下载地址公布如下：<br>作品下载地址（发布版）：<a href="http://download.csdn.net/detail/tengweitw/8548767" target="_blank" rel="noopener">http://download.csdn.net/detail/tengweitw/8548767</a><br>作品下载地址（绿色版）：<a href="http://download.csdn.net/detail/tengweitw/8830495" target="_blank" rel="noopener">http://download.csdn.net/detail/tengweitw/8830495</a><br>源码下载地址：<a href="http://download.csdn.net/detail/tengweitw/8830503" target="_blank" rel="noopener">http://download.csdn.net/detail/tengweitw/8830503</a><br><strong>声明：</strong>本词典软件的布局、图标、代码有部分是参考其它软件的部分，如有侵权，请联系我771257840@qq.com。</p>
<h2 id="词典项目的改进"><a href="#词典项目的改进" class="headerlink" title="词典项目的改进"></a>词典项目的改进</h2><p>   十分欢迎有志之士来共同参与该软件的改进！</p>
<p><strong>本软件的开发平台为window操作系统，Qt5.3.0版本</strong>。本人将源码在ubuntu下能成功运行，由于没有苹果电脑，未在MAC OS系统上测试过。我这里只提供了window系统下的词典软件，希望有人能够发布在linux和OS系统版本的词典软件。在目前该软件的背单词部分由于时间关系，尚未实现，同时该软件还存在一些bug。希望大家一起共同参与进来！拜谢大家！<br>        <strong>词典项目交流群</strong>： 172672086</p>
<hr>
<h2 id="其它作品："><a href="#其它作品：" class="headerlink" title="其它作品："></a>其它作品：</h2><p> <a href="http://blog.csdn.net/tengweitw/article/details/26811621" target="_blank" rel="noopener">Matlab版生日快乐歌</a><br>                 <a href="http://blog.csdn.net/tengweitw/article/details/20228303" target="_blank" rel="noopener">Matlab扫雷</a><br>                 <a href="http://blog.csdn.net/tengweitw/article/details/21468723" target="_blank" rel="noopener">Matlab及Java时钟</a><br>                 <a href="http://blog.csdn.net/tengweitw/article/details/23378983" target="_blank" rel="noopener">Qt扫雷</a><br>                 <a href="http://blog.csdn.net/tengweitw/article/details/22308627" target="_blank" rel="noopener">Qt时钟</a><br>                 <a href="http://blog.csdn.net/tengweitw/article/details/40213317" target="_blank" rel="noopener">3D迷宫游戏</a></p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>Qt Coding</tag>
      </tags>
  </entry>
  <entry>
    <title>【Qt编程】基于Qt的词典开发系列--用户登录及API调用的实现</title>
    <url>/2015/06/23/%5B20150623%5D/</url>
    <content><![CDATA[<p>在上一篇文章《<a href="http://blog.csdn.net/tengweitw/article/details/45484803" target="_blank" rel="noopener">调用网络API</a>》中，我只讲述了如何直观的使用API接口以及调用API后返回的结果，本文则从程序实现的角度来实现API的调用，当然本程序的实现也是借助于扇贝网的API接口文档<a href="http://www.shanbay.com/help/developer/api/" target="_blank" rel="noopener">http://www.shanbay.com/help/developer/api/</a>。</p>
<hr>
<p>由<a href="http://www.shanbay.com/help/developer/api/" target="_blank" rel="noopener">API文档</a>可知，要想调用其API，必须先注册。因此，我就注册了，账户名为nineheadedbird， 密码为123456。显然，我们要查词，首先必须得登录该账户。如果用浏览器，那就很简单，只需单纯的输入用户名和密码就可以了。可实际上，这一操作并不简单，只是浏览器为我们做了这一切。如果我们要通过程序来实现上述功能的话，就需要用到Qt中的get()函数了，而发送请求的内容格式就至关重要了。</p>
<a id="more"></a>
<hr>
<h4 id="查看请求格式"><a href="#查看请求格式" class="headerlink" title="查看请求格式"></a>查看请求格式</h4><p> <strong>我们可以通过浏览器来查看请求格式</strong>：首先用谷歌浏览器(其他浏览器也可以，不过你要百度一下怎么来查看这些格式)打开扇贝网的登录界面<a href="http://www.shanbay.com/accounts/login/" target="_blank" rel="noopener">http://www.shanbay.com/accounts/login/</a> ，在谷歌浏览器的设置中单击开发者选项，然后刷新一下页眉，就会出现如下的界面：<br><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20150623/20150623_fig001.jpg" width="600" height="450" title="图1" alt="图1" ></p>
<p>然后<strong>点击右边的第一个文件login</strong>，就会出现下面的内容：<br><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20150623/20150623_fig002.jpg" width="600" height="600" title="图2" alt="图2" ></p>
<p>从上图可以看出，<strong>内容分为三类</strong>：<strong>General、Response Headers、Request Headers</strong><br>在<strong>General</strong>中可以看到<strong>Request Method为GET</strong>(一般还有另一种方式POST，这在Qt中都有对应的函数),Status Code为200表示正常。在Response Headers 中<strong>我们关注的是Set-Cookie中的csrftoken的值</strong>，因为这在我们登录时需要这个值。<strong>我们最关心的是Request Headers的内容，这部分就是我们请求函数中内容格式</strong>！参考上述的具体内容如下：<br><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20150623/20150623_fig003.jpg" width="600" height="300" title="图3" alt="图3" ></p>
<p><strong>我们的程序可以写成如下的方式：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QNetworkRequest request;</span><br><span class="line">        request.setUrl(QUrl(<span class="string">"http://www.shanbay.com/accounts/login/"</span>));</span><br><span class="line">        request.setRawHeader(<span class="string">"Accept"</span>,<span class="string">"text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8"</span>);</span><br><span class="line">        request.setRawHeader(<span class="string">"Accept-Language"</span>,<span class="string">"zh-CN,zh;q=0.8"</span>);</span><br><span class="line">        request.setRawHeader(<span class="string">"Cache-Control"</span>,<span class="string">"max-age=0"</span>);</span><br><span class="line">        request.setRawHeader(<span class="string">"Connection"</span>,<span class="string">"keep-alive"</span>);</span><br><span class="line">        request.setRawHeader(<span class="string">"Host"</span>,<span class="string">"www.shanbay.com"</span>);</span><br><span class="line">        request.setRawHeader(<span class="string">"User-Agent"</span>,<span class="string">"Mozilla/5.0 (Windows NT 6.1) AppleWebKit/535.7 (KHTML, like Gecko) Chrome/16.0.912.63 Safari/535.7"</span>);</span><br><span class="line">        http-&gt;<span class="built_in">get</span>(request);</span><br></pre></td></tr></table></figure>
<p>当我们执行上述的请求之后，服务器就会作答，作答的内容就是上面的Response Headers，而我们需要的是Set-Cookie中的csrftoken的值。<strong>在Qt中，我们将程序中finished信号与我们定义的槽关联，即每当网络应答结束时，都会发射这个信号，从而触发该槽函数的执行，来处理服务器的应答内容</strong>。在程序中，getCookie函数就是来获取csrftoken的值。</p>
<hr>
<h4 id="用户登录"><a href="#用户登录" class="headerlink" title="用户登录"></a>用户登录</h4><p>获得csrftoken的值后，我们就需要实现登录操作了。除了上述的请求格式之外，我们还需要加入csrftoken的值、用户名以及密码。<strong>具体格式可见下述代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QNetworkRequest request;  request.setUrl(QUrl(<span class="string">"http://www.shanbay.com/accounts/login/"</span>));</span><br><span class="line">       request.setRawHeader(<span class="string">"Accept"</span>,<span class="string">"text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8"</span>);</span><br><span class="line">       request.setRawHeader(<span class="string">"Accept-Language"</span>,<span class="string">"zh-CN,zh;q=0.8"</span>);</span><br><span class="line">       request.setRawHeader(<span class="string">"Cache-Control"</span>,<span class="string">"max-age=0"</span>);</span><br><span class="line">       request.setRawHeader(<span class="string">"Connection"</span>,<span class="string">"keep-alive"</span>);</span><br><span class="line">       request.setRawHeader(<span class="string">"Host"</span>,<span class="string">"www.shanbay.com"</span>);</span><br><span class="line">       request.setRawHeader(<span class="string">"User-Agent"</span>,<span class="string">"Mozilla/5.0 (Windows NT 6.1) AppleWebKit/535.7 (KHTML, like Gecko) Chrome/16.0.912.63 Safari/535.7"</span>);</span><br><span class="line">       request.setRawHeader(<span class="string">"Origin"</span>,<span class="string">"http//www.shanbay.com"</span>);</span><br><span class="line">       request.setRawHeader(<span class="string">"Referer"</span>,<span class="string">"http://www.shanbay.com/accounts/login/"</span>);</span><br><span class="line">       request.setRawHeader(<span class="string">"Host"</span>,<span class="string">"www.shanbay.com"</span>);</span><br><span class="line">       request.setRawHeader(<span class="string">"Content-Type"</span>,<span class="string">"application/x-www-form-urlencoded"</span>);</span><br><span class="line">       QByteArray postData;</span><br><span class="line">       postData.append(QString(<span class="string">"csrfmiddlewaretoken=%1&amp;"</span>).arg(sessionid));<span class="comment">//csrftoken的值</span></span><br><span class="line">       postData.append(QString(<span class="string">"username=%1&amp;password=%2&amp;"</span>).arg(QUrl::toPercentEncoding(username).constData()).arg(password));<span class="comment">//用户名及密码</span></span><br><span class="line">       postData.append(<span class="string">"login=登录&amp;continue=home&amp;u=1&amp;next="</span>);</span><br><span class="line">       request.setHeader(QNetworkRequest::ContentLengthHeader,postData.<span class="built_in">size</span>());</span><br><span class="line">       httpAction=LoginAction;</span><br><span class="line">       http-&gt;post(request,postData);</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="调用API"><a href="#调用API" class="headerlink" title="调用API"></a>调用API</h4><p> 完成登录之后，就可以进行查词和添词操作了。除了上述提到的请求头格式之外，只需要遵守API规范（《<a href="http://blog.csdn.net/tengweitw/article/details/45484803" target="_blank" rel="noopener">调用网络API</a>》中提到请求格式）即可。<strong>查词及添词的程序实现分别如下：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> netWork::queryWord(<span class="keyword">const</span> QString &amp;<span class="keyword">word</span>)<span class="comment">//查词操作</span></span><br><span class="line">&#123;</span><br><span class="line">      QNetworkRequest request;</span><br><span class="line">      request.setUrl(QUrl(<span class="string">"http://www.shanbay.com/api/word/"</span>+<span class="keyword">word</span>));</span><br><span class="line">      request.setRawHeader(<span class="string">"Accept"</span>,<span class="string">"text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8"</span>);</span><br><span class="line">      request.setRawHeader(<span class="string">"Accept-Charset"</span>,<span class="string">"GBK,utf-8;q=0.7,*;q=0.3"</span>);</span><br><span class="line">      request.setRawHeader(<span class="string">"Accept-Language"</span>,<span class="string">"zh-CN,zh;q=0.8"</span>);</span><br><span class="line">      request.setRawHeader(<span class="string">"Cache-Control"</span>,<span class="string">"max-age=0"</span>);</span><br><span class="line">      request.setRawHeader(<span class="string">"Connection"</span>,<span class="string">"keep-alive"</span>);</span><br><span class="line">      request.setRawHeader(<span class="string">"Host"</span>,<span class="string">"www.shanbay.com"</span>);</span><br><span class="line">      request.setRawHeader(<span class="string">"User-Agent"</span>,<span class="string">"Mozilla/5.0 (Windows NT 6.1) AppleWebKit/535.7 (KHTML, like Gecko) Chrome/16.0.912.63 Safari/535.7"</span>);</span><br><span class="line">      httpAction=QueryWordAction;</span><br><span class="line">      http-&gt;<span class="built_in">get</span>(request);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> netWork::addWord(<span class="keyword">const</span> QString &amp;<span class="keyword">word</span>)<span class="comment">//添词操作</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">word</span>.isEmpty())</span><br><span class="line">        qDebug()&lt;&lt;<span class="string">"你的输入有误"</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        QNetworkRequest request;</span><br><span class="line">        request.setUrl(QUrl(<span class="string">"http://www.shanbay.com/api/learning/add/"</span>+<span class="keyword">word</span>));</span><br><span class="line">        request.setRawHeader(<span class="string">"Accept"</span>,<span class="string">"text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8"</span>);</span><br><span class="line">        request.setRawHeader(<span class="string">"Accept-Charset"</span>,<span class="string">"GBK,utf-8;q=0.7,*;q=0.3"</span>);</span><br><span class="line">        request.setRawHeader(<span class="string">"Accept-Language"</span>,<span class="string">"zh-CN,zh;q=0.8"</span>);</span><br><span class="line">        request.setRawHeader(<span class="string">"Cache-Control"</span>,<span class="string">"max-age=0"</span>);</span><br><span class="line">        request.setRawHeader(<span class="string">"Connection"</span>,<span class="string">"keep-alive"</span>);</span><br><span class="line">        request.setRawHeader(<span class="string">"Host"</span>,<span class="string">"www.shanbay.com"</span>);</span><br><span class="line">        request.setRawHeader(<span class="string">"User-Agent"</span>,<span class="string">"Mozilla/5.0 (Windows NT 6.1) AppleWebKit/535.7 (KHTML, like Gecko) Chrome/16.0.912.63 Safari/535.7"</span>);</span><br><span class="line">        httpAction=AddWordAction;</span><br><span class="line">        http-&gt;<span class="built_in">get</span>(request);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="完整流程"><a href="#完整流程" class="headerlink" title="完整流程"></a>完整流程</h4><p>至此，API调用的各个功能已经实现，<strong>下面给出程序的整体思路</strong>：<strong>首先</strong>获取csrftoken的值（每次都不同）；<strong>然后</strong>利用用户名、密码及csrftoken的值来登录；<strong>接着</strong>就可以调用API了。在程序中，每当进行请求，都会在replyfinished函数中用case语句来分别处理这些请求对应的应答。<strong>注意</strong>，不要连续的进行请求，否则可能发生冲突。在程序中，为了防止冲突，我在connectNet请求后，在其应答处理函数中再进行loginShanbay的登录，然后在其应答函数中进行queryWord查词请求，然后在其对应的应答处理函数中进行addWord添词请求。<strong>其结果显示如下：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20150623/20150623_fig004.jpg" width="600" height="150" title="图4" alt="图4" ></p>
<hr>
<h4 id="程序实现"><a href="#程序实现" class="headerlink" title="程序实现"></a>程序实现</h4><p><strong>下面我们给出具体的程序实现(qt 5版本，使用到网络类，需要加上QT += network)</strong>：首先建立一个空的qt子项目，然后添加一个名为netWork的类，继承自QObject，然后再添加一个名为main的源文件，这三个文件的内容分别如下：<br><strong>1、network.h文件</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> NETWORK_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NETWORK_H</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QObject&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QtNetwork/QNetworkAccessManager&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;QtNetwork/QNetworkReply&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;QtNetwork/QNetworkRequest&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;QtNetwork/QNetworkCookie&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;QtNetwork/QNetworkCookieJar&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QJsonDocument&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QJsonObject&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QJsonArray&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QJsonValue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;QString&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;QDebug&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;QList&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;QUrl&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;QByteArray&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">netWork</span> :</span> <span class="keyword">public</span> QObject <span class="comment">//由于程序文件直接摘自整个项目文件，所以程序中有关的定义或函数没有使用，但是这个程序可以单独运行</span></span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">netWork</span><span class="params">(QObject *parent = <span class="number">0</span>)</span></span>;</span><br><span class="line"> <span class="comment">//   ~netWork();</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">enum</span> HttpAction&#123;NoAction,NetStudy,GetSessionidAction,LoginAction,QueryWordAction,AddWordAction,AddExampleAction,QueryWordExamplesAction&#125;;</span><br><span class="line">    HttpAction httpAction;</span><br><span class="line">    QNetworkAccessManager * http;</span><br><span class="line">    QString sessionid;</span><br><span class="line">    QString queryword;<span class="comment">//要查询的单词</span></span><br><span class="line">    QString nickname;</span><br><span class="line">    QString username;</span><br><span class="line">    QString password;</span><br><span class="line">    <span class="keyword">bool</span> isBusy;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function">QString <span class="title">getCookie</span><span class="params">(<span class="keyword">const</span> QString &amp;name)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">loginShanbay</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">queryWord</span><span class="params">(<span class="keyword">const</span> QString &amp;<span class="keyword">word</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">queryExamples</span><span class="params">(QString learningid)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">connectNet</span><span class="params">(QString username=<span class="string">"nineheadedbird"</span>, QString password=<span class="string">"123456"</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addWord</span><span class="params">(<span class="keyword">const</span> QString &amp;<span class="keyword">word</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">signals:<span class="comment">//这里的信号都没有用到</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">connectSuccess</span><span class="params">()</span></span>; </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">connectFail</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">verifySuccess</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">verifyFail</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">NetState</span><span class="params">(<span class="keyword">bool</span>)</span></span>;</span><br><span class="line"><span class="keyword">public</span> slots:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">replyfinished</span><span class="params">(QNetworkReply*)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// NETWORK_H</span></span></span><br></pre></td></tr></table></figure>
<p><strong>2、network.cpp文件</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"network.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;QList&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;QDesktopServices&gt;</span></span></span><br><span class="line">netWork::netWork(QObject *parent) :</span><br><span class="line">    QObject(parent)</span><br><span class="line">&#123;</span><br><span class="line">        http=<span class="keyword">new</span> QNetworkAccessManager(<span class="keyword">this</span>);</span><br><span class="line">        http-&gt;setCookieJar(<span class="keyword">new</span> QNetworkCookieJar(<span class="keyword">this</span>));</span><br><span class="line">        <span class="built_in">connect</span>(http,SIGNAL(finished(QNetworkReply*)),<span class="keyword">this</span>,SLOT(replyfinished(QNetworkReply*)));<span class="comment">//将finished信号与我们定义的槽关联，每当网络应答结束时，都会发射这个信号</span></span><br><span class="line">        isBusy=<span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">QString netWork::getCookie(<span class="keyword">const</span> QString &amp;name)<span class="comment">//用于获得SessionId</span></span><br><span class="line">&#123;</span><br><span class="line">    foreach(QNetworkCookie cookie , http-&gt;cookieJar()-&gt;cookiesForUrl(QUrl(<span class="string">"http://www.shanbay.com/"</span>)))</span><br><span class="line">    &#123;</span><br><span class="line">            <span class="keyword">if</span>(cookie.name()==name)</span><br><span class="line">            &#123;</span><br><span class="line">                qDebug()&lt;&lt;<span class="string">"csrftoken:"</span>&lt;&lt;cookie.value();</span><br><span class="line">                <span class="keyword">return</span> cookie.value();</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> netWork::connectNet(QString username, QString password)<span class="comment">//连接网络,使用默认的用户名和密码</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;username=username;</span><br><span class="line">        <span class="keyword">this</span>-&gt;password=password;</span><br><span class="line">        QNetworkRequest request;</span><br><span class="line">        request.setUrl(QUrl(<span class="string">"http://www.shanbay.com/accounts/login/"</span>));</span><br><span class="line">        request.setRawHeader(<span class="string">"Accept"</span>,<span class="string">"text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8"</span>);</span><br><span class="line">        request.setRawHeader(<span class="string">"Accept-Language"</span>,<span class="string">"zh-CN,zh;q=0.8"</span>);</span><br><span class="line">        request.setRawHeader(<span class="string">"Cache-Control"</span>,<span class="string">"max-age=0"</span>);</span><br><span class="line">        request.setRawHeader(<span class="string">"Connection"</span>,<span class="string">"keep-alive"</span>);</span><br><span class="line">        request.setRawHeader(<span class="string">"Host"</span>,<span class="string">"www.shanbay.com"</span>);</span><br><span class="line">        request.setRawHeader(<span class="string">"User-Agent"</span>,<span class="string">"Mozilla/5.0 (Windows NT 6.1) AppleWebKit/535.7 (KHTML, like Gecko) Chrome/16.0.912.63 Safari/535.7"</span>);</span><br><span class="line">        httpAction=GetSessionidAction;</span><br><span class="line">        http-&gt;<span class="built_in">get</span>(request);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> netWork::replyfinished(QNetworkReply *reply)<span class="comment">//每当执行网站应答结束后，就会执行该槽函数</span></span><br><span class="line">&#123;</span><br><span class="line">    QVariant status_code=reply-&gt;attribute(QNetworkRequest::HttpStatusCodeAttribute);</span><br><span class="line">    qDebug()&lt;&lt;<span class="string">"code_state="</span>&lt;&lt;status_code;<span class="comment">//网络状态,200代表正常，302代表重定向，404：not found等等</span></span><br><span class="line">    <span class="keyword">if</span>(status_code==QVariant::Invalid)<span class="comment">//判断是否连接到网站,即当前设备能否上网</span></span><br><span class="line">        <span class="function">emit <span class="title">NetState</span><span class="params">(<span class="literal">false</span>)</span></span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        emit NetState(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span>(httpAction)<span class="comment">//根据我们都进行了什么网络请求</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> NoAction:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> GetSessionidAction:<span class="comment">//获取SessionId</span></span><br><span class="line">        sessionid=getCookie(<span class="string">"csrftoken"</span>);</span><br><span class="line">        <span class="keyword">if</span>(!sessionid.isEmpty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">emit <span class="title">connectSuccess</span><span class="params">()</span></span>;</span><br><span class="line">            qDebug()&lt;&lt;(<span class="string">"已经连接扇贝网，正在验证用户名密码..."</span>);</span><br><span class="line">            loginShanbay();</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            emit connectFail();</span><br><span class="line"></span><br><span class="line">             qDebug()&lt;&lt;(<span class="string">"Cannot connect to the website!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> LoginAction: <span class="comment">//进行登录操作</span></span><br><span class="line">        httpAction=NoAction;</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">0</span>==reply-&gt;readAll().<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            QString nickname=QUrl::fromPercentEncoding(getCookie(<span class="string">"username"</span>).toLatin1());</span><br><span class="line">            <span class="function">emit <span class="title">verifySuccess</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">            qDebug()&lt;&lt;<span class="string">"Successfully Login"</span>&lt;&lt;nickname;</span><br><span class="line">            queryWord(<span class="string">"hello"</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            emit verifyFail();</span><br><span class="line">            qDebug()&lt;&lt;<span class="string">"Failed to login!"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> QueryWordAction:<span class="comment">//查词操作</span></span><br><span class="line">        qDebug()&lt;&lt;<span class="string">"----query word----"</span>;</span><br><span class="line">        qDebug()&lt;&lt;reply-&gt;readAll();<span class="comment">//读取查词结果</span></span><br><span class="line"></span><br><span class="line">        addWord(<span class="string">"hello"</span>);<span class="comment">//添加单词到单词本</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> AddWordAction:<span class="comment">//添词操作</span></span><br><span class="line">        qDebug()&lt;&lt;<span class="string">"---add word----"</span>;</span><br><span class="line">        qDebug()&lt;&lt;reply-&gt;readAll();<span class="comment">//返回添加词语的learning_id</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:<span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> netWork::loginShanbay()<span class="comment">//账户密码的登录操作</span></span><br><span class="line">&#123;</span><br><span class="line">       QNetworkRequest request;</span><br><span class="line">       request.setUrl(QUrl(<span class="string">"http://www.shanbay.com/accounts/login/"</span>));</span><br><span class="line">       request.setRawHeader(<span class="string">"Accept"</span>,<span class="string">"text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8"</span>);</span><br><span class="line">       request.setRawHeader(<span class="string">"Accept-Language"</span>,<span class="string">"zh-CN,zh;q=0.8"</span>);</span><br><span class="line">       request.setRawHeader(<span class="string">"Cache-Control"</span>,<span class="string">"max-age=0"</span>);</span><br><span class="line">       request.setRawHeader(<span class="string">"Connection"</span>,<span class="string">"keep-alive"</span>);</span><br><span class="line">       request.setRawHeader(<span class="string">"Host"</span>,<span class="string">"www.shanbay.com"</span>);</span><br><span class="line">       request.setRawHeader(<span class="string">"User-Agent"</span>,<span class="string">"Mozilla/5.0 (Windows NT 6.1) AppleWebKit/535.7 (KHTML, like Gecko) Chrome/16.0.912.63 Safari/535.7"</span>);</span><br><span class="line">       request.setRawHeader(<span class="string">"Origin"</span>,<span class="string">"http//www.shanbay.com"</span>);</span><br><span class="line">       request.setRawHeader(<span class="string">"Referer"</span>,<span class="string">"http://www.shanbay.com/accounts/login/"</span>);</span><br><span class="line">       request.setRawHeader(<span class="string">"Host"</span>,<span class="string">"www.shanbay.com"</span>);</span><br><span class="line">       request.setRawHeader(<span class="string">"Content-Type"</span>,<span class="string">"application/x-www-form-urlencoded"</span>);</span><br><span class="line">       QByteArray postData;</span><br><span class="line">       postData.append(QString(<span class="string">"csrfmiddlewaretoken=%1&amp;"</span>).arg(sessionid));</span><br><span class="line">       postData.append(QString(<span class="string">"username=%1&amp;password=%2&amp;"</span>).arg(QUrl::toPercentEncoding(username).constData()).arg(password));</span><br><span class="line">       postData.append(<span class="string">"login=登录&amp;continue=home&amp;u=1&amp;next="</span>);</span><br><span class="line">       request.setHeader(QNetworkRequest::ContentLengthHeader,postData.<span class="built_in">size</span>());</span><br><span class="line">       httpAction=LoginAction;</span><br><span class="line">       http-&gt;post(request,postData);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> netWork::queryWord(<span class="keyword">const</span> QString &amp;<span class="keyword">word</span>)<span class="comment">//查词操作</span></span><br><span class="line">&#123;</span><br><span class="line">      QNetworkRequest request;</span><br><span class="line">      request.setUrl(QUrl(<span class="string">"http://www.shanbay.com/api/word/"</span>+<span class="keyword">word</span>));</span><br><span class="line">      request.setRawHeader(<span class="string">"Accept"</span>,<span class="string">"text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8"</span>);</span><br><span class="line">      request.setRawHeader(<span class="string">"Accept-Charset"</span>,<span class="string">"GBK,utf-8;q=0.7,*;q=0.3"</span>);</span><br><span class="line">      request.setRawHeader(<span class="string">"Accept-Language"</span>,<span class="string">"zh-CN,zh;q=0.8"</span>);</span><br><span class="line">      request.setRawHeader(<span class="string">"Cache-Control"</span>,<span class="string">"max-age=0"</span>);</span><br><span class="line">      request.setRawHeader(<span class="string">"Connection"</span>,<span class="string">"keep-alive"</span>);</span><br><span class="line">      request.setRawHeader(<span class="string">"Host"</span>,<span class="string">"www.shanbay.com"</span>);</span><br><span class="line">      request.setRawHeader(<span class="string">"User-Agent"</span>,<span class="string">"Mozilla/5.0 (Windows NT 6.1) AppleWebKit/535.7 (KHTML, like Gecko) Chrome/16.0.912.63 Safari/535.7"</span>);</span><br><span class="line">      httpAction=QueryWordAction;</span><br><span class="line">      http-&gt;<span class="built_in">get</span>(request);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> netWork::addWord(<span class="keyword">const</span> QString &amp;<span class="keyword">word</span>)<span class="comment">//添词操作</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">word</span>.isEmpty())</span><br><span class="line">        qDebug()&lt;&lt;<span class="string">"你的输入有误"</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        QNetworkRequest request;</span><br><span class="line">        request.setUrl(QUrl(<span class="string">"http://www.shanbay.com/api/learning/add/"</span>+<span class="keyword">word</span>));</span><br><span class="line">        request.setRawHeader(<span class="string">"Accept"</span>,<span class="string">"text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8"</span>);</span><br><span class="line">        request.setRawHeader(<span class="string">"Accept-Charset"</span>,<span class="string">"GBK,utf-8;q=0.7,*;q=0.3"</span>);</span><br><span class="line">        request.setRawHeader(<span class="string">"Accept-Language"</span>,<span class="string">"zh-CN,zh;q=0.8"</span>);</span><br><span class="line">        request.setRawHeader(<span class="string">"Cache-Control"</span>,<span class="string">"max-age=0"</span>);</span><br><span class="line">        request.setRawHeader(<span class="string">"Connection"</span>,<span class="string">"keep-alive"</span>);</span><br><span class="line">        request.setRawHeader(<span class="string">"Host"</span>,<span class="string">"www.shanbay.com"</span>);</span><br><span class="line">        request.setRawHeader(<span class="string">"User-Agent"</span>,<span class="string">"Mozilla/5.0 (Windows NT 6.1) AppleWebKit/535.7 (KHTML, like Gecko) Chrome/16.0.912.63 Safari/535.7"</span>);</span><br><span class="line">        httpAction=AddWordAction;</span><br><span class="line">        http-&gt;<span class="built_in">get</span>(request);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>3、main.cpp文件</strong></p>
<h2 id=""><a href="#" class="headerlink" title=""></a><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"network.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    netWork *nW = <span class="keyword">new</span> netWork();</span><br><span class="line">   <span class="comment">//</span></span><br><span class="line">    nW-&gt;connectNet();</span><br><span class="line">  <span class="comment">//  nW-&gt;loginShanbay();</span></span><br><span class="line">  <span class="comment">//  nW-&gt;queryWord("hello");</span></span><br><span class="line">    <span class="keyword">return</span> a.exec();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></h2><p><strong><a href="http://blog.csdn.net/column/details/tengwei.html" target="_blank" rel="noopener">基于Qt的词典开发系列</a></strong></p>
<ol>
<li><a href="http://blog.csdn.net/tengweitw/article/details/44757875" target="_blank" rel="noopener">词典框架设计及成品展示</a> </li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/45014771" target="_blank" rel="noopener">本地词典的设计</a></li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/45099867" target="_blank" rel="noopener">开始菜单的设计</a></li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/38758051" target="_blank" rel="noopener">无边框窗口的缩放与拖动</a>  </li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/38817595" target="_blank" rel="noopener">无边框窗口的拖动</a>  </li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/45223931" target="_blank" rel="noopener">界面美化设计</a>  </li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/45484803" target="_blank" rel="noopener">调用网络API</a>  </li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/45932429" target="_blank" rel="noopener">用户登录及API调用的实现</a>  </li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/46506945" target="_blank" rel="noopener">JSON数据解析</a>  </li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/23294533" target="_blank" rel="noopener">国际音标的显示</a>  </li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/38237203" target="_blank" rel="noopener">系统托盘的显示</a>  </li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/38306803" target="_blank" rel="noopener">调用讲述人</a>  </li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/38555787" target="_blank" rel="noopener">音频播放</a>  </li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/38689745" target="_blank" rel="noopener">自动补全功能</a>  </li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/38734201" target="_blank" rel="noopener">HTML特殊字符及正则表达式</a>  </li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/46563781" target="_blank" rel="noopener">后序</a></li>
</ol>
<p>作品下载地址（发布版）：<a href="http://download.csdn.net/detail/tengweitw/8548767" target="_blank" rel="noopener">http://download.csdn.net/detail/tengweitw/8548767</a><br>作品下载地址（绿色版）：<a href="http://download.csdn.net/detail/tengweitw/8830495" target="_blank" rel="noopener">http://download.csdn.net/detail/tengweitw/8830495</a><br>源码下载地址：<a href="http://download.csdn.net/detail/tengweitw/8830503" target="_blank" rel="noopener">http://download.csdn.net/detail/tengweitw/8830503</a></p>
<hr>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>Qt Coding</tag>
      </tags>
  </entry>
  <entry>
    <title>【算法编程】小学数学题难倒博士</title>
    <url>/2015/05/27/%5B20150527%5D/</url>
    <content><![CDATA[<p>昨天在科学网上得知这样一个新闻《越南小学数学题难倒博士》，据悉题目来自越南保禄小学三年班，不过报道称该题难倒了上至博士下至家长，未免也太言过其实了。</p>
<hr>
<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>学生需要在下图表格中按由上至下、从左到右的顺序，填入1~9的数字，可重复填写，并按先乘除后加减（图中冒号代表除法）的运算法则，完成整条算式。<br><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20150527/20150527_fig001.jpg" width="400" height="300" title="图1" alt="图1" ></p>
<a id="more"></a>
<hr>
<h4 id="解题方法"><a href="#解题方法" class="headerlink" title="解题方法"></a>解题方法</h4><p>显然，这题对于我们这种程序员来说完全不是问题，只要在大一上过C语言的学生(我们学校全校都学过C，即使是文科专业)基本上都可以用九重for循环来穷举解出此题，下面我分别用C和Matlab实现，并对Matlab算法进行了改进。</p>
<hr>
<h5 id="C语言实现"><a href="#C语言实现" class="headerlink" title="C语言实现:"></a>C语言实现:</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">clock_t</span> start, finish; <span class="comment">//用于计时</span></span><br><span class="line">    <span class="keyword">double</span>   duration; </span><br><span class="line">    start = clock(); </span><br><span class="line">    <span class="keyword">double</span> result=<span class="number">0</span>;<span class="comment">//存储计算结果来看是否与66相等</span></span><br><span class="line">    <span class="keyword">int</span> index=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> a=<span class="number">1</span>;a&lt;<span class="number">10</span>;a++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> b=<span class="number">1</span>;b&lt;<span class="number">10</span>;b++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> c=<span class="number">1</span>;c&lt;<span class="number">10</span>;c++)</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> d=<span class="number">1</span>;d&lt;<span class="number">10</span>;d++)</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> e=<span class="number">1</span>;e&lt;<span class="number">10</span>;e++)</span><br><span class="line">                        <span class="keyword">for</span>(<span class="keyword">int</span> f=<span class="number">1</span>;f&lt;<span class="number">10</span>;f++)</span><br><span class="line">                            <span class="keyword">for</span>(<span class="keyword">int</span> g=<span class="number">1</span>;g&lt;<span class="number">10</span>;g++)</span><br><span class="line">                                <span class="keyword">for</span>(<span class="keyword">int</span> h=<span class="number">1</span>;h&lt;<span class="number">10</span>;h++)</span><br><span class="line">                                    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">                                    &#123;</span><br><span class="line">                                        result=a+<span class="number">13</span>*b/<span class="keyword">float</span>(c)+d+<span class="number">12</span>*e-f<span class="number">-11</span>+g*h/<span class="keyword">float</span>(i)<span class="number">-10</span>;</span><br><span class="line">                                        <span class="keyword">if</span>(result==<span class="number">66</span>)</span><br><span class="line">                                        &#123;</span><br><span class="line">                                            <span class="comment">//这里可以打印解的结果</span></span><br><span class="line">                                            num=num+<span class="number">1</span>;</span><br><span class="line">                                        &#125;</span><br><span class="line">                                    &#125;</span><br><span class="line">    finish = clock(); </span><br><span class="line">    duration = (<span class="keyword">double</span>)(finish - start) / CLOCKS_PER_SEC; </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"总共有%d种结果\n耗时为%f秒\n"</span>,num,duration);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>结果显示如下：</strong><br><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20150527/20150527_fig002.jpg" width="600" height="500" title="图2" alt="图2" ></p>
<hr>
<h5 id="Matlab实现"><a href="#Matlab实现" class="headerlink" title="Matlab实现"></a>Matlab实现</h5><ul>
<li><strong>最直接的方法</strong>：耗时4911.131591 秒。 </li>
</ul>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clear all;<span class="built_in">ans</span>=[];</span><br><span class="line">tic</span><br><span class="line"><span class="keyword">for</span> a=<span class="number">1</span>:<span class="number">9</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> b=<span class="number">1</span>:<span class="number">9</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> c=<span class="number">1</span>:<span class="number">9</span></span><br><span class="line"></span><br><span class="line">          <span class="keyword">for</span> d=<span class="number">1</span>:<span class="number">9</span></span><br><span class="line"></span><br><span class="line">               <span class="keyword">for</span> e=<span class="number">1</span>:<span class="number">9</span></span><br><span class="line"></span><br><span class="line">                   <span class="keyword">for</span> f=<span class="number">1</span>:<span class="number">9</span></span><br><span class="line"></span><br><span class="line">                       <span class="keyword">for</span> g=<span class="number">1</span>:<span class="number">9</span></span><br><span class="line"></span><br><span class="line">                           <span class="keyword">for</span> h=<span class="number">1</span>:<span class="number">9</span></span><br><span class="line"></span><br><span class="line">                               <span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:<span class="number">9</span></span><br><span class="line"></span><br><span class="line">                                   result=a+<span class="number">13</span>*b/c+d+<span class="number">12</span>*e-f<span class="number">-11</span>+g*h/<span class="built_in">i</span><span class="number">-10</span>;</span><br><span class="line"></span><br><span class="line">                                   <span class="keyword">if</span> result==<span class="number">66</span>;</span><br><span class="line"></span><br><span class="line">                                      answer=[a b c d e f g h <span class="built_in">i</span>]; <span class="built_in">ans</span>=[<span class="built_in">ans</span>;answer];                              </span><br><span class="line"></span><br><span class="line">                                   <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">                               <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">                           <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">                       <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">                   <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">               <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">          <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span> </span><br><span class="line">toc</span><br></pre></td></tr></table></figure>
<p>在上面的算法中，存储结果answer的操作十分耗时，我们可以想办法来优化。于是，<strong>我将存储结果的过程注释掉后（去掉if语句块），耗时为16.814298 秒</strong>，时间由一个小时缩短到了十几秒。不过即使不储存结果，也耗时16.814298 秒，这与用C语言（同样也没有存储结果）的4秒还是有差距的！<strong>下面我来讲讲如何改进算法。</strong></p>
<hr>
<h5 id="改进的matlab实现"><a href="#改进的matlab实现" class="headerlink" title="改进的matlab实现"></a>改进的matlab实现</h5><p>在之前的文章《<a href="http://blog.csdn.net/tengweitw/article/details/31410865" target="_blank" rel="noopener">Matlab高效编程技巧</a>》中，提到了要<strong>尽量避免多重循环，多使用向量化函数</strong>。因此，我决定用矩阵来代替这$9$重循环。<br><strong>首先从简单的例子出发</strong>：假设有$2$个一维数组$a,b$，其元素都是$1:9$，显然这$2$个数组任意元素之间进行四则运算（在这里我们假设是相乘）的结果有$9\times 9$项，可以用一个$9\times 9$的二维数组表示；同理，假设有$3$个一维数组$a,b,c$，其元素都是$1:9$，我们要计算这三个数组任意元素之间进行四则运算的结果，这样总共有$9\times 9\times 9$项，正好用一个$9\times 9\times 9$的三维数组存储；依此类推，我们可以得到$9$个一维数组元素间进行四则运算可以用$9\times 9\times 9\times 9\times 9\times 9\times 9\times 9\times 9\times 9$的$9$维数组表示。<br>然而，在matlab中，乘法符号只能用于二维数组的相乘，幸好我们可以通过bsxfun函数来进行不同维数数组的计算.<strong>下面举例演示一下bsxfun的用法：</strong></p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clear all</span><br><span class="line"> </span><br><span class="line">a=<span class="built_in">ones</span>(<span class="number">9</span>,<span class="number">1</span>);<span class="comment">%注意一维列向量相当于一个大小为9*1的二维向量</span></span><br><span class="line">b=<span class="built_in">ones</span>(<span class="number">1</span>,<span class="number">9</span>);</span><br><span class="line">c=<span class="built_in">ones</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="number">9</span>);</span><br><span class="line"> </span><br><span class="line">a(<span class="number">1</span>:<span class="number">9</span>)=<span class="number">1</span>:<span class="number">9</span></span><br><span class="line">b(<span class="number">1</span>,<span class="number">1</span>:<span class="number">9</span>)=<span class="number">1</span>:<span class="number">9</span></span><br><span class="line">c(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>:<span class="number">9</span>)=<span class="number">1</span>:<span class="number">9</span>;</span><br><span class="line"> </span><br><span class="line">temp1=<span class="built_in">bsxfun</span>(@times,a,b)<span class="comment">%乘法a*b temp1是9*9的二维数组</span></span><br><span class="line"> </span><br><span class="line">temp2=<span class="built_in">bsxfun</span>(@plus,a,b)<span class="comment">%加法a+b</span></span><br><span class="line"> </span><br><span class="line">temp3=<span class="built_in">bsxfun</span>(@times,temp1,c)<span class="comment">%乘法a*b*c 9*9*9的三维数组</span></span><br></pre></td></tr></table></figure>
<p>通过运行上述结果，你就可以发现，<strong>bsxfun完成了任意元素间两两进行四则运算的结果,而且并不要求维数相等</strong>。当然关于bsxfun的运算原理以及作用可以查看Matlab的自带文档。我们的算法只需要上述的功能就可以了，<strong>在程序中，我按照公式$a+13\cdot b/c+d+12\cdot e-f-11+g\cdot h/i-10$计算了当$a, b, \cdots, i$的所有组合的值，并存储在abcdefghi中，最后再找到数组abcdefghi中值为66的元素所在的下标索引，其索引就是问题的解</strong>。具体的Matlab程序实现如下：</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clear all</span><br><span class="line">tic</span><br><span class="line"></span><br><span class="line"><span class="comment">%使得a,b,c,d,e,f,g,h,i分别为1，2，3，4，5，6，7，8，9维的向量</span></span><br><span class="line">a=<span class="built_in">ones</span>(<span class="number">9</span>,<span class="number">1</span>);<span class="comment">%注意一维列向量相当于一个大小为9*1的二维向量</span></span><br><span class="line">b=<span class="built_in">ones</span>(<span class="number">1</span>,<span class="number">9</span>);</span><br><span class="line">c=<span class="built_in">ones</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="number">9</span>);</span><br><span class="line">d=<span class="built_in">ones</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">9</span>);</span><br><span class="line">e=<span class="built_in">ones</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">9</span>);</span><br><span class="line">f=<span class="built_in">ones</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">9</span>);</span><br><span class="line">g=<span class="built_in">ones</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">9</span>);</span><br><span class="line">h=<span class="built_in">ones</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">9</span>);</span><br><span class="line"><span class="built_in">i</span>=<span class="built_in">ones</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">9</span>);</span><br><span class="line"></span><br><span class="line">a(<span class="number">1</span>:<span class="number">9</span>)=<span class="number">1</span>:<span class="number">9</span>;</span><br><span class="line">b(<span class="number">1</span>,<span class="number">1</span>:<span class="number">9</span>)=<span class="number">1</span>:<span class="number">9</span>;</span><br><span class="line">c(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>:<span class="number">9</span>)=<span class="number">1</span>:<span class="number">9</span>;</span><br><span class="line">d(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>:<span class="number">9</span>)=<span class="number">1</span>:<span class="number">9</span>;</span><br><span class="line">e(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>:<span class="number">9</span>)=<span class="number">1</span>:<span class="number">9</span>;</span><br><span class="line">f(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>:<span class="number">9</span>)=<span class="number">1</span>:<span class="number">9</span>;</span><br><span class="line">g(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>:<span class="number">9</span>)=<span class="number">1</span>:<span class="number">9</span>;</span><br><span class="line">h(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>:<span class="number">9</span>)=<span class="number">1</span>:<span class="number">9</span>;</span><br><span class="line"><span class="built_in">i</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>:<span class="number">9</span>)=<span class="number">1</span>:<span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">%主要使用bsxfun函数来实现不同维函数的四则运算</span></span><br><span class="line"><span class="comment">%a+13*b/c+d+12*e-f-11+g*h/i-10=66</span></span><br><span class="line">b=<span class="built_in">bsxfun</span>(@times,b,<span class="number">13</span>);</span><br><span class="line">bc=<span class="built_in">bsxfun</span>(@rdivide,b,c);</span><br><span class="line">gh=<span class="built_in">bsxfun</span>(@times,g,h);</span><br><span class="line">ghi=<span class="built_in">bsxfun</span>(@rdivide,gh,<span class="built_in">i</span>);</span><br><span class="line"></span><br><span class="line">abc=<span class="built_in">bsxfun</span>(@plus,a,bc);</span><br><span class="line">abcd=<span class="built_in">bsxfun</span>(@plus,abc,d);</span><br><span class="line">e=<span class="built_in">bsxfun</span>(@times,e,<span class="number">12</span>);</span><br><span class="line">abcde=<span class="built_in">bsxfun</span>(@plus,abcd,e);</span><br><span class="line">abcdef=<span class="built_in">bsxfun</span>(@minus,abcde,f);</span><br><span class="line">abcdef=<span class="built_in">bsxfun</span>(@minus,abcdef,<span class="number">11</span>);</span><br><span class="line">abcdefghi=<span class="built_in">bsxfun</span>(@plus,abcdef,ghi);</span><br><span class="line">abcdefghi=<span class="built_in">bsxfun</span>(@minus,abcdefghi,<span class="number">10</span>);</span><br><span class="line">toc</span><br><span class="line">counter=<span class="built_in">find</span>(abcdefghi==<span class="number">66</span>);<span class="comment">%找到下标索引</span></span><br><span class="line">[l1,l2,l3,l4,l5,l6,l7,l8,l9]=<span class="built_in">ind2sub</span>(<span class="built_in">size</span>(abcdefghi),counter(<span class="number">1</span>))<span class="comment">%这就是一种可能的解</span></span><br></pre></td></tr></table></figure>
<p><strong>运行结果如下图：</strong><br><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20150527/20150527_fig003.jpg" width="400" height="300" title="图3" alt="图3" ></p>
<p>从图中可以看到，此方法耗时4.183608秒，图中我只显示了前十个结果，并且只计算了第一个结果45所对应的abcdefghi的值，其值在下图的变量空间中：<br><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20150527/20150527_fig004.jpg" width="300" height="600" title="图4" alt="图4" ></p>
<p>从上图中可以看出，<strong>counter大小为442232，即总共有442232个解，其中counter(1)=45时，对应的解为abcdefghi=9 5 1 1 1 1 1 1 1 1 1。</strong><br><strong>注释</strong>：此程序在内存较小的电脑中会由于内存不够而运行不成功，我是在实验室的工作站（内存128g）上运行的。</p>
<hr>
<h4 id="结果分析"><a href="#结果分析" class="headerlink" title="结果分析"></a>结果分析</h4><p>使用matlab编程时，要避免使用多重循环，尽量以矩阵的角度思考问题。由上面的程序耗时对比可以看出，用C语言实现和我改进的算法耗时都在4秒左右，而且用C语言实现是在没有存储解的结果的情况下，如果同样的要存储结果（存储结果可以用不同的数据结构：链表、队列等等）的话，谁更耗时还说不定！由文中提到的两种matlab实现可知，第一种方法占用内存小，可以在普通的电脑上运行，但是耗时长；而我们改进的算法，耗时短，但是占用内存大，在内存小的机器上无法运行。这就是所谓的时间换空间，空间换时间吧！</p>
<hr>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>Algorithm Design</tag>
      </tags>
  </entry>
  <entry>
    <title>【单片机】基于有方GPRS的智能电梯控制系统</title>
    <url>/2015/05/22/%5B20150522%5D/</url>
    <content><![CDATA[<p>前一篇文章《<a href="http://blog.csdn.net/tengweitw/article/details/45895989" target="_blank" rel="noopener">时钟及温度的显示</a>》中所介绍的作品，是作为一个单片机新手在暑假学了一个月的单片机之后，做的第一个综合性作品，涵盖了二极管、蜂鸣器、数码管、液晶屏、按键、时钟芯片、温度传感器的控制操作。做完这个之后，也没碰过单片机了。在大三开始的时候，由于和同学参加了一个由有方公司提供GPRS芯片的比赛，便开始重拾单片机，完成了下面这个作品，还获奖了。</p>
<a id="more"></a>
<hr>
<p>基于有方GPRS的智能电梯控制系统，名字感觉很高端，其实就是噱头。其功能描述如下（直接复制当初演示用的PPT）：</p>
<h4 id="构思背景"><a href="#构思背景" class="headerlink" title="构思背景"></a>构思背景</h4><p>目前的很多企业都在很高的楼层办公，每天上下班高峰期，电梯门口总是会排上很长的队，为了让电梯用最快的速度将所有的员工送到指定楼层，需要给出一些改进；下班的时候，由于楼层很高，员工往往需要花费一些时间等待电梯到达自己的楼层，利用一些改进可以让员工掌握电梯状态，从而节省一些等电梯的时间。</p>
<hr>
<h4 id="功能特色"><a href="#功能特色" class="headerlink" title="功能特色"></a>功能特色</h4><ul>
<li><p><strong>功能一</strong>：我们对电梯作出这样的改进：在上班高峰时段，电梯只能向上运行时开门搭载上朝楼上去的人员，即电梯只会响应朝上行的按键,在向下运行的过程中，不会响应任何按钮。在下班时间段，也可以做相应修改。从而节省大多数人的时间，将人快速送达指定地点。</p>
</li>
<li><p><strong>功能二</strong>：       平时，由于工作人员多工作于很高的楼层，而此时的电梯可能处于一楼，所以可以先向控制中心发送一条短信来获取电梯的实际位置，如果电梯此时距离自己所在的楼层还有一段距离，就可以提前向控制中心发送一条请求短信，这时控制中心会向电梯应用端发送请求信号，命令电梯开往指定的楼层，从而减少等待的时间。</p>
</li>
</ul>
<hr>
<h4 id="具体操作"><a href="#具体操作" class="headerlink" title="具体操作"></a>具体操作</h4><p>只需要编辑短信XY#到指定的电话号码就可以远程控制电梯的运行。其中X代表发信人所在楼层，Y代表发信人将要到达的楼层。电梯也会对发信人的要求进行应答，告诉电梯当前的运行情况，好让发信人掌握好乘坐电梯的时间。</p>
<hr>
<h4 id="GPRS的使用"><a href="#GPRS的使用" class="headerlink" title="GPRS的使用"></a>GPRS的使用</h4><p> 我们主要用到了有方GPRS模块的短信收发功能。主要用于在上下班高峰时帮助员工获得电梯状态信息、向电梯发送停靠指令。命令电梯开往指定的楼层，从而减少等待的时间。电梯应用端使用有方GPRSM660+模块来接收来自控制中心的信号并发送短信作为应答，从而实现用户与电梯的交互通信。</p>
<hr>
<h4 id="硬件电路图"><a href="#硬件电路图" class="headerlink" title="硬件电路图"></a>硬件电路图</h4><p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20150522/20150522_fig001.jpg" width="600" height="450" title="图1" alt="图1" ></p>
<hr>
<h4 id="作品展示"><a href="#作品展示" class="headerlink" title="作品展示"></a>作品展示</h4><p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20150522/20150522_fig002.jpg" width="600" height="450" title="图2" alt="图2" ></p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20150522/20150522_fig003.jpg" width="600" height="450" title="图3" alt="图3" ></p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20150522/20150522_fig004.jpg" width="600" height="450" title="图4" alt="图4" ></p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20150522/20150522_fig005.jpg" width="600" height="450" title="图5" alt="图5" ></p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        单片机完整源代码:
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;REG52.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;STRING.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> uint unsigned int</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> uchar unsigned char</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FLOOR  10</span></span><br><span class="line"><span class="keyword">int</span> Con_Floor = <span class="number">1</span>;<span class="comment">//当前的楼层号</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> com_dat = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">int</span> flag2 = <span class="number">0</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> low = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">int</span> high = <span class="number">9</span> ;</span><br><span class="line"><span class="keyword">int</span> sign_flag = <span class="number">0</span> ;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delayms</span><span class="params">(uint xms)</span></span>;                       <span class="comment">//延时函数（毫秒级）</span></span><br><span class="line"></span><br><span class="line"><span class="function">uint <span class="title">test</span><span class="params">(uchar * <span class="built_in">floor</span>)</span></span>;                     <span class="comment">//测试在几楼</span></span><br><span class="line"></span><br><span class="line"><span class="function">uint <span class="title">checkinfo</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">uchar <span class="title">ReceiveData</span><span class="params">(uchar* ,uchar*)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writefloor</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writestate</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">up_down_logic</span><span class="params">()</span></span>;                         <span class="comment">//电梯的运行逻辑</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">com_init</span><span class="params">(<span class="keyword">void</span>)</span></span>;                         <span class="comment">//串口初始化</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">send_uart</span><span class="params">(uchar ch)</span></span>;                    <span class="comment">//向串口发送单个字符</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">send_AT_IPR</span><span class="params">(<span class="keyword">void</span>)</span></span>;                        <span class="comment">//设置模块的波特率为9600bps</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">send_AT_CMGF</span><span class="params">(<span class="keyword">void</span>)</span></span>;                      <span class="comment">//设置发短信为文本模式</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">send_AT_CSCS</span><span class="params">(<span class="keyword">void</span>)</span></span>;                       <span class="comment">//发送TE的字符集为GSM</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">send_AT_CNMI</span><span class="params">(<span class="keyword">void</span>)</span></span>;                     <span class="comment">//设置短信的提示信息</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">send_AT_CMGR</span><span class="params">()</span></span>;                       <span class="comment">//发送读取命令</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">send_AT_CMGS</span><span class="params">(uchar *phone_num)</span></span>;         <span class="comment">//选择发送目的手机号</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">send_text</span><span class="params">(uchar *<span class="built_in">text</span>)</span></span>;            <span class="comment">//发送短信文本</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_GPRS</span><span class="params">(<span class="keyword">void</span>)</span></span>;                         <span class="comment">//初始化GPRS模块</span></span><br><span class="line"></span><br><span class="line">sbit dula=P2^<span class="number">6</span>;</span><br><span class="line">sbit wela=P2^<span class="number">7</span>;</span><br><span class="line">sbit rs=P3^<span class="number">5</span>;</span><br><span class="line">sbit lcden=P3^<span class="number">4</span>;</span><br><span class="line">sbit s1=P2^<span class="number">0</span>;</span><br><span class="line">sbit s2=P2^<span class="number">1</span>;</span><br><span class="line">sbit s3=P2^<span class="number">2</span>;</span><br><span class="line">sbit s4=P2^<span class="number">3</span>;</span><br><span class="line">sbit rd=P3^<span class="number">7</span>;</span><br><span class="line">sbit dscs=P1^<span class="number">4</span>;</span><br><span class="line">sbit dsas=P1^<span class="number">5</span>;</span><br><span class="line">sbit dsrw=P1^<span class="number">6</span>;</span><br><span class="line">sbit dsds=P1^<span class="number">7</span>;</span><br><span class="line">sbit dsirq=P3^<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">uchar count,s1num,flag,flag1;</span><br><span class="line">uchar miao,shi,fen;</span><br><span class="line">uchar code table[]=<span class="string">" 2012-10-15 MON"</span>;</span><br><span class="line">uchar code table1[]=<span class="string">"    00:00:00"</span>;</span><br><span class="line">uchar code <span class="built_in">floor</span>[]=<span class="string">"FLOOR: 1"</span>;</span><br><span class="line">uchar code state[]=<span class="string">"STATE: IDLE"</span>;</span><br><span class="line">uchar code welcome[]=<span class="string">"WELCOME TO USE!"</span>;</span><br><span class="line"></span><br><span class="line">uchar code up[]=<span class="string">"UP  "</span>;</span><br><span class="line">uchar code down[]=<span class="string">"DOWN"</span>;</span><br><span class="line">uchar code idle[]=<span class="string">"IDLE"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write_date</span><span class="params">(uchar)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write_ds</span><span class="params">(uchar,uchar)</span></span>;</span><br><span class="line"><span class="function">uchar <span class="title">read_ds</span><span class="params">(uchar)</span></span>;                  <span class="comment">//从ds187读取时间</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">keyscan</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write_sfm</span><span class="params">(uchar add,uchar date)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">uchar code *AT_CMGF = <span class="string">"AT+CMGF=1"</span>;          <span class="comment">//发送AT+CMGF=1,设置文本模式</span></span><br><span class="line"></span><br><span class="line">uchar code *AT_CSCS = <span class="string">"AT+CSCS="</span>;              <span class="comment">//选择TE的字符集（默认是GSM），M580返回数据时缓冲数组是OK</span></span><br><span class="line"></span><br><span class="line">uchar code *AT_IPR = <span class="string">"AT+IPR=9600"</span>;            <span class="comment">//设置波特率为9600bps</span></span><br><span class="line"></span><br><span class="line">uchar code *AT_CNMI =<span class="string">"AT+CNMI=2,1,0,0,0"</span> ;  <span class="comment">//设置收到新短信存于SIM卡中并发CMTI通知</span></span><br><span class="line"></span><br><span class="line">uchar code *AT_CMGR=<span class="string">"AT+CMGR="</span>;             <span class="comment">//发送读取短信的命令</span></span><br><span class="line"></span><br><span class="line">uchar code *AT_CMGS=<span class="string">"AT+CMGS="</span>;</span><br><span class="line"></span><br><span class="line">uchar xdata <span class="built_in">buffer</span>[<span class="number">100</span>]=&#123;<span class="number">0</span>&#125;;                <span class="comment">//单片机用于接收短信的缓冲</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">uchar code tab[]=&#123;<span class="number">0xff</span>,<span class="number">0xfe</span>,<span class="number">0xfd</span>,<span class="number">0xfb</span>,<span class="number">0xf7</span>,<span class="number">0xef</span>,<span class="number">0xdf</span>,<span class="number">0xbf</span>,<span class="number">0x7f</span>&#125;;<span class="comment">//流水灯的状态</span></span><br><span class="line"></span><br><span class="line">uchar code message0[] = <span class="string">"Sorry ,it is busy now "</span>;</span><br><span class="line"></span><br><span class="line">uchar code message1[] = <span class="string">"Sorry , we can only reach to "</span>;<span class="comment">//指明可以到达的终点</span></span><br><span class="line"></span><br><span class="line">uchar code message2[] = <span class="string">"and now we are moving to "</span>;<span class="comment">//指明将要到达的楼层</span></span><br><span class="line"></span><br><span class="line">uchar code message3[] = <span class="string">"Ok , we have accepted your request !"</span>;<span class="comment">//接受请求后发送的消息</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**************************************************************\</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*名称：test(char* )</span></span><br><span class="line"><span class="comment">*功能：判断电梯的此刻状态</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">\**************************************************************/</span></span><br><span class="line"><span class="function">uint <span class="title">test</span><span class="params">(uchar * <span class="built_in">floor</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    uint i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt; FLOOR ; i++)<span class="comment">//从一楼开始判断</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">floor</span>[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i &lt; Con_Floor)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;<span class="comment">//表示电梯正在下降</span></span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//表示电梯正在上升</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;<span class="comment">//表示此时电梯为空</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**************************************************************\</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*名称：up_down_logic()</span></span><br><span class="line"><span class="comment">*功能:电梯的升降逻辑</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">\**************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">up_down_logic</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    uchar  floor_data [FLOOR]=&#123;<span class="number">0</span>&#125;;<span class="comment">//判断执行方向</span></span><br><span class="line">    uchar  buf[FLOOR]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    uchar  tel[<span class="number">13</span>] ;</span><br><span class="line">    uchar temp;</span><br><span class="line">    uint i=<span class="number">0</span>;</span><br><span class="line">    uchar temp1 ;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        miao=read_ds(<span class="number">0</span>);    <span class="comment">//没有响应时，时间可以正确的运行，但是一旦有请求，时间便会出现跳跃情况</span></span><br><span class="line">        fen=read_ds(<span class="number">2</span>);</span><br><span class="line">        shi=read_ds(<span class="number">4</span>);</span><br><span class="line">        write_sfm(<span class="number">10</span>,miao);</span><br><span class="line">        write_sfm(<span class="number">7</span>,fen);</span><br><span class="line">        write_sfm(<span class="number">4</span>,shi);</span><br><span class="line">        delayms(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(checkinfo())</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="comment">/*    i = 0;</span></span><br><span class="line"><span class="comment">            while(tel[i])</span></span><br><span class="line"><span class="comment">            &#123;</span></span><br><span class="line"><span class="comment">                tel[i] = 0 ;</span></span><br><span class="line"><span class="comment">                i++;</span></span><br><span class="line"><span class="comment">            &#125;*/</span></span><br><span class="line">            temp=ReceiveData(&amp;temp1,tel);<span class="comment">//temp 表示起点,temp1表示终点</span></span><br><span class="line">            </span><br><span class="line">            EA=<span class="number">0</span>;<span class="comment">//关中断</span></span><br><span class="line">            <span class="comment">//以下是将缓冲区清空</span></span><br><span class="line">            i=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(<span class="built_in">buffer</span>[i])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">buffer</span>[i]=<span class="number">0</span>;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            com_dat=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (test(floor_data)==<span class="number">1</span>&amp;&amp;temp-<span class="string">'0'</span>&gt;=<span class="number">1</span>&amp;&amp;Con_Floor&gt;=<span class="number">1</span>)<span class="comment">//在下降</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(temp -<span class="string">'0'</span> &lt; Con_Floor&amp;&amp;!floor_data[temp-<span class="string">'0'</span>])<span class="comment">//8点之前为上楼的高峰，所以下楼的请求（在7点半以前）不予响应,电梯直接到达一楼</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(temp1-<span class="string">'0'</span> &lt; temp - <span class="string">'0'</span> &amp;&amp; temp1 - <span class="string">'0'</span> &gt;= low&amp;&amp;(read_ds(<span class="number">4</span>)&gt;<span class="number">8</span>))<span class="comment">//希望到楼下去,即temp1 &lt; temp的且此时电梯所能到的最低点比temp1还小</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        floor_data[temp-<span class="string">'0'</span>]=<span class="number">1</span>;</span><br><span class="line">                        buf[temp-<span class="string">'0'</span>] = temp1-<span class="string">'0'</span>;</span><br><span class="line"></span><br><span class="line">                        send_AT_CMGS(tel);<span class="comment">//先发号码</span></span><br><span class="line">                        delayms(<span class="number">500</span>);</span><br><span class="line">                        send_text(message3);</span><br><span class="line">                        send_text(message2);</span><br><span class="line">                        send_uart(Con_Floor<span class="number">-1</span>+<span class="string">'0'</span>);</span><br><span class="line">                        delayms(<span class="number">10</span>);</span><br><span class="line">                        send_uart(<span class="number">0x1a</span>);</span><br><span class="line">                        delayms(<span class="number">10</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (temp1 - <span class="string">'0'</span> &lt; temp - <span class="string">'0'</span> &amp;&amp; temp1 - <span class="string">'0'</span> &lt; low &amp;&amp;(read_ds(<span class="number">4</span>)&gt;<span class="number">8</span>))<span class="comment">//希望到楼下去,即temp1 &lt; temp的且此时电梯所能到的最低点比temp1大</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">if</span> (buf[low]  &lt; low)<span class="comment">//如果在电梯所能到的最低点处就没有请求了或有向下的请求</span></span><br><span class="line">                        &#123;</span><br><span class="line">                            floor_data[temp-<span class="string">'0'</span>]=<span class="number">1</span>;</span><br><span class="line">                            buf[temp-<span class="string">'0'</span>] = temp1-<span class="string">'0'</span>;</span><br><span class="line"></span><br><span class="line">                            send_AT_CMGS(tel);<span class="comment">//先发号码</span></span><br><span class="line">                            delayms(<span class="number">500</span>);</span><br><span class="line">                            send_text(message3);</span><br><span class="line">                            send_text(message2);</span><br><span class="line">                            send_uart(Con_Floor<span class="number">-1</span>+<span class="string">'0'</span>);</span><br><span class="line">                            delayms(<span class="number">10</span>);</span><br><span class="line">                            send_uart(<span class="number">0x1a</span>);</span><br><span class="line">                            delayms(<span class="number">10</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                        &#123;</span><br><span class="line">                            send_AT_CMGS(tel);<span class="comment">//先发号码</span></span><br><span class="line">                            delayms(<span class="number">500</span>);</span><br><span class="line">                            send_text(message1);</span><br><span class="line">                            send_uart(low+<span class="string">'0'</span>);</span><br><span class="line">                            delayms(<span class="number">10</span>);</span><br><span class="line">                            send_text(message2);</span><br><span class="line">                            send_uart(Con_Floor<span class="number">-1</span>+<span class="string">'0'</span>);</span><br><span class="line">                            delayms(<span class="number">10</span>);</span><br><span class="line">                            send_uart(<span class="number">0x1a</span>);</span><br><span class="line">                            delayms(<span class="number">10</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(temp1 - <span class="string">'0'</span> &lt; temp - <span class="string">'0'</span> &amp;&amp; temp1 - <span class="string">'0'</span> &lt; low &amp;&amp;(read_ds(<span class="number">4</span>)&lt;<span class="number">8</span>))</span><br><span class="line">                    &#123;</span><br><span class="line">                            send_AT_CMGS(tel);<span class="comment">//先发号码</span></span><br><span class="line">                            delayms(<span class="number">500</span>);</span><br><span class="line">                            send_text(message0);</span><br><span class="line">                            send_uart(low+<span class="string">'0'</span>);</span><br><span class="line">                            delayms(<span class="number">10</span>);</span><br><span class="line">                            send_text(message2);</span><br><span class="line">                            send_uart(Con_Floor<span class="number">-1</span>+<span class="string">'0'</span>);</span><br><span class="line">                            delayms(<span class="number">10</span>);</span><br><span class="line">                            send_uart(<span class="number">0x1a</span>);</span><br><span class="line">                            delayms(<span class="number">10</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (temp1 - <span class="string">'0'</span> &gt; temp - <span class="string">'0'</span>&amp;&amp; temp - <span class="string">'0'</span> &lt; low)<span class="comment">//如果希望到楼上去,则仅当到最低点处没有请求或请求到达的地方小于temp后才可以</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">if</span> ((buf[low] == <span class="number">0</span>||(buf[low] &gt; temp - <span class="string">'0'</span> &amp;&amp; buf[low] &lt; low))&amp;&amp;(read_ds(<span class="number">4</span>)&lt;<span class="number">5</span>))<span class="comment">//确保电梯到low层后无请求或有向下的但大于temp的请求</span></span><br><span class="line">                        &#123;</span><br><span class="line">                            floor_data[temp - <span class="string">'0'</span>] = <span class="number">1</span> ;</span><br><span class="line">                            buf[temp - <span class="string">'0'</span>] = temp1 - <span class="string">'0'</span> ;</span><br><span class="line">                            high = temp1 - <span class="string">'0'</span> ;<span class="comment">//在电梯向上运行时所能到达的最高点</span></span><br><span class="line">                            low = temp - <span class="string">'0'</span> ;</span><br><span class="line"></span><br><span class="line">                            send_AT_CMGS(tel);<span class="comment">//先发号码</span></span><br><span class="line">                            delayms(<span class="number">500</span>);</span><br><span class="line">                            send_text(message3);</span><br><span class="line">                            send_text(message2);</span><br><span class="line">                            send_uart(Con_Floor+<span class="number">1</span>+<span class="string">'0'</span>);</span><br><span class="line">                            delayms(<span class="number">10</span>);</span><br><span class="line">                            send_uart(<span class="number">0x1a</span>);</span><br><span class="line">                            delayms(<span class="number">10</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span>(buf[low] &gt; low &amp;&amp;(read_ds(<span class="number">4</span>)&lt;<span class="number">5</span>))</span><br><span class="line">                        &#123;</span><br><span class="line">                            send_AT_CMGS(tel);<span class="comment">//先发号码</span></span><br><span class="line">                            delayms(<span class="number">500</span>);</span><br><span class="line">                            send_text(message1);</span><br><span class="line">                            send_uart(low+<span class="string">'0'</span>);</span><br><span class="line">                            delayms(<span class="number">10</span>);</span><br><span class="line">                            send_text(message2);</span><br><span class="line">                            send_uart(Con_Floor<span class="number">-1</span>+<span class="string">'0'</span>);</span><br><span class="line">                            delayms(<span class="number">10</span>);</span><br><span class="line">                            send_uart(<span class="number">0x1a</span>);</span><br><span class="line">                            delayms(<span class="number">10</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span>(buf[low] &lt; temp - <span class="string">'0'</span> &amp;&amp;(read_ds(<span class="number">4</span>)&lt;<span class="number">5</span>))</span><br><span class="line">                        &#123;</span><br><span class="line">                            send_AT_CMGS(tel);<span class="comment">//先发号码</span></span><br><span class="line">                            delayms(<span class="number">500</span>);</span><br><span class="line">                            send_text(message1);</span><br><span class="line">                            send_uart(buf[low]+<span class="string">'0'</span>);</span><br><span class="line">                            delayms(<span class="number">10</span>);</span><br><span class="line">                            send_text(message2);</span><br><span class="line">                            send_uart(Con_Floor<span class="number">-1</span>+<span class="string">'0'</span>);</span><br><span class="line">                            delayms(<span class="number">10</span>);</span><br><span class="line">                            send_uart(<span class="number">0x1a</span>);</span><br><span class="line">                            delayms(<span class="number">10</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span><span class="comment">//不响应会执行下面的语句</span></span><br><span class="line">                        &#123;</span><br><span class="line">                            send_AT_CMGS(tel);<span class="comment">//先发号码</span></span><br><span class="line">                            delayms(<span class="number">500</span>);</span><br><span class="line">                            send_text(message0);</span><br><span class="line">                            send_uart(buf[low]+<span class="string">'0'</span>);</span><br><span class="line">                            delayms(<span class="number">10</span>);</span><br><span class="line">                            send_text(message2);</span><br><span class="line">                            send_uart(Con_Floor+<span class="number">1</span>+<span class="string">'0'</span>);</span><br><span class="line">                            delayms(<span class="number">10</span>);</span><br><span class="line">                            send_uart(<span class="number">0x1a</span>);</span><br><span class="line">                            delayms(<span class="number">10</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!test(floor_data)&amp;&amp;temp-<span class="string">'0'</span>&gt;=<span class="number">1</span>&amp;&amp;Con_Floor&gt;=<span class="number">1</span>)<span class="comment">//在上升</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(temp-<span class="string">'0'</span> &gt; Con_Floor&amp;&amp;!floor_data[temp-<span class="string">'0'</span>])</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(temp1-<span class="string">'0'</span> &gt;  temp - <span class="string">'0'</span> &amp;&amp; temp1 - <span class="string">'0'</span> &lt;= high &amp;&amp;(read_ds(<span class="number">4</span>)&lt;<span class="number">5</span>))<span class="comment">//请求者希望到楼上去,且此时电梯所能到达的最高点比请求temp1还大</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        floor_data[temp-<span class="string">'0'</span>]=<span class="number">1</span>;</span><br><span class="line">                        buf[temp-<span class="string">'0'</span>] = temp1-<span class="string">'0'</span>;</span><br><span class="line"></span><br><span class="line">                        send_AT_CMGS(tel);<span class="comment">//先发号码</span></span><br><span class="line">                        delayms(<span class="number">500</span>);</span><br><span class="line">                        send_text(message3);</span><br><span class="line">                        send_text(message2);</span><br><span class="line">                        send_uart(Con_Floor+<span class="number">1</span>+<span class="string">'0'</span>);</span><br><span class="line">                        delayms(<span class="number">10</span>);</span><br><span class="line">                        send_uart(<span class="number">0x1a</span>);</span><br><span class="line">                        delayms(<span class="number">10</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (temp1 - <span class="string">'0'</span> &gt; temp - <span class="string">'0'</span> &amp;&amp; temp1 - <span class="string">'0'</span> &gt; high &amp;&amp;(read_ds(<span class="number">4</span>)&lt;<span class="number">5</span>))<span class="comment">//请求者希望到楼上去,且此时请求的目的地已经超过了电梯所能到达的最高点</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">if</span> (buf[high]  &gt; high || buf[high] == <span class="number">0</span>)<span class="comment">//如果电梯到了最高点处还有向上的请求或者到了最高点处就没有请求了</span></span><br><span class="line">                        &#123;</span><br><span class="line">                            floor_data[temp-<span class="string">'0'</span>]=<span class="number">1</span>;</span><br><span class="line">                            buf[temp-<span class="string">'0'</span>] = temp1-<span class="string">'0'</span>;</span><br><span class="line"></span><br><span class="line">                            send_AT_CMGS(tel);<span class="comment">//先发号码</span></span><br><span class="line">                            delayms(<span class="number">500</span>);</span><br><span class="line">                            send_text(message3);</span><br><span class="line">                            send_text(message2);</span><br><span class="line">                            send_uart(Con_Floor+<span class="number">1</span>+<span class="string">'0'</span>);</span><br><span class="line">                            delayms(<span class="number">10</span>);</span><br><span class="line">                            send_uart(<span class="number">0x1a</span>);</span><br><span class="line">                            delayms(<span class="number">10</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> (buf[high] &lt; high)</span><br><span class="line">                        &#123;</span><br><span class="line">                            send_AT_CMGS(tel);<span class="comment">//先发号码</span></span><br><span class="line">                            delayms(<span class="number">500</span>);</span><br><span class="line">                            send_text(message1);</span><br><span class="line">                            send_uart(high+<span class="string">'0'</span>);</span><br><span class="line">                            delayms(<span class="number">10</span>);</span><br><span class="line">                            send_text(message2);</span><br><span class="line">                            send_uart(Con_Floor+<span class="number">1</span>+<span class="string">'0'</span>);</span><br><span class="line">                            delayms(<span class="number">10</span>);</span><br><span class="line">                            send_uart(<span class="number">0x1a</span>);</span><br><span class="line">                            delayms(<span class="number">10</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(temp1 - <span class="string">'0'</span> &gt; temp - <span class="string">'0'</span> &amp;&amp; temp1 - <span class="string">'0'</span> &gt; high &amp;&amp;(read_ds(<span class="number">4</span>)&gt;<span class="number">5</span>))<span class="comment">//不响应时执行</span></span><br><span class="line">                    &#123;</span><br><span class="line">                            send_AT_CMGS(tel);<span class="comment">//先发号码</span></span><br><span class="line">                            delayms(<span class="number">500</span>);</span><br><span class="line">                            send_text(message0);</span><br><span class="line">                            send_uart(buf[low]+<span class="string">'0'</span>);</span><br><span class="line">                            delayms(<span class="number">10</span>);</span><br><span class="line">                            send_text(message2);</span><br><span class="line">                            send_uart(Con_Floor+<span class="number">1</span>+<span class="string">'0'</span>);</span><br><span class="line">                            delayms(<span class="number">10</span>);</span><br><span class="line">                            send_uart(<span class="number">0x1a</span>);</span><br><span class="line">                            delayms(<span class="number">10</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (temp1 - <span class="string">'0'</span> &lt; temp - <span class="string">'0'</span> &amp;&amp; temp - <span class="string">'0'</span> &gt; high )<span class="comment">//请求者希望到楼下去</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">if</span> ((buf[high] == <span class="number">0</span>||(buf[high] &lt; temp - <span class="string">'0'</span>&amp;&amp;buf[high] &gt; high))&amp;&amp;(read_ds(<span class="number">4</span>)&gt;<span class="number">8</span>))<span class="comment">//要确保电梯到达high层后没有请求或有向上的小于temp的请求</span></span><br><span class="line">                        &#123;</span><br><span class="line">                            floor_data[temp - <span class="string">'0'</span>] = <span class="number">1</span> ;</span><br><span class="line">                            buf[temp-<span class="string">'0'</span>] = temp1 - <span class="string">'0'</span>;</span><br><span class="line">                            low = temp1 - <span class="string">'0'</span>;</span><br><span class="line">                            high = temp - <span class="string">'0'</span>;</span><br><span class="line"></span><br><span class="line">                            send_AT_CMGS(tel);<span class="comment">//先发号码</span></span><br><span class="line">                            delayms(<span class="number">500</span>);</span><br><span class="line">                            send_text(message3);</span><br><span class="line">                            send_text(message2);</span><br><span class="line">                            send_uart(Con_Floor+<span class="number">1</span>+<span class="string">'0'</span>);</span><br><span class="line">                            delayms(<span class="number">10</span>);</span><br><span class="line">                            send_uart(<span class="number">0x1a</span>);</span><br><span class="line">                            delayms(<span class="number">10</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> (buf[high] &lt; high &amp;&amp;(read_ds(<span class="number">4</span>)&gt;<span class="number">8</span>))</span><br><span class="line">                        &#123;</span><br><span class="line">                            send_AT_CMGS(tel);<span class="comment">//先发号码</span></span><br><span class="line">                            delayms(<span class="number">500</span>);</span><br><span class="line">                            send_text(message1);</span><br><span class="line">                            send_uart(high+<span class="string">'0'</span>);</span><br><span class="line">                            delayms(<span class="number">10</span>);</span><br><span class="line">                            send_text(message2);</span><br><span class="line">                            send_uart(Con_Floor+<span class="number">1</span>+<span class="string">'0'</span>);</span><br><span class="line">                            delayms(<span class="number">10</span>);</span><br><span class="line">                            send_uart(<span class="number">0x1a</span>);</span><br><span class="line">                            delayms(<span class="number">10</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> (buf[high] &gt; temp - <span class="string">'0'</span>&amp;&amp;(read_ds(<span class="number">4</span>)&gt;<span class="number">8</span>))</span><br><span class="line">                        &#123;</span><br><span class="line">                            send_AT_CMGS(tel);<span class="comment">//先发号码</span></span><br><span class="line">                            delayms(<span class="number">500</span>);</span><br><span class="line">                            send_text(message1);</span><br><span class="line">                            send_uart(buf[high]+<span class="string">'0'</span>);</span><br><span class="line">                            delayms(<span class="number">10</span>);</span><br><span class="line">                            send_text(message2);</span><br><span class="line">                            send_uart(Con_Floor+<span class="number">1</span>+<span class="string">'0'</span>);</span><br><span class="line">                            delayms(<span class="number">10</span>);</span><br><span class="line">                            send_uart(<span class="number">0x1a</span>);</span><br><span class="line">                            delayms(<span class="number">10</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                        &#123;</span><br><span class="line">                            send_AT_CMGS(tel);<span class="comment">//先发号码</span></span><br><span class="line">                            delayms(<span class="number">500</span>);</span><br><span class="line">                            send_text(message0);</span><br><span class="line">                            send_uart(low+<span class="string">'0'</span>);</span><br><span class="line">                            delayms(<span class="number">10</span>);</span><br><span class="line">                            send_text(message2);</span><br><span class="line">                            send_uart(Con_Floor<span class="number">-1</span>+<span class="string">'0'</span>);</span><br><span class="line">                            delayms(<span class="number">10</span>);</span><br><span class="line">                            send_uart(<span class="number">0x1a</span>);</span><br><span class="line">                            delayms(<span class="number">10</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (test(floor_data)==<span class="number">2</span>&amp;&amp;temp-<span class="string">'0'</span>!=Con_Floor&amp;&amp;temp-<span class="string">'0'</span>&gt;=<span class="number">1</span>&amp;&amp;Con_Floor&gt;=<span class="number">1</span>)<span class="comment">//电梯未被请求,则响应,但是请求的楼层数就是本层楼则不予响应</span></span><br><span class="line">            &#123;</span><br><span class="line">                    </span><br><span class="line">                <span class="keyword">if</span> (temp - <span class="string">'0'</span> &gt; temp1 - <span class="string">'0'</span>&amp;&amp;(read_ds(<span class="number">4</span>)&gt;<span class="number">8</span>))</span><br><span class="line">                &#123;</span><br><span class="line">                    low = temp1 - <span class="string">'0'</span>;</span><br><span class="line">                    buf[temp - <span class="string">'0'</span>] = temp1 - <span class="string">'0'</span>;</span><br><span class="line">                    floor_data[temp-<span class="string">'0'</span>]=<span class="number">1</span>;</span><br><span class="line">                    send_AT_CMGS(tel);<span class="comment">//先发号码</span></span><br><span class="line">                    delayms(<span class="number">500</span>);</span><br><span class="line">                    send_text(message3);</span><br><span class="line">                    send_text(message2);</span><br><span class="line">                    <span class="keyword">if</span>(temp-<span class="string">'0'</span>&gt;Con_Floor)</span><br><span class="line">                        send_uart(Con_Floor+<span class="number">1</span>+<span class="string">'0'</span>);</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        send_uart(Con_Floor<span class="number">-1</span>+<span class="string">'0'</span>);</span><br><span class="line">                    delayms(<span class="number">10</span>);</span><br><span class="line">                    send_uart(<span class="number">0x1a</span>);</span><br><span class="line">                    delayms(<span class="number">10</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(temp - <span class="string">'0'</span> &gt; temp1 - <span class="string">'0'</span>&amp;&amp;(read_ds(<span class="number">4</span>)&lt;<span class="number">8</span>))</span><br><span class="line">                &#123;</span><br><span class="line">                    send_AT_CMGS(tel);<span class="comment">//先发号码</span></span><br><span class="line">                    delayms(<span class="number">500</span>);</span><br><span class="line">                    send_text(message0);</span><br><span class="line">                    send_uart(low+<span class="string">'0'</span>);</span><br><span class="line">                    delayms(<span class="number">10</span>);</span><br><span class="line">                    send_text(message2);</span><br><span class="line">                    send_uart(Con_Floor+<span class="string">'0'</span>);</span><br><span class="line">                    delayms(<span class="number">10</span>);</span><br><span class="line">                    send_uart(<span class="number">0x1a</span>);</span><br><span class="line">                    delayms(<span class="number">10</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(temp - <span class="string">'0'</span> &lt; temp1 - <span class="string">'0'</span>&amp;&amp;(read_ds(<span class="number">4</span>)&lt;<span class="number">5</span>))</span><br><span class="line">                &#123;</span><br><span class="line">                    high = temp1 - <span class="string">'0'</span>;</span><br><span class="line">                    buf[temp - <span class="string">'0'</span>] = temp1 - <span class="string">'0'</span> ;</span><br><span class="line">                    send_AT_CMGS(tel);<span class="comment">//先发号码</span></span><br><span class="line">                    floor_data[temp-<span class="string">'0'</span>]=<span class="number">1</span>;</span><br><span class="line">                    delayms(<span class="number">500</span>);</span><br><span class="line">                    send_text(message3);</span><br><span class="line">                    send_text(message2);</span><br><span class="line">                    <span class="keyword">if</span>(temp-<span class="string">'0'</span> &gt; Con_Floor)</span><br><span class="line">                        send_uart(Con_Floor+<span class="number">1</span>+<span class="string">'0'</span>);</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        send_uart(Con_Floor<span class="number">-1</span>+<span class="string">'0'</span>);</span><br><span class="line">                    delayms(<span class="number">10</span>);</span><br><span class="line">                    send_uart(<span class="number">0x1a</span>);</span><br><span class="line">                    delayms(<span class="number">10</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(temp - <span class="string">'0'</span> &lt; temp1 - <span class="string">'0'</span>&amp;&amp;(read_ds(<span class="number">4</span>)&gt;<span class="number">5</span>))<span class="comment">//不响应时执行</span></span><br><span class="line">                &#123;</span><br><span class="line">                    send_AT_CMGS(tel);<span class="comment">//先发号码</span></span><br><span class="line">                    delayms(<span class="number">500</span>);</span><br><span class="line">                    send_text(message0);</span><br><span class="line">                    send_uart(buf[low]+<span class="string">'0'</span>);</span><br><span class="line">                    delayms(<span class="number">10</span>);</span><br><span class="line">                    send_text(message2);</span><br><span class="line">                    send_uart(Con_Floor+<span class="number">1</span>+<span class="string">'0'</span>);</span><br><span class="line">                    delayms(<span class="number">10</span>);</span><br><span class="line">                    send_uart(<span class="number">0x1a</span>);</span><br><span class="line">                    delayms(<span class="number">10</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(test(floor_data)==<span class="number">1</span>)<span class="comment">//下降</span></span><br><span class="line">        &#123;</span><br><span class="line">            writefloor(Con_Floor);</span><br><span class="line">            writestate(<span class="number">1</span>);</span><br><span class="line">            delayms(<span class="number">3000</span>);</span><br><span class="line">            Con_Floor--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!test(floor_data))<span class="comment">//上升</span></span><br><span class="line">        &#123;</span><br><span class="line">            writefloor(Con_Floor);</span><br><span class="line">            writestate(<span class="number">0</span>);</span><br><span class="line">            delayms(<span class="number">3000</span>);</span><br><span class="line">            Con_Floor++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (test(floor_data) == <span class="number">2</span>)<span class="comment">//处于空闲状态</span></span><br><span class="line">        &#123;</span><br><span class="line">            writefloor(Con_Floor);</span><br><span class="line">            writestate(<span class="number">2</span>);</span><br><span class="line">            high = <span class="number">9</span>;</span><br><span class="line">            low = <span class="number">1</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(floor_data[Con_Floor])<span class="comment">//如果之前被请求过，则响应</span></span><br><span class="line">        &#123;</span><br><span class="line">            P1=tab[Con_Floor];</span><br><span class="line">            delayms(<span class="number">3000</span>);</span><br><span class="line">            <span class="keyword">if</span> (buf[Con_Floor]!=<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                floor_data[buf[Con_Floor]] = <span class="number">1</span> ;</span><br><span class="line">                buf[Con_Floor] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            P1=<span class="number">0xff</span>;</span><br><span class="line">            floor_data[Con_Floor] = <span class="number">0</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        EA = <span class="number">1</span> ;<span class="comment">//开中断</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delay</span><span class="params">(uint z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    uint x,y;</span><br><span class="line">    <span class="keyword">for</span>(x=z;x&gt;<span class="number">0</span>;x--)</span><br><span class="line">        <span class="keyword">for</span>(y=<span class="number">110</span>;y&gt;<span class="number">0</span>;y--);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write_com</span><span class="params">(uchar com)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    rs=<span class="number">0</span>;</span><br><span class="line">    lcden=<span class="number">0</span>;</span><br><span class="line">    P0=com;</span><br><span class="line">    <span class="built_in">delay</span>(<span class="number">5</span>);</span><br><span class="line">    lcden=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">delay</span>(<span class="number">5</span>);</span><br><span class="line">    lcden=<span class="number">0</span>;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write_date</span><span class="params">(uchar date)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    rs=<span class="number">1</span>;</span><br><span class="line">    lcden=<span class="number">0</span>;</span><br><span class="line">    P0=date;</span><br><span class="line">    <span class="built_in">delay</span>(<span class="number">5</span>);</span><br><span class="line">    lcden=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">delay</span>(<span class="number">5</span>);</span><br><span class="line">    lcden=<span class="number">0</span>;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    uchar num;</span><br><span class="line">    EA=<span class="number">1</span>;</span><br><span class="line">    EX0=<span class="number">1</span>;</span><br><span class="line">    IT0=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    dula=<span class="number">0</span>;</span><br><span class="line">    wela=<span class="number">0</span>;</span><br><span class="line">    lcden=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    write_ds(<span class="number">0x0B</span>,<span class="number">0x26</span>);</span><br><span class="line">    read_ds(<span class="number">0x0c</span>);</span><br><span class="line">    write_com(<span class="number">0x38</span>);</span><br><span class="line">    write_com(<span class="number">0x0c</span>);</span><br><span class="line">    write_com(<span class="number">0x06</span>);</span><br><span class="line">    write_com(<span class="number">0x01</span>);</span><br><span class="line">    write_com(<span class="number">0x80</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">for</span>(num=<span class="number">0</span>;num&lt;<span class="number">15</span>;num++)</span><br><span class="line">        &#123;</span><br><span class="line">            write_date(table[num]);</span><br><span class="line">            <span class="built_in">delay</span>(<span class="number">5</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    write_com(<span class="number">0x80</span>+<span class="number">0x40</span>);</span><br><span class="line">    <span class="keyword">for</span>(num=<span class="number">0</span>;num&lt;<span class="number">12</span>;num++)</span><br><span class="line">        &#123;</span><br><span class="line">            write_date(table1[num]);</span><br><span class="line">            <span class="built_in">delay</span>(<span class="number">5</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    miao=read_ds(<span class="number">0</span>);    </span><br><span class="line">    fen=read_ds(<span class="number">2</span>);</span><br><span class="line">    shi=read_ds(<span class="number">4</span>);</span><br><span class="line">    write_sfm(<span class="number">10</span>,miao);</span><br><span class="line">    write_sfm(<span class="number">7</span>,fen);</span><br><span class="line">    write_sfm(<span class="number">4</span>,shi);</span><br><span class="line">    delayms(<span class="number">5000</span>);</span><br><span class="line">    write_com(<span class="number">0x80</span>);</span><br><span class="line">    write_com(<span class="number">0x01</span>);</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(num=<span class="number">0</span>;num&lt;<span class="number">15</span>;num++)</span><br><span class="line">    &#123;</span><br><span class="line">        write_date(welcome[num]);</span><br><span class="line">        <span class="built_in">delay</span>(<span class="number">20</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">delay</span>(<span class="number">3000</span>);</span><br><span class="line">    write_com(<span class="number">0x01</span>);</span><br><span class="line"></span><br><span class="line">    write_com(<span class="number">0x80</span>+<span class="number">0x10</span>);</span><br><span class="line">    <span class="keyword">for</span>(num=<span class="number">0</span>;num&lt;<span class="number">8</span>;num++)</span><br><span class="line">    &#123;</span><br><span class="line">        write_date(<span class="built_in">floor</span>[num]);</span><br><span class="line">        <span class="built_in">delay</span>(<span class="number">20</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    write_com(<span class="number">0x80</span>+<span class="number">0x50</span>);</span><br><span class="line">    <span class="keyword">for</span>(num=<span class="number">0</span>;num&lt;<span class="number">11</span>;num++)</span><br><span class="line">    &#123;</span><br><span class="line">        write_date(state[num]);</span><br><span class="line">        <span class="built_in">delay</span>(<span class="number">20</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(num=<span class="number">0</span>;num&lt;<span class="number">16</span>;num++)</span><br><span class="line">    &#123;</span><br><span class="line">        write_com(<span class="number">0x18</span>);</span><br><span class="line">        <span class="built_in">delay</span>(<span class="number">50</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writefloor</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    write_com(<span class="number">0x80</span>+<span class="number">0x17</span>);</span><br><span class="line">     write_date(<span class="number">0x30</span>+i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writestate</span><span class="params">(<span class="keyword">int</span> flaggg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    uint i ;</span><br><span class="line">    write_com(<span class="number">0x80</span>+<span class="number">0x57</span>);</span><br><span class="line">     </span><br><span class="line">     <span class="keyword">if</span>(flaggg==<span class="number">1</span>)</span><br><span class="line">     &#123;</span><br><span class="line">     <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="built_in">strlen</span>(down);i++)</span><br><span class="line">     &#123;</span><br><span class="line">         write_date(down[i]);</span><br><span class="line">     &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span>(flaggg==<span class="number">2</span>)</span><br><span class="line">     &#123;</span><br><span class="line">     <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="built_in">strlen</span>(idle);i++)</span><br><span class="line">     &#123;</span><br><span class="line">         write_date(idle[i]);</span><br><span class="line">     &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span>(flaggg==<span class="number">0</span>)</span><br><span class="line">     &#123;</span><br><span class="line">     <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="built_in">strlen</span>(up);i++)</span><br><span class="line">     &#123;</span><br><span class="line">         write_date(up[i]);</span><br><span class="line">     &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write_sfm</span><span class="params">(uchar add,uchar date)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    uchar shi,ge;</span><br><span class="line">    shi=date/<span class="number">10</span>;</span><br><span class="line">    ge=date%<span class="number">10</span>;</span><br><span class="line">    write_com(<span class="number">0x80</span>+<span class="number">0x40</span>+add);</span><br><span class="line">    write_date(<span class="number">0x30</span>+shi);</span><br><span class="line">    write_date(<span class="number">0x30</span>+ge);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">keyscan</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    rd=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(flag1==<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(s2==<span class="number">0</span>)</span><br><span class="line">        &#123;    </span><br><span class="line">            <span class="built_in">delay</span>(<span class="number">5</span>);</span><br><span class="line">            <span class="keyword">if</span>(s2==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">while</span>(!s2);</span><br><span class="line">                flag1=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">                 </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s3==<span class="number">0</span>)</span><br><span class="line">        &#123;    </span><br><span class="line">            <span class="built_in">delay</span>(<span class="number">5</span>);</span><br><span class="line">            <span class="keyword">if</span>(s3==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">while</span>(!s3);</span><br><span class="line">                flag1=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">                 </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(s4==<span class="number">0</span>)</span><br><span class="line">        &#123;    </span><br><span class="line">            <span class="built_in">delay</span>(<span class="number">5</span>);</span><br><span class="line">            <span class="keyword">if</span>(s4==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                flag1=<span class="number">0</span>;</span><br><span class="line">                miao=read_ds(<span class="number">0</span>);    </span><br><span class="line">                fen=read_ds(<span class="number">2</span>);</span><br><span class="line">                shi=read_ds(<span class="number">4</span>);</span><br><span class="line">                write_sfm(<span class="number">10</span>,miao);</span><br><span class="line">                write_sfm(<span class="number">7</span>,fen);</span><br><span class="line">                write_sfm(<span class="number">4</span>,shi);</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">                 </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(s1==<span class="number">0</span>)    </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">delay</span>(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">if</span>(s1==<span class="number">0</span>)</span><br><span class="line">        &#123;    s1num++;</span><br><span class="line">            flag=<span class="number">1</span>;</span><br><span class="line">            flag1=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(!s1);</span><br><span class="line">            <span class="keyword">if</span>(s1num==<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                TR0=<span class="number">0</span>;</span><br><span class="line">                write_com(<span class="number">0x80</span>+<span class="number">0x40</span>+<span class="number">10</span>);</span><br><span class="line">                write_com(<span class="number">0x0f</span>);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">            <span class="keyword">if</span>(s1num==<span class="number">2</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                write_com(<span class="number">0x80</span>+<span class="number">0x40</span>+<span class="number">7</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(s1num==<span class="number">3</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                write_com(<span class="number">0x80</span>+<span class="number">0x40</span>+<span class="number">4</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(s1num==<span class="number">4</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                s1num=<span class="number">0</span>;</span><br><span class="line">                write_com(<span class="number">0x0c</span>);</span><br><span class="line">                flag=<span class="number">0</span>;</span><br><span class="line">                write_ds(<span class="number">0</span>,miao);</span><br><span class="line">                write_ds(<span class="number">2</span>,fen);</span><br><span class="line">                write_ds(<span class="number">4</span>,shi);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">                </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s1num!=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s2==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">delay</span>(<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span>(s2==<span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">while</span>(!s2);</span><br><span class="line">                    <span class="keyword">if</span>(s1num==<span class="number">1</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        miao++;</span><br><span class="line">                        <span class="keyword">if</span>(miao==<span class="number">60</span>)</span><br><span class="line">                            miao=<span class="number">0</span>;</span><br><span class="line">                        write_sfm(<span class="number">10</span>,miao);</span><br><span class="line">                        write_com(<span class="number">0x80</span>+<span class="number">0x40</span>+<span class="number">10</span>);</span><br><span class="line">                        </span><br><span class="line">                        </span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(s1num==<span class="number">2</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        fen++;</span><br><span class="line">                        <span class="keyword">if</span>(fen==<span class="number">60</span>)</span><br><span class="line">                            fen=<span class="number">0</span>;</span><br><span class="line">                        write_sfm(<span class="number">7</span>,fen);</span><br><span class="line">                        write_com(<span class="number">0x80</span>+<span class="number">0x40</span>+<span class="number">7</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(s1num==<span class="number">3</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        shi++;</span><br><span class="line">                        <span class="keyword">if</span>(shi==<span class="number">24</span>)</span><br><span class="line">                            shi=<span class="number">0</span>;</span><br><span class="line">                        write_sfm(<span class="number">4</span>,shi);</span><br><span class="line">                        write_com(<span class="number">0x80</span>+<span class="number">0x40</span>+<span class="number">4</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(s3==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">delay</span>(<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span>(s3==<span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">while</span>(!s3);</span><br><span class="line">                    <span class="keyword">if</span>(s1num==<span class="number">1</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                    </span><br><span class="line">                        miao--;</span><br><span class="line">                        <span class="keyword">if</span>(miao==<span class="number">-1</span>)</span><br><span class="line">                            miao=<span class="number">59</span>;</span><br><span class="line">                        write_sfm(<span class="number">10</span>,miao);</span><br><span class="line">                        write_com(<span class="number">0x80</span>+<span class="number">0x40</span>+<span class="number">10</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(s1num==<span class="number">2</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        fen--;</span><br><span class="line">                        <span class="keyword">if</span>(fen==<span class="number">-1</span>)</span><br><span class="line">                            fen=<span class="number">59</span>;</span><br><span class="line">                        write_sfm(<span class="number">7</span>,fen);</span><br><span class="line">                        write_com(<span class="number">0x80</span>+<span class="number">0x40</span>+<span class="number">7</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(s1num==<span class="number">3</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        shi--;</span><br><span class="line">                        <span class="keyword">if</span>(shi==<span class="number">-1</span>)</span><br><span class="line">                            shi=<span class="number">23</span>;</span><br><span class="line">                        write_sfm(<span class="number">4</span>,shi);</span><br><span class="line">                        write_com(<span class="number">0x80</span>+<span class="number">0x40</span>+<span class="number">4</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write_ds</span><span class="params">(uchar add,uchar date)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dscs=<span class="number">0</span>;</span><br><span class="line">    dsas=<span class="number">1</span>;</span><br><span class="line">    dsds=<span class="number">1</span>;</span><br><span class="line">    dsrw=<span class="number">1</span>;</span><br><span class="line">    P0=add;</span><br><span class="line">    dsas=<span class="number">0</span>;</span><br><span class="line">    dsrw=<span class="number">0</span>;</span><br><span class="line">    P0=date;</span><br><span class="line">    dsrw=<span class="number">1</span>;</span><br><span class="line">    dsas=<span class="number">1</span>;</span><br><span class="line">    dscs=<span class="number">1</span>;                </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">uchar <span class="title">read_ds</span><span class="params">(uchar add)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     uchar ds_date;</span><br><span class="line">    dsas=<span class="number">1</span>;</span><br><span class="line">    dsds=<span class="number">1</span>;</span><br><span class="line">    dsrw=<span class="number">1</span>;</span><br><span class="line">    dscs=<span class="number">0</span>;</span><br><span class="line">    P0=add;</span><br><span class="line">    dsas=<span class="number">0</span>;</span><br><span class="line">    dsds=<span class="number">0</span>;</span><br><span class="line">    P0=<span class="number">0xff</span>;</span><br><span class="line">    ds_date=P0;</span><br><span class="line">    dsds=<span class="number">1</span>;</span><br><span class="line">    dsas=<span class="number">1</span>;</span><br><span class="line">    dscs=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> ds_date;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**************************************************************\</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* 名称: send_uart(unsigned char ch)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* 功能: 向串口发送一个字符</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* 输入: 无</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* 输出: 无</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">\**************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">send_uart</span><span class="params">(uchar ch)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">         SBUF = ch; </span><br><span class="line"></span><br><span class="line">         <span class="keyword">while</span>(<span class="number">0</span> == TI);<span class="comment">//当TI为1时跳出死循环(表明数据已从串口发出)，并进入中断处理程序，不过在中断处理程序中并不会对TI进行任何操作,转而执行下面的清0语句</span></span><br><span class="line"></span><br><span class="line">         TI = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;<span class="comment">/* end function send_uart */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**************************************************************\</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* 名称: send_AT_CMGS</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* 功能: 发送AT+CMGS=***********，选择目的手机号</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* 输入: 无</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* 输出: 无</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">\**************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">send_AT_CMGS</span><span class="params">(uchar *phone_num)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        uint i ;</span><br><span class="line">         <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(AT_CMGS); i++)</span><br><span class="line"></span><br><span class="line">         &#123;</span><br><span class="line"></span><br><span class="line">                   send_uart(AT_CMGS[i]);</span><br><span class="line">                   delayms(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">         &#125;</span><br><span class="line">         delayms(<span class="number">10</span>);</span><br><span class="line">         send_uart(<span class="number">0X22</span>); <span class="comment">//双引号</span></span><br><span class="line">         delayms(<span class="number">10</span>);</span><br><span class="line">         <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(phone_num)<span class="number">-1</span>; i++)</span><br><span class="line"></span><br><span class="line">         &#123;</span><br><span class="line">                </span><br><span class="line">                   send_uart(phone_num[i]);</span><br><span class="line"></span><br><span class="line">                   delayms(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">         &#125;</span><br><span class="line">         delayms(<span class="number">10</span>);</span><br><span class="line">         send_uart(<span class="number">0X22</span>);</span><br><span class="line">         delayms(<span class="number">10</span>);</span><br><span class="line">         send_uart(<span class="string">'\r'</span>); <span class="comment">//发送回车符号</span></span><br><span class="line">         delayms(<span class="number">10</span>);</span><br><span class="line">         send_uart(<span class="string">'\n'</span>);        <span class="comment">//发送换行符号</span></span><br><span class="line"></span><br><span class="line">         delayms(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">&#125;<span class="comment">/* end function send_AT_CMGS */</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"><span class="comment">/**************************************************************\</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* 名称: send_text</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* 功能: 发送短信内容</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* 输入: 无</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* 输出: 无</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">\**************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">send_text</span><span class="params">(uchar *<span class="built_in">text</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        uint i ;</span><br><span class="line">         <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(<span class="built_in">text</span>); i++)</span><br><span class="line"></span><br><span class="line">         &#123;</span><br><span class="line"></span><br><span class="line">                   send_uart(<span class="built_in">text</span>[i]);</span><br><span class="line"></span><br><span class="line">                   delayms(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">         &#125;</span><br><span class="line">         delayms(<span class="number">10</span>);</span><br><span class="line">      </span><br><span class="line">&#125;<span class="comment">/* end function send_text */</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**************************************************************\</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* 名称: send_AT_IPR</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* 功能: 设置模块波特率为9600bps</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* 输入: 无</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* 输出: 无</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">***************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">send_AT_IPR</span><span class="params">(<span class="keyword">void</span>)</span><span class="comment">//设置波特率9600</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        uint i;</span><br><span class="line">         <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(AT_IPR); i++)</span><br><span class="line"></span><br><span class="line">         &#123;</span><br><span class="line"></span><br><span class="line">                   send_uart(AT_IPR[i]);</span><br><span class="line">                   delayms(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">         &#125;</span><br><span class="line">         delayms(<span class="number">10</span>);</span><br><span class="line">         send_uart(<span class="string">'\r'</span>); <span class="comment">//发送回车符号</span></span><br><span class="line">         delayms(<span class="number">10</span>);</span><br><span class="line">         send_uart(<span class="string">'\n'</span>);</span><br><span class="line">         delayms(<span class="number">200</span>);     </span><br><span class="line"></span><br><span class="line">&#125;<span class="comment">/* end function send_AT_IPR */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*************************************************************\</span></span><br><span class="line"><span class="comment">*名称：send_AT_CNMI()</span></span><br><span class="line"><span class="comment">*功能：发送CNMI</span></span><br><span class="line"><span class="comment">\*************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">send_AT_CNMI</span><span class="params">(<span class="keyword">void</span>)</span><span class="comment">//设置短信提示方式</span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    uint i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(AT_CNMI) ; i++)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        send_uart(AT_CNMI[i]);</span><br><span class="line">        delayms(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    delayms(<span class="number">10</span>);</span><br><span class="line">    send_uart(<span class="string">'\r'</span>);</span><br><span class="line">    delayms(<span class="number">10</span>);</span><br><span class="line">    send_uart(<span class="string">'\n'</span>);</span><br><span class="line">    delayms(<span class="number">200</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*************************************************************\</span></span><br><span class="line"><span class="comment">*功能：发送读命令</span></span><br><span class="line"><span class="comment">\*************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">send_AT_CMGR</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    uint i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; <span class="built_in">strlen</span>(AT_CMGR) ; i++)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        send_uart(AT_CMGR[i]);</span><br><span class="line">        delayms(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    delayms(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**************************************************************\</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* 名称: send_AT_CMGF</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* 功能: 短信AT指令，发送AT+CMGF=1，设置文本模式</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* 输入: 无</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* 输出: 无</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">***************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">send_AT_CMGF</span><span class="params">(<span class="keyword">void</span>)</span><span class="comment">//设置短信的读模式</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        uint i ;</span><br><span class="line">         <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(AT_CMGF); i++)</span><br><span class="line"></span><br><span class="line">         &#123;</span><br><span class="line"></span><br><span class="line">                   send_uart(AT_CMGF[i]);</span><br><span class="line">                   delayms(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">         &#125;</span><br><span class="line">         delayms(<span class="number">10</span>);</span><br><span class="line">         send_uart(<span class="string">'\r'</span>); <span class="comment">//发送回车符号</span></span><br><span class="line">         delayms(<span class="number">10</span>);</span><br><span class="line">         send_uart(<span class="string">'\n'</span>);</span><br><span class="line"></span><br><span class="line">         delayms(<span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">&#125;<span class="comment">/* end function send_AT_CMGF */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**************************************************************\</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* 名称: send_AT_CSCS</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* 功能: 发送AT+CSCS="GSM"，选择TE的字符集</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* 输入: 无</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* 输出: 无</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">\**************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">send_AT_CSCS</span><span class="params">(<span class="keyword">void</span>)</span><span class="comment">//设置字符集为"GSM"</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        uint i ;</span><br><span class="line">         <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; <span class="built_in">strlen</span>(AT_CSCS); i++)</span><br><span class="line">         &#123;</span><br><span class="line"></span><br><span class="line">                   send_uart(AT_CSCS[i]);</span><br><span class="line">                   delayms(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">         &#125;</span><br><span class="line">         delayms(<span class="number">10</span>);</span><br><span class="line">         send_uart(<span class="number">0X22</span>); <span class="comment">//双引号</span></span><br><span class="line">         delayms(<span class="number">10</span>);</span><br><span class="line">         send_uart(<span class="string">'G'</span>);</span><br><span class="line">         delayms(<span class="number">10</span>);</span><br><span class="line">         send_uart(<span class="string">'S'</span>);</span><br><span class="line">         delayms(<span class="number">10</span>);</span><br><span class="line">         send_uart(<span class="string">'M'</span>);</span><br><span class="line">         delayms(<span class="number">10</span>);</span><br><span class="line">         send_uart(<span class="number">0X22</span>);</span><br><span class="line">         delayms(<span class="number">10</span>);</span><br><span class="line">         send_uart(<span class="string">'\r'</span>); <span class="comment">//发送回车符号</span></span><br><span class="line">         delayms(<span class="number">10</span>);</span><br><span class="line">         send_uart(<span class="string">'\n'</span>);</span><br><span class="line">         delayms(<span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">&#125;<span class="comment">/* end function send_AT_CSCS */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**************************************************************\</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 函数名及功能：delayms —— 延时函数（毫秒级),晶振频率为11.0592MHz        </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 入口参数：      欲延时毫秒数，必须为正整数                                  </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 出口参数：      无                                                               </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 备注：    此函数需要根据晶振频率修改j的初值                               </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">\**************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delayms</span><span class="params">(uint xms)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">         uint i,j;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">for</span>(i=xms;i&gt;<span class="number">0</span>;i--)</span><br><span class="line"></span><br><span class="line">                   <span class="keyword">for</span>(j=<span class="number">113</span>;j&gt;<span class="number">0</span>;j--);</span><br><span class="line"></span><br><span class="line">&#125;<span class="comment">/* end function delayms */</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="comment">/**************************************************************\</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* 名称: com_int()</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* 功能: 串口中断子函数</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* 输入: 无</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* 输出: 无</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">\**************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">com_int</span><span class="params">(<span class="keyword">void</span>)</span> interrupt 4</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        </span><br><span class="line">         EA=<span class="number">0</span>;                   <span class="comment">//关总中断</span></span><br><span class="line">         <span class="keyword">if</span>(<span class="number">1</span> == RI)  <span class="comment">//当硬件接收到一个数据时，RI会置高位</span></span><br><span class="line">         &#123;</span><br><span class="line">             </span><br><span class="line">                   <span class="built_in">buffer</span>[com_dat] = SBUF;        <span class="comment">//存取串口接收的数据</span></span><br><span class="line"></span><br><span class="line">                   RI = <span class="number">0</span>;        <span class="comment">//软件置RI为0</span></span><br><span class="line">                    </span><br><span class="line">                   <span class="keyword">if</span>(<span class="built_in">buffer</span>[com_dat]==<span class="string">'#'</span>)</span><br><span class="line">                   &#123;</span><br><span class="line">                           flag2 = <span class="number">1</span>; <span class="comment">//接收短信内容结束</span></span><br><span class="line">                        com_dat++;<span class="comment">//#号不一定是最后一个字符！！！</span></span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="keyword">else</span></span><br><span class="line">                   &#123;</span><br><span class="line">                           com_dat++;</span><br><span class="line">                   &#125;                 </span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         EA = <span class="number">1</span>;                 <span class="comment">//开总中断</span></span><br><span class="line"></span><br><span class="line">&#125;<span class="comment">/*  end function com_int */</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="comment">/**************************************************************\</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* 名称: com_init()</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* 功能: 串口初始化，晶振11.0592MHz,波特率9600bps</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* 输入: 无</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* 输出: 无</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">\**************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">com_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    TMOD=<span class="number">0X20</span>;</span><br><span class="line">    TH1=<span class="number">253</span>;</span><br><span class="line">    TL1=<span class="number">253</span>;</span><br><span class="line">    TR1=<span class="number">1</span>;</span><br><span class="line">    EA=<span class="number">1</span>;</span><br><span class="line">    ES=<span class="number">1</span>;</span><br><span class="line">    SM0=<span class="number">0</span>;</span><br><span class="line">    SM1=<span class="number">1</span>;</span><br><span class="line">    REN=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/************************************************************\</span></span><br><span class="line"><span class="comment">*名称：checkinfo()</span></span><br><span class="line"><span class="comment">*功能：检查是否有数据到达</span></span><br><span class="line"><span class="comment">\************************************************************/</span></span><br><span class="line"><span class="function">uint <span class="title">checkinfo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">    uint i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">buffer</span>[<span class="number">0</span>]!=<span class="number">0</span>&amp;&amp;flag2==<span class="number">0</span>)<span class="comment">//短信到达的提示命令已经被单片机接收</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">buffer</span>[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">buffer</span>[i]==<span class="string">','</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span> ;<span class="comment">//有短信到达</span></span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//数据暂时不能接收</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/************************************************************\</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*名称：ReceiveData()</span></span><br><span class="line"><span class="comment">*功能：接收数据并返回</span></span><br><span class="line"><span class="comment">\************************************************************/</span></span><br><span class="line"><span class="function">uchar <span class="title">ReceiveData</span><span class="params">(uchar *buf , uchar *buf2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//这是为了发送接收数据的命令</span></span><br><span class="line">    uint i=<span class="number">0</span>;</span><br><span class="line">    uint j ;</span><br><span class="line">    send_AT_CMGR();</span><br><span class="line">    delayms(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">buffer</span>[i] != <span class="string">','</span>)<span class="comment">//检查时顺便将buffer[i]清0</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">buffer</span>[i] = <span class="number">0</span> ;</span><br><span class="line">        i++ ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">buffer</span>[i] = <span class="number">0</span> ;<span class="comment">//将，清0</span></span><br><span class="line">    i++;</span><br><span class="line">    <span class="built_in">buffer</span>[i++]=<span class="number">0</span>;<span class="comment">//将空格清0</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">buffer</span>[i])</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">buffer</span>[i]&gt;=<span class="string">'0'</span>&amp;&amp;<span class="built_in">buffer</span>[i]&lt;=<span class="string">'9'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            send_uart(<span class="built_in">buffer</span>[i]);</span><br><span class="line">            <span class="built_in">buffer</span>[i]=<span class="number">0</span>;<span class="comment">//发完数据后将该位清0</span></span><br><span class="line">            delayms(<span class="number">10</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          <span class="keyword">break</span>;<span class="comment">//数据接收完后跳出</span></span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    delayms(<span class="number">10</span>);</span><br><span class="line">    send_uart(<span class="string">'\r'</span>);</span><br><span class="line">    delayms(<span class="number">10</span>);</span><br><span class="line">    send_uart(<span class="string">'\n'</span>);</span><br><span class="line">    delayms(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    com_dat = <span class="number">0</span> ;<span class="comment">//为下次接收数据做准备</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//这是为了检测需要的数据</span></span><br><span class="line">    delayms(<span class="number">3000</span>);</span><br><span class="line">    i = <span class="number">0</span> ;</span><br><span class="line">    j = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">buffer</span>[<span class="number">0</span>]!=<span class="number">0</span>&amp;&amp;flag2==<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            flag2=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(<span class="built_in">buffer</span>[i]!=<span class="string">'#'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">buffer</span>[i] == <span class="string">'\"'</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    sign_flag++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (sign_flag == <span class="number">3</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    buf2[j++]=<span class="built_in">buffer</span>[i+<span class="number">1</span>];<span class="comment">//接收电话号码</span></span><br><span class="line">                &#125;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            sign_flag = <span class="number">0</span>;</span><br><span class="line">            *buf = <span class="built_in">buffer</span>[i<span class="number">-1</span>];<span class="comment">//目的地点</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">buffer</span>[i<span class="number">-2</span>];<span class="comment">//模拟的楼层数不超过10楼,所以可只返回一个字符，起点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**************************************************************\</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*名称：init_GPRS()</span></span><br><span class="line"><span class="comment">*功能：初始化GPRS模块</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">\**************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_GPRS</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    uint i = <span class="number">0</span> ;</span><br><span class="line">    delayms(<span class="number">1000</span>);</span><br><span class="line">    send_AT_IPR();<span class="comment">//设置波特率</span></span><br><span class="line">    delayms(<span class="number">15000</span>);</span><br><span class="line">    send_AT_CMGF();<span class="comment">//设置短信格式</span></span><br><span class="line">    delayms(<span class="number">1000</span>);</span><br><span class="line">    send_AT_CSCS();<span class="comment">//设置字符集</span></span><br><span class="line">    delayms(<span class="number">1000</span>);</span><br><span class="line">    send_AT_CNMI();<span class="comment">//设置短信提示方式</span></span><br><span class="line">    delayms(<span class="number">3000</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">buffer</span>[i])<span class="comment">//将初始化时接收到的数据清0</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">buffer</span>[i] = <span class="number">0</span> ;</span><br><span class="line">        i++ ; </span><br><span class="line">    &#125;</span><br><span class="line">    com_dat = <span class="number">0</span> ;<span class="comment">//为下一次接收做准备</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">    init();<span class="comment">//初始化时钟芯片,液晶显示屏</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    delayms(<span class="number">20000</span>);<span class="comment">//避开开机时的无用数据</span></span><br><span class="line">    com_init();<span class="comment">//串口初始化</span></span><br><span class="line">    delayms(<span class="number">1500</span>);</span><br><span class="line">    init_GPRS();<span class="comment">//给gprs设置必要的参数</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        keyscan();<span class="comment">//只是在时间不准确时会被按下，其它时间，不予理会</span></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span>(flag==<span class="number">0</span>)<span class="comment">//表示没有键盘按下</span></span><br><span class="line">        &#123;</span><br><span class="line">            up_down_logic();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exter</span><span class="params">()</span> interrupt 0</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    uchar c;</span><br><span class="line">    flag1=<span class="number">1</span>;</span><br><span class="line">    c=read_ds(<span class="number">0x0c</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



    </div>
</div>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>Hardware Design</tag>
      </tags>
  </entry>
  <entry>
    <title>【概率统计】连续分布之间的关系</title>
    <url>/2015/05/19/%5B20150519%5D/</url>
    <content><![CDATA[<p>前面的文章《<a href="http://blog.csdn.net/tengweitw/article/details/45599011" target="_blank" rel="noopener">连续分布的产生</a>》中，我主要讲述了用均匀分布生成各种连续分布的方法，其中的特殊方法都是利用分布之间的关系来生成的。那么，<strong>本文主要介绍连续分布之间的一些关系</strong>。</p>
<a id="more"></a>
<hr>
<h4 id="伽马分布与泊松分布的关系"><a href="#伽马分布与泊松分布的关系" class="headerlink" title="伽马分布与泊松分布的关系"></a>伽马分布与泊松分布的关系</h4><p>假设$X \sim gamma( \alpha, \beta ), Y \sim Poisson( x/\beta )$，当$\alpha$是整数的时候，下面等式成立：</p>
<script type="math/tex; mode=display">
P( X \le x) = P( Y \ge \alpha)</script><hr>
<h4 id="伽马分布与卡方分布的关系"><a href="#伽马分布与卡方分布的关系" class="headerlink" title="伽马分布与卡方分布的关系"></a>伽马分布与卡方分布的关系</h4><p>服从形状参数为$\alpha$，尺度参数为$\beta$的伽马分布的概率密度函数pdf可以表示为：$f(x) = \frac{x^{( \alpha  - 1)}e^{( - x/\beta )}}{\Gamma( \alpha)\beta ^\alpha}$现在，我们假设$\alpha=p/2$，其中$p$是整数且$\beta=2$，那么此时的概率密度函数可以表示为：$f(x) = \frac{x^{( p/2 - 1 )}e^{( - x/2)}}{\Gamma ( p/2 )2^{p/2}},0 &lt; x &lt; \infty $显然，此时的概率密度函数$pdf$服从自由度为$p$的卡方分布的$pdf$。</p>
<hr>
<h4 id="伽马分布与指数分布的关系"><a href="#伽马分布与指数分布的关系" class="headerlink" title="伽马分布与指数分布的关系"></a>伽马分布与指数分布的关系</h4><p>当伽马分布中的形式参数$\alpha=1$时，概率密度函数变为：$f( x ) = \frac{e^{( - x/\beta  )}}{\beta },0 &lt; x &lt; \infty$显然，此时的概率密度函数就是参数为$\beta$的指数分布密度函数的$pdf$。</p>
<hr>
<h4 id="韦伯分布与指数分布、瑞利分布的关系"><a href="#韦伯分布与指数分布、瑞利分布的关系" class="headerlink" title="韦伯分布与指数分布、瑞利分布的关系"></a>韦伯分布与指数分布、瑞利分布的关系</h4><p>比例参数为$\lambda$，形状参数为$k$的韦伯分布的概率密度函数为：$f(x) = \frac{k}{\lambda }( \frac{x}{\lambda })^{k - 1}e^{ - {( x/\lambda )^k}},x \ge 0$当$\lambda=1$时，它是指数分布；当$\lambda=2$时，它是瑞利分布。</p>
<hr>
<h4 id="贝塔分布与均匀分布的关系"><a href="#贝塔分布与均匀分布的关系" class="headerlink" title="贝塔分布与均匀分布的关系"></a>贝塔分布与均匀分布的关系</h4><p>参数为$\alpha,\beta$的贝塔分布的概率密度函数为：$f( x ) = \frac{1}{B( \alpha ,\beta )}x^{\alpha  - 1}( 1 - x )^{\beta  - 1},0 &lt; x &lt; 1,\alpha  &gt; 0,\beta  &gt; 0,B( \alpha ,\beta) = \frac{\Gamma ( \alpha)\Gamma( \beta)}{\Gamma ( \alpha  + \beta )}$当$\alpha=\beta=1$时，此时退化成了区间在$0$到$1$的均匀分布。</p>
<hr>
<h4 id="正态分布与柯西分布的关系"><a href="#正态分布与柯西分布的关系" class="headerlink" title="正态分布与柯西分布的关系"></a>正态分布与柯西分布的关系</h4><p>位置参数为$x_0$，尺度参数为$\gamma$的柯西分布的概率密度函数为：$f( x ) = \frac{1}{\pi \gamma \left[ 1 + {( {\frac{x - {x_0}}\gamma })^2} \right]}$当$x_0=0,\gamma=1$时则是标准柯西分布。</p>
<ul>
<li><strong>关系</strong>：两个标准正态分布函数的比值服从标准柯西分布。</li>
</ul>
<hr>
<h4 id="其它关系式"><a href="#其它关系式" class="headerlink" title="其它关系式"></a>其它关系式</h4><p>假设$U_j$是独立同分布于区间$0$到$1$的均匀分布，由文章《<a href="http://blog.csdn.net/tengweitw/article/details/45599011" target="_blank" rel="noopener">连续分布的产生</a>》可以得到：$Y_i=-\lambda log(U_i)$是独立同分布于指数分布的随机变量。那么由指数分布与其它分布的关系推导得到如下的表达式：</p>
<script type="math/tex; mode=display">
\begin{array}{l}
Y =  - 2\sum\limits_{j = 1}^v \log (U_j)  \sim \chi _{2v}^2\\
Y =  - \beta \sum\limits_{j = 1}^\alpha  \log( U_j )  \sim gamma( {\alpha ,\beta })\\
Y = \frac{\sum\nolimits_{j = 1}^a {\log ( U_j)} }{\sum\nolimits_{j = 1}^{a + b} \log ( U_j )}  \sim beta( {a,b})
\end{array}</script><p>很显然，我们可以先通过均匀分布产生指数分布，然后利用指数分布与其它分布的关系来生成对应的分布。因此，知道分布之间的关系就很容易由已知的分布得到要求的分布。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>Probability Theory</tag>
      </tags>
  </entry>
  <entry>
    <title>【概率统计】离散分布之间的关系</title>
    <url>/2015/05/15/%5B20150515%5D/</url>
    <content><![CDATA[<p>前面文章《<a href="http://blog.csdn.net/tengweitw/article/details/45584597" target="_blank" rel="noopener">离散分布的产生</a>》中，主要讲述了如何通过均匀分布来产生各种离散分布。下面我给出一些离散分布之间的关系，从而可以由一种已知的分布来产生另一种分布。</p>
<a id="more"></a>
<hr>
<h2 id="伯努利分布、二项分布与多项分布"><a href="#伯努利分布、二项分布与多项分布" class="headerlink" title="伯努利分布、二项分布与多项分布"></a>伯努利分布、二项分布与多项分布</h2><hr>
<h4 id="伯努利分布"><a href="#伯努利分布" class="headerlink" title="伯努利分布"></a>伯努利分布</h4><p><strong>定义</strong>：一个离散随机变量$X$的取值仅为$0$和$1$，且其分布律$P(X = 1) = p, P(X = 0) = 1 - p$则此随机变量服从伯努利分布。</p>
<p>实例：抛硬币就是伯努利分布，伯努利分布产生的结果就是$1$或则$0$（正面或则反面）。</p>
<hr>
<h4 id="二项分布"><a href="#二项分布" class="headerlink" title="二项分布"></a>二项分布</h4><p> <strong>定义</strong>：设$B<em>1,B_2, \cdots ,B_n ( n \in N)$为相互独立的服从参数为$p (p \in [ 0,1 ])$的伯努利分布，定义随机变量：$X = \sum\nolimits</em>{i = 1}^n {B_i} $那么，随机变量$X$服从参数为$(n,p)$的二项分布。</p>
<p> <strong>实例</strong>：由定义可知，二项分布就是$n$重伯努利分布。形象的说，抛$n$次硬币，出现正面朝上的次数服从二项分布。</p>
<hr>
<h4 id="多项分布"><a href="#多项分布" class="headerlink" title="多项分布"></a>多项分布</h4><p> <strong>定义</strong>：设$m \in N,p<em>i\in [ 0,1] $，假设$( Y_1,Y_2, \cdots, Y_m)$是一个离散型$m$维随机变量。如果其联合分布律满足：对于$k_1, \cdots, k_m= 0,1,\cdots,n$，当其满足$\sum\nolimits</em>{i = 1}^m k_i = n $时，$ P( Y_1 = k_1, \cdots ,Y_m = k_m) = \frac{n!}{k_1! \cdots k_n!}p_1^{k_1} \cdots p_m^{k_m}$<br> 则称$m$维随机变量$( Y_1,Y_2, \cdots ,Y_m )$服从参数为$( n;p_1, \cdots, p_m)$的$m$项分布。</p>
<hr>
<h2 id="几何分布与负二项分布"><a href="#几何分布与负二项分布" class="headerlink" title="几何分布与负二项分布"></a>几何分布与负二项分布</h2><hr>
<h4 id="几何分布"><a href="#几何分布" class="headerlink" title="几何分布"></a>几何分布</h4><ul>
<li><p><strong>定义</strong>：设随机变量$Y$具有如下的分布律：$P( Y = k ) = ( 1 - p )^kp$,其中$p\in [ 0,1], k=0,1,\cdots$<br>则我们称$Y$服从几何分布。</p>
</li>
<li><p><strong>实例</strong>：几何分布的物理意义就是实验成功前所经历的失败次数。拿掷硬币来说，假设正面朝上视为成功，服从该几何分布的随机变量的物理意义就是不断掷硬币直到出现正面朝上前，出现反面朝上的次数，也即是失败的次数。</p>
</li>
<li><p><strong>重要性质</strong>：<strong>无记忆性</strong>,即对于整数$s &gt;t$，有下式成立：$P( X &gt; s| {X &gt; t} ) = P( X &gt; s - t)$</p>
</li>
</ul>
<hr>
<h4 id="负二项分布"><a href="#负二项分布" class="headerlink" title="负二项分布"></a>负二项分布</h4><ul>
<li><p><strong>定义</strong>：设$Y<em>1,Y_2, \cdots ,Y_m$是$m$个相互独立且服从相同的几何分布，那么，当随机变量$Z$满足下式：$$Z = \sum\nolimits</em>{i = 1}^m {Y_i} $$此时$Z$服从负二项分布，此时的分布律为：$P( Z = k ) = \frac{( k + m - 1)!}{( m - 1)!k!}{p^m}( 1 - p)^k,k=0,1,\cdots$</p>
</li>
<li><p><strong>实例</strong>：由定义可知，可以通过几何分布得到负二项分布。举例来说，若我们掷骰子，掷到$1$即视为成功。则每次掷骰的成功率是$1/6$。要掷出三次1，所需的掷骰次数属于集合${ 3,  4,  5,  6, \cdots }$。掷到三次$1$的掷骰次数即是服从负二项分布的随机变量。</p>
</li>
</ul>
<hr>
<h2 id="二项分布与泊松分布"><a href="#二项分布与泊松分布" class="headerlink" title="二项分布与泊松分布"></a>二项分布与泊松分布</h2><ul>
<li><p><strong>关系</strong>：对于参数为$(n,p)$的二项分布，如果参数$n$较大，$p$较小，那么我们可以用参数为$\lambda=np$的泊松分布来逼近。</p>
</li>
<li><p><strong>实例</strong>：一个盒子里有$144$个鸡蛋，假如每个鸡蛋破碎的概率都为$0.01$，请问恰好有$3$个鸡蛋破碎的概率是多少？</p>
<p> 显然，这是一个二项分布的问题。设随机变量$X$表示鸡蛋破碎的个数，那么$X$服从参数为$(n=144,p=0.01)$的二项分布。因此在这$144$个鸡蛋中恰好有$3$个鸡蛋破碎的概率为：$P( X = 3) = C_{144}^3{0.01^3}{0.99^{144 - 3}} = 0.1181$<br> 如果用泊松分布进行逼近的话，可知$X$服从参数为$\lambda=np$的泊松分布，则概率近似等于$P( {X = 3}) = \frac{1.44^3}{3!}{e^{ - 1.44}} = 0.1179$比较上面两种计算概率的方法，很明显第二种方法的计算量要小于第一种，因此当$n$较大，$p$较小时，我们常常用泊松分布来近似计算概率。</p>
</li>
</ul>
<hr>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>Probability Theory</tag>
      </tags>
  </entry>
  <entry>
    <title>【概率统计】离散分布的生成</title>
    <url>/2015/05/09/%5B20150509%5D/</url>
    <content><![CDATA[<p>本文讲解的不是离散分布的一些性质如：方差、期望和概率密度函数pdf(若为离散分布，则是概率质量函数pmf)等。<strong>本文要讲解的是如何通过均匀分布来产生其他各种分布的方法。</strong>尽管很多编程语言的函数库中包含了这些分布函数：</p>
<a id="more"></a>
<ul>
<li><p>在matlab中，我们可以看到关于这些函数的详细文档及使用方法：<br><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20150509/20150509_fig001.jpg" width="200" height="600" title="图1" alt="图1" ></p>
</li>
<li><p>在linux C中，GNU有一个名字叫GUN Scientific Library的库，里面有各种分布函数，比如说，高斯分布：<br><a href="http://www.gnu.org/software/gsl/manual/html_node/The-Gaussian-Distribution.html" target="_blank" rel="noopener">http://www.gnu.org/software/gsl/manual/html_node/The-Gaussian-Distribution.html</a></p>
</li>
<li><p>在标准C中，就只有仅仅的rand函数来产生均匀分布，那么这时候就需要使用均匀分布来产生其他分布了。</p>
</li>
</ul>
<p><strong>在下文中，我只是用比较通俗易懂的方式来说明用均匀分布来产生各种其他分布的过程，从而知道如何编程实现，具体原理的证明以及各种分布函数的性质就不具体展开</strong>。</p>
<hr>
<h2 id="离散分布"><a href="#离散分布" class="headerlink" title="离散分布"></a>离散分布</h2><p>离散分布主要有以下几种：<strong>均匀分布、超几何分布、二项分布、泊松分布、负二项分布、几何分布</strong></p>
<p><strong>基本原理：</strong><br>对于一个给定的离散分布，我们假设其分布如下：有$n$个离散的取值分别为${x<em>1},{x_2},\cdots ,{x_n}$，他们的概率分别为${P</em>}, {P<em>}, \cdots, {P</em>}$，并且有${P<em>} + {P</em>}+ \cdots  + {P_} = 1$，设该离散分布的分布函数为$F(x)$，那么，<strong>我们可以通过如下步骤来产生该离散分布：</strong></p>
<ol>
<li>产生区间在$[0, 1]$的均匀分布${U}$</li>
<li>当$F(x<em>i)&lt;U\le F(x</em>{i + 1})$时，令$X$=$x_{i+1}$,这时$X$的取值就服从上述给定的离散分布。</li>
</ol>
<p>上述理论很简单，<strong>不过为了更简单明了的说明上述原理步骤，下面通过举例来具体描述：</strong><br>假设离散分布如下：$x$的可能取值分别为$1,2,3$，对应的概率分别为$\frac{1}{4}$,$\frac{1}{4}$,$\frac{1}{2}$。那么其分布函数$F\left(  \right)$可以表示如下：</p>
<script type="math/tex; mode=display">F\left( x \right){\rm{ = }}\left\{ \begin{array}{l}
{\kern 1pt} 0{\kern 1pt} {\kern 1pt} {\kern 1pt} ,{\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} x < 1\\
\frac{1}{4},{\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} 1 \le x < 2\\
\frac{1}{2},{\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} 2 \le x < 3\\
{\kern 1pt} {\kern 1pt} 1{\kern 1pt} {\kern 1pt} ,{\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} x \ge 3
\end{array} \right.</script><p><strong>那么通过均匀分布产生上述离散分布的方法由步骤2可知如下式</strong>：</p>
<script type="math/tex; mode=display">X = \left\{ \begin{array}{l}
{\kern 1pt} x_{1} ,{\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} 0 < U \le F\left(  \right)\\
x_{2},{\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} F\left(  \right) < U \le F\left(  \right)\\
x_{3},{\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} F\left(  \right) < U \le F\left(  \right)
\end{array} \right.{\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {x_1} = 1,{x_2} = 2,{x_3} = 3</script><p>其中，由分布函数$F(x)$的表达式可知，$F\left(  \right) = \frac{1}{4},F\left(  \right) = \frac{1}{2},F\left(  \right) = 1$，带入到上式中可知，$x$取值分别为$1,2,3$时，对应的概率分别为$\frac{1}{4}$,$\frac{1}{4}$,$\frac{1}{2}$，即服从上面指定的离散分布。</p>
<p>从上面的方法可以看出，<strong>只要知道了离散随机变量在各个点的概率就可以使用该方法，通过均匀分布得到指定的分布了</strong>。而各个点的概率可以通过概率质量函数（pmf）得到。<strong>关于各种离散分布的pmf，我们可以在维基百科上得到</strong>。下面通过上面提到的方法，分别以二项分布、泊松分布为例进行Matlab编程实现：</p>
<hr>
<h2 id="二项分布"><a href="#二项分布" class="headerlink" title="二项分布"></a><strong>二项分布</strong></h2><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clear all</span><br><span class="line">close all</span><br><span class="line">clc</span><br><span class="line"></span><br><span class="line"><span class="comment">%二项分布</span></span><br><span class="line"><span class="comment">%参数：实验次数n，每次实验成功概率p</span></span><br><span class="line"><span class="comment">%mean=np ,  var=np(1-p)</span></span><br><span class="line">n=<span class="number">10</span>,p=<span class="number">0.5</span></span><br><span class="line"><span class="comment">%---------------由Matlab内置函数直接给出--------------%</span></span><br><span class="line"><span class="comment">%二项分布的产生，即n次实验成功的次数X,X&lt;=n</span></span><br><span class="line">X1= binornd(n,p);</span><br><span class="line"><span class="comment">%二项分布概率质量密度pmf</span></span><br><span class="line">x = <span class="number">0</span>:n;</span><br><span class="line">Py = binopdf(x,n,p);<span class="comment">%当取值分别为x的时候的概率</span></span><br><span class="line"><span class="built_in">plot</span>(x,Py,<span class="string">'r*'</span>)</span><br><span class="line"><span class="built_in">hold</span> on</span><br><span class="line"></span><br><span class="line"><span class="comment">%---------------由均匀分布U推导出--------------------%</span></span><br><span class="line">N=<span class="number">1000</span>;<span class="comment">%样本点数</span></span><br><span class="line">U=<span class="built_in">rand</span>(<span class="number">1</span>,N);<span class="comment">%U服从均匀分布</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">0</span>:n</span><br><span class="line">    P(<span class="built_in">i</span>+<span class="number">1</span>)=<span class="built_in">nchoosek</span>(n,<span class="built_in">i</span>)*p^<span class="built_in">i</span>*(<span class="number">1</span>-p)^(n-<span class="built_in">i</span>);<span class="comment">%不同的离散分布只需更改这里的计算公式来计算pmf</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">P=cumsum(P);<span class="comment">%得到累计分布函数cdf</span></span><br><span class="line"></span><br><span class="line">X2=U;</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:<span class="built_in">length</span>(X2)</span><br><span class="line">    X2(<span class="built_in">i</span>)=sum(X2(<span class="built_in">i</span>)&gt;P);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">%X2就是我们通过均匀分布得到的服从二项分布的变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%计算通过均匀分布得到的服从二项分布的pmf，从而与理论的pmf对比</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">0</span>:n</span><br><span class="line">     Y2(<span class="built_in">i</span>+<span class="number">1</span>)=sum(X2==<span class="built_in">i</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">plot</span>([<span class="number">0</span>:n],Y2/N,<span class="string">'bo'</span>)</span><br><span class="line">title(<span class="string">'二项分布的pmf'</span>)</span><br><span class="line"><span class="built_in">legend</span>(<span class="string">'自带函数产生'</span>,<span class="string">'均匀分布产生'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">%--------------------------------------------------------------------%</span></span><br></pre></td></tr></table></figure>
<p><strong>运行结果如下：</strong><br><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20150509/20150509_fig002.jpg" width="600" height="500" title="图1" alt="图1" ></p>
<hr>
<h2 id="泊松分布"><a href="#泊松分布" class="headerlink" title="泊松分布"></a>泊松分布</h2><p> 每个分布的实现大致相同，<strong>只需要更改计算pmf的公式即可！</strong>由于泊松分布在实际问题中非常常见，因此在此赘述。</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%泊松分布</span></span><br><span class="line"><span class="comment">%参数：到达率lambda</span></span><br><span class="line"><span class="comment">%mean=lamda,  var=lambda</span></span><br><span class="line">clear all</span><br><span class="line">close all</span><br><span class="line">clc</span><br><span class="line">lambda=<span class="number">1</span>;</span><br><span class="line">n=<span class="number">10</span>;<span class="comment">%x的取值为0到无穷大，这里只取前n个</span></span><br><span class="line"><span class="comment">%------------------------由内置函数直接给出---------------------%</span></span><br><span class="line"><span class="comment">%泊松分布的产生，即单位时间内事件发生的次数x,x取值为0到正无穷</span></span><br><span class="line">X=poissrnd(lambda,<span class="number">1</span>,<span class="number">10</span>);<span class="comment">%产生10个服从参数为lamda的泊松分布</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%泊松分布的cdf</span></span><br><span class="line">x=<span class="number">0</span>:n;</span><br><span class="line">Fx=poisscdf(x,lambda);</span><br><span class="line"><span class="comment">%figure</span></span><br><span class="line"><span class="comment">%plot(x,Fx,'r*')</span></span><br><span class="line"><span class="comment">%title('泊松分布的cdf')</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%泊松分布的pdf</span></span><br><span class="line">x=<span class="number">0</span>:n;</span><br><span class="line">Px=poisspdf(x,lambda);</span><br><span class="line"><span class="built_in">figure</span></span><br><span class="line"><span class="built_in">plot</span>(x,Px,<span class="string">'r*'</span>)</span><br><span class="line"><span class="built_in">hold</span> on</span><br><span class="line">title(<span class="string">'泊松分布的pmf'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">%-----------------------由均匀分布推导出-----------------------%</span></span><br><span class="line">N=<span class="number">1000</span>;<span class="comment">%样本点数</span></span><br><span class="line">U=<span class="built_in">rand</span>(<span class="number">1</span>,N);<span class="comment">%U服从均匀分布</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">0</span>:n</span><br><span class="line">    P(<span class="built_in">i</span>+<span class="number">1</span>)=<span class="built_in">exp</span>(-lambda)*lambda^<span class="built_in">i</span>/<span class="built_in">factorial</span>(<span class="built_in">i</span>);<span class="comment">%不同的离散分布只需更改这里的计算公式来计算pmf</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">P=cumsum(P);</span><br><span class="line"></span><br><span class="line">X2=U;</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:<span class="built_in">length</span>(X2)</span><br><span class="line">    X2(<span class="built_in">i</span>)=sum(X2(<span class="built_in">i</span>)&gt;P);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">%X2就是我们通过均匀分布得到的服从参数为lambda的泊松分布的变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%计算通过均匀分布得到的服从泊松分布的pmf，从而与理论的pmf对比</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">0</span>:n</span><br><span class="line">     Y2(<span class="built_in">i</span>+<span class="number">1</span>)=sum(X2==<span class="built_in">i</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">plot</span>([<span class="number">0</span>:n],Y2/N,<span class="string">'bo'</span>)</span><br><span class="line">title(<span class="string">'泊松分布的pmf'</span>)</span><br><span class="line"><span class="built_in">legend</span>(<span class="string">'自带函数产生'</span>,<span class="string">'均匀分布产生'</span>)</span><br></pre></td></tr></table></figure>
<p><strong>显示结果如下</strong>：（到达率$\lambda=1$时）</p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20150509/20150509_fig003.jpg" width="600" height="600" title="图3" alt="图3" ></p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>Probability Theory</tag>
      </tags>
  </entry>
  <entry>
    <title>【Matlab编程】哈夫曼编码的Matlab实现</title>
    <url>/2015/05/04/%5B20150504%5D/</url>
    <content><![CDATA[<p>在前年暑假的时候，用C实现了哈夫曼编译码的功能，见文章<a href="http://blog.csdn.net/tengweitw/article/details/9838343" target="_blank" rel="noopener">《哈夫曼树及编译码》</a>。不过在通信仿真中，经常要使用到Matlab编程，所以为了方便起见，这里用Matlab实现的哈夫曼编码的功能。至于哈夫曼编译码的基本原理，我们可以参考之前的文章<a href="http://blog.csdn.net/tengweitw/article/details/9838343" target="_blank" rel="noopener">《哈夫曼树及编译码》</a>，<strong>里面有详细的说明及图解过程</strong>。下面直接给出具体的Matlab实现的哈夫曼编码函数，由于程序中注释还算比较详细，在此就不予与说明：</p>
<a id="more"></a>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[ h,e ]</span> = <span class="title">Huffman_code</span><span class="params">( p )</span></span></span><br><span class="line"><span class="comment">%p为概率分布，此函数功能是进行哈夫曼编码</span></span><br><span class="line"><span class="comment">%   此处显示详细说明</span></span><br><span class="line"><span class="comment">% h为各个元素的麻子</span></span><br><span class="line"><span class="comment">% e为输出的平均码长</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">length</span>(<span class="built_in">find</span>(p&lt;<span class="number">0</span>))~=<span class="number">0</span></span><br><span class="line">    error(<span class="string">'概率不应该小于0！'</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> <span class="built_in">abs</span>(sum(p)<span class="number">-1</span>)&gt;<span class="number">10e-10</span></span><br><span class="line">    error(<span class="string">'概率之和大于1，请检查输入！'</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">n=<span class="built_in">length</span>(p);</span><br><span class="line"> </span><br><span class="line">p=<span class="built_in">sort</span>(p)</span><br><span class="line">q=p;</span><br><span class="line">m=<span class="built_in">zeros</span>(n<span class="number">-1</span>,n);</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:n<span class="number">-1</span></span><br><span class="line">    [q,e]=<span class="built_in">sort</span>(q); </span><br><span class="line">    m(<span class="built_in">i</span>,:)=[e(<span class="number">1</span>:n-<span class="built_in">i</span>+<span class="number">1</span>),<span class="built_in">zeros</span>(<span class="number">1</span>,<span class="built_in">i</span><span class="number">-1</span>)]; <span class="comment">%由数组l 构建一个矩阵，该矩阵表明概率合并时的顺序，用于后面的编码</span></span><br><span class="line">    q=[q(<span class="number">1</span>)+q(<span class="number">2</span>),q(<span class="number">3</span>:n),<span class="number">1</span>]; </span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:n<span class="number">-1</span></span><br><span class="line">    c(<span class="built_in">i</span>,<span class="number">1</span>:n*n)=blanks(n*n); <span class="comment">%c 矩阵用于进行huffman 编码</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">    c(n<span class="number">-1</span>,n)=<span class="string">'1'</span>; <span class="comment">%由于a 矩阵的第n-1 行的前两个元素为进行huffman 编码加和运算时所得的最后两个概率(在本例中为0.02、0.08)，因此其值为0 或1</span></span><br><span class="line">    c(n<span class="number">-1</span>,<span class="number">2</span>*n)=<span class="string">'0'</span>; </span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">2</span>:n<span class="number">-1</span></span><br><span class="line">    c(n-<span class="built_in">i</span>,<span class="number">1</span>:n<span class="number">-1</span>)=c(n-<span class="built_in">i</span>+<span class="number">1</span>,n*(<span class="built_in">find</span>(m(n-<span class="built_in">i</span>+<span class="number">1</span>,:)==<span class="number">1</span>))-(n<span class="number">-2</span>):n*(<span class="built_in">find</span>(m(n-<span class="built_in">i</span>+<span class="number">1</span>,:)==<span class="number">1</span>))); <span class="comment">%矩阵c 的第n-i 的第一个元素的n-1 的字符赋值为对应于a 矩阵中第n-i+1 行中值为1 的位置在c 矩阵中的编码值</span></span><br><span class="line">    c(n-<span class="built_in">i</span>,n)=<span class="string">'0'</span>; </span><br><span class="line">    c(n-<span class="built_in">i</span>,n+<span class="number">1</span>:<span class="number">2</span>*n<span class="number">-1</span>)=c(n-<span class="built_in">i</span>,<span class="number">1</span>:n<span class="number">-1</span>); <span class="comment">%矩阵c 的第n-i 的第二个元素的n-1 的字符与第n-i 行的第一个元素的前n-1 个符号相同，因为其根节点相同</span></span><br><span class="line">    c(n-<span class="built_in">i</span>,<span class="number">2</span>*n)=<span class="string">'1'</span>; </span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">j</span>=<span class="number">1</span>:<span class="built_in">i</span><span class="number">-1</span></span><br><span class="line">         c(n-<span class="built_in">i</span>,(<span class="built_in">j</span>+<span class="number">1</span>)*n+<span class="number">1</span>:(<span class="built_in">j</span>+<span class="number">2</span>)*n)=c(n-<span class="built_in">i</span>+<span class="number">1</span>,n*(<span class="built_in">find</span>(m(n-<span class="built_in">i</span>+<span class="number">1</span>,:)==<span class="built_in">j</span>+<span class="number">1</span>)<span class="number">-1</span>)+<span class="number">1</span>:n*<span class="built_in">find</span>(m(n-<span class="built_in">i</span>+<span class="number">1</span>,:)==<span class="built_in">j</span>+<span class="number">1</span>));</span><br><span class="line">            <span class="comment">%矩阵c 中第n-i 行第j+1 列的值等于对应于a 矩阵中第n-i+1 行中值为j+1 的前面一个元素的位置在c 矩阵中的编码值</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span> </span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:n</span><br><span class="line">    h(<span class="built_in">i</span>,<span class="number">1</span>:n)=c(<span class="number">1</span>,n*(<span class="built_in">find</span>(m(<span class="number">1</span>,:)==<span class="built_in">i</span>)<span class="number">-1</span>)+<span class="number">1</span>:<span class="built_in">find</span>(m(<span class="number">1</span>,:)==<span class="built_in">i</span>)*n); <span class="comment">%用h表示最后的huffman 编码</span></span><br><span class="line">    len(<span class="built_in">i</span>)=<span class="built_in">length</span>(<span class="built_in">find</span>(<span class="built_in">abs</span>(h(<span class="built_in">i</span>,:))~=<span class="number">32</span>)); <span class="comment">%计算每一个编码的长度</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">e=sum(p.*len); <span class="comment">%计算平均码长</span></span><br></pre></td></tr></table></figure>
<p><strong>在Matlab窗口中执行如下命令得到结果：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20150504/20150504_fig001.jpg" width="500" height="450" title="图1" alt="图1" ></p>
<p><strong>其中，p为权值，h表示和p中权值对应的编码，e代表平均码长。注意：哈夫曼编码的结果不唯一，它与左节点和右节点设置0 1 的方式有关。</strong></p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>Matlab Coding</tag>
      </tags>
  </entry>
  <entry>
    <title>【Qt编程】基于Qt的词典开发系列--界面美化设计</title>
    <url>/2015/04/23/%5B20150423%5D/</url>
    <content><![CDATA[<p>本文讲一讲界面设计，作品要面向用户，界面设计的好坏直接影响到用户的体验。现在的窗口设计基本都是扁平化的，你可以从window XP与window 8的窗口可以明显感觉出来。当然除了窗口本身的效果，窗口中各种控件的特效也是特别重要的一环。下面讲讲我在词典软件中的一些设计：说到界面美化的设计，不得不提到美工，一个好的美工是相当的重要！软件毕竟少不了图标，而不懂美工的我，也就只能在网上使用别人的图标了。</p>
<a id="more"></a>
<hr>
<h2 id="如何得到网上的图标？"><a href="#如何得到网上的图标？" class="headerlink" title="如何得到网上的图标？"></a>如何得到网上的图标？</h2><p>直接百度就可以了，当然还有另一种方法：就是从别人的文件中提取这些图标文件。一般来说，图标文件是不会以图片格式存储在软件目录中的，一般都存放在后缀名为.rdb以及.ui文件中。具体的步骤如下：</p>
<ul>
<li>找到要提取软件的安装目录</li>
<li>进行搜索：搜索.jpg、.png等图片格式文件（能够搜到最好了），然后搜索.rdb或.ui文件</li>
<li>下载RDB打包解包工具，进行解包，就可以得到图片资源了  </li>
</ul>
<hr>
<h2 id="控件间的无缝连接："><a href="#控件间的无缝连接：" class="headerlink" title="控件间的无缝连接："></a>控件间的无缝连接：</h2><p>所谓无缝连接是指控件与控件之间没有空隙，用Qt Creator打开界面文件，比如我打开这个词典项目，打开searchwindow.ui文件，控件是否有空隙的效果如下所示：</p>
<p>控件间的空隙大小可以由这些子控件所在父控件的Layout属性控制</p>
<p><strong>1、当Layout属性设置如下时：（有空隙的情况）</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20150423/20150423_fig001.jpg" width="400" height="180" title="图1" alt="图1" ></p>
<p>则控件间有空隙，显示效果如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20150423/20150423_fig002.jpg" width="600" height="500" title="图2" alt="图2" ></p>
<p><strong>2当Layout属性设置如下时：（没有空隙的情况）</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20150423/20150423_fig003.jpg" width="400" height="180" title="图3" alt="图3" ></p>
<p>则控件间无空隙，显示效果如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20150423/20150423_fig004.jpg" width="600" height="500" title="图4" alt="图4" ></p>
<hr>
<h2 id="按钮的美化"><a href="#按钮的美化" class="headerlink" title="按钮的美化"></a>按钮的美化</h2><p>现在按钮也开始扁平化，例如上图中的所有按钮都是扁平化的，两者的差别如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20150423/20150423_fig005.jpg" width="200" height="200" title="图5" alt="图5" ></p>
<p>显然第一种是常规的按钮，如果我们把ToolButton的autoRise属性书中，就会出现第二种情况，之所以没有使用QPushButton是因为它没有autoRaise属性。</p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20150423/20150423_fig006.jpg" width="400" height="120" title="图6" alt="图6" ></p>
<p>当选中autoRasie属性后，当鼠标放在该按钮上时效果如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20150423/20150423_fig007.jpg" width="200" height="100" title="图7" alt="图7" ></p>
<hr>
<h2 id="动态渲染效果"><a href="#动态渲染效果" class="headerlink" title="动态渲染效果"></a>动态渲染效果</h2><p>我们发现很多软件都有动态效果，如鼠标放在按钮上时，会发生变化，点击后又发生变化，这些是怎么做到的呢？Qt中美化界面最好的使用QML，不过由于刚出来不久，网上资料不是很多，我也不是很懂，就不介绍了。学习过网页制作的都知道，网页的渲染效果用到了css，与此类似，Qt使用qss来美化界面。下面介绍一种简单使用的方法来进行渲染操作：</p>
<p>右键单击界面中的控件，选择“更改样式表……”，然后在弹出的窗口中设置渲染效果，<strong>下面以单击按钮来举例说明：</strong></p>
<p>首先，右击关闭按钮，选择“更改样式表……”：</p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20150423/20150423_fig008.jpg" width="600" height="500" title="图8" alt="图8" ></p>
<p>然后在弹出的“编辑样式表”按钮中写入如下代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">QToolButton&#123;</span><br><span class="line">	</span><br><span class="line">	border-image: url(:/searchwindow/searchwindow/close_normal.png);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//上面的语句是给“关闭”按钮添加close_normal.png的图标，注意这里需要写你自己图片的路径</span></span><br><span class="line">QToolButton:hover&#123;</span><br><span class="line">	</span><br><span class="line">	border-image: url(:/searchwindow/searchwindow/close_hover.png);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这条语句的作用是，当鼠标放在“关闭”按钮上时，图标变成close_hover.png的图标，注意这里需要写你自己图片的路径</span></span><br></pre></td></tr></table></figure>
<p><strong>这两条语句实现的效果如下：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20150423/20150423_fig009.jpg" width="600" height="500" title="图9" alt="图9" ></p>
<p>一般情况下,关闭按钮显示如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20150423/20150423_fig010.jpg" width="50" height="50" title="图10" alt="图10" ></p>
<p>当鼠标放在上面时，效果如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20150423/20150423_fig011.jpg" width="50" height="50" title="图11" alt="图11" ></p>
<p>我在词典中所有的按钮几乎都是采用了这种效果，如果想使用更多的效果，可以百度qt setstylesheet，可以看到更多的渲染效果。<strong>在软件界面中，listWidget控件中我使用的样式表如下</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">QListWidget::item</span><br><span class="line">&#123;</span><br><span class="line">	width:<span class="number">40</span>px;</span><br><span class="line">	height:<span class="number">40</span>px;</span><br><span class="line">	font:bold <span class="number">20</span>px;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"> QListWidget &#123;</span><br><span class="line">    </span><br><span class="line">	background-color: rgb(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> QListWidget::item:selected:!active &#123;</span><br><span class="line">    background-color: rgb(<span class="number">98</span>, <span class="number">93</span>, <span class="number">255</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> QListWidget::item:selected:active &#123;</span><br><span class="line">    </span><br><span class="line">	background-color: rgb(<span class="number">98</span>, <span class="number">93</span>, <span class="number">255</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> QListWidget::item:hover &#123;</span><br><span class="line"> </span><br><span class="line">	background-color: rgba(<span class="number">50</span>, <span class="number">23</span>, <span class="number">255</span>, <span class="number">100</span>);</span><br><span class="line">	</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>具体含义可以根据效果就可以看出，如下演示效果：</p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20150423/20150423_fig012.jpg" width="150" height="400" title="图12" alt="图12" ></p>
<p>当前选择项使用深蓝表示，而鼠标停靠的选择项使用浅蓝表示。</p>
<p><strong>下面是我软件项目中所有的界面，图标都是使用网络上的图标（若有侵权，请告知）：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20150423/20150423_fig013.jpg" width="600" height="500" title="图13" alt="图13" ></p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20150423/20150423_fig014.jpg" width="600" height="500" title="图14" alt="图14" ></p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20150423/20150423_fig015.jpg" width="400" height="300" title="图15" alt="图15" ></p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20150423/20150423_fig016.jpg" width="400" height="300" title="图16" alt="图16" ></p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20150423/20150423_fig017.jpg" width="400" height="400" title="图17" alt="图17" ></p>
<hr>
<ol>
<li><a href="http://blog.csdn.net/tengweitw/article/details/44757875" target="_blank" rel="noopener">词典框架设计及成品展示</a></li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/45014771" target="_blank" rel="noopener">本地词典的设计</a></li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/45099867" target="_blank" rel="noopener">开始菜单的设计</a></li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/38758051" target="_blank" rel="noopener">无边框窗口的缩放与拖动</a></li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/38817595" target="_blank" rel="noopener">无边框窗口的拖动</a></li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/45223931" target="_blank" rel="noopener">界面美化设计</a></li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/45484803" target="_blank" rel="noopener">调用网络API</a></li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/45932429" target="_blank" rel="noopener">用户登录及API调用的实现</a></li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/45932429" target="_blank" rel="noopener">JSON数据解析</a></li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/23294533" target="_blank" rel="noopener">国际音标的显示</a></li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/38237203" target="_blank" rel="noopener">系统托盘的显示</a></li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/38306803" target="_blank" rel="noopener">调用讲述人</a></li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/38555787" target="_blank" rel="noopener">音频播放</a></li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/38689745" target="_blank" rel="noopener">自动补全功能</a></li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/38734201" target="_blank" rel="noopener">HTML特殊字符及正则表达式</a></li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/46563781" target="_blank" rel="noopener">后序</a></li>
</ol>
<p><strong>作品下载地址（发布版）</strong>：<a href="http://download.csdn.net/detail/tengweitw/8548767" target="_blank" rel="noopener">http://download.csdn.net/detail/tengweitw/8548767</a></p>
<p><strong>作品下载地址（绿色版）</strong>：<a href="http://download.csdn.net/detail/tengweitw/8830495" target="_blank" rel="noopener">http://download.csdn.net/detail/tengweitw/8830495</a></p>
<p><strong>源码下载地址</strong>：<a href="http://download.csdn.net/detail/tengweitw/8830503" target="_blank" rel="noopener">http://download.csdn.net/detail/tengweitw/8830503</a></p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>Qt Coding</tag>
      </tags>
  </entry>
  <entry>
    <title>【Qt编程】基于Qt的词典开发系列--开始菜单的设计</title>
    <url>/2015/04/17/%5B20150417%5D/</url>
    <content><![CDATA[<p> 这篇文章讲讲如何实现开始菜单（或者称为主菜单）的设计。什么是开始菜单呢？我们拿常用的软件来用图例说明，大多数软件的开始菜单在左下角，如下图：</p>
<a id="more"></a>
<p>1、window 7的开始菜单</p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20150417/20150417_fig001.jpg" width="300" height="500" title="图1" alt="图1" ></p>
<p>2、有道词典的主菜单</p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20150417/20150417_fig002.jpg" width="600" height="500" title="图2" alt="图2" ></p>
<p>3、QQ的开始菜单</p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20150417/20150417_fig003.jpg" width="200" height="500" title="图3" alt="图3" ></p>
<p>4、我写的词典软件的开始菜单</p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20150417/20150417_fig004.jpg" width="600" height="500" title="图4" alt="图4" ></p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20150417/20150417_fig005.jpg" width="600" height="500" title="图5" alt="图5" ></p>
<p>当你左键单击开始菜单时，就会弹出相应的菜单选项，然后你就可以进行相关操作。<strong>本文只讲如何实现点击按钮，弹出菜单功能，至于点击菜单后的事件需要你自己编写</strong>。当然，关于右击按钮出现菜单的方法，则是要重写qt自带的函数，至于具体操作可以百度。</p>
<p><strong>要想使按钮实现左键单击弹出菜单，我们需要让按钮继承下面的名为QMenuButton类,类文件如下</strong>：</p>
<p><strong>1、qmenubutton.h</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">  <span class="meta">#<span class="meta-keyword">ifndef</span> QMENUBUTTON_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> QMENUBUTTON_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QToolButton&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QMenu</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QMenuButton</span> :</span> <span class="keyword">public</span> QToolButton</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">QMenuButton</span><span class="params">(QWidget *parent = <span class="number">0</span>)</span></span>;</span><br><span class="line">     <span class="function">QMenu * <span class="title">getmenu</span><span class="params">()</span></span>;</span><br><span class="line">     QMenu * menu;</span><br><span class="line">signals:</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> slots:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">popupmenu</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// QMENUBUTTON_H</span></span></span><br></pre></td></tr></table></figure>
<p><strong>2、qmenubutton.cpp</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"qmenubutton.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QMenu&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;QRect&gt;</span></span></span><br><span class="line">QMenuButton::QMenuButton(QWidget *parent) :</span><br><span class="line">    QToolButton(parent)</span><br><span class="line">&#123;</span><br><span class="line">    menu = <span class="keyword">new</span> QMenu(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    connect(<span class="keyword">this</span>,SIGNAL(clicked()),<span class="keyword">this</span>,SLOT(popupmenu()));<span class="comment">//点击按钮就弹出菜单</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">QMenu *QMenuButton::getmenu()</span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">return</span> menu;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> QMenuButton::popupmenu()</span><br><span class="line">&#123;   QPoint pos; <span class="comment">//获取按键菜单的坐标</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// int x = pos.x();</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> y = pos.y();</span><br><span class="line">   <span class="comment">// pos.setX(x + this-&gt;geometry().width()/2);//也可以改变出现菜单的窗口的x位置</span></span><br><span class="line"></span><br><span class="line">    pos.setY(y-<span class="keyword">this</span>-&gt;geometry().height());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回菜单下面的action不管有没被选中，可以算一个小事件循环</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//里面参数的意思是在哪个坐标弹出菜单，这里将自定义的pop按键的坐标作参考，并在其下面弹出菜单</span></span><br><span class="line"></span><br><span class="line">    menu-&gt;exec(<span class="keyword">this</span>-&gt;mapToGlobal(pos));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>好吧，对于不懂得怎么继承，也嫌麻烦，下面给出一个简单的方法</strong>：首先建立一个Qt Widgets Application，假设取项目名为MenuButton，类名取为Widget，选择继承于QWidget，然后将上面的qmenubutton.h和qmenubutton.cpp文件添加到项目中来。然后打开界面文件widgets.ui拖一个PushButton按钮,<strong>将objectName改为MenuButton</strong>。然后右击MenuButton选择“提升为……”选项，然后在提升的类名称中填写上面我所提到的类的名字QMenuButton，然后选择提升，这样就完成了PushButton继承QMenuButton。接着我们就要实现菜单选项的设计，具体需要用到QMenu类中的函数，在程序中，我给出了注释，大家可以依葫芦画瓢来定制自己的菜单内容。<strong>下面给出具体的实现：</strong></p>
<p>1、widget.h文件：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> WIDGET_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WIDGET_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QWidget&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Ui &#123;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> :</span> <span class="keyword">public</span> QWidget</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Widget</span><span class="params">(QWidget *parent = <span class="number">0</span>)</span></span>;</span><br><span class="line">    ~Widget();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Ui::Widget *ui;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// WIDGET_H</span></span></span><br></pre></td></tr></table></figure>
<p><strong>2、qmenubutton.h (前面已给出)</strong></p>
<p><strong>3、widget.cpp文件：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"widget.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ui_widget.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;QMenu&gt;</span></span></span><br><span class="line">Widget::Widget(QWidget *parent) :</span><br><span class="line">    QWidget(parent),</span><br><span class="line">    ui(<span class="keyword">new</span> Ui::Widget)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;setupUi(<span class="keyword">this</span>);</span><br><span class="line">    QMenu * menu = ui-&gt;MenuButton-&gt;getmenu();<span class="comment">//获得菜单，并向上面添加菜单</span></span><br><span class="line">    QAction* ToTop =menu-&gt;addAction(<span class="string">"toTop"</span>);<span class="comment">//一级菜单</span></span><br><span class="line">    <span class="comment">//ToTop-&gt;setIcon(QIcon(":/searchwindow/searchwindow/topon_normal.png")); 为ToTop菜单添加图片标识</span></span><br><span class="line">   <span class="comment">// connect(ToTop, SIGNAL(triggered()), this, SLOT(on_toTopBtn_clicked()));添加事件，当单击ToTop时，产生相应的事件</span></span><br><span class="line">    QMenu *fontMenu=menu-&gt;addMenu(<span class="string">"Font"</span>);</span><br><span class="line">    QAction* FontSize1 = fontMenu-&gt;addAction(<span class="string">"small"</span>);<span class="comment">//二级菜单</span></span><br><span class="line">    QAction* FontSize2 = fontMenu-&gt;addAction(<span class="string">"middle"</span>);</span><br><span class="line">    QAction* FontSize3 = fontMenu-&gt;addAction(<span class="string">"large"</span>);</span><br><span class="line">&#125;</span><br><span class="line">Widget::~Widget()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>4、qmenubutton.cpp(前面已给出)</strong></p>
<p><strong>5、main.cpp文件：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"widget.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QApplication&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line">    Widget w;</span><br><span class="line">    w.show();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a.exec();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>运行结果如下：</strong></p>
<p><strong>点击前：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20150417/20150417_fig006.jpg" width="400" height="300" title="图6" alt="图6" ></p>
<p><strong>点击后：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20150417/20150417_fig007.jpg" width="400" height="300" title="图7" alt="图7" ></p>
<p><strong>基于Qt的词典开发系列</strong></p>
<ol>
<li><a href="http://blog.csdn.net/tengweitw/article/details/44757875" target="_blank" rel="noopener">词典框架设计及成品展示</a></li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/45014771" target="_blank" rel="noopener">本地词典的设计</a></li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/45099867" target="_blank" rel="noopener">开始菜单的设计</a></li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/38758051" target="_blank" rel="noopener">无边框窗口的缩放与拖动</a></li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/38817595" target="_blank" rel="noopener">无边框窗口的拖动</a></li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/45223931" target="_blank" rel="noopener">界面美化设计</a></li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/45484803" target="_blank" rel="noopener">调用网络API</a></li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/45932429" target="_blank" rel="noopener">用户登录及API调用的实现</a></li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/45932429" target="_blank" rel="noopener">JSON数据解析</a></li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/23294533" target="_blank" rel="noopener">国际音标的显示</a></li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/38237203" target="_blank" rel="noopener">系统托盘的显示</a></li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/38306803" target="_blank" rel="noopener">调用讲述人</a></li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/38555787" target="_blank" rel="noopener">音频播放</a></li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/38689745" target="_blank" rel="noopener">自动补全功能</a></li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/38734201" target="_blank" rel="noopener">HTML特殊字符及正则表达式</a></li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/46563781" target="_blank" rel="noopener">后序</a></li>
</ol>
<p><strong>作品下载地址（发布版）</strong>：<a href="http://download.csdn.net/detail/tengweitw/8548767" target="_blank" rel="noopener">http://download.csdn.net/detail/tengweitw/8548767</a></p>
<p><strong>作品下载地址（绿色版）</strong>：<a href="http://download.csdn.net/detail/tengweitw/8830495" target="_blank" rel="noopener">http://download.csdn.net/detail/tengweitw/8830495</a></p>
<p><strong>源码下载地址</strong>：<a href="http://download.csdn.net/detail/tengweitw/8830503" target="_blank" rel="noopener">http://download.csdn.net/detail/tengweitw/8830503</a></p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>Qt Coding</tag>
      </tags>
  </entry>
  <entry>
    <title>【Qt编程】基于Qt的词典开发系列--本地词典的设计</title>
    <url>/2015/04/13/%5B20150413%5D/</url>
    <content><![CDATA[<p>我设计的词典不仅可以实现在线查单词，而且一个重大特色就是具有<strong>丰富的本地词典库</strong>：我默认加入了八个类型的词典，如下所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20150413/20150413_fig001.jpg" width="600" height="500" title="图1" alt="图1" ></p>
<p>由于是本人是通信专业，因此加入了华为通信词典、电子工程词典，又由于我喜爱编程，也加入了c语言基本函数词典。下面介绍如何设计本地词典：</p>
<a id="more"></a>
<h2 id="词典类型的选择"><a href="#词典类型的选择" class="headerlink" title="词典类型的选择"></a>词典类型的选择</h2><p>当然是txt格式的最好了，因为我们可以用程序直接进行读取。可是网上词典一般都是用mdx格式、ld2格式的，我无法用Qt来直接读取。最终，经过不断摸索，网上查找，发现我们可以将mdx格式的词典通过软件转化为txt格式的！</p>
<h2 id="mdx词典的下载"><a href="#mdx词典的下载" class="headerlink" title="mdx词典的下载"></a>mdx词典的下载</h2><p>​    如何获取mdx格式的词典呢？直接百度 mdx 词典就可以发现如下搜索结果：</p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20150413/20150413_fig002.jpg" width="600" height="400" title="图2" alt="图2" ></p>
<p>从中选择下载你想要的词典，这里我以<a href="http://bbs.meizu.cn/thread-3299845-1-1.html中的第一个mdx词典“三合一汉语大辞典”作为例子。" target="_blank" rel="noopener">http://bbs.meizu.cn/thread-3299845-1-1.html中的第一个mdx词典“三合一汉语大辞典”作为例子。</a></p>
<hr>
<h2 id="mdx词典的查看"><a href="#mdx词典的查看" class="headerlink" title="mdx词典的查看"></a>mdx词典的查看</h2><p>​    由于是mdx格式的，你用记事本打开就会显示乱码。那么怎么查看你下载的词典的内容呢？这时我们可以利用一个可以解析mdx格式的<strong>软件MDict（<a href="http://download.csdn.net/detail/tengweitw/8588165" target="_blank" rel="noopener">点击下载</a>）</strong>来打开该mdx词典。</p>
<p>举例说明：</p>
<p>假设我下载了一个“三合一汉语大辞典.mdx”，我们首先打开MDict软件来查看该词典的内容。首先选择“词库”—“词库管理”—“加入词典”，从而加入我们下载的词典文件，然后点击“词库”，从下拉列表中选择我们刚才加入的“三合一汉语大辞典”。然后单击左侧栏，就会在右侧栏中显示对应的内容。具体操作图解如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20150413/20150413_fig003.jpg" width="600" height="400" title="图3" alt="图3" ></p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20150413/20150413_fig004.jpg" width="600" height="500" title="图4" alt="图4" ></p>
<h2 id="mdx词典的转换"><a href="#mdx词典的转换" class="headerlink" title="mdx词典的转换"></a>mdx词典的转换</h2><p>将mdx格式的词典转化为txt格式需要利用工具MDx词典转化工具（<a href="http://download.csdn.net/detail/tengweitw/8588171" target="_blank" rel="noopener">点击下载</a>），只需要按照下图即可转化为txt文件：</p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20150413/20150413_fig005.jpg" width="500" height="400" title="图5" alt="图5" ></p>
<p>​    用记事本打开该txt文件我们就可以发现下图类似的语言格式：</p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20150413/20150413_fig006.jpg" width="700" height="400" title="图6" alt="图6" ></p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20150413/20150413_fig007.jpg" width="600" height="400" title="图7" alt="图7" ></p>
<p>我们以图中第二行为例，aadb为我们要查的单词（注意:我们这里的词典是成语词典，即查找aadb四个拼音首字母所组成的成语），而后面<code>&lt;font &lt;/font&gt;&lt;br&gt;</code>中的即为我们要找的成语，学过网页设计的人应该都知道<code>&lt;font color=&quot;#0000FF&quot;&gt;&lt;br&gt;嗷嗷待哺&lt;/font&gt;&lt;br&gt;</code>的意思，这其实是html语言，即将“嗷嗷待哺”变为蓝色字体，正如我们在MDict所看到的一样。而恰好Qt可以识别html语言，因此即使像我这种没有学过html语言的人也不用费心思去了解。</p>
<hr>
<h2 id="txt词典的处理"><a href="#txt词典的处理" class="headerlink" title="txt词典的处理"></a>txt词典的处理</h2><p>前面我们基本上完成了词典的制作，但是我为了简便起见，我将词典中要查的词和内容分开保存。例如，我将上面的txt文件改名为Chinese.txt(方便编程使用)，将其拆分如下名为ChineseA和ChineseB文件：</p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20150413/20150413_fig008.jpg" width="700" height="200" title="图8" alt="图8" ></p>
<p>这样做的好处是，每当我在搜索窗口输入我想要查询的内容时（比如输入aadb），我就只需要打开ChineseA文件，在这里寻找是否存在该词，而不需要打开整个词典（词+内容），这样查找速度会快一点，因为很明显ChineseA的文件的大小要明显小于Chinese文件大小，<strong>还有一点好处，会在后面的系列文章中提到</strong>。如下所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20150413/20150413_fig009.jpg" width="400" height="100" title="图9" alt="图9" ></p>
<p>关于如何将上面的文件拆分成两个文件，我想应该很简单，我就不在这写出具体的实现过程，只说说思路：首先读取整个文件，每次读取一行，在每一行中，遇到第一个空格就提取出来放入ChineseA.txt中，该行剩余部分放入ChineseB.txt。<strong>值得注意的是</strong>，两个子文件中，对应的内容应该在相同行！</p>
<p>好吧，也许说了这么多，你也嫌太复杂，懒得自己操作，觉得我的本地词典库足够了，那好吧，你可以自己下载我已经处理好了的txt格式的词典文件。链接为：<a href="http://download.csdn.net/detail/tengweitw/8588209" target="_blank" rel="noopener">http://download.csdn.net/detail/tengweitw/8588209</a></p>
<p><strong>基于Qt的词典开发系列</strong></p>
<ol>
<li><a href="http://blog.csdn.net/tengweitw/article/details/44757875" target="_blank" rel="noopener">词典框架设计及成品展示</a></li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/45014771" target="_blank" rel="noopener">本地词典的设计</a></li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/45099867" target="_blank" rel="noopener">开始菜单的设计</a></li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/38758051" target="_blank" rel="noopener">无边框窗口的缩放与拖动</a></li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/38817595" target="_blank" rel="noopener">无边框窗口的拖动</a></li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/45223931" target="_blank" rel="noopener">界面美化设计</a></li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/45484803" target="_blank" rel="noopener">调用网络API</a></li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/45932429" target="_blank" rel="noopener">用户登录及API调用的实现</a></li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/45932429" target="_blank" rel="noopener">JSON数据解析</a></li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/23294533" target="_blank" rel="noopener">国际音标的显示</a></li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/38237203" target="_blank" rel="noopener">系统托盘的显示</a></li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/38306803" target="_blank" rel="noopener">调用讲述人</a></li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/38555787" target="_blank" rel="noopener">音频播放</a></li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/38689745" target="_blank" rel="noopener">自动补全功能</a></li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/38734201" target="_blank" rel="noopener">HTML特殊字符及正则表达式</a></li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/46563781" target="_blank" rel="noopener">后序</a></li>
</ol>
<p><strong>作品下载地址（发布版）</strong>：<a href="http://download.csdn.net/detail/tengweitw/8548767" target="_blank" rel="noopener">http://download.csdn.net/detail/tengweitw/8548767</a></p>
<p><strong>作品下载地址（绿色版）</strong>：<a href="http://download.csdn.net/detail/tengweitw/8830495" target="_blank" rel="noopener">http://download.csdn.net/detail/tengweitw/8830495</a></p>
<p><strong>源码下载地址</strong>：<a href="http://download.csdn.net/detail/tengweitw/8830503" target="_blank" rel="noopener">http://download.csdn.net/detail/tengweitw/8830503</a></p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>Qt Coding</tag>
      </tags>
  </entry>
  <entry>
    <title>【Qt编程】设计ColorBar颜色栏</title>
    <url>/2015/04/09/%5B20150409%5D/</url>
    <content><![CDATA[<p>画过图的都知道，我们常常用颜色的深浅来表示值的大小，在Matlab作图中，我们使用的是colorbar这个函数来给出颜色的直观参考。下面给出Matlab的示例：在Matlab命令窗口输入：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">figure</span><br><span class="line"></span><br><span class="line">surf(peaks)</span><br><span class="line"></span><br><span class="line">colorbar</span><br></pre></td></tr></table></figure>
<p>可以得到的图像如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20150409/20150409_fig001.jpg" width="600" height="500" title="图1" alt="图1" ></p>
<a id="more"></a>
<p>通过右击该颜色栏，可以选择不同的颜色，<strong>当选择jet后，可以得到如下的图像：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20150409/20150409_fig002.jpg" width="600" height="400" title="图2" alt="图2" ></p>
<p>那上面的示例来说，使用颜色栏的好处是可以显示四维信息，例如（x，y，z）表示了一个三维空间的坐标，坐标点温度的大小则可以通过颜色栏的温度来表明。当然，要说明的是这里的温度值的大小和高度z的值是相同的，这个例子没举好，若要画四维图可以自行百度。</p>
<p>上面讲了Matlab如何运用颜色栏以及其好处，下面我们看看如何在Qt中绘制颜色条。本以为Qt中也有类似的函数，可以我没有找到（如果谁知道，可以告知我），只好自己写函数实现了。关于Qt中最基本的使用QPaint画图我就不介绍了，网上也有很多教程。程序中我只是将Matlab中Colorbar常用的四种颜色栏（Gray，Jet，Hsv，Hot）进行了绘制。绘制过程只使用到了简单的fillRect函数来画填充四边形。下面主要讲讲颜色的设置：</p>
<p>我们首先在上面Matlab的Colorbar上右击选择一个你希望绘制的颜色栏（假设选择了jet）,然后选择“打开颜色图编辑器”，<strong>得到如下界面：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20150409/20150409_fig003.jpg" width="600" height="400" title="图3" alt="图3" ></p>
<p>将鼠标放在颜色上，就可以得到对应的RGB、HSV的值。然后在Qt中就可以通过程序描绘这种值的变化，就可以得到与之相同的颜色栏了。<strong>注意：在程序中，你可以任意选择RGB或HSV来描述，我在程序中，两种方式都用到了。</strong></p>
<p>为了方便，我将工程放着一个.cpp文件中，因此只需要建立一个空的Qt项目然后添加下面的.cpp文件就可以了，<strong>具体的程序实现如下：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QWidget&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QPainter&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PainterWidget</span> :</span> <span class="keyword">public</span> QWidget</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">paintEvent</span><span class="params">(QPaintEvent*)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> PainterWidget::paintEvent(QPaintEvent *event)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">QPainter <span class="title">painter</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">    QColor color;</span><br><span class="line">    QRect section;</span><br><span class="line">    <span class="keyword">float</span> colorBarLength=<span class="number">343.0</span>;<span class="comment">//设置颜色条的长度</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//------设置为gray颜色条---------//</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=colorBarLength;i++)<span class="comment">// gray</span></span><br><span class="line">    &#123;        </span><br><span class="line">       <span class="comment">//color.setRgbF(i/colorBarLength,i/colorBarLength,i/colorBarLength);//也可以使用这种方法</span></span><br><span class="line">       color.setHsv(<span class="number">0</span>,<span class="number">0</span>,(colorBarLength-i)/colorBarLength*<span class="number">255</span>);</span><br><span class="line">        section.setRect(<span class="number">150</span>,<span class="number">50</span>+i*<span class="number">1</span>,<span class="number">20</span>,<span class="number">1</span>);</span><br><span class="line">        painter.fillRect(section,color);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//------设置为jet颜色条---------//</span></span><br><span class="line">    <span class="keyword">float</span> tempLength=colorBarLength/<span class="number">4</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;tempLength/<span class="number">2</span>;i++)<span class="comment">// jet</span></span><br><span class="line">    &#123;</span><br><span class="line">        color.setRgbF(<span class="number">0</span>,<span class="number">0</span>,(tempLength/<span class="number">2</span>+i)/tempLength);</span><br><span class="line">        section.setRect(<span class="number">200</span>,colorBarLength+<span class="number">50</span>-i*<span class="number">1</span>,<span class="number">20</span>,<span class="number">1</span>);</span><br><span class="line">        painter.fillRect(section,color);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=tempLength/<span class="number">2</span>+<span class="number">1</span>;i&lt;tempLength/<span class="number">2</span>+tempLength;i++)<span class="comment">// jet</span></span><br><span class="line">    &#123;</span><br><span class="line">        color.setRgbF(<span class="number">0</span>,(i-tempLength/<span class="number">2</span>)/tempLength,<span class="number">1</span>);</span><br><span class="line">        section.setRect(<span class="number">200</span>,colorBarLength+<span class="number">50</span>-i*<span class="number">1</span>,<span class="number">20</span>,<span class="number">1</span>);</span><br><span class="line">        painter.fillRect(section,color);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=tempLength/<span class="number">2</span>+tempLength+<span class="number">1</span>;i&lt;tempLength/<span class="number">2</span>+<span class="number">2</span>*tempLength;i++)<span class="comment">// jet</span></span><br><span class="line">    &#123;</span><br><span class="line">        color.setRgbF((i-tempLength-tempLength/<span class="number">2</span>)/tempLength,<span class="number">1</span>,(tempLength*<span class="number">2</span>+tempLength/<span class="number">2</span>-i)/tempLength);</span><br><span class="line">        section.setRect(<span class="number">200</span>,colorBarLength+<span class="number">50</span>-i*<span class="number">1</span>,<span class="number">20</span>,<span class="number">1</span>);</span><br><span class="line">        painter.fillRect(section,color);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=tempLength/<span class="number">2</span>+<span class="number">2</span>*tempLength+<span class="number">1</span>;i&lt;tempLength/<span class="number">2</span>+<span class="number">3</span>*tempLength;i++)<span class="comment">// jet</span></span><br><span class="line">    &#123;</span><br><span class="line">        color.setRgbF(<span class="number">1</span>,(tempLength*<span class="number">3</span>+tempLength/<span class="number">2</span>-i)/tempLength,<span class="number">0</span>);</span><br><span class="line">        section.setRect(<span class="number">200</span>,colorBarLength+<span class="number">50</span>-i*<span class="number">1</span>,<span class="number">20</span>,<span class="number">1</span>);</span><br><span class="line">        painter.fillRect(section,color);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=tempLength/<span class="number">2</span>+<span class="number">3</span>*tempLength+<span class="number">1</span>;i&lt;colorBarLength;i++)<span class="comment">// jet</span></span><br><span class="line">    &#123;</span><br><span class="line">        color.setRgbF((colorBarLength-i+tempLength/<span class="number">2</span>)/(tempLength),<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        section.setRect(<span class="number">200</span>,colorBarLength+<span class="number">50</span>-i*<span class="number">1</span>,<span class="number">20</span>,<span class="number">1</span>);</span><br><span class="line">        painter.fillRect(section,color);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//------设置为hsv颜色条---------//</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=colorBarLength;i++)<span class="comment">// hsv</span></span><br><span class="line">    &#123;</span><br><span class="line">        color.setHsvF(i/colorBarLength,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">        section.setRect(<span class="number">250</span>,colorBarLength+<span class="number">50</span>-i*<span class="number">1</span>,<span class="number">20</span>,<span class="number">1</span>);</span><br><span class="line">        painter.fillRect(section,color);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//------设置为hot颜色条---------//</span></span><br><span class="line">    tempLength=colorBarLength/<span class="number">2.5</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;tempLength/<span class="number">2</span>;i++)<span class="comment">// hot</span></span><br><span class="line">    &#123;</span><br><span class="line">        color.setRgbF((tempLength/<span class="number">2</span>+i)/tempLength,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        section.setRect(<span class="number">300</span>,colorBarLength+<span class="number">50</span>-i*<span class="number">1</span>,<span class="number">20</span>,<span class="number">1</span>);</span><br><span class="line">        painter.fillRect(section,color);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=tempLength/<span class="number">2</span>+<span class="number">1</span>;i&lt;tempLength/<span class="number">2</span>+tempLength;i++)<span class="comment">// hot</span></span><br><span class="line">    &#123;</span><br><span class="line">        color.setRgbF(<span class="number">1</span>,(i-tempLength/<span class="number">2</span>)/tempLength,<span class="number">0</span>);</span><br><span class="line">        section.setRect(<span class="number">300</span>,colorBarLength+<span class="number">50</span>-i*<span class="number">1</span>,<span class="number">20</span>,<span class="number">1</span>);</span><br><span class="line">        painter.fillRect(section,color);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=tempLength/<span class="number">2</span>+tempLength+<span class="number">1</span>;i&lt;colorBarLength;i++)<span class="comment">// hot</span></span><br><span class="line">    &#123;</span><br><span class="line">        color.setRgbF(<span class="number">1</span>,<span class="number">1</span>,(i-tempLength/<span class="number">2</span>-tempLength)/(colorBarLength-tempLength/<span class="number">2</span>-tempLength+<span class="number">20</span>));</span><br><span class="line">        section.setRect(<span class="number">300</span>,colorBarLength+<span class="number">50</span>-i*<span class="number">1</span>,<span class="number">20</span>,<span class="number">1</span>);</span><br><span class="line">        painter.fillRect(section,color);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//---------设置边框--------------//</span></span><br><span class="line">    <span class="comment">//刻度值的绘制可以自己设计，使用drawText函数即可,刻度的绘制可以使用drawLine函数</span></span><br><span class="line">    painter.setPen(Qt::black);</span><br><span class="line">    painter.drawRect(<span class="number">150</span>,<span class="number">50</span>,<span class="number">20</span>,colorBarLength);</span><br><span class="line">    painter.setFont(QFont(QString::fromLocal8Bit(<span class="string">"宋体"</span>),<span class="number">10</span>,<span class="number">-1</span>,<span class="literal">false</span>));</span><br><span class="line">    painter.drawText(<span class="number">150</span>,<span class="number">40</span>,QStringLiteral(<span class="string">"Gray"</span>));</span><br><span class="line"></span><br><span class="line">    painter.drawRect(<span class="number">200</span>,<span class="number">50</span>,<span class="number">20</span>,colorBarLength);</span><br><span class="line">    painter.setFont(QFont(QString::fromLocal8Bit(<span class="string">"宋体"</span>),<span class="number">10</span>,<span class="number">-1</span>,<span class="literal">false</span>));</span><br><span class="line">    painter.drawText(<span class="number">200</span>,<span class="number">40</span>,QStringLiteral(<span class="string">"Jet"</span>));</span><br><span class="line"></span><br><span class="line">    painter.drawRect(<span class="number">250</span>,<span class="number">50</span>,<span class="number">20</span>,colorBarLength);</span><br><span class="line">    painter.setFont(QFont(QString::fromLocal8Bit(<span class="string">"宋体"</span>),<span class="number">10</span>,<span class="number">-1</span>,<span class="literal">false</span>));</span><br><span class="line">    painter.drawText(<span class="number">250</span>,<span class="number">40</span>,QStringLiteral(<span class="string">"Hsv"</span>));</span><br><span class="line"></span><br><span class="line">    painter.drawRect(<span class="number">300</span>,<span class="number">50</span>,<span class="number">20</span>,colorBarLength);</span><br><span class="line">    painter.setFont(QFont(QString::fromLocal8Bit(<span class="string">"宋体"</span>),<span class="number">10</span>,<span class="number">-1</span>,<span class="literal">false</span>));</span><br><span class="line">    painter.drawText(<span class="number">300</span>,<span class="number">40</span>,QStringLiteral(<span class="string">"Hot"</span>));</span><br><span class="line">   <span class="comment">// painter.drawText(150,320,QStringLiteral(" 0"));</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    PainterWidget pWidget;</span><br><span class="line">    pWidget.setWindowTitle(<span class="string">"ColorTest"</span>);</span><br><span class="line">    pWidget.resize(<span class="number">500</span>, <span class="number">500</span>);</span><br><span class="line">    pWidget.show();</span><br><span class="line">    <span class="keyword">return</span> app.exec();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20150409/20150409_fig004.jpg" width="600" height="500" title="图4" alt="图4" ></p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>Qt Coding</tag>
      </tags>
  </entry>
  <entry>
    <title>【妄言之言】清明</title>
    <url>/2015/04/06/%5B20150406%5D/</url>
    <content><![CDATA[<p>昨天是清明节，也是复活节。清明节我是知道的，就是祭祖扫墓的日子。复活节我就听说过，谷歌了一下：复活节是西方基督教徒纪念他们的上帝之子耶稣死后三天复活的节日，一个纯粹的宗教节日，象征重生与希望。比较有趣的是，今年中国的清明节与西方的复活节意外相遇，而去年中国的元宵节与西方的情人节不期而至。想想，这两两节日之间也是有联系的。</p>
<a id="more"></a>
<p>“清明时节雨纷纷，路上行人欲断魂”。西安最近几天都在下雨，就是昨天没下，可能是天公作美，让人们可以多烧点纸钱供先人们享用。打我记事起，有五位亲人相继去世，而我却没能见他们最后一面。每次遇到这种事，我都体会到子欲养而亲不待的感觉。他们都给了我很多关爱，可是我也没能为他们做点什么。转眼又到清明节，作为漂泊异乡的游子，只能在心中默念远去的亲人。</p>
<p>珍惜眼前人，随着我一天天长大，奶奶、外公一天天老去。每年回家都感觉他们苍老了好多。每次回家都给他们买东西，陪奶奶聊聊天，陪外公下下棋。亲戚们都说我没有点朝气，应该多和同辈人玩。而对于我来说，打牌是很没意思的，况且以后和他们玩的机会多的是，而陪两位老人的时间则是一天天的减少。每周都给他们打打电话，叫他们注意身体，希望他们能够健康长寿。</p>
<p>“弟子规 ,圣人训, 首孝悌, 次谨信”，《弟子规》中把孝放在首位，这也说明我们从古代开始就注重孝顺亲人。清明节，我们不仅仅要缅怀已逝的亲人，更要孝顺身边的亲人！</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>Life Thoughts</tag>
      </tags>
  </entry>
  <entry>
    <title>【Qt编程】基于Qt的词典开发系列--词典框架设计及成品展示</title>
    <url>/2015/03/31/%5B20150331%5D/</url>
    <content><![CDATA[<p>  去年暑假的时候，作为学习Qt的实战，我写了一个名为《我爱查词典》的词典软件。后来由于导师项目及上课等原因，时间不足，所以该软件的部分功能欠缺，性能有待改善。这学期重新拿出来看时，又有很多东西都不熟悉了。恰逢这学期课比较少，于是乎想写写关于这个软件制作的一系列文章，对日后重拾该软件时能够较快入手。当然，也非常乐意读者们在该软件的基础上添加一些功能，源代码会在该系列文章写完之后公布。可运行的词典软件的下载地址：<a href="http://download.csdn.net/detail/tengweitw/8548767" target="_blank" rel="noopener">http://download.csdn.net/detail/tengweitw/8548767</a></p>
<a id="more"></a>
<p><strong>下面先给出软件的架构，文章后面会给出各个功能展示图。</strong></p>
<h2 id="词典的功能模块"><a href="#词典的功能模块" class="headerlink" title="词典的功能模块"></a>词典的功能模块</h2><p>​    </p>
<p>1、无边框窗口的拖动、放大缩小</p>
<p>2、系统托盘的显示</p>
<p>3、登录管理</p>
<p>4、用户账号显示</p>
<p>5、置顶、换肤、最小化、关闭按钮</p>
<p>6、调用本地浏览器查词</p>
<p>7、查词历史前进后退按钮</p>
<p>8、查词框、搜索按钮</p>
<p>9、三种查词：网络查词、本地查词、网页查词</p>
<p>10、单词信息显示窗口</p>
<p>11、主菜单：置顶、字体大小选择、匹配模式选择、注销、关于、退出</p>
<p>12、单词本</p>
<p>13、本地词典的选择模块</p>
<p>14、网上学堂</p>
<p>15、网络连通状态标志</p>
<p>16、本地词典使用状态</p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20150331/20150331_fig001.jpg" width="600" height="500" title="图1" alt="图1" ></p>
<h2 id="工程目录文件"><a href="#工程目录文件" class="headerlink" title="工程目录文件"></a>工程目录文件</h2><p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20150331/20150331_fig002.jpg" width="200" height="500" title="图2" alt="图2" ></p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20150331/20150331_fig003.jpg" width="200" height="300" title="图3" alt="图3" ></p>
<p><strong>下面给出各个文件的大概功能说明：</strong></p>
<p>1、basicwindow.h、basicwindow.cpp和basicwindow.ui文件定义了Basicwindow类，主要实现的是边框窗口的拖动和缩放，软件中其他的窗口设计大都继承该类</p>
<p>2、completelineedit.h和completelineedit.cpp文件定义了CompleteLineEdit类，该类主要是改进QLineEdit类，可以有下拉列表的显示，软件中功能8就用到该类。</p>
<p>3、libmanager.h、libmanager.cpp和libmanager.ui文件用于生成本地词典的选择界面。</p>
<p>4、localdict.h和localdict.cpp文件定义了LocalDict类，用于读取本地的词典库。</p>
<p>5、logindialog.h、logindialog.cpp和logindialog.ui定义了LoginDialog类，用于管理用户帐号的登录。</p>
<p>6、network.h和network.cpp文件定义了netWork类，用于根据扇贝网的公开API，使用帐号登录扇贝网，进行网络查词。</p>
<p>7、qmenubutton.h和qmenubutton.cpp定义了QMenuButton类，功能11继承了该类，使之可以出现下拉菜单。</p>
<p>8、searchwindow.h、searchwindow.cpp和searchwindow.ui定义了SearchWindow类，用于软件主界面的显示，这个是软件的核心部分。</p>
<p>9、word.h和word.cpp文件定义了Word类，主要用于储存从网络查词获得的单词内容。</p>
<p>10、wordbook.h、wordbook.cpp和wordbook.ui文件定义了WordBook类，用于管理单词本，此部分功能尚未实现。</p>
<p>11、wordmodify.h、wordmodify.cpp和wordmodify.ui文件定义了WordModify，用于单词本中单词的修改功能。</p>
<hr>
<h2 id="部分功能的展示图"><a href="#部分功能的展示图" class="headerlink" title="部分功能的展示图"></a>部分功能的展示图</h2><p><strong>1、主界面</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20150331/20150331_fig004.jpg" width="600" height="500" title="图4" alt="图4" ></p>
<p><strong>2、网络查词</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20150331/20150331_fig005.jpg" width="600" height="500" title="图5" alt="图5" ></p>
<p><strong>3、本地查词</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20150331/20150331_fig006.jpg" width="600" height="500" title="图6" alt="图6" ></p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20150331/20150331_fig007.jpg" width="600" height="500" title="图7" alt="图7" ></p>
<p><strong>4、网络搜索</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20150331/20150331_fig008.jpg" width="600" height="500" title="图8" alt="图8" ></p>
<p><strong>5、换肤功能</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20150331/20150331_fig009.jpg" width="600" height="500" title="图9" alt="图9" ></p>
<p><strong>6、搜索模式：句首匹配、句中匹配</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20150331/20150331_fig010.jpg" width="600" height="500" title="图10" alt="图10" ></p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20150331/20150331_fig011.jpg" width="600" height="500" title="图11" alt="图11" ></p>
<p><strong>7、主菜单</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20150331/20150331_fig012.jpg" width="600" height="500" title="图12" alt="图12" ></p>
<p><strong>8、托盘显示</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20150331/20150331_fig013.jpg" width="220" height="40" title="图13" alt="图13" ></p>
<p><strong>9、其他一些截图：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20150331/20150331_fig014.jpg" width="600" height="500" title="图14" alt="图14" ></p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20150331/20150331_fig015.jpg" width="600" height="500" title="图15" alt="图15" ></p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20150331/20150331_fig016.jpg" width="600" height="500" title="图16" alt="图16" ></p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20150331/20150331_fig017.jpg" width="600" height="500" title="图17" alt="图17" ></p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20150331/20150331_fig018.jpg" width="600" height="500" title="图18" alt="图18" ></p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20150331/20150331_fig019.jpg" width="600" height="500" title="图19" alt="图19" ></p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20150331/20150331_fig020.jpg" width="600" height="500" title="图20" alt="图20" ></p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20150331/20150331_fig021.jpg" width="600" height="550" title="图21" alt="图21" ></p>
<p><strong>基于Qt的词典开发系列</strong></p>
<ol>
<li><a href="http://blog.csdn.net/tengweitw/article/details/44757875" target="_blank" rel="noopener">词典框架设计及成品展示</a></li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/45014771" target="_blank" rel="noopener">本地词典的设计</a></li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/45099867" target="_blank" rel="noopener">开始菜单的设计</a></li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/38758051" target="_blank" rel="noopener">无边框窗口的缩放与拖动</a></li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/38817595" target="_blank" rel="noopener">无边框窗口的拖动</a></li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/45223931" target="_blank" rel="noopener">界面美化设计</a></li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/45484803" target="_blank" rel="noopener">调用网络API</a></li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/45932429" target="_blank" rel="noopener">用户登录及API调用的实现</a></li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/45932429" target="_blank" rel="noopener">JSON数据解析</a></li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/23294533" target="_blank" rel="noopener">国际音标的显示</a></li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/38237203" target="_blank" rel="noopener">系统托盘的显示</a></li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/38306803" target="_blank" rel="noopener">调用讲述人</a></li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/38555787" target="_blank" rel="noopener">音频播放</a></li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/38689745" target="_blank" rel="noopener">自动补全功能</a></li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/38734201" target="_blank" rel="noopener">HTML特殊字符及正则表达式</a></li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/46563781" target="_blank" rel="noopener">后序</a></li>
</ol>
<p><strong>作品下载地址（发布版）</strong>：<a href="http://download.csdn.net/detail/tengweitw/8548767" target="_blank" rel="noopener">http://download.csdn.net/detail/tengweitw/8548767</a></p>
<p><strong>作品下载地址（绿色版）</strong>：<a href="http://download.csdn.net/detail/tengweitw/8830495" target="_blank" rel="noopener">http://download.csdn.net/detail/tengweitw/8830495</a></p>
<p><strong>源码下载地址</strong>：<a href="http://download.csdn.net/detail/tengweitw/8830503" target="_blank" rel="noopener">http://download.csdn.net/detail/tengweitw/8830503</a></p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>Qt Coding</tag>
      </tags>
  </entry>
  <entry>
    <title>【妄言之言】考研</title>
    <url>/2015/03/28/%5B20150328%5D/</url>
    <content><![CDATA[<p>对于一个没有考过研的人来说，谈考研好像有点不着边际。正如韩寒导演的电影《后会无期》中的一句台词：你连世界都没观过，哪来的世界观。不过古语有云：当局者迷，旁观者清。我就以一个旁观者的身份来谈谈考研。（以下内容都是我本人的观点，与我本人无关—皆为自己的妄言之言）</p>
<a id="more"></a>
<p>为什么要说考研呢？毕竟考研已经过了几个月的。因为这一周应该是复试周，很多学校都陆续开始了复试。最明显的感觉就是自习室的人变多了，记得开学前两周我每天来自习室的时候，教室里基本没人，很多教室都空着，这一周好像人变多了，拿着专业课本在看，而我呢却看着英文书，显得有点格格不入，没办法，下个月要考英语了。今天在逛学校论坛的时候，看了一些关于考研的帖子。有的在传教考研经验，庆祝考研成功，有的在抱怨学校的录取体制，有的在伤感二战的失败，简直就是人生百态。</p>
<p>幸好，我周围一些考研的同学大多数都成功了。想当年，涛哥在大三上学期就开准备考研了，而且是跨学校跨专业。记得当初我们在准备期末复习的时候，他就在看《离散数学》等等计算机专业的书籍。然后呢，《信息论》给挂了，这个消息真是令我等目瞪口呆。毕竟涛哥在我们眼中就是神一般的人物，当然也有着“神”一般的思想。不过，这也是意料之外，情理之中，毕竟都去准备考研了。涛哥为了考研，也是蛮拼的，记得大三暑假的时候都是睡在我们客厅里，唉，每次都被我们戏弄。最后，功夫不负有心人，成功的去了南大的计算机系。说起涛哥，的确有不少的话。记得我好多东西都是跟着涛哥学的，谁叫我是个电脑白痴呢。涛哥的编程水平可谓一流，记得大一时学c语言，都知道他很厉害，我却还是个连开机键都不知道（高中没玩过电脑），连计算机文化基础课（考word、excel、ppt）都要靠舍友才能及格。谭浩强的那本绿皮书，看了两遍才独立完成了算法大作业（好像是用双向链表实现飞机航班查询功能），通过了考试。大一暑假的时候，涛哥说学个单片机吧，好吧，我当时连单片机是啥都不知道，也就稀里糊涂的用奖学金的钱买了块郭天祥的板子（在这里推荐看看郭天祥的《我的大学六年》）。说好的，暑假一起学习单片机的，我回家十天就会学校了，结果涛哥说他头疼要在家休息，真是坑我啊，害的我一个人在没有电、没有热水的条件下还坚持学完了单片机。也难怪，涛哥肯定用脑过度，大学四年也没见他看过电视、电影以及综艺娱乐节目，就连考研复试结束，依旧拉着我去图书馆学linux。记得上csdn这个博客，也是被涛哥带进来的，当初看涛哥在用这个，还发了几篇文章，我就注册了号，等我真正用这个写博客的时候，都已经忘了那个用户名了，于是就重新注册了。现在也就不知道涛哥的帐号了，不能写太多关于他的事，万一不小心被他看到就不好了。我们宿舍也有两个考研的，一个去了上海交大，一个去了北京邮电，真好！关于他俩的事就不在这寒暄了，以后会有专门的文章来念叨念叨宿舍的小伙伴们。</p>
<p>记得我们班有三个考清华的，结果都没考上。情哥会家乡，调剂到了山东大学；小阳子调剂去了中科大；“学姐”准备二战，且在上周日告知，已被东南大学录取了。不由得为他感到高兴，付出总算有回报了。经常我、情歌、涛哥、晖哥我们“四人帮”一起自习、吃饭，考研复习就抛弃我了，让我伤心一会。我们呢，经常就调侃涛哥和“疏影”，情歌和“北在北方”的不得不说的“故事”。小阳子呢，记得是大一暑假，关系开始混的比较好的。因为暑假留在学校的人比较少，就渐渐的就熟悉了，我每次都去他那里和他一起看电视剧（基本上都是抗战、谍战片）。然后大二暑假的时候，和他一起参加了数学建模，寒假又一起参加了美国数学建模。关于“学姐”，是老乡洪湖的，经常一起都是说家乡话（好吧，我承认我一直都是说的家乡话）。大三的时候，经常和他一起坐在信远教室的左边第三排。二战的时候，每个月还去新校区看看他，这次回学校，还和他在华科待了两天。现在想来，都是满满的回忆。</p>
<p>研究生，顾名思义，就是未来准备从事科学研究的学生。但是，随着我国研究生招生扩招，研究生已经不再是以往的概念。读研的人，抱着不同的目的，有因高考失利导致第一学历不满意而为了圆重点大学梦的、有为了缓冲就业压力的、有迫于家庭压力的，还有为了与恋人同在一个城市的等等。当然，也有一些真正为了以后能从事专业技术而渴望深造的学生。现在想来，我想他们之中大多数是为了和恋人在同一个城市：涛哥、晖哥、舸哥。早知道，我也去考研了，不过当初即使考研也不知去哪，毕竟……。所谓伊人，在哪一方？</p>
<p>距上述事情已有近一年了，回想起来，仿佛就在昨天，如今的他们正在为自己的前途奉献者青春，我们都要为彼此加油。祝他们能怀揣着他们的梦想向远方翱翔！也祝所有考研的同学向着自己的目标进行！</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>Life Thoughts</tag>
      </tags>
  </entry>
  <entry>
    <title>【算法导论】八皇后问题的算法实现（C、MATLAB、Python版）</title>
    <url>/2015/03/26/%5B20150326%5D/</url>
    <content><![CDATA[<p>八皇后问题是一道经典的回溯问题。问题描述如下：皇后可以在横、竖、斜线上不限步数地吃掉其他棋子。如何将8个皇后放在棋盘上（有8*8个方格），使它们谁也不能被吃掉？</p>
<p>看到这个问题，最容易想到的就是遍历穷举法，不过仔细一想，思路虽然非常清晰，但是需要遍历次数太多，时间复杂度很高。那么，我们应该怎么办呢？下面给出算法思路：</p>
<p><strong>算法思想：</strong>首先尝试在第一行放置第一个皇后，然后在第二行放置第二个使之与前面的皇后不构成威胁，依此类推。如果发现不能放置下一个皇后，就回溯到上一步，试着将皇后放在其他的位置。最后，或者尝试完所有的可能或者找到解决方案。</p>
<p>这种算法思想与中国的一句古话“不撞南墙不回头”类似：一路向前走，直到走到死胡同，然后往回走，回到上一个岔路口，重新选择一个方向，继续向前走，直到到达目的地。</p>
<a id="more"></a>
<p>下面给出了该算法的具体实现，用C、MATLAB、PYTHON分别进行了实现，由于程序给出了比较详细的注释，因此就不对具体程序解释说明了。</p>
<h2 id="C语言实现："><a href="#C语言实现：" class="headerlink" title="C语言实现："></a>C语言实现：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 8<span class="comment">//棋盘大小</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> matrix[N][N];<span class="comment">//存储皇后的位置，其实也可以用一维数组表示</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintQueen</span><span class="params">()</span></span>;<span class="comment">//打印棋盘</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PlaceQueen</span><span class="params">(<span class="keyword">int</span> row)</span></span>;<span class="comment">//放置皇后</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Conflict</span><span class="params">(<span class="keyword">int</span> row,<span class="keyword">int</span> col)</span></span>;<span class="comment">//检查当前皇后是否与之前的冲突</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PlaceQueen(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintQueen</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> solutionNum=<span class="number">0</span>;<span class="comment">//看总共有多少种情况</span></span><br><span class="line">    solutionNum+=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> row,col;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"第%d种方法：\n"</span>,solutionNum);</span><br><span class="line">    <span class="keyword">for</span>(row=<span class="number">0</span>;row&lt;N;row+=<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(col=<span class="number">0</span>;col&lt;N;col+=<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[row][col])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"* "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"- "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Conflict</span><span class="params">(<span class="keyword">int</span> row,<span class="keyword">int</span> col)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> m = <span class="number">0</span>; m &lt;row ; m++) </span><br><span class="line">	&#123;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> n = <span class="number">0</span>; n &lt;N; n++)</span><br><span class="line">		&#123;   </span><br><span class="line">            <span class="keyword">if</span> (matrix[m][n] == <span class="number">1</span>) <span class="comment">//  每一行只有一个皇后  </span></span><br><span class="line">			&#123;  </span><br><span class="line">                <span class="keyword">if</span> ( n == col || <span class="built_in">abs</span>(row - m) == <span class="built_in">abs</span>(col - n) )   <span class="comment">// 检查是否与之前的皇后冲突</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PlaceQueen</span><span class="params">(<span class="keyword">int</span> row)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(row&gt;=N)<span class="comment">//已经放置了N个皇后</span></span><br><span class="line">	&#123;</span><br><span class="line">		PrintQueen();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> col=<span class="number">0</span>;col&lt;N;col++)</span><br><span class="line">		&#123;</span><br><span class="line">			matrix[row][col]=<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span>(row==<span class="number">0</span>||Conflict(row,col))</span><br><span class="line">					PlaceQueen(row+<span class="number">1</span>);<span class="comment">//递归调用		</span></span><br><span class="line">			matrix[row][col]=<span class="number">0</span>;		</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="MATLAB实现"><a href="#MATLAB实现" class="headerlink" title="MATLAB实现"></a>MATLAB实现</h2><h3 id="脚本文件Queen-m"><a href="#脚本文件Queen-m" class="headerlink" title="脚本文件Queen.m"></a>脚本文件Queen.m</h3><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"> clear all</span><br><span class="line">clc</span><br><span class="line"> </span><br><span class="line"><span class="keyword">global</span> solutionNum;</span><br><span class="line">solutionNum=<span class="number">0</span>;<span class="comment">%全局变量记录方法数</span></span><br><span class="line">N=<span class="number">8</span>;<span class="comment">%皇后个数</span></span><br><span class="line">matrix=<span class="built_in">zeros</span>(N);<span class="comment">%存储皇后位置信息</span></span><br><span class="line"> </span><br><span class="line">PlaceQueen(<span class="number">1</span>,matrix,N)<span class="comment">%调用放置方法</span></span><br></pre></td></tr></table></figure>
<h3 id="函数文件PlaceQueen-m"><a href="#函数文件PlaceQueen-m" class="headerlink" title="函数文件PlaceQueen.m"></a>函数文件PlaceQueen.m</h3><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">PlaceQueen</span><span class="params">(row,matrix,N)</span>%回溯法放置皇后</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> row&gt;N</span><br><span class="line">        PrintQueen(N,matrix);<span class="comment">%打印棋盘</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">for</span> col=<span class="number">1</span>:N</span><br><span class="line">            matrix(row,col)=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> row==<span class="number">1</span>||Conflict(row,col,N,matrix)<span class="comment">%检测是否冲突</span></span><br><span class="line">                PlaceQueen(row+<span class="number">1</span>,matrix,N);</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            matrix(row,col)=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">%子函数：检测冲突</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">result</span>=<span class="title">Conflict</span><span class="params">(row,col,N,matrix)</span>%检测是否冲突</span></span><br><span class="line"> </span><br><span class="line">    result=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:row<span class="number">-1</span></span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">j</span>=<span class="number">1</span>:N</span><br><span class="line">            <span class="keyword">if</span> matrix(<span class="built_in">i</span>,<span class="built_in">j</span>)==<span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> ((<span class="built_in">j</span>==col)||(<span class="built_in">abs</span>(row-<span class="built_in">i</span>)==<span class="built_in">abs</span>(col-<span class="built_in">j</span>)))<span class="comment">%是否产生冲突：在同一直线，斜线上</span></span><br><span class="line">                    result=<span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">if</span> result==<span class="number">0</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">     </span><br><span class="line">    <span class="comment">%子函数：打印棋盘信息</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">PrintQueen</span><span class="params">(N,matrix)</span></span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">global</span> solutionNum; <span class="comment">%定义全局变量，来累积方法数</span></span><br><span class="line">    solutionNum=solutionNum+<span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">disp</span>([<span class="string">'第'</span>,num2str(solutionNum),<span class="string">'种方法：'</span>])</span><br><span class="line"> </span><br><span class="line"><span class="built_in">disp</span>(matrix)</span><br></pre></td></tr></table></figure>
<h2 id="PYTHON实现："><a href="#PYTHON实现：" class="headerlink" title="PYTHON实现："></a>PYTHON实现：</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">conflict</span><span class="params">(state,nextX)</span>:</span><span class="comment">#冲突检测函数</span></span><br><span class="line">    nextY=len(state)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(nextY):</span><br><span class="line">        <span class="keyword">if</span> abs(state[i]-nextX) <span class="keyword">in</span> (<span class="number">0</span>,nextY-i):<span class="comment">#检测是否在同一直线、斜线</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">queens</span><span class="params">(num=<span class="number">8</span>,state=<span class="params">()</span>)</span>:</span> <span class="comment">#放置皇后,采用元组state来存储皇后的位置</span></span><br><span class="line">    <span class="keyword">for</span> pos <span class="keyword">in</span> range(num):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> conflict(state,pos):</span><br><span class="line">            <span class="keyword">if</span> len(state)==num<span class="number">-1</span>:</span><br><span class="line">                <span class="keyword">yield</span> (pos,)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">for</span> result <span class="keyword">in</span> queens(num,state+(pos,)):</span><br><span class="line">                    <span class="keyword">yield</span> (pos,)+result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> solution <span class="keyword">in</span> queens(<span class="number">8</span>):</span><br><span class="line">    <span class="keyword">print</span> (solution)</span><br><span class="line">    </span><br><span class="line">print(<span class="string">'总共的方法数为：'</span>,len(list(queens(<span class="number">8</span>))))</span><br></pre></td></tr></table></figure>
<hr>
<p><strong>运行结果分别如下：</strong></p>
<p>1、C语言的运行结果：</p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20150326/20150326_fig001.jpg" width="600" height="400" title="图1" alt="图1" ></p>
<p>2、MATLAB语言的运行结果：</p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20150326/20150326_fig002.jpg" width="500" height="600" title="图2" alt="图2" ></p>
<p>3、PYTHON语言的运行结果：</p>
<p> <img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20150326/20150326_fig003.jpg" width="400" height="400" title="图3" alt="图3" ></p>
<hr>
<h2 id="扩展："><a href="#扩展：" class="headerlink" title="扩展："></a>扩展：</h2><p>上面的程序中，改变N的值就可以解决N皇后的问题了，但还可以用分治法来解决N皇后的问题，具体参见文献《N皇后问题解的构造和等价性分析》。下面的Matlab程序给出了一个简单的算法过程：</p>
<p><strong>4皇后的一种放置方式：</strong></p>
<p>   0   0   1   0</p>
<p>   1   0   0   0</p>
<p>   0   0   0   1</p>
<p>   0   1   0   0</p>
<p><strong>根据4皇后的放置方式可以推导出16皇后的一种放置方式：</strong></p>
<p>   0   0   0   0   0   0   0   0   0   0   1   0   0   0   0   0</p>
<p>   0   0   0   0   0   0   0   0   1   0   0   0   0   0   0   0</p>
<p>   0   0   0   0   0   0   0   0   0   0   0   1   0   0   0   0</p>
<p>   0   0   0   0   0   0   0   0   0   1   0   0   0   0   0   0</p>
<p>   0   0   1   0   0   0   0   0   0   0   0   0   0   0   0   0</p>
<p>   1   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0</p>
<p>   0   0   0   1   0   0   0   0   0   0   0   0   0   0   0   0</p>
<p>   0   1   0   0   0   0   0   0   0   0   0   0   0   0   0   0</p>
<p>   0   0   0   0   0   0   0   0   0   0   0   0   0   0   1   0</p>
<p>   0   0   0   0   0   0   0   0   0   0   0   0   1   0   0   0</p>
<p>   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   1</p>
<p>   0   0   0   0   0   0   0   0   0   0   0   0   0   1   0   0</p>
<p>   0   0   0   0   0   0   1   0   0   0   0   0   0   0   0   0</p>
<p>   0   0   0   0   1   0   0   0   0   0   0   0   0   0   0   0</p>
<p>   0   0   0   0   0   0   0   1   0   0   0   0   0   0   0   0</p>
<p>   0   0   0   0   0   1   0   0   0   0   0   0   0   0   0   0</p>
<p>依次类推，可以得到4的幂次皇后的一种放置方式，不过<strong>值得注意的是</strong>：2、3、8、9、14、15、26、27、38、39这10个N值不能采用这种分治法。</p>
<p><strong>由4皇后直接推出16皇后的Matlab实现如下：</strong></p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clear all</span><br><span class="line">clc</span><br><span class="line"> </span><br><span class="line">a4=[  <span class="number">0</span>     <span class="number">0</span>     <span class="number">1</span>     <span class="number">0</span></span><br><span class="line">     <span class="number">1</span>     <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span></span><br><span class="line">     <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>     <span class="number">1</span></span><br><span class="line">     <span class="number">0</span>     <span class="number">1</span>     <span class="number">0</span>     <span class="number">0</span>]</span><br><span class="line"> [asize bsize]=<span class="built_in">size</span>(a4);</span><br><span class="line"> </span><br><span class="line"> a16=<span class="built_in">zeros</span>(asize^<span class="number">2</span>,bsize^<span class="number">2</span>);</span><br><span class="line"> [rowIndex,colIndex]=<span class="built_in">find</span>(a4);</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:<span class="built_in">length</span>(rowIndex)</span><br><span class="line">     a16((<span class="number">1</span>+asize*(rowIndex(<span class="built_in">i</span>)<span class="number">-1</span>)):asize*rowIndex(<span class="built_in">i</span>),(<span class="number">1</span>+asize*(colIndex(<span class="built_in">i</span>)<span class="number">-1</span>)):asize*colIndex(<span class="built_in">i</span>))=a4;</span><br><span class="line"> <span class="keyword">end</span></span><br><span class="line"> a16</span><br></pre></td></tr></table></figure>
<p><strong>运行结果如下：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20150326/20150326_fig004.jpg" width="600" height="500" title="图4" alt="图4" ></p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>Algorithm Design</tag>
      </tags>
  </entry>
  <entry>
    <title>【算法导论】矩阵乘法</title>
    <url>/2015/02/11/%5B20150211%5D/</url>
    <content><![CDATA[<p>离过年都不到十天了，还要等到这周五才能回家，想想也一年没回家了。从寒假开始到现在，已经有二十来天，这期间把2014年总结中的寒假计划也大多数完成了：The Element Of Style的阅读，三门数学课《随机过程》、《工程优化》、《数值分析》的算法实现。回家过年期间肯定不会写博客了，今天一看，这个月只写了三篇，于是乎今天必须再写一篇来完成这个月的基本工作量。言归正传，这篇文章写写选修课《算法设计》作业题中的矩阵乘法的三种方法。</p>
<a id="more"></a>
<hr>
<h1 id="矩阵乘法"><a href="#矩阵乘法" class="headerlink" title="矩阵乘法"></a>矩阵乘法</h1><hr>
<ul>
<li><p>传统方法</p>
<ul>
<li>理论公式</li>
</ul>
<script type="math/tex; mode=display">
C=AB\\C_{ij}=\sum\limits_{k=1}^{n}A_{ik}B_{kj}</script><ul>
<li><p>算法实现</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TraditionalMethod</span><span class="params">(<span class="keyword">float</span> A[][N],<span class="keyword">float</span> B[][N],<span class="keyword">float</span> C[][N])</span><span class="comment">//传统方法，三重循环</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;N;j++)</span><br><span class="line">            C[i][j]=<span class="number">0</span>;<span class="comment">//之所以每次调用都清零，是因为前面是循环调用，如果只调用一次就不需要</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;N;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;N;k++)</span><br><span class="line">            &#123;</span><br><span class="line">                C[i][j]=C[i][j]+A[i][k]*B[k][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><p>分块相乘法</p>
<ul>
<li><p>理论公式</p>
<script type="math/tex; mode=display">

A=\left[\begin{array}{cc}A_{11}&A_{21}\\A_{12}&A_{22}\end{array}\right],
B=\left[\begin{array}{cccc}B_{11}&B_{21}\\B_{12}&B_{22}\end{array}\right],
C=\left[\begin{array}{cc}C_{11}&C_{21}\\C_{12}&C_{22}\end{array}\right]\\
C_{11}=A_{11}B_{11}+A_{12}B_{21},
C_{12}=A_{11}B_{12}+A_{12}B_{22}\\
C_{21}=A_{21}B_{11}+A_{22}B_{21},
C_{22}=A_{21}B_{12}+A_{22}B_{22}</script></li>
<li><p>算法实现</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BlockMatrix</span><span class="params">()</span><span class="comment">//分块矩阵计算</span></span></span><br><span class="line"><span class="function"></span>&#123;     </span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N/<span class="number">2</span>;i++)              </span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;N/<span class="number">2</span>;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                A11[i][j]=A[i][j];</span><br><span class="line">                A12[i][j]=A[i][j+N/<span class="number">2</span>];</span><br><span class="line">                A21[i][j]=A[i+N/<span class="number">2</span>][j];</span><br><span class="line">                A22[i][j]=A[i+N/<span class="number">2</span>][j+N/<span class="number">2</span>];</span><br><span class="line">                B11[i][j]=B[i][j];</span><br><span class="line">                B12[i][j]=B[i][j+N/<span class="number">2</span>];</span><br><span class="line">                B21[i][j]=B[i+N/<span class="number">2</span>][j];</span><br><span class="line">                B22[i][j]=B[i+N/<span class="number">2</span>][j+N/<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">                C11[i][j]=<span class="number">0</span>;</span><br><span class="line">                C12[i][j]=<span class="number">0</span>;</span><br><span class="line">                C21[i][j]=<span class="number">0</span>;</span><br><span class="line">                C22[i][j]=<span class="number">0</span>;</span><br><span class="line">            &#125;       <span class="comment">//将矩阵A和B式分为四块</span></span><br><span class="line"></span><br><span class="line">         MATRIX_Multiply(N/<span class="number">2</span>,A11,B11, AA);</span><br><span class="line">         MATRIX_Multiply(N/<span class="number">2</span>,A12,B21, BB);</span><br><span class="line">         MATRIX_ADD(N/<span class="number">2</span>,AA,BB,C11); <span class="comment">//矩阵加法函数X+Y—&gt;Z</span></span><br><span class="line"></span><br><span class="line">         MATRIX_Multiply(N/<span class="number">2</span>,A11,B12, AA);</span><br><span class="line">         MATRIX_Multiply(N/<span class="number">2</span>,A12,B22, BB);</span><br><span class="line">         MATRIX_ADD(N/<span class="number">2</span>,AA,BB,C12); <span class="comment">//矩阵加法函数X+Y—&gt;Z</span></span><br><span class="line"></span><br><span class="line">         MATRIX_Multiply(N/<span class="number">2</span>,A21,B11, AA);</span><br><span class="line">         MATRIX_Multiply(N/<span class="number">2</span>,A22,B21, BB);</span><br><span class="line">         MATRIX_ADD(N/<span class="number">2</span>,AA,BB,C21); <span class="comment">//矩阵加法函数X+Y—&gt;Z</span></span><br><span class="line"></span><br><span class="line">         MATRIX_Multiply(N/<span class="number">2</span>,A21,B12, AA);</span><br><span class="line">         MATRIX_Multiply(N/<span class="number">2</span>,A22,B22, BB);</span><br><span class="line">         MATRIX_ADD(N/<span class="number">2</span>,AA,BB,C22); <span class="comment">//矩阵加法函数X+Y—&gt;Z</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N/<span class="number">2</span>;i++)<span class="comment">//将上面计算得到的结果放入结果矩阵C中</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;N/<span class="number">2</span>;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            C[i][j]=C11[i][j];</span><br><span class="line">            C[i][j+N/<span class="number">2</span>]=C12[i][j];</span><br><span class="line">            C[i+N/<span class="number">2</span>][j]=C21[i][j];</span><br><span class="line">            C[i+N/<span class="number">2</span>][j+N/<span class="number">2</span>]=C22[i][j];</span><br><span class="line">        &#125;                                            <span class="comment">//计算结果送回C[N][N]</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><p>Strassen法</p>
<ul>
<li><p>理论公式</p>
<script type="math/tex; mode=display">
M_1=A_{11}(B_{12}−B_{22}),M_2=B_{22}(A_{11}+A_{12}),M_3=B_{11}(A_{21}+A_{22})\\
M_4=A_{22}(B_{21}−B_{11}),M_5=(A_{11}+A_{22})(B_{11}+B_{22}),\\M_6=(A_{12}−A_{22})(B_{21}+B_{22}),M_7=(A_{12}−A_{21})(B_{11}+B_{12})\\
C_{11}=M_4+M_5+M_6−M_2,C_{12}=M_1+M_2,\\C_{21}=M_3+M_4,C_{22}=M_1+M_5−M_3−M_7</script></li>
<li><p>算法实现</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">STRASSEN</span><span class="params">()</span>  <span class="comment">//STRASSEN函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j;<span class="comment">//,x;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;N/<span class="number">2</span>;i++)              </span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;N/<span class="number">2</span>;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            A11[i][j]=A[i][j];</span><br><span class="line">            A12[i][j]=A[i][j+N/<span class="number">2</span>];</span><br><span class="line">            A21[i][j]=A[i+N/<span class="number">2</span>][j];</span><br><span class="line">            A22[i][j]=A[i+N/<span class="number">2</span>][j+N/<span class="number">2</span>];</span><br><span class="line">            B11[i][j]=B[i][j];</span><br><span class="line">            B12[i][j]=B[i][j+N/<span class="number">2</span>];</span><br><span class="line">            B21[i][j]=B[i+N/<span class="number">2</span>][j];</span><br><span class="line">            B22[i][j]=B[i+N/<span class="number">2</span>][j+N/<span class="number">2</span>];</span><br><span class="line">        &#125;       <span class="comment">//将矩阵A和B式分为四块</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    MATRIX_SUB(N/<span class="number">2</span>,B12,B22,BB);         </span><br><span class="line">    MATRIX_Multiply(N/<span class="number">2</span>,A11,BB,M1);</span><br><span class="line"></span><br><span class="line">    MATRIX_ADD(N/<span class="number">2</span>,A11,A12,AA);</span><br><span class="line">    MATRIX_Multiply(N/<span class="number">2</span>,AA,B22,M2);<span class="comment">//M2=(A11+A12)B22</span></span><br><span class="line"></span><br><span class="line">    MATRIX_ADD(N/<span class="number">2</span>,A21,A22,AA);</span><br><span class="line">    MATRIX_Multiply(N/<span class="number">2</span>,AA,B11,M3);<span class="comment">//M3=(A21+A22)B11</span></span><br><span class="line"></span><br><span class="line">    MATRIX_SUB(N/<span class="number">2</span>,B21,B11,BB);</span><br><span class="line">    MATRIX_Multiply(N/<span class="number">2</span>,A22,BB,M4);<span class="comment">//M4=A22(B21-B11)</span></span><br><span class="line"></span><br><span class="line">    MATRIX_ADD(N/<span class="number">2</span>,A11,A22,AA);</span><br><span class="line">    MATRIX_ADD(N/<span class="number">2</span>,B11,B22,BB);</span><br><span class="line">    MATRIX_Multiply(N/<span class="number">2</span>,AA,BB,M5);<span class="comment">//M5=(A11+A22)(B11+B22)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    MATRIX_SUB(N/<span class="number">2</span>,A12,A22,AA);</span><br><span class="line">    MATRIX_ADD(N/<span class="number">2</span>,B21,B22,BB);</span><br><span class="line">    MATRIX_Multiply(N/<span class="number">2</span>,AA,BB,M6);<span class="comment">//M6=(A12-A22)(B21+B22)</span></span><br><span class="line"></span><br><span class="line">    MATRIX_SUB(N/<span class="number">2</span>,A11,A21,AA);</span><br><span class="line">    MATRIX_ADD(N/<span class="number">2</span>,B11,B12,BB);</span><br><span class="line">    MATRIX_Multiply(N/<span class="number">2</span>,AA,BB,M7);<span class="comment">//M7=(A11-A21)(B11+B12)</span></span><br><span class="line">    <span class="comment">//计算M1,M2,M3,M4,M5,M6,M7（递归部分）</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    MATRIX_ADD(N/<span class="number">2</span>,M5,M4,MM1);                </span><br><span class="line">    MATRIX_SUB(N/<span class="number">2</span>,M2,M6,MM2);</span><br><span class="line">    MATRIX_SUB(N/<span class="number">2</span>,MM1,MM2,C11);<span class="comment">//C11=M5+M4-M2+M6</span></span><br><span class="line"></span><br><span class="line">    MATRIX_ADD(N/<span class="number">2</span>,M1,M2,C12);<span class="comment">//C12=M1+M2</span></span><br><span class="line"></span><br><span class="line">    MATRIX_ADD(N/<span class="number">2</span>,M3,M4,C21);<span class="comment">//C21=M3+M4</span></span><br><span class="line"></span><br><span class="line">    MATRIX_ADD(N/<span class="number">2</span>,M5,M1,MM1);</span><br><span class="line">    MATRIX_ADD(N/<span class="number">2</span>,M3,M7,MM2);</span><br><span class="line">    MATRIX_SUB(N/<span class="number">2</span>,MM1,MM2,C22);<span class="comment">//C22=M5+M1-M3-M7</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;N/<span class="number">2</span>;i++)</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;N/<span class="number">2</span>;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            C[i][j]=C11[i][j];</span><br><span class="line">            C[i][j+N/<span class="number">2</span>]=C12[i][j];</span><br><span class="line">            C[i+N/<span class="number">2</span>][j]=C21[i][j];</span><br><span class="line">            C[i+N/<span class="number">2</span>][j+N/<span class="number">2</span>]=C22[i][j];</span><br><span class="line">        &#125;                                            <span class="comment">//计算结果送回C[N][N]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><strong>完整程序实现</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include&lt;ctime&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N&#x3D;32; &#x2F;&#x2F;常量N用来定义方阵的大小</span><br><span class="line">void output(int n,float C[][N]); &#x2F;&#x2F;函数声明部分</span><br><span class="line">void TraditionalMethod(float A[][N],float B[][N],float C[][N]);&#x2F;&#x2F;传统的矩阵相乘</span><br><span class="line">void BlockMatrix();</span><br><span class="line">void STRASSEN();</span><br><span class="line">void MATRIX_Multiply(int n,float A[][N&#x2F;2],float B[][N&#x2F;2],float C[][N&#x2F;2]);</span><br><span class="line"></span><br><span class="line">float A[N][N];</span><br><span class="line">float B[N][N];</span><br><span class="line">float C[N][N];  &#x2F;&#x2F;定义三个矩阵A,B,C</span><br><span class="line"></span><br><span class="line">float A11[N&#x2F;2][N&#x2F;2],A12[N&#x2F;2][N&#x2F;2],A21[N&#x2F;2][N&#x2F;2],A22[N&#x2F;2][N&#x2F;2];</span><br><span class="line">float B11[N&#x2F;2][N&#x2F;2],B12[N&#x2F;2][N&#x2F;2],B21[N&#x2F;2][N&#x2F;2],B22[N&#x2F;2][N&#x2F;2];</span><br><span class="line">float C11[N&#x2F;2][N&#x2F;2],C12[N&#x2F;2][N&#x2F;2],C21[N&#x2F;2][N&#x2F;2],C22[N&#x2F;2][N&#x2F;2];</span><br><span class="line">float M1[N&#x2F;2][N&#x2F;2],M2[N&#x2F;2][N&#x2F;2],M3[N&#x2F;2][N&#x2F;2],M4[N&#x2F;2][N&#x2F;2],M5[N&#x2F;2][N&#x2F;2],M6[N&#x2F;2][N&#x2F;2],M7[N&#x2F;2][N&#x2F;2];</span><br><span class="line">float AA[N&#x2F;2][N&#x2F;2],BB[N&#x2F;2][N&#x2F;2],MM1[N&#x2F;2][N&#x2F;2],MM2[N&#x2F;2][N&#x2F;2];</span><br><span class="line">void MATRIX_ADD(int n,float X[][N&#x2F;2],float Y[][N&#x2F;2],float Z[][N&#x2F;2]); &#x2F;&#x2F;矩阵加法函数X+Y—&gt;Z</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">  &#x2F;&#x2F;初始化，使相乘的两个矩阵都为全1矩阵</span><br><span class="line">    for(int i&#x3D;0;i&lt;N;i++)</span><br><span class="line">        for(int j&#x3D;0;j&lt;N;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            A[i][j]&#x3D;1;</span><br><span class="line">            B[i][j]&#x3D;1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#x2F;&#x2F;将结果矩阵C初始化为全0矩阵</span><br><span class="line">    for(int i&#x3D;0;i&lt;N;i++)</span><br><span class="line">        for(int j&#x3D;0;j&lt;N;j++)</span><br><span class="line">            C[i][j]&#x3D;0;</span><br><span class="line"></span><br><span class="line">    clock_t start, finish; &#x2F;&#x2F;用于计时</span><br><span class="line">    double   duration; </span><br><span class="line">    int loop&#x3D;0;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;&quot;当矩阵为&quot;&lt;&lt;N&lt;&lt;&quot;×&quot;&lt;&lt;N&lt;&lt;&quot;，循环次数为10000时：&quot;&lt;&lt;endl&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;--------使用传统方法--------------&#x2F;&#x2F;</span><br><span class="line">    start &#x3D; clock();  </span><br><span class="line">    while(loop&lt;10000)&#x2F;&#x2F;循环10000次,这里可以更改</span><br><span class="line">    &#123;</span><br><span class="line">        loop++;</span><br><span class="line">        TraditionalMethod(A,B,C);   &#x2F;&#x2F;传统方法计算</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    finish &#x3D; clock(); </span><br><span class="line">    duration &#x3D; (double)(finish - start) &#x2F; CLOCKS_PER_SEC; </span><br><span class="line">    cout&lt;&lt;&quot;使用传统方法：&quot;&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;&quot;所需时间为：&quot;&lt;&lt;duration&lt;&lt;endl&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;  output(N,C);  &#x2F;&#x2F;输出计算结果</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;---------使用分块矩阵乘法------------&#x2F;&#x2F;</span><br><span class="line">    start &#x3D; clock();  </span><br><span class="line">    loop&#x3D;0;</span><br><span class="line">    while(loop&lt;10000)&#x2F;&#x2F;循环10000次,这里可以更改</span><br><span class="line">    &#123;</span><br><span class="line">        loop++;</span><br><span class="line">        BlockMatrix();   &#x2F;&#x2F;分块矩阵计算</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    finish &#x3D; clock(); </span><br><span class="line">    duration &#x3D; (double)(finish - start) &#x2F; CLOCKS_PER_SEC; </span><br><span class="line">    cout&lt;&lt;&quot;使用分块相乘方法：&quot;&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;&quot;所需时间为：&quot;&lt;&lt;duration&lt;&lt;endl&lt;&lt;endl;</span><br><span class="line">    &#x2F;&#x2F;  output(N,C);  &#x2F;&#x2F;输出计算结果</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;-------使用strassen方法-------------------&#x2F;&#x2F;</span><br><span class="line">    start &#x3D; clock();  </span><br><span class="line">    loop&#x3D;0;</span><br><span class="line">    while(loop&lt;10000)&#x2F;&#x2F;当时间非常小时，需要加大循环次数,这里可以更改</span><br><span class="line">    &#123;</span><br><span class="line">        loop++;</span><br><span class="line">        STRASSEN();   &#x2F;&#x2F;调用STRASSEN函数计算      </span><br><span class="line">    &#125;</span><br><span class="line">    finish &#x3D; clock(); </span><br><span class="line">    duration &#x3D; (double)(finish - start) &#x2F; CLOCKS_PER_SEC; </span><br><span class="line">    cout&lt;&lt;&quot;使用strassen方法：&quot;&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;&quot;所需时间为：&quot;&lt;&lt;duration&lt;&lt;endl;</span><br><span class="line">&#x2F;&#x2F;  output(N,C);  &#x2F;&#x2F;输出计算结果</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void TraditionalMethod(float A[][N],float B[][N],float C[][N])&#x2F;&#x2F;传统方法，三重循环</span><br><span class="line">&#123;</span><br><span class="line">    for(int i&#x3D;0;i&lt;N;i++)</span><br><span class="line">        for(int j&#x3D;0;j&lt;N;j++)</span><br><span class="line">            C[i][j]&#x3D;0;&#x2F;&#x2F;之所以每次调用都清零，是因为前面是循环调用，如果只调用一次就不需要</span><br><span class="line">    for(int i&#x3D;0;i&lt;N;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for(int j&#x3D;0;j&lt;N;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            for(int k&#x3D;0;k&lt;N;k++)</span><br><span class="line">            &#123;</span><br><span class="line">                C[i][j]&#x3D;C[i][j]+A[i][k]*B[k][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void BlockMatrix()&#x2F;&#x2F;分块矩阵计算</span><br><span class="line">&#123;     </span><br><span class="line">      for(int i&#x3D;0;i&lt;N&#x2F;2;i++)              </span><br><span class="line">         for(int j&#x3D;0;j&lt;N&#x2F;2;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                A11[i][j]&#x3D;A[i][j];</span><br><span class="line">                A12[i][j]&#x3D;A[i][j+N&#x2F;2];</span><br><span class="line">                A21[i][j]&#x3D;A[i+N&#x2F;2][j];</span><br><span class="line">                A22[i][j]&#x3D;A[i+N&#x2F;2][j+N&#x2F;2];</span><br><span class="line">                B11[i][j]&#x3D;B[i][j];</span><br><span class="line">                B12[i][j]&#x3D;B[i][j+N&#x2F;2];</span><br><span class="line">                B21[i][j]&#x3D;B[i+N&#x2F;2][j];</span><br><span class="line">                B22[i][j]&#x3D;B[i+N&#x2F;2][j+N&#x2F;2];</span><br><span class="line"></span><br><span class="line">                C11[i][j]&#x3D;0;</span><br><span class="line">                C12[i][j]&#x3D;0;</span><br><span class="line">                C21[i][j]&#x3D;0;</span><br><span class="line">                C22[i][j]&#x3D;0;</span><br><span class="line">            &#125;       &#x2F;&#x2F;将矩阵A和B式分为四块</span><br><span class="line"></span><br><span class="line">         MATRIX_Multiply(N&#x2F;2,A11,B11, AA);</span><br><span class="line">         MATRIX_Multiply(N&#x2F;2,A12,B21, BB);</span><br><span class="line">         MATRIX_ADD(N&#x2F;2,AA,BB,C11); &#x2F;&#x2F;矩阵加法函数X+Y—&gt;Z</span><br><span class="line"></span><br><span class="line">         MATRIX_Multiply(N&#x2F;2,A11,B12, AA);</span><br><span class="line">         MATRIX_Multiply(N&#x2F;2,A12,B22, BB);</span><br><span class="line">         MATRIX_ADD(N&#x2F;2,AA,BB,C12); &#x2F;&#x2F;矩阵加法函数X+Y—&gt;Z</span><br><span class="line"></span><br><span class="line">         MATRIX_Multiply(N&#x2F;2,A21,B11, AA);</span><br><span class="line">         MATRIX_Multiply(N&#x2F;2,A22,B21, BB);</span><br><span class="line">         MATRIX_ADD(N&#x2F;2,AA,BB,C21); &#x2F;&#x2F;矩阵加法函数X+Y—&gt;Z</span><br><span class="line"></span><br><span class="line">         MATRIX_Multiply(N&#x2F;2,A21,B12, AA);</span><br><span class="line">         MATRIX_Multiply(N&#x2F;2,A22,B22, BB);</span><br><span class="line">         MATRIX_ADD(N&#x2F;2,AA,BB,C22); &#x2F;&#x2F;矩阵加法函数X+Y—&gt;Z</span><br><span class="line"></span><br><span class="line">    for(int i&#x3D;0;i&lt;N&#x2F;2;i++)&#x2F;&#x2F;将上面计算得到的结果放入结果矩阵C中</span><br><span class="line">        for(int j&#x3D;0;j&lt;N&#x2F;2;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            C[i][j]&#x3D;C11[i][j];</span><br><span class="line">            C[i][j+N&#x2F;2]&#x3D;C12[i][j];</span><br><span class="line">            C[i+N&#x2F;2][j]&#x3D;C21[i][j];</span><br><span class="line">            C[i+N&#x2F;2][j+N&#x2F;2]&#x3D;C22[i][j];</span><br><span class="line">        &#125;                                            &#x2F;&#x2F;计算结果送回C[N][N]</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void output(int n,float C[][N]) &#x2F;&#x2F;矩阵输出函数</span><br><span class="line">&#123;</span><br><span class="line">    int i,j;</span><br><span class="line">    cout&lt;&lt;&quot;输出矩阵:&quot;&lt;&lt;endl;</span><br><span class="line">    for(i&#x3D;0;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">        for(j&#x3D;0;j&lt;n;j++)</span><br><span class="line">            cout&lt;&lt;C[i][j]&lt;&lt;&quot;  &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void MATRIX_Multiply(int n,float A[][N&#x2F;2],float B[][N&#x2F;2],float C[][N&#x2F;2])&#x2F;&#x2F;矩阵加法函数X*Y—&gt;C</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    for(int i&#x3D;0;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for(int j&#x3D;0;j&lt;n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            C[i][j]&#x3D;0;</span><br><span class="line">            for(int k&#x3D;0;k&lt;n;k++)</span><br><span class="line">            &#123;</span><br><span class="line">                C[i][j]&#x3D;C[i][j]+A[i][k]*B[k][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void MATRIX_ADD(int n,float X[][N&#x2F;2],float Y[][N&#x2F;2],float Z[][N&#x2F;2]) &#x2F;&#x2F;矩阵加法函数X+Y—&gt;Z</span><br><span class="line">&#123;</span><br><span class="line">    int i,j;</span><br><span class="line">    for(i&#x3D;0;i&lt;n;i++)</span><br><span class="line">        for(j&#x3D;0;j&lt;n;j++)</span><br><span class="line">            Z[i][j]&#x3D;X[i][j]+Y[i][j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void MATRIX_SUB(int n,float X[][N&#x2F;2],float Y[][N&#x2F;2],float Z[][N&#x2F;2]) &#x2F;&#x2F;矩阵减法函数X-Y—&gt;Z</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    int i,j;</span><br><span class="line">    for(i&#x3D;0;i&lt;n;i++)</span><br><span class="line">        for(j&#x3D;0;j&lt;n;j++)</span><br><span class="line">            Z[i][j]&#x3D;X[i][j]-Y[i][j];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void STRASSEN()  &#x2F;&#x2F;STRASSEN函数</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    int i,j;&#x2F;&#x2F;,x;</span><br><span class="line"></span><br><span class="line">    for(i&#x3D;0;i&lt;N&#x2F;2;i++)              </span><br><span class="line">        for(j&#x3D;0;j&lt;N&#x2F;2;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            A11[i][j]&#x3D;A[i][j];</span><br><span class="line">            A12[i][j]&#x3D;A[i][j+N&#x2F;2];</span><br><span class="line">            A21[i][j]&#x3D;A[i+N&#x2F;2][j];</span><br><span class="line">            A22[i][j]&#x3D;A[i+N&#x2F;2][j+N&#x2F;2];</span><br><span class="line">            B11[i][j]&#x3D;B[i][j];</span><br><span class="line">            B12[i][j]&#x3D;B[i][j+N&#x2F;2];</span><br><span class="line">            B21[i][j]&#x3D;B[i+N&#x2F;2][j];</span><br><span class="line">            B22[i][j]&#x3D;B[i+N&#x2F;2][j+N&#x2F;2];</span><br><span class="line">        &#125;       &#x2F;&#x2F;将矩阵A和B式分为四块</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    MATRIX_SUB(N&#x2F;2,B12,B22,BB);         </span><br><span class="line">    MATRIX_Multiply(N&#x2F;2,A11,BB,M1);</span><br><span class="line"></span><br><span class="line">    MATRIX_ADD(N&#x2F;2,A11,A12,AA);</span><br><span class="line">    MATRIX_Multiply(N&#x2F;2,AA,B22,M2);&#x2F;&#x2F;M2&#x3D;(A11+A12)B22</span><br><span class="line"></span><br><span class="line">    MATRIX_ADD(N&#x2F;2,A21,A22,AA);</span><br><span class="line">    MATRIX_Multiply(N&#x2F;2,AA,B11,M3);&#x2F;&#x2F;M3&#x3D;(A21+A22)B11</span><br><span class="line"></span><br><span class="line">    MATRIX_SUB(N&#x2F;2,B21,B11,BB);</span><br><span class="line">    MATRIX_Multiply(N&#x2F;2,A22,BB,M4);&#x2F;&#x2F;M4&#x3D;A22(B21-B11)</span><br><span class="line"></span><br><span class="line">    MATRIX_ADD(N&#x2F;2,A11,A22,AA);</span><br><span class="line">    MATRIX_ADD(N&#x2F;2,B11,B22,BB);</span><br><span class="line">    MATRIX_Multiply(N&#x2F;2,AA,BB,M5);&#x2F;&#x2F;M5&#x3D;(A11+A22)(B11+B22)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    MATRIX_SUB(N&#x2F;2,A12,A22,AA);</span><br><span class="line">    MATRIX_ADD(N&#x2F;2,B21,B22,BB);</span><br><span class="line">    MATRIX_Multiply(N&#x2F;2,AA,BB,M6);&#x2F;&#x2F;M6&#x3D;(A12-A22)(B21+B22)</span><br><span class="line"></span><br><span class="line">    MATRIX_SUB(N&#x2F;2,A11,A21,AA);</span><br><span class="line">    MATRIX_ADD(N&#x2F;2,B11,B12,BB);</span><br><span class="line">    MATRIX_Multiply(N&#x2F;2,AA,BB,M7);&#x2F;&#x2F;M7&#x3D;(A11-A21)(B11+B12)</span><br><span class="line">    &#x2F;&#x2F;计算M1,M2,M3,M4,M5,M6,M7（递归部分）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    MATRIX_ADD(N&#x2F;2,M5,M4,MM1);                </span><br><span class="line">    MATRIX_SUB(N&#x2F;2,M2,M6,MM2);</span><br><span class="line">    MATRIX_SUB(N&#x2F;2,MM1,MM2,C11);&#x2F;&#x2F;C11&#x3D;M5+M4-M2+M6</span><br><span class="line"></span><br><span class="line">    MATRIX_ADD(N&#x2F;2,M1,M2,C12);&#x2F;&#x2F;C12&#x3D;M1+M2</span><br><span class="line"></span><br><span class="line">    MATRIX_ADD(N&#x2F;2,M3,M4,C21);&#x2F;&#x2F;C21&#x3D;M3+M4</span><br><span class="line"></span><br><span class="line">    MATRIX_ADD(N&#x2F;2,M5,M1,MM1);</span><br><span class="line">    MATRIX_ADD(N&#x2F;2,M3,M7,MM2);</span><br><span class="line">    MATRIX_SUB(N&#x2F;2,MM1,MM2,C22);&#x2F;&#x2F;C22&#x3D;M5+M1-M3-M7</span><br><span class="line"></span><br><span class="line">    for(i&#x3D;0;i&lt;N&#x2F;2;i++)</span><br><span class="line">        for(j&#x3D;0;j&lt;N&#x2F;2;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            C[i][j]&#x3D;C11[i][j];</span><br><span class="line">            C[i][j+N&#x2F;2]&#x3D;C12[i][j];</span><br><span class="line">            C[i+N&#x2F;2][j]&#x3D;C21[i][j];</span><br><span class="line">            C[i+N&#x2F;2][j+N&#x2F;2]&#x3D;C22[i][j];</span><br><span class="line">        &#125;                                            &#x2F;&#x2F;计算结果送回C[N][N]   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下图：</p>
<p>​     <img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20150211/20150211_fig001.jpg" width="600" height="400" title="图1" alt="图1" ></p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>Algorithm Design</tag>
      </tags>
  </entry>
  <entry>
    <title>【工程优化】最优化算法--牛顿法、阻尼牛顿法及单纯形法</title>
    <url>/2015/02/09/%5B20150209%5D/</url>
    <content><![CDATA[<h2 id="牛顿法"><a href="#牛顿法" class="headerlink" title="牛顿法"></a>牛顿法</h2><p><strong>使用条件</strong>：目标函数具有二阶导数，且海塞矩阵正定。</p>
<p><strong>优缺点</strong>： 收敛速度快、计算量大、很依赖初始点的选择。</p>
<p><strong>算法的基本步骤：</strong></p>
<p>已知目标函数$f(x)$，梯度$g(x)$, Hessan矩阵$G(x)$, 给定误差限$\epsilon$:</p>
<ul>
<li>步骤1：选定初始点$x_0$，计算$f_0=f(x_0), k=0$;</li>
<li>步骤2：计算$g_k=g(x_k)$，如果$\Vert g_k\Vert\le\epsilon$, 算法停止, $x^\star=x_k$，否则转到步骤3：</li>
<li>步骤3：计算$G_k=G(x_k)$, 由方程$G_kd^k=-g_k$, 解得$d^k$;</li>
<li>步骤4：令$x_{k+1}=x_k+d^{k}, k=k+1$, 转到步骤2</li>
</ul>
<p><strong>算法流程图</strong>：</p>
<p>​     <img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20150209/20150209_fig001.jpg" width="450" height="200" title="图1" alt="图1" ></p>
<a id="more"></a>
<hr>
<h2 id="阻尼牛顿法"><a href="#阻尼牛顿法" class="headerlink" title="阻尼牛顿法"></a>阻尼牛顿法</h2><p>与牛顿法基本相同，<strong>只是加入了一维精确搜索</strong>。在牛顿迭代中，取$d^{(k)}=-[\nabla^2f(x^{(k)}) ]^{-1}\nabla f(x^{(k)}) $ , 加入精确一维搜索：$\min f(x^{(k)}+\lambda_kd^{(k)})$, 求得$\lambda_k$, 然后更新：$x^{(k+1)}=x^{(k)}+\lambda_kd^{(k)}$.</p>
<p><strong>优缺点</strong>：改善了局部收敛性。</p>
<p><strong>我们假设要求$f=(x-1)\cdot(x-1)+y\cdot y$的最小值，具体算法实现如下，只需要运行NTTest.m文件，其它函数文件放在同一目录下即可：</strong></p>
<p><strong>1、脚本文件NTTest.m</strong></p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clear all</span><br><span class="line">clc</span><br><span class="line"> </span><br><span class="line">syms x y</span><br><span class="line">f=(x<span class="number">-1</span>)*(x<span class="number">-1</span>)+y*y;</span><br><span class="line">var=[x y];</span><br><span class="line">x0=[<span class="number">1</span> <span class="number">1</span>];<span class="built_in">eps</span>=<span class="number">0.000001</span>;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">disp</span>(<span class="string">'牛顿法:'</span>)</span><br><span class="line">minNT(f,x0,var,<span class="built_in">eps</span>)</span><br><span class="line"> </span><br><span class="line"><span class="built_in">disp</span>(<span class="string">'阻尼牛顿法:'</span>)</span><br><span class="line">minMNT(f,x0,var,<span class="built_in">eps</span>)</span><br></pre></td></tr></table></figure>
<p><strong>2、minNT.m</strong></p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">function</span> <span class="params">[x,minf]</span>=<span class="title">minNT</span><span class="params">(f,x0,var,eps)</span></span></span><br><span class="line"><span class="comment">%目标函数：f</span></span><br><span class="line"><span class="comment">%初始点：x0</span></span><br><span class="line"><span class="comment">%自变量向量：var</span></span><br><span class="line"><span class="comment">%精度：eps</span></span><br><span class="line"><span class="comment">%目标函数取最小值时的自变量值：x;</span></span><br><span class="line"><span class="comment">%目标函数的最小值：minf</span></span><br><span class="line"> </span><br><span class="line">format long;</span><br><span class="line"><span class="keyword">if</span> nargin==<span class="number">3</span></span><br><span class="line">    <span class="built_in">eps</span>=<span class="number">1.0e-6</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">tol=<span class="number">1</span>;</span><br><span class="line">syms L</span><br><span class="line"><span class="comment">% x0=transpose(x0);</span></span><br><span class="line"><span class="keyword">while</span> tol&gt;<span class="built_in">eps</span> <span class="comment">%不满足精度要求          </span></span><br><span class="line">    gradf=jacobian(f,var);      <span class="comment">%梯度方向</span></span><br><span class="line">    jacf=jacobian(gradf,var);   <span class="comment">%雅克比矩阵</span></span><br><span class="line">    v=Funval(gradf,var,x0);<span class="comment">%梯度的数值解</span></span><br><span class="line">    tol=norm(v);<span class="comment">%计算梯度（即一阶导）的大小</span></span><br><span class="line">    pv=Funval(jacf,var,x0);<span class="comment">%二阶导的数值解</span></span><br><span class="line">    p=-inv(pv)*transpose(v);    <span class="comment">%搜索方向</span></span><br><span class="line">    x1=x0+p';<span class="comment">%进行迭代</span></span><br><span class="line">    x0=x1;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line">x=x1;</span><br><span class="line">minf=Funval(f,var,x);</span><br><span class="line">format short;</span><br></pre></td></tr></table></figure>
<p><strong>3、minMNT.m</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function [x,minf]&#x3D;minMNT(f,x0,var,eps)</span><br><span class="line">%目标函数：f</span><br><span class="line">%初始点：x0</span><br><span class="line">%自变量向量：var</span><br><span class="line">%精度：eps</span><br><span class="line">%目标函数取最小值时的自变量值：x;</span><br><span class="line">%目标函数的最小值：minf</span><br><span class="line"> </span><br><span class="line">format long;</span><br><span class="line">if nargin&#x3D;&#x3D;3</span><br><span class="line">    eps&#x3D;1.0e-6;</span><br><span class="line">end</span><br><span class="line">tol&#x3D;1;</span><br><span class="line">syms L</span><br><span class="line">% x0&#x3D;transpose(x0);</span><br><span class="line">while tol&gt;eps %不满足精度要求          </span><br><span class="line">    gradf&#x3D;jacobian(f,var);      %梯度方向</span><br><span class="line">    jacf&#x3D;jacobian(gradf,var);   %雅克比矩阵</span><br><span class="line">    v&#x3D;Funval(gradf,var,x0);%梯度的数值解</span><br><span class="line">    tol&#x3D;norm(v);%计算梯度（即一阶导）的大小</span><br><span class="line">    pv&#x3D;Funval(jacf,var,x0);%二阶导的数值解</span><br><span class="line">    p&#x3D;-inv(pv)*transpose(v);    %搜索方向</span><br><span class="line">    %%%%寻找最佳步长%%%</span><br><span class="line">    y&#x3D;x0+L*p&#39;;</span><br><span class="line">    yf&#x3D;Funval(f,var,y);</span><br><span class="line">    [a,b]&#x3D;minJT(yf,0,0.1);</span><br><span class="line">    xm&#x3D;minHJ(yf,a,b);           %黄金分割法进行一维搜索最佳步长</span><br><span class="line">    x1&#x3D;x0+xm*p&#39;;%进行迭代</span><br><span class="line">    x0&#x3D;x1;</span><br><span class="line"> </span><br><span class="line">end</span><br><span class="line"> </span><br><span class="line">x&#x3D;double(x1);</span><br><span class="line">minf&#x3D;double(Funval(f,var,x));</span><br><span class="line">format short;</span><br></pre></td></tr></table></figure>
<p><strong>4、minHJ.m</strong></p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[x,minf]</span>=<span class="title">minHJ</span><span class="params">(f,a,b,eps)</span></span></span><br><span class="line"><span class="comment">%目标函数：f</span></span><br><span class="line"><span class="comment">%极值区间左端点：a</span></span><br><span class="line"><span class="comment">%极值区间右端点：b</span></span><br><span class="line"><span class="comment">%精度：eps</span></span><br><span class="line"><span class="comment">%目标函数取最小值时自变量的值：x</span></span><br><span class="line"><span class="comment">%目标函数所取的最小值：minf</span></span><br><span class="line"> </span><br><span class="line">format long;</span><br><span class="line"><span class="keyword">if</span> nargin==<span class="number">3</span></span><br><span class="line">    <span class="built_in">eps</span>=<span class="number">1.0e-6</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line">l=a+<span class="number">0.382</span>*(b-a);            <span class="comment">%试探点</span></span><br><span class="line">u=a+<span class="number">0.618</span>*(b-a);            <span class="comment">%试探点</span></span><br><span class="line">k=<span class="number">1</span>;</span><br><span class="line">tol=b-a;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">while</span> tol&gt;<span class="built_in">eps</span>&amp;&amp;k&lt;<span class="number">100000</span></span><br><span class="line">    fl=subs(f,findsym(f),l);        <span class="comment">%试探点函数值</span></span><br><span class="line">    fu=subs(f,findsym(f),u);        <span class="comment">%试探点函数值</span></span><br><span class="line">    <span class="keyword">if</span> fl&gt;fu</span><br><span class="line">        a=<span class="number">1</span>;                        <span class="comment">%改变区间左端点</span></span><br><span class="line">        l=u;</span><br><span class="line">        u=a+<span class="number">0.618</span>*(b-a);            <span class="comment">%缩短搜索区间</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        b=u;                        <span class="comment">%改变区间右端点</span></span><br><span class="line">        u=l;</span><br><span class="line">        l=a+<span class="number">0.382</span>*(b-a);             <span class="comment">%缩短搜索区间</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    k=k+<span class="number">1</span>;</span><br><span class="line">    tol=<span class="built_in">abs</span>(b-a);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">if</span> k==<span class="number">100000</span></span><br><span class="line">    <span class="built_in">disp</span>(<span class="string">'找不到最小值！'</span>);</span><br><span class="line">    x=NaN;</span><br><span class="line">    minf=NaN;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">x=(a+b)/<span class="number">2</span>;</span><br><span class="line">minf=subs(f,findsym(f),x);</span><br><span class="line">format short;</span><br></pre></td></tr></table></figure>
<p><strong>5、minJT.m</strong></p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[minx,maxx]</span>=<span class="title">minJT</span><span class="params">(f,x0,h0,eps)</span></span></span><br><span class="line"><span class="comment">%目标函数：f</span></span><br><span class="line"><span class="comment">%初始点：x0</span></span><br><span class="line"><span class="comment">%初始步长：h0</span></span><br><span class="line"><span class="comment">%精度：eps</span></span><br><span class="line"><span class="comment">%目标函数取包含极值的区间左端点：minx</span></span><br><span class="line"><span class="comment">%目标函数取包含极值的区间右端点：maxx</span></span><br><span class="line"> </span><br><span class="line">format long</span><br><span class="line"><span class="keyword">if</span> nargin==<span class="number">3</span></span><br><span class="line">    <span class="built_in">eps</span>=<span class="number">1.0e-6</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line">x1=x0;</span><br><span class="line">k=<span class="number">0</span>;</span><br><span class="line">h=h0;</span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span></span><br><span class="line">    x4=x1+h;        <span class="comment">%试探步</span></span><br><span class="line">    k=k+<span class="number">1</span>;</span><br><span class="line">    f4=subs(f,findsym(f),x4);</span><br><span class="line">    f1=subs(f,findsym(f),x1);</span><br><span class="line">    <span class="keyword">if</span> f4&lt;f1</span><br><span class="line">        x2=x1;</span><br><span class="line">        x1=x4;</span><br><span class="line">        f2=f1;</span><br><span class="line">        f1=f4;</span><br><span class="line">        h=<span class="number">2</span>*h;      <span class="comment">%加大步长</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">if</span> k==<span class="number">1</span></span><br><span class="line">            h=-h;   <span class="comment">%方向搜索</span></span><br><span class="line">            x2=x4;</span><br><span class="line">            f2=f4;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            x3=x2;</span><br><span class="line">            x2=x1;</span><br><span class="line">            x1=x4;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line">minx=<span class="built_in">min</span>(x1,x3);</span><br><span class="line">maxx=x1+x3-minx;</span><br><span class="line">format short;</span><br></pre></td></tr></table></figure>
<p><strong>6、Funval.m</strong></p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fv</span>=<span class="title">Funval</span><span class="params">(f,varvec,varval)</span></span></span><br><span class="line">var=findsym(f);</span><br><span class="line">varc=findsym(varvec);</span><br><span class="line">s1=<span class="built_in">length</span>(var);</span><br><span class="line">s2=<span class="built_in">length</span>(varc);</span><br><span class="line">m=<span class="built_in">floor</span>((s1<span class="number">-1</span>)/<span class="number">3</span>+<span class="number">1</span>);</span><br><span class="line">varv=<span class="built_in">zeros</span>(<span class="number">1</span>,m);</span><br><span class="line"><span class="keyword">if</span> s1~=s2</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">0</span>:((s1<span class="number">-1</span>)/<span class="number">3</span>)</span><br><span class="line">        k=findstr(varc,var(<span class="number">3</span>*<span class="built_in">i</span>+<span class="number">1</span>));</span><br><span class="line">        index=(k<span class="number">-1</span>)/<span class="number">3</span>;</span><br><span class="line">        varv(<span class="built_in">i</span>+<span class="number">1</span>)=varval(index+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    fv=subs(f,var,varv);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    fv=subs(f,varvec,varval);</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p><strong>运行结果如下图：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20150209/20150209_fig002.jpg" width="350" height="300" title="图2" alt="图2" ></p>
<hr>
<h2 id="单纯形法"><a href="#单纯形法" class="headerlink" title="单纯形法"></a>单纯形法</h2><p>单纯形法的理论还有点复杂，而本文主要针对算法的基本实现，因此，理论部分就此略过，详情可以参考网上的相关资料。<strong>下面给出具体的实现：</strong></p>
<p><strong>我们以具体实例来说明：</strong></p>
<p>假定线性规划问题如下：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\min &\quad f=x_1-2x_2+x_3\\
s.t. &\quad x_1+x_2-2x_3+x_4=12\\
&\quad 2x_1-x_2+4x_3\le 8\\
&\quad -x_1+2x_2-4x_3\le 4\\
&\quad x_1, x_2, x_3, x_4\ge 0\\
\end{aligned}</script><p>化为标准型可得：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\min &\quad f=x_1-2x_2+x_3\\
s.t. &\quad x_1+x_2-2x_3+x_4=12\\
&\quad 2x_1-x_2+4x_3+x_5= 8\\
&\quad -x_1+2x_2-4x_3+x_6= 4\\
&\quad x_1, x_2, x_3, x_4, x_5, x_6\ge 0\\
\end{aligned}</script><p><strong>具体的Matlab实现如下：</strong></p>
<p><strong>1、脚本文件：</strong></p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clear all</span><br><span class="line">clc</span><br><span class="line"><span class="comment">% A=[2 2 1 0 0 0</span></span><br><span class="line"><span class="comment">%    1 2 0 1 0 0</span></span><br><span class="line"><span class="comment">%    4 0 0 0 1 0</span></span><br><span class="line"><span class="comment">%    0 4 0 0 0 1];</span></span><br><span class="line"><span class="comment">% c=[-2 -3 0 0 0 0];</span></span><br><span class="line"><span class="comment">% b=[12 8 16 12]';</span></span><br><span class="line"><span class="comment">% baseVector=[3 4 5 6];</span></span><br><span class="line"> </span><br><span class="line">A=[<span class="number">1</span> <span class="number">1</span> <span class="number">-2</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line">   <span class="number">2</span> <span class="number">-1</span> <span class="number">4</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span></span><br><span class="line">   <span class="number">-1</span> <span class="number">2</span> <span class="number">-4</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span>];</span><br><span class="line">c=[<span class="number">1</span> <span class="number">-2</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>];</span><br><span class="line">b=[<span class="number">12</span> <span class="number">8</span> <span class="number">4</span>]';</span><br><span class="line">baseVector=[<span class="number">4</span> <span class="number">5</span> <span class="number">6</span>];</span><br><span class="line"> </span><br><span class="line">[x y]=ModifSimpleMthd(A,c,b,baseVector)</span><br></pre></td></tr></table></figure>
<p><strong>2、ModifSimpleMthd.m文件</strong></p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[x,minf]</span>=<span class="title">ModifSimpleMthd</span><span class="params">(A,c,b,baseVector)</span></span></span><br><span class="line"><span class="comment">%约束矩阵：A</span></span><br><span class="line"><span class="comment">%目标函数系数向量：c</span></span><br><span class="line"><span class="comment">%约束右端向量：b</span></span><br><span class="line"><span class="comment">%初始基向量：baseVector</span></span><br><span class="line"><span class="comment">%目标函数取最小值时的自变量值：x</span></span><br><span class="line"><span class="comment">%目标函数的最小值：minf</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">sz=<span class="built_in">size</span>(A);</span><br><span class="line">nVia=sz(<span class="number">2</span>);</span><br><span class="line">n=sz(<span class="number">1</span>);</span><br><span class="line">xx=<span class="number">1</span>:nVia;</span><br><span class="line">nobase=<span class="built_in">zeros</span>(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">m=<span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> c&gt;=<span class="number">0</span></span><br><span class="line">    vr=<span class="built_in">find</span>(c~=<span class="number">0</span>,<span class="number">1</span>,<span class="string">'last'</span>);</span><br><span class="line">    rgv=inv(A(:,(nVia-n+<span class="number">1</span>):nVia))*b;</span><br><span class="line">    <span class="keyword">if</span> rgv&gt;=<span class="number">0</span></span><br><span class="line">        x=<span class="built_in">zeros</span>(<span class="number">1</span>,vr);</span><br><span class="line">        minf=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">disp</span>(<span class="string">'不存在最优解'</span>);</span><br><span class="line">        x=NaN;</span><br><span class="line">        minf=NaN;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:nVia            <span class="comment">%获取非基变量下标</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">isempty</span>(<span class="built_in">find</span>(baseVector==xx(<span class="built_in">i</span>),<span class="number">1</span>)))</span><br><span class="line">        nobase(m)=<span class="built_in">i</span>;</span><br><span class="line">        m=m+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        ;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line">bCon=<span class="number">1</span>;</span><br><span class="line">M=<span class="number">0</span>;</span><br><span class="line">B=A(:,baseVector);</span><br><span class="line">invB=inv(B);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">while</span> bCon</span><br><span class="line">    nB=A(:,nobase);         <span class="comment">%非基变量矩阵</span></span><br><span class="line">    ncb=c(nobase);          <span class="comment">%非基变量系数</span></span><br><span class="line">    B=A(:,baseVector);      <span class="comment">%基变量矩阵</span></span><br><span class="line">    cb=c(baseVector);       <span class="comment">%基变量系数</span></span><br><span class="line">    xb=invB*b;</span><br><span class="line">    f=cb*xb;</span><br><span class="line">    w=cb*invB;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:<span class="built_in">length</span>(nobase)  <span class="comment">%判别</span></span><br><span class="line">        sigma(<span class="built_in">i</span>)=w*nB(:,<span class="built_in">i</span>)-ncb(<span class="built_in">i</span>);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    [maxs,ind]=<span class="built_in">max</span>(sigma);  <span class="comment">%ind为进基变量下标</span></span><br><span class="line">    <span class="keyword">if</span> maxs&lt;=<span class="number">0</span>              <span class="comment">%最大值小于零，输出解最优</span></span><br><span class="line">        minf=cb*xb;</span><br><span class="line">        vr=<span class="built_in">find</span>(c~=<span class="number">0</span>,<span class="number">1</span>,<span class="string">'last'</span>);</span><br><span class="line">        <span class="keyword">for</span> l=<span class="number">1</span>:vr</span><br><span class="line">            ele=<span class="built_in">find</span>(baseVector==l,<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">isempty</span>(ele))</span><br><span class="line">                x(l)=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                x(l)=xb(ele);</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        bCon=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        y=inv(B)*A(:,nobase(ind));</span><br><span class="line">        <span class="keyword">if</span> y&lt;=<span class="number">0</span>             <span class="comment">%不存在最优解</span></span><br><span class="line">            <span class="built_in">disp</span>(<span class="string">'不存在最优解！'</span>);</span><br><span class="line">            x=NaN;</span><br><span class="line">            minf=NaN;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            minb=<span class="built_in">inf</span>;</span><br><span class="line">            chagB=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> <span class="built_in">j</span>=<span class="number">1</span>:<span class="built_in">length</span>(y)</span><br><span class="line">                <span class="keyword">if</span> y(<span class="built_in">j</span>)&gt;<span class="number">0</span></span><br><span class="line">                    bz=xb(<span class="built_in">j</span>)/y(<span class="built_in">j</span>);</span><br><span class="line">                    <span class="keyword">if</span> bz&lt;minb</span><br><span class="line">                        minb=bz;</span><br><span class="line">                        chagB=<span class="built_in">j</span>;</span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">end</span>                     <span class="comment">%chagB为基变量下标</span></span><br><span class="line">            tmp=baseVector(chagB);  <span class="comment">%更新基矩阵和非基矩阵</span></span><br><span class="line">            baseVector(chagB)=nobase(ind);</span><br><span class="line">            nobase(ind)=tmp;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> <span class="built_in">j</span>=<span class="number">1</span>:chagB<span class="number">-1</span>         <span class="comment">%基变量矩阵的逆矩阵变换</span></span><br><span class="line">                <span class="keyword">if</span> y(<span class="built_in">j</span>)~=<span class="number">0</span></span><br><span class="line">                    invB(<span class="built_in">j</span>,:)=invB(<span class="built_in">j</span>,:)-invB(chagB,:)*y(<span class="built_in">j</span>)/y(chagB);</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">for</span> <span class="built_in">j</span>=chagB+<span class="number">1</span>:<span class="built_in">length</span>(y)</span><br><span class="line">                <span class="keyword">if</span> y(<span class="built_in">j</span>)~=<span class="number">0</span></span><br><span class="line">                    invB(<span class="built_in">j</span>,:)=invB(<span class="built_in">j</span>,:)-invB(chagB,:)*y(<span class="built_in">j</span>)/y(chagB);</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            invB(chagB,:)=invB(chagB,:)/y(chagB);</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    M=M+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(M==<span class="number">1000000</span>)               <span class="comment">%迭代步数限制</span></span><br><span class="line">        <span class="built_in">disp</span>(<span class="string">'找不到最优解！'</span>);</span><br><span class="line">        x=NaN;</span><br><span class="line">        minf=NaN;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p> <strong>运行结果如下图：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20150209/20150209_fig003.jpg" width="450" height="300" title="图3" alt="图3" ></p>
<p><strong>关于最优化的更多算法实现，请访问</strong><a href="http://download.csdn.net/detail/tengweitw/8434549，里面有每个算法的索引说明，当然也包括上述算法。" target="_blank" rel="noopener">http://download.csdn.net/detail/tengweitw/8434549，里面有每个算法的索引说明，当然也包括上述算法。</a></p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>【工程优化】一维搜索方法</title>
    <url>/2015/02/04/%5B20150204%5D/</url>
    <content><![CDATA[<p><strong>一维搜索方法的分类如下：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20150204/20150204_fig001.jpg" width="400" height="450" title="图1" alt="图1" ></p>
<p>这篇文章主要讲解<strong>黄金分割法、二分法、牛顿法</strong>这三种一维搜索方法。黄金分割法只用到原函数，二分法用到函数的一阶导，牛顿法用到函数的二阶导。由于本文主要对研一上学期的课程中的部分算法进行程序实现，<strong>理论部分大多参考上课的课件</strong>。</p>
<a id="more"></a>
<hr>
<h2 id="黄金分割法"><a href="#黄金分割法" class="headerlink" title="黄金分割法"></a>黄金分割法</h2><p><strong>基本概念：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20150204/20150204_fig002.jpg" width="500" height="350" title="图2" alt="图2" ></p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20150204/20150204_fig003.jpg" width="500" height="350" title="图3" alt="图3" ></p>
<p><strong>算法思想：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20150204/20150204_fig004.jpg" width="800" height="250" title="图4" alt="图4" ></p>
<p><strong>算法流程图及优缺点如下：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20150204/20150204_fig005.jpg" width="800" height="250" title="图5" alt="图5" ></p>
<hr>
<h2 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h2><p> <strong>基本思想：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20150204/20150204_fig006.jpg" width="500" height="350" title="图6" alt="图6" ></p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20150204/20150204_fig007.jpg" width="500" height="350" title="图7" alt="图7" ></p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20150204/20150204_fig008.jpg" width="500" height="350" title="图8" alt="图8" ></p>
<h2 id="牛顿法"><a href="#牛顿法" class="headerlink" title="牛顿法"></a>牛顿法</h2><p><strong>基本思想：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20150204/20150204_fig009.jpg" width="500" height="350" title="图9" alt="图9" ></p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20150204/20150204_fig010.jpg" width="500" height="350" title="图10" alt="图10" ></p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20150204/20150204_fig011.jpg" width="500" height="350" title="图11" alt="图11" ></p>
<p><strong>算法流程图：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20150204/20150204_fig012.jpg" width="500" height="350" title="图12" alt="图12" ></p>
<h2 id="具体实现："><a href="#具体实现：" class="headerlink" title="具体实现："></a>具体实现：</h2><p>下面我们通过程序具体实现，<strong>在程序中，我们设置原函数都是$f(x)=\sin(x)/x$，搜索区间都是$[0,1]$，牛顿法中假设初始值设为1,具体程序如下所示</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="comment">/********************函数的定义、一阶导、二阶导的模块 BEGIN*************************/</span></span><br><span class="line"><span class="comment">/*****************************\</span></span><br><span class="line"><span class="comment">输入：x为自变量</span></span><br><span class="line"><span class="comment">输出：x自变量对应的函数值</span></span><br><span class="line"><span class="comment">\*****************************/</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Function</span><span class="params">(<span class="keyword">double</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x<span class="number">-0.5</span>)*(x<span class="number">-0.5</span>);<span class="comment">//这里填写函数式f(x),根据自己的函数修改</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*****************************\</span></span><br><span class="line"><span class="comment">输入：x为自变量</span></span><br><span class="line"><span class="comment">输出：x自变量对应的一阶导数值</span></span><br><span class="line"><span class="comment">\*****************************/</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Derivative</span><span class="params">(<span class="keyword">double</span> x)</span><span class="comment">//求函数的一阶导数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> eps=<span class="number">0.0000001</span>;<span class="comment">//精度控制</span></span><br><span class="line">    <span class="keyword">double</span> dx=<span class="number">0.5</span>;<span class="comment">//设置初始的间隔，太大需要迭代多次，太小缺乏精度</span></span><br><span class="line">    <span class="keyword">double</span> dy=Function(x+dx)-Function(x);<span class="comment">//函数值的增量</span></span><br><span class="line">    <span class="keyword">double</span> dd1=dy/dx;<span class="comment">//导数</span></span><br><span class="line">    <span class="keyword">double</span> dd2=<span class="number">0</span>;<span class="comment">//dx变化时的导数</span></span><br><span class="line">    dx=dx/<span class="number">2</span>;<span class="comment">//不断地减少x的增量</span></span><br><span class="line">    dy=Function(x)-Function(x+dx);</span><br><span class="line">    dd2=dy/dx;<span class="comment">//计算新的导数值</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">abs</span>(dd1-dd2)&gt;eps)<span class="comment">//当相邻两次的导数值小于精度时终止迭代，得到导数</span></span><br><span class="line">    &#123;</span><br><span class="line">        dd1=dd2;</span><br><span class="line">        dx=dx/<span class="number">2.0</span>;</span><br><span class="line">        dy=Function(x+dx)-Function(x);</span><br><span class="line">        dd2=dy/dx;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dd2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//求函数的2阶导数,与求一阶导数的原理一样，只需要把求函数值的函数Function换成求一阶导数的函数Derivative</span></span><br><span class="line"><span class="comment">/*****************************\</span></span><br><span class="line"><span class="comment">输入：x为自变量</span></span><br><span class="line"><span class="comment">输出：x自变量对应的二阶导数值</span></span><br><span class="line"><span class="comment">\*****************************/</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Derivative2</span><span class="params">(<span class="keyword">double</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> eps=<span class="number">0.00000001</span>;</span><br><span class="line">    <span class="keyword">double</span> dx=<span class="number">0.5</span>;</span><br><span class="line">    <span class="keyword">double</span> dy=Derivative(x+dx)-Derivative(x);</span><br><span class="line">    <span class="keyword">double</span> dd1=dy/dx;</span><br><span class="line">    <span class="keyword">double</span> dd2=<span class="number">0</span>;</span><br><span class="line">    dx=dx/<span class="number">2</span>;</span><br><span class="line">    dy=Derivative(x)-Derivative(x+dx);</span><br><span class="line">    dd2=dy/dx;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">abs</span>(dd1-dd2)&gt;eps)</span><br><span class="line">    &#123;</span><br><span class="line">        dd1=dd2;</span><br><span class="line">        dx=dx/<span class="number">2.0</span>;</span><br><span class="line">        dy=Derivative(x+dx)-Derivative(x);</span><br><span class="line">        dd2=dy/dx;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dd2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/********************函数的定义、一阶导、二阶导的模块  END*************************/</span></span><br><span class="line"><span class="comment">/******************************************\</span></span><br><span class="line"><span class="comment">输入：a，b为区间的上下限，n为最大的迭代次数</span></span><br><span class="line"><span class="comment">输出：打印函数最小值及对应的自变量x</span></span><br><span class="line"><span class="comment">\******************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GoldenSection</span><span class="params">(<span class="keyword">double</span> a,<span class="keyword">double</span> b,<span class="keyword">int</span> n)</span><span class="comment">//黄金分割法</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> l=a+<span class="number">0.382</span>*(b-a);</span><br><span class="line">    <span class="keyword">double</span> h=a+<span class="number">0.618</span>*(b-a);</span><br><span class="line">    <span class="keyword">double</span> region=b-a;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">double</span> fl;</span><br><span class="line">    <span class="keyword">double</span> fh;</span><br><span class="line">    <span class="keyword">int</span> num=<span class="number">1</span>;<span class="comment">//迭代次数</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(region&gt;<span class="number">0.0000000001</span>&amp;&amp;num&lt;n)</span><br><span class="line">    &#123;</span><br><span class="line">        fl=Function(l);</span><br><span class="line">        fh=Function(h);</span><br><span class="line">        <span class="keyword">if</span>(fl&gt;fh)</span><br><span class="line">        &#123;</span><br><span class="line">            a=l;</span><br><span class="line">            l=h;</span><br><span class="line">            h=a+<span class="number">0.618</span>*(b-a);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            b=h;</span><br><span class="line">            h=l;</span><br><span class="line">            l=a+<span class="number">0.382</span>*(b-a);</span><br><span class="line">        &#125;</span><br><span class="line">        num++;</span><br><span class="line">        region=<span class="built_in">abs</span>(b-a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(num==n)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"找不到最小值"</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"黄金分割法:x=%f时，最小值f(x)=%f"</span>,(a+b)/<span class="number">2</span>,Function((a+b)/<span class="number">2</span>));</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/******************************************\</span></span><br><span class="line"><span class="comment">输入：a，b为区间的上下限</span></span><br><span class="line"><span class="comment">输出：打印函数最小值及对应的自变量x</span></span><br><span class="line"><span class="comment">\******************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dichotomy</span><span class="params">(<span class="keyword">double</span> a,<span class="keyword">double</span> b)</span><span class="comment">//二分法</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> eps=<span class="number">0.0000001</span>;</span><br><span class="line">    <span class="keyword">double</span> x=(a+b)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">double</span> region=b-a;</span><br><span class="line">    <span class="keyword">double</span> fxDerivative= Derivative(x);</span><br><span class="line">    <span class="keyword">while</span>(region&gt;<span class="number">0.0000001</span>&amp;&amp;<span class="built_in">abs</span>(fxDerivative)&gt;eps)</span><br><span class="line">    &#123;</span><br><span class="line">        fxDerivative= Derivative(x);</span><br><span class="line">        <span class="keyword">if</span>(fxDerivative&gt;eps)</span><br><span class="line">            b=x;</span><br><span class="line">        <span class="keyword">if</span>(fxDerivative&lt;-eps)</span><br><span class="line">            a=x;</span><br><span class="line">        x=(a+b)/<span class="number">2</span>;</span><br><span class="line">        region=<span class="built_in">abs</span>(b-a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n\n二分法：x=%f时，f(x)=%f\n"</span>,x,Function(x));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/******************************************\</span></span><br><span class="line"><span class="comment">输入：a，b为区间的上下限，x1是初始值</span></span><br><span class="line"><span class="comment">输出：打印函数最小值及对应的自变量x</span></span><br><span class="line"><span class="comment">\******************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Newton</span><span class="params">(<span class="keyword">double</span> a,<span class="keyword">double</span> b,<span class="keyword">double</span> x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> eps=<span class="number">0.0000001</span>;</span><br><span class="line">    <span class="keyword">double</span> x=x1;</span><br><span class="line">    <span class="keyword">double</span> d1=Derivative(x1);<span class="comment">//一阶导</span></span><br><span class="line">    <span class="keyword">double</span> d2;<span class="comment">//二阶导</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">abs</span>(d1)&gt;eps)</span><br><span class="line">    &#123;</span><br><span class="line">        d2=Derivative2(x);</span><br><span class="line">        <span class="keyword">if</span>(d2&lt;<span class="number">0</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"二阶导小于0，无法求解"</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            x=x-d1/d2;<span class="comment">//x迭代公式</span></span><br><span class="line">            d1=Derivative(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n牛顿法：x=%f时，f(x)=%f\n\n"</span>,x,Function(x));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    GoldenSection(<span class="number">0</span>,<span class="number">1</span>,<span class="number">100000</span>);<span class="comment">//黄金分割法</span></span><br><span class="line">    </span><br><span class="line">    Dichotomy(<span class="number">0</span>,<span class="number">1</span>);<span class="comment">//二分法</span></span><br><span class="line">    Newton(<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>);<span class="comment">//牛顿法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>运行结果如下图：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20150204/20150204_fig013.jpg" width="600" height="450" title="图13" alt="图13" ></p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>【数值分析】复化积分公式</title>
    <url>/2015/02/02/%5B20150202%5D/</url>
    <content><![CDATA[<p> 对于积分$\int_{a}^{b}f(x)dx$只要找到被积公式的原函数$F(x)$，利用牛顿莱普利兹公式有：</p>
<script type="math/tex; mode=display">
I=\int_{a}^{b}f(x)dx=F(b)-F(a)</script><p>但是，实际使用这种求积分的方法往往是有困难的，因为大量的被积函数的原函数是不能用初等函数表示的；另外，当$f(x)$是由测量或数值计算给出的一张数据表时，牛顿莱普利兹公式也无法直接运用，因此有必要研究积分的数值计算问题。</p>
<a id="more"></a>
<hr>
<p>对于一些理论的推导，大家可以看看维基百科，下面我<strong>主要给出牛顿-科特斯公式在$n=1$(梯形求积公式)、$n=2$（辛普森公式）的情况，并通过代码实现</strong>。</p>
<p><strong>梯形公式：</strong></p>
<script type="math/tex; mode=display">
T=(b-a)\left[\frac{1}{2}f(a)+\frac{1}{2}f(b)\right]</script><p><strong>辛普森公式：</strong></p>
<script type="math/tex; mode=display">
S=(b-a)\left[\frac{1}{6}f(a)+\frac{4}{6}f(\frac{a+b}{2})+\frac{1}{6}f(b)\right]</script><p>应用高阶牛顿-科特斯公式计算积分时，会出现数值不稳定的情况，而低阶公式往往因为积分步长过大使得离散误差变大，因此，为了提高求积公式的精度，可以把积分区间分成若干个子区间，在每个子区间上使用低阶求积公式，然后将结果加起来，这种方法称为复化求积法。</p>
<p><strong>复化梯形公式</strong></p>
<p>将区间$[a,b]$划分为$n$等分，步长为$h=(b-a)/h$，节点为$x<em>i=a+ih,i=1,2,\cdots,n+1$，在每个子区间$[x_i,x</em>{i+1}]$ 使用梯形公式得：</p>
<script type="math/tex; mode=display">
\int_{a}^{b}f(x)dx\approx\sum\limits_{i=1}^{n}\int_{x_i}^{x_{i+1}}f(x)dx=T_n=\frac{h}{2}\left[f(a)+2\sum\limits_{i=1}^{n-1}f(a+ih)+f(b)\right],h=\frac{b-a}{n}</script><p><strong>复化辛普森公式</strong></p>
<p>根据复化梯形公式的推导，同理可得复化辛普森公式为：</p>
<script type="math/tex; mode=display">
S_n=\frac{h}{6}\sum\limits_{i=0}^{n-1}\left[f(x_i)+4f(x_{i+1/2})+f(x_{i+1})\right], h=\frac{b-a}{n}</script><hr>
<p>下面我们通过实例来实现复化梯形公式和复化辛普森公式：</p>
<p><strong>对于函数$f(x)=\sin(x)/x$，试用复化梯形公式和复化辛普森公式计算函数$f(x)$在$[0, 1]$上的积分。</strong></p>
<p><strong>具体的程序实现如下：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Function</span><span class="params">(<span class="keyword">double</span> x)</span><span class="comment">//所要计算积分的函数f(x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x==<span class="number">0</span>)<span class="comment">//sin(x)/x在0处的取值为1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sin</span>(x)/x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//复化梯形公式</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Trapz</span><span class="params">(<span class="keyword">double</span> a,<span class="keyword">double</span> b,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> h=(b-a)/n;</span><br><span class="line">    <span class="keyword">double</span> T=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        T=T+Function(a+i*h);</span><br><span class="line">    &#125;</span><br><span class="line">    T*=<span class="number">2</span>;</span><br><span class="line">    T=(Function(a)+Function(b)+T)*h/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//复化辛普森公式</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">MulripleSimpson</span><span class="params">(<span class="keyword">double</span> a,<span class="keyword">double</span> b,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> h=(b-a)/n;</span><br><span class="line">    <span class="keyword">double</span> T=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        T=T+Function(a+i*h)+<span class="number">4</span>*Function(a+(i+<span class="number">0.5</span>)*h)+Function(a+(i+<span class="number">1</span>)*h);</span><br><span class="line">    &#125;</span><br><span class="line">    T=T*h/<span class="number">6</span>;</span><br><span class="line">    <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"使用复化梯形公式可得：%f\n"</span>,Trapz(<span class="number">0</span>,<span class="number">1</span>,<span class="number">8</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"使用复化辛普森公式可得：%f\n"</span>,MulripleSimpson(<span class="number">0</span>,<span class="number">1</span>,<span class="number">4</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>运行结果如下图：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20150202/20150202_fig001.jpg" width="600" height="450" title="图1" alt="图1" ></p>
<p><strong>结果分析：</strong></p>
<p>比较复化梯形公式和复化辛普森公式两种方法的运行结果，我们发现复化辛普森公式与准确值$0.9460831$更加接近，复化梯形公式只有$2$位有效数字，而复化辛普森公式有$6$为有效数字。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>【随机过程】马氏链的理论与仿真</title>
    <url>/2015/01/27/%5B20150127%5D/</url>
    <content><![CDATA[<p>在<a href="http://blog.csdn.net/tengweitw/article/details/42775597" target="_blank" rel="noopener">2014年终总结</a>中，我提到要对这学期学过的数学课中的部分算法进行仿真实现。<a href="http://blog.csdn.net/tengweitw/article/category/2848347" target="_blank" rel="noopener">《数值分析》</a>和《工程优化》这两门数学课里面还有些专门讲算法的，可以用来仿真。在《随机过程》这门课中，几乎全都是公式推导，定理证明，实在难以仿真实现。最后发现，马尔科夫链这一章比较适合仿真，况且先前也写过类似的程序，更重要的是之前有人也问过关于马氏链的Matlab实现问题。关于马氏链的理论原理在这就不作描述，下面直接用程序来实现具体问题的求解。</p>
<a id="more"></a>
<p>假设有$9$个状态，其状态转移图如下所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20150127/20150127_fig001.jpg" width="600" height="150" title="图1" alt="图1" ></p>
<p>根据状态转移图，我们可以得到其一步转移概率矩阵为$P$:</p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20150127/20150127_fig002.jpg" width="600" height="250" title="图2" alt="图2" ></p>
<hr>
<p><strong>问题一：从状态$1$在$1000$次内转移到状态$9$的概率为多少？</strong></p>
<p><strong>理论值：</strong></p>
<p>由一步转移概率矩阵$P$的性质知，$P$的$n$次幂矩阵$P^n$中的第$i$行第$j$列的元素表示的是从状态$i$经过$n$步转移到状态$j$的概率。注意到，状态$9$为吸收态。因此，在$1000$步以内的任意一步到达状态$9$后，就永远停留在了状态$9$。所以$P$的$1000$次幂矩阵$P^{1000}$中的第$1$行第$9$列就是从状态$1$在$1000$次内转移到状态$9$的概率。</p>
<p><strong>仿真值：</strong></p>
<p>在仿真中，我们设置仿真次数为$100000$次（越大越好），设置初始状态为$1$，在$1000$步中，如果到达状态$9$就记录，然后跳出循环，开始新一轮循环。<strong>具体代码如下：</strong></p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clear all</span><br><span class="line">clc</span><br><span class="line"> </span><br><span class="line"><span class="comment">%一步转移概率矩阵</span></span><br><span class="line">P=[<span class="number">0.7</span> <span class="number">0.3</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line">   <span class="number">0.7</span> <span class="number">0</span> <span class="number">0.3</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line">   <span class="number">0</span> <span class="number">0.7</span> <span class="number">0</span> <span class="number">0.3</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> </span><br><span class="line">   <span class="number">0</span> <span class="number">0</span> <span class="number">0.7</span> <span class="number">0</span> <span class="number">0.3</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> </span><br><span class="line">   <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0.7</span> <span class="number">0</span> <span class="number">0.3</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> </span><br><span class="line">   <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0.7</span> <span class="number">0</span> <span class="number">0.3</span> <span class="number">0</span> <span class="number">0</span> </span><br><span class="line">   <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0.7</span> <span class="number">0</span> <span class="number">0.3</span> <span class="number">0</span> </span><br><span class="line">   <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0.7</span> <span class="number">0</span> <span class="number">0.3</span> </span><br><span class="line">   <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span>];</span><br><span class="line"> </span><br><span class="line">p=P^<span class="number">1000</span>;</span><br><span class="line">p(<span class="number">1</span>,<span class="number">9</span>)<span class="comment">%理论值</span></span><br><span class="line">num=<span class="number">0</span>;<span class="comment">%记录到达状态9的次数</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:<span class="number">100000</span><span class="comment">%实验次数</span></span><br><span class="line">    state=<span class="number">1</span>;<span class="comment">%初始状态为1</span></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">j</span>=<span class="number">1</span>:<span class="number">1000</span><span class="comment">%1000步</span></span><br><span class="line">         <span class="keyword">if</span> state==<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">rand</span>()&lt;<span class="number">0.3</span></span><br><span class="line">                state=<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">elseif</span> state==<span class="number">9</span></span><br><span class="line">            state=<span class="number">9</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">rand</span>()&lt;<span class="number">0.3</span></span><br><span class="line">                state=state+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                state=state<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">if</span> state==<span class="number">9</span></span><br><span class="line">            num=num+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span> </span><br><span class="line">        num/<span class="number">100000</span> <span class="comment">%仿真值</span></span><br></pre></td></tr></table></figure>
<hr>
<p><strong>问题二：从状态$1$到状态$9$平均需要几步？</strong></p>
<p><strong>理论值：</strong></p>
<p>最直观的想法就是：假设从状态$1$到达状态$9$需要$n$步的概率为$p^n$，则平均步数可以表示为$1p^1+2p^2+\cdots+np^n+\cdots$。注意，这里的$p^n$是首达概率，即从状态$1$经过$k$步首次到达状态$9$的概率，也就是前$k-1$次没有到达状态$9$。显然这里的首达概率而不是转移概率矩阵中的概率。这里的首达概率不好求，不过可以矩阵论（可惜没有选这门课）的相关知识来理论求解，最终可以得到的表达式如下：</p>
<script type="math/tex; mode=display">
T_{x\rightarrow y}=I_x(I-PE_y)^{-2}PI_y</script><p>其中，$x$，$y$表示状态，在本例中，$x=1$,$y=9$，其它符号表示如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20150127/20150127_fig003.jpg" width="600" height="200" title="图3" alt="图3" ></p>
<p><strong>仿真值：</strong></p>
<p>有时候，理论比较复杂的问题，仿真起来就相对简单，和问题一中的仿真类似，假定仿真次数为$10000$次，设置最大步数为$100000000$，当到达状态$9$时，就记录所需步数并跳出循环，<strong>具体的程序实现如下：</strong></p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clear all</span><br><span class="line">clc</span><br><span class="line"></span><br><span class="line">P=[<span class="number">0.7</span> <span class="number">0.3</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line">   <span class="number">0.7</span> <span class="number">0</span> <span class="number">0.3</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line">   <span class="number">0</span> <span class="number">0.7</span> <span class="number">0</span> <span class="number">0.3</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> </span><br><span class="line">   <span class="number">0</span> <span class="number">0</span> <span class="number">0.7</span> <span class="number">0</span> <span class="number">0.3</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> </span><br><span class="line">   <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0.7</span> <span class="number">0</span> <span class="number">0.3</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> </span><br><span class="line">   <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0.7</span> <span class="number">0</span> <span class="number">0.3</span> <span class="number">0</span> <span class="number">0</span> </span><br><span class="line">   <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0.7</span> <span class="number">0</span> <span class="number">0.3</span> <span class="number">0</span> </span><br><span class="line">   <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0.7</span> <span class="number">0</span> <span class="number">0.3</span> </span><br><span class="line">   <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">sum=<span class="number">0</span>;</span><br><span class="line">p=P^<span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">x=<span class="number">1</span>;</span><br><span class="line">y=<span class="number">9</span>;</span><br><span class="line">P_size=<span class="number">9</span>;<span class="comment">%状态个数</span></span><br><span class="line">Ix=<span class="built_in">zeros</span>(<span class="number">1</span>,P_size);<span class="comment">%行向量</span></span><br><span class="line">Ix(x)=<span class="number">1</span>;</span><br><span class="line">Iy=<span class="built_in">zeros</span>(P_size,<span class="number">1</span>);<span class="comment">%列向量</span></span><br><span class="line">Iy(y)=<span class="number">1</span>;</span><br><span class="line">I=<span class="built_in">eye</span>(P_size);</span><br><span class="line">Ey=I;</span><br><span class="line">Ey(y,y)=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">average=Ix*(I-P*Ey)^<span class="number">-2</span>*P*Iy<span class="comment">%理论值</span></span><br><span class="line"></span><br><span class="line">state=<span class="number">1</span>;<span class="comment">%初始状态</span></span><br><span class="line">num=<span class="number">0</span>;<span class="comment">%达到次数</span></span><br><span class="line">result=<span class="number">0</span>;<span class="comment">%需要经过的步数</span></span><br><span class="line"><span class="keyword">for</span> k=<span class="number">1</span>:<span class="number">100000</span><span class="comment">%仿真10000次</span></span><br><span class="line">    state=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:<span class="number">100000000</span><span class="comment">%设定最大步数（越大越好）</span></span><br><span class="line">        <span class="keyword">if</span> state==<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">rand</span>()&lt;<span class="number">0.3</span></span><br><span class="line">                state=<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">elseif</span> state==<span class="number">9</span></span><br><span class="line">            state=<span class="number">9</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">rand</span>()&lt;<span class="number">0.3</span></span><br><span class="line">                state=state+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                state=state<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">if</span> state==<span class="number">9</span></span><br><span class="line">            num=num+<span class="number">1</span>;</span><br><span class="line">            result=result+<span class="built_in">i</span>;<span class="comment">%记录总的步数</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span>  </span><br><span class="line"></span><br><span class="line">result/num<span class="comment">%计算平均步数</span></span><br></pre></td></tr></table></figure>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>【数值分析】拉格朗日插值与牛顿插值</title>
    <url>/2015/01/22/%5B20150122%5D/</url>
    <content><![CDATA[<p>​    在工程应用和科学研究中，经常要研究变量之间的关系$y=f(x)$。但对于函数$f(x)$，常常得不到一个具体的解析表达式，它可能是通过观测或实验得到的一组数据$(x,f(x))$，$x$为一向量;或则是解析表达式非常复杂，不便于计算和使用。因此我们需要寻找一个计算比较简单的函数$S(x)$近似代替$f(x)$，并使得$S(x)=f(x)$，<strong>这种方法就称为插值法</strong>。</p>
<p><strong>常用的插值法有：</strong></p>
<p>​    一维插值法：拉格朗日插值、牛顿插值、分段低次插值、埃尔米特插值、样条插值。</p>
<p>​    二维插值法：双线性插值、双二次插值。</p>
<a id="more"></a>
<hr>
<h2 id="拉格朗日插值法"><a href="#拉格朗日插值法" class="headerlink" title="拉格朗日插值法"></a>拉格朗日插值法</h2><p>​    已知函数$f(x)$的$n+1$个互异的节点$x_i$处的函数值$f(x_i)$，则其拉格朗日插值多项式可以写为：</p>
<script type="math/tex; mode=display">
L_n(x)=\sum\limits_{k=0}^ny_kl_k(x)</script><p>其中，$l_k(x)$为插值基函数，其表达式为：</p>
<script type="math/tex; mode=display">
l_k(x)=\prod\limits_{j=0,j\neq k}^n\frac{x-x_j}{x_k-x_j}</script><hr>
<h2 id="牛顿插值法"><a href="#牛顿插值法" class="headerlink" title="牛顿插值法"></a>牛顿插值法</h2><p>已知函数$f(x)$的$n+1$个互异的节点$x_i$处的函数值$f(x_i)$，则其牛顿插值多项式可以写为：</p>
<script type="math/tex; mode=display">
N_n(x)=a_0+a_1(x-x_0)+\cdots+a_n(x-x_0)(x-x_1)\cdots(x-x_{n-1})</script><p>其中，$a_k$为$f(x)$的$k$阶差商（也叫均差），可以表示如下：</p>
<script type="math/tex; mode=display">
a_k=f[x_0,x_1,\cdots,x_{k-1},x_k]</script><p>也可以由函数值$f(x_i)$线性表示为：</p>
<script type="math/tex; mode=display">
a_k=\sum\limits_{i=0}^{n}\frac{f(x_i)}{(x_i-x_0)\cdots(x_i-x_{i-1})(x_i-x_{i+1})\cdots(x_i-x_k)}</script><p>根据上述基本原理和公式，很容易编程实现。我们假设根据下面的数据表，来分别用拉格朗日插值和牛顿插值来计算$f(8.4)$的近似值：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>x</th>
<th>8.1</th>
<th>8.3</th>
<th>8.6</th>
<th>8.7</th>
</tr>
</thead>
<tbody>
<tr>
<td>f(x)</td>
<td>16.94410</td>
<td>17.56492</td>
<td>18.50515</td>
<td>18.82091</td>
</tr>
</tbody>
</table>
</div>
<p><strong>具体代码实现如下：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">//-----------------拉格朗日插值法BEGIN---------------------//</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Lagrange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; x,<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; y ,<span class="keyword">double</span> X)</span><span class="comment">//x,y分别为x和f(x)的值，X为要求的点，返回值为f(X)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> result=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">double</span> temp=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;x.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        temp=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;x.size();j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(j!=i)</span><br><span class="line">            &#123;</span><br><span class="line">                temp=temp*(X-x.at(j))/(x.at(i)-x.at(j));</span><br><span class="line">            &#125;        </span><br><span class="line">        &#125;</span><br><span class="line">        result+=temp*y.at(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//-----------------拉格朗日插值法END---------------------//</span></span><br><span class="line"><span class="comment">//-----------------牛顿法BEGIN---------------------//</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">DifferenceQuotient</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; x,<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; y ,<span class="keyword">int</span> k)</span><span class="comment">//计算差商</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> result=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=k;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">double</span> temp=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=k;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i!=j)</span><br><span class="line">            &#123;</span><br><span class="line">                temp=temp/(x.at(i)-x.at(j));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        temp=y.at(i)*temp;</span><br><span class="line">        result+=temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Newton</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; x,<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; y ,<span class="keyword">double</span> X)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> result=y.at(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">double</span> temp=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;x.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        temp=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            temp*=(X-x.at(j));</span><br><span class="line">        &#125;</span><br><span class="line">        result+=DifferenceQuotient(x,y,i)*temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//-----------------牛顿法END---------------------//</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; x;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; y;</span><br><span class="line">    <span class="comment">//这里输入x的值,这里使用向量vector是为了方便添加数据点，可以根据实际的观测点更改</span></span><br><span class="line">    x.push_back(<span class="number">8.1</span>);</span><br><span class="line">    x.push_back(<span class="number">8.3</span>);</span><br><span class="line">    x.push_back(<span class="number">8.6</span>);</span><br><span class="line">    x.push_back(<span class="number">8.7</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//这里输入f(x)的值</span></span><br><span class="line">    y.push_back(<span class="number">16.94410</span>);</span><br><span class="line">    y.push_back(<span class="number">17.56492</span>);</span><br><span class="line">    y.push_back(<span class="number">18.50515</span>);</span><br><span class="line">    y.push_back(<span class="number">18.82091</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span>.precision(<span class="number">10</span>);<span class="comment">//设置显示精度</span></span><br><span class="line">    <span class="comment">//下面是根据上面的4个样本点及其函数值来分别使用两种插值法计算在x=8.4处的函数值</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"使用拉格朗日插值法："</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;Lagrange(x,y,<span class="number">8.4</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"使用牛顿插值法："</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;Newton(x,y,<span class="number">8.4</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>程序运行结果如下：</strong></p>
<p>  <img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20150122/20150122_fig001.jpg" width="600" height="450" title="图1" alt="图1" ></p>
<p><strong>优缺点比较：</strong></p>
<p>​    拉格朗日插值法：插值多项式和插值基函数的形式对称，容易编程。但是，增加节点时，需要重新计算每一个插值基函数。</p>
<p>​    牛顿插值法：当插值节点增加时，之前已计算的结果仍然能用，每增加一个节点，只要再增加一项即可，从而避免了重复性计算。</p>
<hr>
<h2 id="Matlab实现多种插值函数"><a href="#Matlab实现多种插值函数" class="headerlink" title="Matlab实现多种插值函数"></a>Matlab实现多种插值函数</h2><p>​    现在也有很多人使用Matlab来进行算法的仿真，我在这里把大二时数学建模整理的插值算法函数也共享出来，链接为：<a href="http://download.csdn.net/detail/tengweitw/8387451" target="_blank" rel="noopener">http://download.csdn.net/detail/tengweitw/838745</a>1具体的使用说明在文件中都有说明。下面就拿我们刚才所讲的拉格朗日插值和牛顿插值来举例说明，<strong>还是使用上面的数据表，则拉格朗日插值函数如下：</strong></p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span> = <span class="title">Language</span><span class="params">(x,y,x0)</span></span></span><br><span class="line"><span class="comment">%x y为坐标向量  x0为插值点的x坐标|| f0为x0对应的值</span></span><br><span class="line"> </span><br><span class="line">syms t;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">length</span>(x) == <span class="built_in">length</span>(y))</span><br><span class="line">    n = <span class="built_in">length</span>(x);    </span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">disp</span>(<span class="string">'x和y的维数不相等！'</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">end</span>                                      <span class="comment">%检错</span></span><br><span class="line"> </span><br><span class="line">f = <span class="number">0.0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">i</span> = <span class="number">1</span>:n)</span><br><span class="line">    l = y(<span class="built_in">i</span>); </span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">j</span> = <span class="number">1</span>:<span class="built_in">i</span><span class="number">-1</span>)</span><br><span class="line">        l = l*(t-x(<span class="built_in">j</span>))/(x(<span class="built_in">i</span>)-x(<span class="built_in">j</span>));      </span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">j</span> = <span class="built_in">i</span>+<span class="number">1</span>:n)</span><br><span class="line">        l = l*(t-x(<span class="built_in">j</span>))/(x(<span class="built_in">i</span>)-x(<span class="built_in">j</span>));      <span class="comment">%计算拉格朗日基函数</span></span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line"> </span><br><span class="line">    f = f + l;                           <span class="comment">%计算拉格朗日插值函数      </span></span><br><span class="line">    simplify(f);                         <span class="comment">%化简</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">i</span>==n)</span><br><span class="line">        <span class="keyword">if</span>(nargin == <span class="number">3</span>)</span><br><span class="line">            f = subs(f,<span class="string">'t'</span>,x0);          <span class="comment">%计算插值点的函数值</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            f = collect(f);          <span class="comment">%将插值多项式展开</span></span><br><span class="line">            f = vpa(f,<span class="number">6</span>);                <span class="comment">%将插值多项式的系数化成6位精度的小数</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p><strong>牛顿插值函数如下：</strong></p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span> = <span class="title">Newton</span><span class="params">(x,y,x0)</span></span></span><br><span class="line"><span class="comment">%x y为坐标向量  x0为插值点的x坐标|| f0为x0对应的值</span></span><br><span class="line">syms t;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">length</span>(x) == <span class="built_in">length</span>(y))</span><br><span class="line">    n = <span class="built_in">length</span>(x);</span><br><span class="line">    c(<span class="number">1</span>:n) = <span class="number">0.0</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">disp</span>(<span class="string">'x和y的维数不相等！'</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line">f = y(<span class="number">1</span>);</span><br><span class="line">y1 = <span class="number">0</span>;</span><br><span class="line">l  = <span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">i</span>=<span class="number">1</span>:n<span class="number">-1</span>)   </span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">j</span>=<span class="built_in">i</span>+<span class="number">1</span>:n)</span><br><span class="line">        y1(<span class="built_in">j</span>) = (y(<span class="built_in">j</span>)-y(<span class="built_in">i</span>))/(x(<span class="built_in">j</span>)-x(<span class="built_in">i</span>));</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    c(<span class="built_in">i</span>) = y1(<span class="built_in">i</span>+<span class="number">1</span>);     </span><br><span class="line">    l = l*(t-x(<span class="built_in">i</span>));  </span><br><span class="line">    f = f + c(<span class="built_in">i</span>)*l;</span><br><span class="line">    simplify(f);</span><br><span class="line">    y = y1;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">i</span>==n<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">if</span>(nargin == <span class="number">3</span>)</span><br><span class="line">            f = subs(f,<span class="string">'t'</span>,x0);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            f = collect(f);                <span class="comment">%将插值多项式展开</span></span><br><span class="line">            f = vpa(f, <span class="number">6</span>);</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p><strong>为了使用上面两个函数，脚本文件如下：</strong></p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clear all</span><br><span class="line">clc</span><br><span class="line">format long </span><br><span class="line">format compact</span><br><span class="line"> </span><br><span class="line">x=[<span class="number">8.1</span> <span class="number">8.3</span> <span class="number">8.6</span> <span class="number">8.7</span> ];</span><br><span class="line">y=[ <span class="number">16.94410</span> <span class="number">17.56492</span> <span class="number">18.50515</span> <span class="number">18.82091</span>];</span><br><span class="line">x0=<span class="number">8.4</span>;</span><br><span class="line"><span class="built_in">disp</span>(<span class="string">'拉格朗日插值法：'</span>)</span><br><span class="line"><span class="built_in">disp</span>(Language(x,y,x0))</span><br><span class="line"><span class="built_in">disp</span>(<span class="string">'牛顿插值法：'</span>)</span><br><span class="line"><span class="built_in">disp</span>(Newton(x,y,x0))</span><br></pre></td></tr></table></figure>
<p><strong>结果显示如下：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20150122/20150122_fig002.jpg" width="600" height="450" title="图2" alt="图2" ></p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>【数值分析】误差的分析与减少及Matlab解线性方程的四种方法</title>
    <url>/2015/01/20/%5B20150120%5D/</url>
    <content><![CDATA[<h2 id="误差的来源"><a href="#误差的来源" class="headerlink" title="误差的来源"></a>误差的来源</h2><ul>
<li>模型误差：数学模型与实际问题之间的误差</li>
<li>观测误差：测量数据与实际数据的误差</li>
<li>方法误差：数学模型的精确解与数值方法得到的数值解之间的误差：例如</li>
<li>舍入误差：对数据进行四舍五入后产生的误差</li>
</ul>
<a id="more"></a>
<hr>
<h2 id="减少误差的几种方法"><a href="#减少误差的几种方法" class="headerlink" title="减少误差的几种方法"></a>减少误差的几种方法</h2><p>​     现在，我们一般用计算机解决计算问题，使用最多的是Matlab软件。对实际问题进行数学建模时，可能存在模型误差，对数学模型进行数值求解时，我们使用的方法可能产生方法误差，我们输入计算机的数据一般是有测量误差的，计算机在运算过程的每一步又会产生舍入误差（十进制转化为二进制时可能产生舍入误差）。由此看来，解决一个问题，基本上会有以上四种四种误差。记得高中物理老师说过，错误是可以避免的，误差是不可避免的，我们只可以减少误差。下面我们就来介绍减少误差的几种方法：</p>
<ul>
<li><p><strong>避免两个相近的数相减</strong><br>比如: 当$x=10003$时，计算$\sqrt{x+1}-\sqrt{x}$的近似值。<br>如果使用$6$位十进制浮点运算，运算时取$6$位有效数字，结果如下：</p>
<script type="math/tex; mode=display">
\sqrt{x+1}-\sqrt{x}=100.020-100.015=0.005</script><p>结果只有一位有效数字，与之前相比，损失了$5$位有效数字。</p>
<p>如果使用下面的方法：</p>
<script type="math/tex; mode=display">
\sqrt{x+1}-\sqrt{x}=\frac{1}{\sqrt{x+1}+\sqrt{x}}=\frac{1}{100.020+100.015}=0.00499913</script><p>则结果有$6$位有效数字，与精确值$0.00499912523117984\cdots$较为接近。</p>
</li>
<li><p><strong>防止重要的小数被大数吃掉</strong><br>比如: 已知$x=3\times 10^{12},y=7,z=-3\times 10^{12}$,求$x+y+z$<br>如果按照$(x+y)+z$的顺序来求的话，由于$x$远大于$y$，在计算机中可能导致$x+y=x$的情况，因此我们可以按照$(x+z)+y$的顺序计算得到正确的结果。</p>
</li>
<li><p><strong>避免除数的绝对值远小于被除数的绝对值</strong><br>比如：用消去法解线性方程组</p>
<script type="math/tex; mode=display">
\left\{\begin{array}{l} 0.00003x_1-3x_2=0.6\\x_1+2x_2=1\end{array}\right.</script><p>这个方程组的正确解为：</p>
<script type="math/tex; mode=display">
x_1=1.399972, x_2=-0.199986</script><p>对于上述方程组，当我们将第一个方程除以$0.00003$减去第二个方程时，可以得到下面的化简和计算结果：</p>
<script type="math/tex; mode=display">
\left\{\begin{array}{l} 0.00003x_1-3x_2=0.6\\-100000x_2=20000\end{array}\right.\rightarrow
\left\{\begin{array}{l} x_1=0\\x_2=-0.2\end{array}\right.</script><p>显然上述结果严重失真，产生了很大的误差。这就是由于除数的绝对值远小于被除数的绝对值造成的。为了避免上述情况，我们可以用第二个方程消去第一个方程中的$x_1$，即第二个方程乘以$0.00003$减去第一个方程，得到如下表达式和结果：</p>
<script type="math/tex; mode=display">
\left\{\begin{array}{l}-3x_2=0.6\\x_1+2x_2=1\end{array}\right.\rightarrow
\left\{\begin{array}{l} x_1=1.4\\x_2=-0.2\end{array}\right.</script><p>将结果与正确解相比发现，这是一组相当好的近似解。           </p>
</li>
<li><p><strong>注意算法的稳定性</strong><br>所谓算法的稳定性是指，一个算法如果输入数据有误差，而在计算过程中误差不增长，那么称此算法是数值稳定的。</p>
</li>
</ul>
<hr>
<p>上面的部分基本上都来源于《数值分析》一书，讲的挺好的，这些减小误差的方法，我们平时需要多注意，在用c进行编程实现时需要注意，而用Matlab实现时，上面的问题都不是问题了，不过我们要学习的是这种方法和技巧。<strong>下面讲讲，在实现上述方法的Matlab的知识：1、精度控制；2、解线性方程组。</strong></p>
<h4 id="精度控制"><a href="#精度控制" class="headerlink" title="精度控制"></a>精度控制</h4><ul>
<li>format  digits  vpa函数的使用</li>
<li>format只用来控制显示精度的，并不控制计算精度，digits用来控制计算精度，vpa也是控制计算精度。</li>
<li>digits必须与vpa配合使用，单独不起作用。</li>
<li><p>vpa可单独控制计算精度</p>
<p><strong>具体操作如下图：</strong></p>
</li>
</ul>
<ol>
<li><p>​    format的操作</p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20150120/20150120_fig001.jpg" width="300" height="500" title="图1" alt="图1" ></p>
</li>
<li><p>​    digits的操作<br><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20150120/20150120_fig002.jpg" width="300" height="500" title="图2" alt="图2" ></p>
</li>
<li><p>​    vpa的操作<br><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20150120/20150120_fig003.jpg" width="400" height="500" title="图3" alt="图3" ></p>
</li>
</ol>
<hr>
<h4 id="解非齐次线性方程组"><a href="#解非齐次线性方程组" class="headerlink" title="解非齐次线性方程组"></a>解非齐次线性方程组</h4><script type="math/tex; mode=display">
\left\{\begin{array}{l} 6x_1+2x_2+3x_3+4x_4+5x_5=80\\
2x_1-3x_2+7x_3+10x_4+13x_5=59\\
3x_1+5x_2+11x_3-16x_4+21x_5=90\\
2x_1-7x_2+7x_3+7x_4+2x_5=22\\
7x_1+3x_2-5x_3+3x_4+10x_5=85
\end{array}\right.</script><p><strong>可以通过以下四种方法求解该方程组：</strong></p>
<p>用矩阵表示上述的线性方程组如下：</p>
<script type="math/tex; mode=display">
A=\left[\begin{array}{ccccc}6&2&3&4&5\\2&-3&7&10&13\\3&5&11&-16&21\\2&-7&7&7&2\\7&3&-5&3&10\end{array}\right],
b=\left[\begin{array}{c}80\\59\\90\\22\\85\end{array}\right]</script><ul>
<li><p><strong>求逆矩阵法</strong></p>
<script type="math/tex; mode=display">
Ax=b\rightarrow x=A^{-1}b</script></li>
<li><p><strong>矩阵左除法</strong></p>
<script type="math/tex; mode=display">
x=A\backslash b</script></li>
<li><p><strong>初等行变换</strong></p>
<script type="math/tex; mode=display">
Ax=b\rightarrow x=A^{-1}b\rightarrow rref\left[\begin{array}{c}A&b\end{array}\right]=\left[\begin{array}{c}A^{-1}A&A^{-1}b\end{array}\right]=\left[\begin{array}{c}I&x\end{array}\right]</script></li>
<li><p><strong>卡莱姆法则</strong></p>
<script type="math/tex; mode=display">
x_i=\frac{\det(A_i)}{\det(A)}</script></li>
</ul>
<p><strong>具体的程序实现如下：</strong></p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clear all</span><br><span class="line">clc</span><br><span class="line"> </span><br><span class="line">A=[ <span class="number">6</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span></span><br><span class="line">    <span class="number">2</span> <span class="number">-3</span> <span class="number">7</span> <span class="number">10</span> <span class="number">13</span></span><br><span class="line">    <span class="number">3</span> <span class="number">5</span> <span class="number">11</span> <span class="number">-16</span> <span class="number">21</span></span><br><span class="line">    <span class="number">2</span> <span class="number">-7</span> <span class="number">7</span> <span class="number">7</span> <span class="number">2</span></span><br><span class="line">    <span class="number">7</span> <span class="number">3</span> <span class="number">-5</span> <span class="number">3</span> <span class="number">10</span>]</span><br><span class="line">b=[<span class="number">80</span> <span class="number">59</span> <span class="number">90</span> <span class="number">22</span> <span class="number">85</span>]'</span><br><span class="line"> </span><br><span class="line">x1=inv(A)*b<span class="comment">%逆矩阵法</span></span><br><span class="line">x2=A\b<span class="comment">%矩阵左除法</span></span><br><span class="line">x3=rref([A b])<span class="comment">%初等行变换</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">%克拉姆法则</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:<span class="built_in">length</span>(A)</span><br><span class="line">    B=A;</span><br><span class="line">    B(:,<span class="built_in">i</span>)=b;</span><br><span class="line">    x(<span class="built_in">i</span>)=det(B)/det(A);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">x'</span><br></pre></td></tr></table></figure>
<p><strong>运行结果如下图：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20150120/20150120_fig004.jpg" width="400" height="500" title="图4" alt="图4" ></p>
<p><strong>注意事项：</strong>当系数矩阵$A$不是方阵，或$A$的行列式为$0$时，逆矩阵法和克拉姆法则无法使用，而初等行变换能适用于各种线性方程组的求解。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>【生活随笔】Introspection of my life in 2014</title>
    <url>/2015/01/16/%5B20150116%5D/</url>
    <content><![CDATA[<p>2014年已过去两星期，有写年度总结的必要了。今天特意看了看去年1月5日写的2013年度总结，看看都有些什么变化。我发现每年作一次总结是很有必要的，无赖恰逢考试周，连元旦都不能好好过，更不用说写写文章了。</p>
<p>这一年是转折的一年：从本科变成了研究生，从学长又退化成学弟了，从新校区来到了老校区，送走了四年的老同学，也引来了新同学。时间都去哪了呢？</p>
<p>上半年,每天和鬼王、普哥去实验室学习点新技能，其实际目的是去实验室免费使用校园网，20G流量3人用其实很多了，奈何普哥每次都在线看新闻，每月底流量就不够了。每周还要抽出一天时间看个论文，用Matlab仿真，然后交个周报，晚上和学姐他们宿舍或普哥宿舍玩游戏。接着就是毕设，接着就是吃饭照毕业照，接着就是授位仪式，有幸能得到郑校长的亲自授位，接着就是各奔东西……。宿舍的小伙伴们去了天南地北，想想有机会写篇文章纪念纪念，记得舸哥临走前一晚还熬夜给我们宿舍每个人写了一份信，我至今仍好好保存着。</p>
<p>暑假也是在学校，没有回家。七月底到八月初的时候，用了大概半个月的时间写了个查词典的软件。本来想加入背单词及代码优化的，导师便来召唤我去帮他做项目了。接着下学期基本上就是在上课和这个项目上弄着，没想到研究所课也这么多，每天晚上都有。这期间也看了看部分线性代数的公开课，也写了一个3D迷宫游戏，好吧，算不上游戏，想想我们本科时候教线代的老师就知道为什么要重看线代了。基本上每个月去趟新校区看看学姐（注：学姐，男，湖北洪湖人氏，不知始何名，勤奋好学，故谓之曰学姐云。反正学姐不上qq,哈哈）。双十一的时候，买了几本书，基本上也没咋看……。十二月下旬的时候，完成导师指定的任务后，就临时抱佛脚的开始了复习考试。</p>
<h4 id="2014总评"><a href="#2014总评" class="headerlink" title="2014总评"></a>2014总评</h4><p>作家格拉德威尔指出：只要经过1万小时的锤炼，任何人都能从平凡变成超凡。我想，写过一万行代码也算得上编程入门了。2013年度总结中提到要学习一下界面编程，这一点应该来说是实现了。仔细算来，用qt写的程序也超过一万行了吧，也算是入门了吧；提及到要坚持锻炼，这一点没做到，只是在暑假的时候每天去跑步，之后就懒散了；提及到要多上自习，这一点也没有做到，基本上下课后就是去实验室帮导师干活；提及要继续写作，从上学期到目前为止，已经写了恰好九九八十一篇文章了，每个月都写，从未间断。总体评价，一半一半吧。</p>
<h4 id="2015计划"><a href="#2015计划" class="headerlink" title="2015计划"></a>2015计划</h4><ul>
<li>注重理论学习，高中物理老师说的好：最主要的思想！要厚积薄发！</li>
<li>每天都去自习室里看点书，少看点电视，少玩游戏；  </li>
<li>坚持跑步，为了那可能的车行；(西安周围50公里都基本骑过，最远从西安骑到延安—20200901)</li>
<li>少干点编程的活，跟着导师学点International Research的能力；</li>
<li>学好数学，这真的很重要！在这一年里，把具体数学看完，组合数学也要继续；</li>
<li>完成基础的机器学习算法的理论学习，并且用代码实现十种左右的机器学习算法；(这么多年过去了，终于完成了! —20200901)</li>
<li>重拾Matlab编程，学习Matlab在数学中的计算； </li>
<li>花心思写一点高质量的文章，写了这么多感觉没有几篇是花了很大心思的，都是在一两个小时就完成的，以后注意点，文章在精而不在多；</li>
<li>少抱怨导师叫你干活，虽然我时不时这么干，但我始终相信你所做的在目前看来没啥用处的事情，终会在某一天你会发现它的用处。就拿我来说，导师叫我暑假看看机器学习算法并仿真，结果在这学期的两个选修课的大作业基本上就已经完成了，而且在机器学习的考试中，还考了暑假导师叫我看的SVM。</li>
</ul>
<h4 id="短期安排"><a href="#短期安排" class="headerlink" title="短期安排"></a>短期安排</h4><p>  已经到1月16日，离回家恰好还有一个月左右的时间。这一阶段的短期目标：</p>
<ul>
<li>首先，完成The element of style的阅读，并用latex进行排版。也极力推荐大家去读读，特别是准备发表国际论文的同学。第一次接触，还是普哥导师要求他们看的，前几天上宽带无线的时候王玺君老师也提到了这本书。本来我从普哥实验室杂物堆里拿了一本看了一部分，记得封面还印着辟邪剑谱，后来又没看了；</li>
<li>其次，是对数值分析和工程优化这两门课的部分算法用程序实现，毕竟学了要会用；</li>
<li>最后，就是对已经写好的一些代码进行注释工作，太懒了，拖到现在。</li>
</ul>
<p>Last but not the least, 每个人都有各自的经历，每个人都是一本书，就看你愿不愿意记录下来。我想，许多年后，自己再来看看在哪一年都干了些啥，那将别是一番感悟。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>Life Thoughts</tag>
      </tags>
  </entry>
  <entry>
    <title>【Qt编程】基于QWT的曲线绘制及图例显示操作</title>
    <url>/2014/12/13/%5B20141213%5D/</url>
    <content><![CDATA[<p>   在<a href="http://blog.csdn.net/tengweitw/article/details/41776901" target="_blank" rel="noopener">《QWT在QtCreator中的安装与使用》</a>一文中，我们完成了QWT的安装，这篇文章我们讲讲基础曲线的绘制功能。</p>
<a id="more"></a>
<p>   <strong>首先</strong>，我们新建一个Qt应用程序，然后一路默认即可。这时，你会发现总共有：mainwindow.h，mainwindow.cpp，main.cpp，mainwindow.ui四个文件。</p>
<p>   <strong>然后</strong>，选中项目，添加新文件，添加一个c++类，我们假设命名为PlotLines，基类选择QwtPlot，选择继承自QWidget。</p>
<p>   <strong>接着</strong>，在pro文件中添加</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">INCLUDEPATH +=D:\Qt\Qt5<span class="number">.3</span><span class="number">.0</span>\<span class="number">5.3</span>\msvc2010_opengl\include\QWT</span><br><span class="line">LIBS+= -lqwtd</span><br></pre></td></tr></table></figure>
<p>   <strong>注意</strong>，<strong>我这里是将绘制曲线单独用一个类PlotLines表示的，而不是向参考实例一样是直接放在其他类的内部。所以这里我们需要在类的头文件中添加关键性语句：<br>  #define QWT_DLL</strong></p>
<p>   <strong>最后</strong>，在主文件main.cpp中添加我们类的头文件，并在函数中生成该类的实例并显示，修改后的main.cpp文件如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mainwindow.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"plotlines.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"><span class="comment">//    MainWindow w;//这里的主窗口我们没有使用，当然也可以在主窗口中显示曲线</span></span><br><span class="line"><span class="comment">//    w.show();</span></span><br><span class="line"></span><br><span class="line">    PlotLines line;</span><br><span class="line">    line.show();</span><br><span class="line">    <span class="keyword">return</span> a.exec();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>PlotLines.h文件如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#ifndef PLOTLINES_H</span><br><span class="line">#define PLOTLINES_H</span><br><span class="line">#define QWT_DLL</span><br><span class="line">#include<span class="tag">&lt;<span class="name">qwt_plot.h</span>&gt;</span></span><br><span class="line">#include <span class="tag">&lt;<span class="name">qwt_plot_layout.h</span>&gt;</span></span><br><span class="line">#include <span class="tag">&lt;<span class="name">qwt_plot_canvas.h</span>&gt;</span></span><br><span class="line">#include <span class="tag">&lt;<span class="name">qwt_plot_renderer.h</span>&gt;</span></span><br><span class="line">#include <span class="tag">&lt;<span class="name">qwt_plot_grid.h</span>&gt;</span></span><br><span class="line">#include <span class="tag">&lt;<span class="name">qwt_plot_histogram.h</span>&gt;</span></span><br><span class="line">#include <span class="tag">&lt;<span class="name">qwt_plot_curve.h</span>&gt;</span></span><br><span class="line">#include <span class="tag">&lt;<span class="name">qwt_plot_zoomer.h</span>&gt;</span></span><br><span class="line">#include <span class="tag">&lt;<span class="name">qwt_plot_panner.h</span>&gt;</span></span><br><span class="line">#include <span class="tag">&lt;<span class="name">qwt_plot_magnifier.h</span>&gt;</span></span><br><span class="line"></span><br><span class="line">#include <span class="tag">&lt;<span class="name">qwt_legend.h</span>&gt;</span></span><br><span class="line">#include <span class="tag">&lt;<span class="name">qwt_legend_label.h</span>&gt;</span></span><br><span class="line">#include <span class="tag">&lt;<span class="name">qwt_column_symbol.h</span>&gt;</span></span><br><span class="line">#include <span class="tag">&lt;<span class="name">qwt_series_data.h</span>&gt;</span></span><br><span class="line">#include <span class="tag">&lt;<span class="name">qpen.h</span>&gt;</span></span><br><span class="line">#include <span class="tag">&lt;<span class="name">qwt_symbol.h</span>&gt;</span></span><br><span class="line">#include <span class="tag">&lt;<span class="name">qwt_picker_machine.h</span>&gt;</span></span><br><span class="line">class PlotLines : public QwtPlot</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line">public:</span><br><span class="line">    explicit PlotLines(QWidget *parent = 0);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">private Q_SLOTS:</span><br><span class="line">    void showItem(const QVariant &amp;itemInfo, bool on);//点击图例，显示相应的曲线</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">#endif // PLOTLINES_H</span><br></pre></td></tr></table></figure>
<p>PlotLines.cpp文件如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"plotlines.h"</span></span></span><br><span class="line"></span><br><span class="line">PlotLines::PlotLines(QWidget *parent) :</span><br><span class="line">    QwtPlot(parent)</span><br><span class="line">&#123;</span><br><span class="line">    setTitle(<span class="string">"图的标题"</span>);</span><br><span class="line"><span class="comment">//---------设置画布---------//</span></span><br><span class="line">    QwtPlotCanvas *canvas=<span class="keyword">new</span> QwtPlotCanvas();</span><br><span class="line">    canvas-&gt;setPalette(Qt::white);</span><br><span class="line">    canvas-&gt;setBorderRadius(<span class="number">10</span>);</span><br><span class="line">    setCanvas( canvas );</span><br><span class="line">    plotLayout()-&gt;setAlignCanvasToScales( <span class="literal">true</span> );</span><br><span class="line"></span><br><span class="line">    <span class="comment">//-----------设置x，y坐标和范围--------------//</span></span><br><span class="line">    setAxisTitle( QwtPlot::yLeft, <span class="string">"ylabel"</span> );</span><br><span class="line">    setAxisTitle( QwtPlot::xBottom, <span class="string">"xlabel"</span> );</span><br><span class="line">    setAxisScale(QwtPlot::yLeft,<span class="number">0.0</span>,<span class="number">10.0</span>);</span><br><span class="line">    setAxisScale(QwtPlot::xBottom,<span class="number">0.0</span>,<span class="number">10.0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//----------------设置栅格线-------------------//</span></span><br><span class="line">    QwtPlotGrid *grid = <span class="keyword">new</span> QwtPlotGrid;</span><br><span class="line">    grid-&gt;enableX( <span class="literal">true</span> );<span class="comment">//设置网格线</span></span><br><span class="line">    grid-&gt;enableY( <span class="literal">true</span> );</span><br><span class="line">    grid-&gt;setMajorPen( Qt::black, <span class="number">0</span>, Qt::DotLine );</span><br><span class="line">    grid-&gt;attach( <span class="keyword">this</span> );</span><br><span class="line"></span><br><span class="line">    <span class="comment">//-----------------开始画图----------------------//</span></span><br><span class="line">    QwtPlotCurve *curve=<span class="keyword">new</span> QwtPlotCurve(<span class="string">"curve"</span>);</span><br><span class="line">   <span class="comment">// curve-&gt;setTitle( "信道"+QString( "%1 " ).arg( i+1));</span></span><br><span class="line">    curve-&gt;setPen(Qt::blue,<span class="number">2</span>);<span class="comment">//设置曲线颜色 粗细</span></span><br><span class="line">    curve-&gt;setRenderHint(QwtPlotItem::RenderAntialiased,<span class="literal">true</span>);<span class="comment">//线条光滑化</span></span><br><span class="line"></span><br><span class="line">    QwtSymbol *symbol = <span class="keyword">new</span> QwtSymbol( QwtSymbol::Ellipse,</span><br><span class="line">    QBrush( Qt::yellow ), QPen( Qt::red, <span class="number">2</span> ), QSize( <span class="number">6</span>, <span class="number">6</span>) );<span class="comment">//设置样本点的颜色、大小</span></span><br><span class="line">    curve-&gt;setSymbol( symbol );<span class="comment">//添加样本点形状</span></span><br><span class="line"></span><br><span class="line">    QPolygonF points1, points2;<span class="comment">//输入节点数据QPointF(x,y)</span></span><br><span class="line">    points1&lt;&lt;QPointF(<span class="number">1</span>,<span class="number">1</span>)&lt;&lt;QPointF(<span class="number">2</span>,<span class="number">2</span>)&lt;&lt;QPointF(<span class="number">3</span>,<span class="number">3</span>)&lt;&lt;QPointF(<span class="number">4</span>,<span class="number">4</span>)&lt;&lt;QPointF(<span class="number">5</span>,<span class="number">5</span>)&lt;&lt;QPointF(<span class="number">6</span>,<span class="number">6</span>)&lt;&lt;QPointF(<span class="number">7</span>,<span class="number">7</span>);</span><br><span class="line">    points2&lt;&lt;QPointF(<span class="number">1</span>,<span class="number">2</span>)&lt;&lt;QPointF(<span class="number">2</span>,<span class="number">3</span>)&lt;&lt;QPointF(<span class="number">3</span>,<span class="number">4</span>)&lt;&lt;QPointF(<span class="number">4</span>,<span class="number">5</span>)&lt;&lt;QPointF(<span class="number">5</span>,<span class="number">6</span>)&lt;&lt;QPointF(<span class="number">6</span>,<span class="number">7</span>)&lt;&lt;QPointF(<span class="number">7</span>,<span class="number">8</span>);</span><br><span class="line">    curve-&gt;setSamples(points1);</span><br><span class="line">    curve-&gt;attach( <span class="keyword">this</span> );</span><br><span class="line">    curve-&gt;setLegendAttribute(curve-&gt;LegendShowLine);<span class="comment">//显示图例的标志，这里显示线的颜色。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//曲线2的形状采用默认，即不单独设置画笔的颜色、样本点的显示</span></span><br><span class="line">    QwtPlotCurve *curve2=<span class="keyword">new</span> QwtPlotCurve(<span class="string">"curve2"</span>);</span><br><span class="line">    curve2-&gt;setSamples(points2);</span><br><span class="line">    curve2-&gt;attach( <span class="keyword">this</span> );</span><br><span class="line">    curve2-&gt;setLegendAttribute(curve-&gt;LegendShowLine);</span><br><span class="line"></span><br><span class="line"><span class="comment">//--------------设置图例可以被点击来确定是否显示曲线-----------------------//</span></span><br><span class="line">    QwtLegend *legend = <span class="keyword">new</span> QwtLegend;</span><br><span class="line">    legend-&gt;setDefaultItemMode( QwtLegendData::Checkable );<span class="comment">//图例可被点击</span></span><br><span class="line">    insertLegend( legend, QwtPlot::RightLegend );</span><br><span class="line">    connect( legend, SIGNAL( checked( <span class="keyword">const</span> QVariant &amp;, <span class="keyword">bool</span>, <span class="keyword">int</span> ) ),</span><br><span class="line">        SLOT( showItem( <span class="keyword">const</span> QVariant &amp;, <span class="keyword">bool</span> ) ) );<span class="comment">//点击图例操作</span></span><br><span class="line"></span><br><span class="line">    QwtPlotItemList items = itemList( QwtPlotItem::Rtti_PlotCurve );<span class="comment">//获取画了多少条曲线,如果为获取其他形状，注意改变参数</span></span><br><span class="line">   <span class="comment">//  qDebug()&lt;&lt;items;</span></span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; items.size(); i++ )</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ( i == <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">const</span> QVariant itemInfo = itemToInfo( items[i] );</span><br><span class="line"></span><br><span class="line">            QwtLegendLabel *legendLabel =</span><br><span class="line">                qobject_cast&lt;QwtLegendLabel *&gt;( legend-&gt;legendWidget( itemInfo ) );</span><br><span class="line">            <span class="keyword">if</span> ( legendLabel )</span><br><span class="line">                legendLabel-&gt;setChecked( <span class="literal">true</span> );<span class="comment">//</span></span><br><span class="line"></span><br><span class="line">            items[i]-&gt;setVisible( <span class="literal">true</span> );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            items[i]-&gt;setVisible( <span class="literal">false</span> );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>-&gt;resize(<span class="number">600</span>,<span class="number">400</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>-&gt;replot();</span><br><span class="line"></span><br><span class="line">    setAutoReplot( <span class="literal">true</span> );<span class="comment">//设置自动重画，相当于更新</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//点击图例，显示相应的曲线</span></span><br><span class="line"><span class="keyword">void</span> PlotLines::showItem(<span class="keyword">const</span> QVariant &amp;itemInfo, <span class="keyword">bool</span> on)</span><br><span class="line">&#123;</span><br><span class="line">    QwtPlotItem *plotItem = infoToItem( itemInfo );</span><br><span class="line">    <span class="keyword">if</span> ( plotItem )</span><br><span class="line">        plotItem-&gt;setVisible( on );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>其他的文件没有作任何改变，在此就不列出来了</strong>。显示结果如下图：</p>
<p><strong>1、初始界面如下：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20141213/20141213_fig001.jpg" width="600" height="400" title="图1" alt="图1" ></p>
<p><strong>2、点击右上角的图例后：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20141213/20141213_fig002.jpg" width="600" height="400" title="图2" alt="图2" ></p>
<p><strong>本文所创建的PlotLines类，完成的功能如下：</strong></p>
<p>1、坐标轴的绘制</p>
<p>2、根据数据点绘制相应的曲线</p>
<p>3、右上角的图例可以点击，并显示或隐藏对应曲线</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>Qt Coding</tag>
      </tags>
  </entry>
  <entry>
    <title>【Qt编程】QWT在QtCreator中的安装与使用</title>
    <url>/2014/12/08/%5B20141208%5D/</url>
    <content><![CDATA[<p>由于导师项目的需要，需要画图，二维+三维。三维图我用的是Qt+opengl，二维图我决定使用qwt工具库来加快我的项目进展，毕竟还有期末考试。关于Qt+opengl的使用有时间的话以后再介绍。</p>
<p>首先我们说说QWT是什么？下面是百度百科的介绍：</p>
<p>QWT，全称是Qt Widgets for Technical Applications，是一个基于LGPL版权协议的开源项目， 可生成各种统计图。它为具有技术专业背景的程序提供GUI组件和一组实用类，其目标是以基于2D方式的窗体部件来显示数据， 数据源以数值，<a href="http://baike.baidu.com/view/209670.htm" target="_blank" rel="noopener">数组</a>或一组浮点数等方式提供， 输出方式可以是Curves（曲线），Slider（滚动条），Dials（圆盘），Compasses（仪表盘）等等。该工具库基于Qt开发，所以也继承了Qt的跨平台特性。</p>
<a id="more"></a>
<hr>
<h2 id="安装环境"><a href="#安装环境" class="headerlink" title="安装环境"></a>安装环境</h2><p>   win7系统</p>
<p>   <a href="http://pan.baidu.com/s/1pJx83I7" target="_blank" rel="noopener"> Qt5.3.0  qt-opensource-windows-x86-msvc2010_opengl-5.3.0</a></p>
<p>   <a href="http://download.csdn.net/detail/tengweitw/8222455" target="_blank" rel="noopener"> qwt6.1(已编译的文件) </a></p>
<p>   <a href="http://download.csdn.net/detail/tengweitw/8231313" target="_blank" rel="noopener"> qwt 官方文档 </a></p>
<hr>
<h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>如果下载上述的已编译文件qwt6.1，则不需要这一步。我曾经遇到的问题：我下载了qwt源码，然后用QtCreator打开项目，进行编译，经过十分钟左右编译完成，然后将生成的相关文件放入指定位置(这一步在下面有介绍)，然后发现，qwt插件不能用。有的人可能会出现，在Qt Designer中可以显示qwt插件，但是在QtCreator中无法显示，这是因为使用不同编译器编译的结果。所以说，最好使用vs编译器，而不是使用mingw编译器(尽管mingw在语言支持上更好用)！为了避免上面可能出现的问题，你最好还是下载上面我给出的已经编译好的qwt文件。</p>
<hr>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>下载或则编译好qwt文件后，需要做的工作如下(以我给出的编译好的qwt文件为例，我的QtCreator的安装目录为：D:\Qt\Qt5.3.0\5.3\msvc2010_opengl)：</p>
<p>具体目录如下图：</p>
<h3 id="1、qwt文件目录："><a href="#1、qwt文件目录：" class="headerlink" title="1、qwt文件目录："></a>1、qwt文件目录：</h3><p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20141208/20141208_fig001.jpg" width="400" height="600" title="图1" alt="图1" ></p>
<h3 id="2、Qt安装目录："><a href="#2、Qt安装目录：" class="headerlink" title="2、Qt安装目录："></a>2、Qt安装目录：</h3><p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20141208/20141208_fig002.jpg" width="600" height="400" title="图2" alt="图2" ></p>
<h3 id="操作如下："><a href="#操作如下：" class="headerlink" title="操作如下："></a>操作如下：</h3><p>1、将D:\QWT\lib中qwt.dll、qwtd.dll文件拷贝到D:\Qt\Qt5.3.0\5.3\msvc2010_opengl\bin文件夹中。</p>
<p>2、将D:\QWT\lib中qwt.lib、qwt.lib文件拷贝到D:\Qt\Qt5.3.0\5.3\msvc2010_opengl\lib文件夹中。</p>
<p>3、将D:\QWT\designer\plugins\designer中的qwt_designer_plugin.dll和qwt_designer_plugin.lib拷贝到D:\Qt\Qt5.3.0\Tools\QtCreator\bin\plugins\designer目录下。</p>
<p>4、将D:\QWT\src中的所有.h文件都放入一个新建名为QWT的文件夹中，然后将这个文件夹拷贝到D:\Qt\Qt5.3.0\5.3\msvc2010_opengl\include</p>
<hr>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>打开QtCreator，建一个qt应用程序，打开.ui文件，你就会发现qwt控件：</p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20141208/20141208_fig003.jpg" width="500" height="600" title="图3" alt="图3" ></p>
<p>这时，你向窗口中拖入两个qwt控件，如上图右边所示，然后运行程序，你就发现错误，这时你需要在.pro文件中添加如下代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">INCLUDEPATH +=D:\Qt\Qt5<span class="number">.3</span><span class="number">.0</span>\<span class="number">5.3</span>\msvc2010_opengl\include\QWT</span><br><span class="line">LIBS+= -lqwtd</span><br></pre></td></tr></table></figure>
<p>注意上面的路径与你自己的安装目录有关！这里使用的是debug方式，如果是release方式，将lqwtd改为lqwt即可。BTW，一般来说名称后面带d的都是与debug有关的，没带d的与release有关，这些文件在qt的动态链接库(.dll)文件中非常常见。</p>
<p>这时再运行程序就会得到正确结果：</p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20141208/20141208_fig004.jpg" width="400" height="600" title="图4" alt="图4" ></p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>Qt Coding</tag>
      </tags>
  </entry>
  <entry>
    <title>【线性代数】标准正交矩阵与Gram-Schmidt正交化</title>
    <url>/2014/12/06/%5B20141206%5D/</url>
    <content><![CDATA[<h2 id="标准正交矩阵"><a href="#标准正交矩阵" class="headerlink" title="标准正交矩阵"></a>标准正交矩阵</h2><p>  假设矩阵$Q$有列向量$q1, q2,\cdots, q_n$表示，且其列向量满足下式：</p>
<script type="math/tex; mode=display">
Q=\left[\begin{array}{cccc}q_1&q_2&\cdots&q_n\end{array}\right]\\
\begin{aligned}
q_i^Tq_j=\left\{  
             \begin{array}{**lr**}  
            0\quad i\neq j \\  
            1\quad i=j   
             \end{array}  
\right. 
\end{aligned}</script><p>则</p>
<script type="math/tex; mode=display">
Q^TQ=\left[\begin{array}{c}q_1\\q_2\\\vdots\\q_n\end{array}\right]
\left[\begin{array}{cccc}q_1&q_2&\cdots&q_n\end{array}\right]=I_{n\times n}</script><p>若$Q$为方阵，由上面的式子则有</p>
<script type="math/tex; mode=display">
Q^TQ=I\rightarrow Q^T=Q^{-1}</script><p><strong>我们举例说明上述概念：</strong></p>
<script type="math/tex; mode=display">
Q=\left[\begin{array}{ccc}0&0&1\\1&0&0\\0&1&0\end{array}\right],
Q^T=\left[\begin{array}{ccc}0&1&0\\0&0&1\\1&0&0\end{array}\right]\rightarrow
QQ^T=\left[\begin{array}{ccc}1&0&0\\0&1&0\\0&0&1\end{array}\right]=I</script><a id="more"></a>
<hr>
<h2 id="标准正交矩阵的好处"><a href="#标准正交矩阵的好处" class="headerlink" title="标准正交矩阵的好处"></a>标准正交矩阵的好处</h2><p>上面我们介绍了标准正交矩阵，那么标准正交矩阵的用处在哪？<strong>下面以两方面来说明标准正交矩阵的用处：</strong></p>
<h3 id="求解-Ax-b"><a href="#求解-Ax-b" class="headerlink" title="求解$Ax=b$"></a>求解$Ax=b$</h3><p>在前面文章<a href="http://blog.csdn.net/tengweitw/article/details/41174555" target="_blank" rel="noopener">《正交投影》</a>中，有下式：</p>
<script type="math/tex; mode=display">
x=(A^TA)^{-1}A^Tb</script><p>当矩阵$A$为标准正交矩阵$Q$时，由于正交矩阵与其转置的乘积为单位矩阵，则上式可以转化为：</p>
<script type="math/tex; mode=display">
x=(Q^TQ)^{-1}Q^Tb=Q^Tb</script><p>可以发现，求$x$时不需要矩阵$Q$的逆，只需要知道转置即可，这样简化了计算。</p>
<h3 id="求解投影矩阵"><a href="#求解投影矩阵" class="headerlink" title="求解投影矩阵"></a>求解投影矩阵</h3><p>在前面文章<a href="http://blog.csdn.net/tengweitw/article/details/41174555" target="_blank" rel="noopener">《正交投影》</a>中，投影矩阵的通式可以表示为：</p>
<script type="math/tex; mode=display">
P=A(A^TA)^{-1}A^T</script><p>当矩阵$A$为标准正交矩阵$Q$时，由于正交矩阵与其转置的乘积为单位矩阵，则上式可以转化为：</p>
<script type="math/tex; mode=display">
P=Q(Q^TQ)^{-1}Q^T=QQ^T</script><p>这样就将投影矩阵简单化了。</p>
<hr>
<h2 id="Gram-Schmidt正交化"><a href="#Gram-Schmidt正交化" class="headerlink" title="Gram-Schmidt正交化"></a>Gram-Schmidt正交化</h2><p>任何复杂问题的求解都可以从简单的问题出发。聪明的数学家不会羞于考虑小问题，因为当最简单的情况弄得明明白白时，一般的形式就容易理解了。并且，简单的情况不仅帮我们发现一般的公式，而且还提供了一种便利的核查方法，看看我们是否犯下了愚蠢的错误。下面我们就从简单的二维情况讨论：</p>
<h3 id="二维情况"><a href="#二维情况" class="headerlink" title="二维情况"></a>二维情况</h3><p> 假设原来的矩阵为$[a,b]$，$a,b$为线性无关的二维向量，下面我们通过Gram-Schmidt正交化使得矩阵$A$为标准正交矩阵：</p>
<p>假设正交化后的矩阵为$Q=[A,B]$,我们可以令$A=a$，那么我们的目的根据$AB=I$来求$B$。如下面的二维情况所示，$B$的方向与$A$成$90$度。图中还表明，$B$可以表示为$b$向量与$b$向量在$a$上的投影的误差向量。由《正交投影》中的结论可知，有如下关系成立：</p>
<script type="math/tex; mode=display">
B=b-Pb=b-\frac{A^Tb}{A^TA}A</script><hr>
<h3 id="三维情况"><a href="#三维情况" class="headerlink" title="三维情况"></a>三维情况</h3><p>假设原来的矩阵为$[a, b, c]$，$a, b, c$为线性无关的二维向量，正交化后的矩阵为$Q=[A, B, C]$,我们可以令$A=a$，则可以根据二维情况得到如下猜想：</p>
<script type="math/tex; mode=display">
B=b-Pb=b-\frac{A^Tb}{A^TA}A\\
C=c-\frac{A^Tc}{A^TA}A-\frac{B^Tc}{B^TB}B</script><p>上式显然满足$AB=0, AC=0, BC=0$。</p>
<p><strong>下面我们用实例说明正交化的过程：</strong></p>
<p>假设矩阵为$[a, b]$:</p>
<script type="math/tex; mode=display">
a=\left[\begin{array}{c}1\\1\\1\end{array}\right],
b=\left[\begin{array}{c}1\\0\\2\end{array}\right]</script><p>则由二维情况的结论可知：</p>
<script type="math/tex; mode=display">
A=a, B=b-\frac{A^Tb}{A^TA}A</script><p>把具体数值代入得：</p>
<script type="math/tex; mode=display">
B=\left[\begin{array}{c}0\\-1\\1\end{array}\right]</script><p>经过归一化得：</p>
<script type="math/tex; mode=display">
Q=\left[\begin{array}{c}\frac{A}{\Vert A\Vert}&\frac{B}{\Vert B\Vert}\end{array}\right]
=\left[\begin{array}{cc}\frac{\sqrt{3}}{3}&0\\\frac{\sqrt{3}}{3}&-\frac{\sqrt{2}}{2}\\\frac{\sqrt{3}}{3}&\frac{\sqrt{2}}{2}\end{array}\right]</script><p><strong>$Q$即是我们经过正交化后的正交矩阵。</strong></p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>Linear Algebra</tag>
      </tags>
  </entry>
  <entry>
    <title>【线性代数】最小二乘与投影矩阵</title>
    <url>/2014/12/05/%5B20141205%5D/</url>
    <content><![CDATA[<p>​    前一篇文章<a href="http://blog.csdn.net/tengweitw/article/details/41174555" target="_blank" rel="noopener">《正交投影》</a>中我们讲述了正交投影，现在我们来从正交投影的角度来看看我们熟悉的最小二乘法。我记得最早知道最小二乘法是在大一上高数课的时候，我们首先回顾一下什么是最小二乘法。</p>
<a id="more"></a>
<hr>
<h2 id="最小二乘法"><a href="#最小二乘法" class="headerlink" title="最小二乘法"></a>最小二乘法</h2><p>最近机器学习比较火，机器学习中的许多算法都是对信息进行分类，比如说支持向量机就是根据已知信息来分类，神经网络可以找到输入输出的关系（当然，不能给出具体的数学表达式），这两种算法都能找到输入与输出的关系，分类和回归总是相辅相成的。以后有时间也准备写写关于机器学习方面的算法（现在终于开始写了图解例说机器学习系列—2020.0831）。 言归正传，最小二乘法的作用也是从一组数据中找到输入与输出之间的关系。</p>
<p><strong>原理：</strong></p>
<p>设经验方程是$y=f(x)$，方程中含有一些待定系数$a_n$，给出真实值${(x_i,y_i)|i=1,2,\cdots,n}$,将这些$x, y$值代入方程然后作差，可以描述误差：$y_i-f(x_i)$，为了考虑整体的误差，可以取平方和，之所以要平方是考虑到误差可正可负直接相加可以相互抵消，所以记误差(注意误差函数的选择有很多种，我们选用典型的误差函数)为：</p>
<script type="math/tex; mode=display">
E=\sum\limits_{i=1}^n(y_i-f(x_i))^2</script><p>它是一个多元函数，有$a_n$共$n$个未知量，现在要求的是最小值。所以必然满足对各变量的偏导等于$0$，于是得到$n$个方程：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\left\{  
             \begin{array}{**lr**}  
            \frac{\partial E}{\partial a_1}=0\\
            \frac{\partial E}{\partial a_2}=0\\
            \quad\quad\vdots\\
            \frac{\partial E}{\partial a_n}=0

             \end{array}  
\right. 

\end{aligned}</script><p>$n$个方程确定$n$个未知量为常量是理论上可以解出来的。<strong>用这种误差分析的方法进行回归方程的方法就是最小二乘法。</strong></p>
<hr>
<h2 id="最小二乘与投影"><a href="#最小二乘与投影" class="headerlink" title="最小二乘与投影"></a>最小二乘与投影</h2><p>我这个人不喜欢看这些理论，公式推导，而更喜欢用例子来展示算法的思想。例如，在二维坐标系中，有三点，$(1, 1), (2, 2), (3, 2)$，那如何用一条直线来拟合这些点呢？</p>
<p>首先，我们可以假设直线表达式如下所示：</p>
<script type="math/tex; mode=display">
a_1x+a_2=y</script><p>然后计算误差函数：</p>
<script type="math/tex; mode=display">
\begin{aligned}
E&=(a_1+a_2-1)^2+(2a_1+a_2-2)^2+(3a_1+a_2-2)^2\\
&=14a_1^2+3a_2^2+12a_1a_2-22a_1-10a_2+9
\end{aligned}</script><p>在求得误差函数$E$对系数$a,b$的偏导，并使之为$0$：</p>
<script type="math/tex; mode=display">
\frac{\partial E}{\partial a_1}=28a_1+12a_2-22=0\\
\frac{\partial E}{\partial a_2}=6a_2+12a_1-10=0</script><p>由上式得到系数$a,b$的值，并得到拟合直线表达式：</p>
<script type="math/tex; mode=display">
a_1=\frac{1}{2},a_2=\frac{2}{3}\rightarrow y=\frac{1}{2}x+\frac{2}{3}</script><p>通过最小二乘法得到的曲线如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20141205/20141205_fig001.jpg" width="600" height="450" title="图1" alt="图1" ></p>
<p><strong>线性代数角度看最小二乘法：</strong></p>
<p>  同样假设拟合直线的表达式设为：</p>
<script type="math/tex; mode=display">
a_1x+a_2=y</script><p>拟合的目的就是使得数据点都满足上述函数表达式，即：</p>
<script type="math/tex; mode=display">
a_1+a_2=1\\
2a_1+a_2=2\\
3a_1+a_2=2</script><p>用矩阵形式表示如下：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\underbrace{\left[\begin{array}{cc}1&1\\2&1\\3&1\end{array}\right]}_{A}
\underbrace{\left[\begin{array}{c}a_1\\a_2\end{array}\right]}_{a}
=\underbrace{\left[\begin{array}{c}1\\2\\2\end{array}\right]}_{b}
\end{aligned}</script><p>上面的式子通过高斯消元后，可以发现是无解的！</p>
<p>​    我们可以发现等式的左边$Aa$的值是矩阵$A$中各个列向量的线性组合，<strong>若$Aa=b$有解的话，则$b$一定在矩阵$A$的列空间内</strong>。上面的例子中，右边的向量显然不在其列空间中，因此方程无解。最小二乘法的思想就是在矩阵$A$的列空间中找到一个向量$p$，使得$p$与$b$的误差最小。下面我们就来求$b$:</p>
<script type="math/tex; mode=display">
b=\left[\begin{array}{c}1\\2\\2\end{array}\right],
p=\left[\begin{array}{c}p_1\\p_2\\p_3\end{array}\right],
e=b-p, E=\Vert e\Vert^2,
Aa=p</script><p>$Aa=p$是肯定有解的，因为$p$在矩阵$A$的列空间中。要使得$e$向量的长度最短，当且仅当$p$为$b$在矩阵列空间上的投影！有上一篇<a href="http://blog.csdn.net/tengweitw/article/details/41174555" target="_blank" rel="noopener">《正交投影》</a>中投影矩阵的通式可得：</p>
<script type="math/tex; mode=display">
p=Pb=A(A^TA)^{-1}A^{T}b</script><p>那么将$p$代入公式$Aa=p$可得：</p>
<script type="math/tex; mode=display">
Aa=p=A(A^TA)^{-1}A^Tb\rightarrow A^TAa=A^Tb</script><p>将具体数值代入得：</p>
<script type="math/tex; mode=display">
A^TA=\left[\begin{array}{ccc}1&2&3\\1&1&1\end{array}\right]
\left[\begin{array}{cc}1&1\\2&1\\3&1\end{array}\right]=
\left[\begin{array}{cc}14&6\\6&3\end{array}\right]\\
A^Tb=\left[\begin{array}{ccc}1&2&3\\1&1&1\end{array}\right]
\left[\begin{array}{c}1\\2\\2\end{array}\right]=
\left[\begin{array}{c}11\\5\end{array}\right]</script><p>则可以得到：</p>
<script type="math/tex; mode=display">
\left[\begin{array}{cc}14&6\\6&3\end{array}\right]
\left[\begin{array}{c}a_1\\a_2\end{array}\right]
=\left[\begin{array}{c}11\\5\end{array}\right]\rightarrow
\begin{aligned}
\left\{  
             \begin{array}{**lr**}  
             14a_1+6a_2=11\\
             6a_1+3a_2=5
             \end{array}  
\right. 
\end{aligned}\\
\rightarrow

             a_1=\frac{1}{2},a_2=\frac{2}{3}\rightarrow y=\frac{1}{2}x+\frac{2}{3}</script><p>$b, p, e$向量分别可以表示如下：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\underbrace{\left[\begin{array}{c}1\\2\\2\end{array}\right]}_{b}=
\underbrace{\left[\begin{array}{c}\frac{6}{7}\\\frac{10}{6}\\\frac{13}{6}\end{array}\right]}_{p}
+\underbrace{\left[\begin{array}{c}-\frac{1}{6}\\\frac{2}{6}\\-\frac{1}{6}\end{array}\right]}_{e}
\end{aligned}</script><p>$p, b$在图中的表示如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20141205/20141205_fig002.jpg" width="600" height="450" title="图2" alt="图2" ></p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>Linear Algebra</tag>
      </tags>
  </entry>
  <entry>
    <title>【线性代数】正交投影</title>
    <url>/2014/11/16/%5B20141116b%5D/</url>
    <content><![CDATA[<p>​    我们在初中就应该学过投影，那么什么是投影呢？形象点说，就是将你需要投影的东西上的每一点向你要投影的平面作垂线，垂线与平面的交点的集合就是你的投影。注意这里我们的投影是向量的投影，几何的投影(并不一定是垂直投影的)可见度娘百科。同样的，我们从简单的二维投影来开始讨论。</p>
<a id="more"></a>
<hr>
<h2 id="二维投影"><a href="#二维投影" class="headerlink" title="二维投影"></a>二维投影</h2><p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20141116b/20141116b_fig001.jpg" width="400" height="300" title="图1" alt="图1" ></p>
<p>上图表示的是，向量$b$在向量$a$上的投影为$p$。显然有如下表达式：</p>
<script type="math/tex; mode=display">
e=b-p=b-xa\\
a^Te=0\rightarrow a^T(b-xa)=0\rightarrow xa^Ta=a^Tb\rightarrow x=\frac{a^Tb}{a^Ta}\\
p=ax=a\frac{a^Tb}{a^Ta}\\
Pb=p\rightarrow P=\frac{aa^T}{a^Ta}</script><p>其中，<strong>$P$为投影矩阵</strong>，由$P$的表达式可以看出，它具有如下性质：</p>
<script type="math/tex; mode=display">
P^T=P, P^2=P</script><hr>
<h2 id="三维投影"><a href="#三维投影" class="headerlink" title="三维投影"></a>三维投影</h2><p>三维投影，就是将一个向量投影到一个平面上。同上面一样，假设$b$向量在平面上的投影为$p$，则有表达式：</p>
<script type="math/tex; mode=display">
e=b-p</script><p>$e$是垂直于平面的向量。由于$p$向量在平面上，则$p$向量可以由该平面的$2$个线性无关向量(正如，在$xy$平面的任何向量都可以由$x$轴，$y$轴表示)表示：</p>
<script type="math/tex; mode=display">
p=x_1a_1+x_2a_2=Ax\\
A=[a_1\quad a_2]\\
x=[x_1\quad x_2]^T</script><p><strong>由于$e$垂直于平面，则$e$向量垂直于平面中的任意向量</strong>，则有：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\left\{  
             \begin{array}{**lr**}  
             e=b-p=b-Ax\\
a_1^T(b-Ax)=0\\ a_2^T(b-Ax)=0
             \end{array}  
\right. \rightarrow

             \left[\begin{array}{c}a_1^T\\a_2^T\end{array}\right]\left[b-Ax\right]=0\rightarrow A^T(b-Ax)=0

\end{aligned}</script><p>将上式化简求得$x$：</p>
<script type="math/tex; mode=display">
A^TAx=A^Tb\rightarrow x=(A^TA)^{-1}A^Tb</script><p>又因为$p=Ax$, $Pb=p$，<strong>则得到投影矩阵为：</strong></p>
<script type="math/tex; mode=display">
P=A(A^TA)^{-1}A^T</script><p>由$P$的表达式可以看出，它具有如下性质：</p>
<script type="math/tex; mode=display">
P^T=P, P^2=P</script><p><strong>上面的投影矩阵是通式</strong>，当投影在一维情况时，$A$即为直线上的任意一个向量$a$,投影矩阵为：</p>
<script type="math/tex; mode=display">
P=A(A^TA)^{-1}A^T=a(a^Ta)^{-1}a^T=\frac{aa^T}{a^Ta}</script><p><strong>注意：一个数值的逆是它的倒数。</strong></p>
<hr>
<h2 id="举例说明"><a href="#举例说明" class="headerlink" title="举例说明"></a>举例说明</h2><p><strong>下面以一个实例来说明：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20141116b/20141116b_fig002.jpg" width="500" height="400" title="图1" alt="图1" ></p>
<p>如上图，假设我们要将向量$b$投影到水平面上，其投影为$p$，$a_1$,  $a_2$为水平面的两个线性无关向量，它们的参数分别为：</p>
<script type="math/tex; mode=display">
b=\left[\begin{array}{c}1\\1\\1\end{array}\right],
a_1=\left[\begin{array}{c}1\\0\\0\end{array}\right],
a_2=\left[\begin{array}{c}0\\1\\0\end{array}\right]</script><p>那么$A=[a_1\quad a_2]$即：</p>
<script type="math/tex; mode=display">
A=\left[\begin{array}{cc}1&0\\0&1\\0&0\end{array}\right]</script><p>由上面我们求得的通式，可得投影矩阵$P$:</p>
<script type="math/tex; mode=display">
P=A(A^TA)^{-1}A^T=\left[\begin{array}{ccc}1&0&0\\0&1&0\\0&0&0\end{array}\right]</script><p>知道投影矩阵$P$后，我们可以得到$b$在水平面上的投影$p$为：</p>
<script type="math/tex; mode=display">
p=Pb=\left[\begin{array}{ccc}1&0&0\\0&1&0\\0&0&0\end{array}\right]
\left[\begin{array}{c}1\\1\\1\end{array}\right]=\left[\begin{array}{c}1\\1\\0\end{array}\right]</script><p>显然，$p$与我们图中所示的结果相同。这里我们是以三维情况进行举例的，更高维情况，我们无法用图像来描述，但是通式也是成立的。</p>
<p><strong>三维图的matlab程序如下：</strong></p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clear all</span><br><span class="line">clc</span><br><span class="line"> </span><br><span class="line">a1=[<span class="number">1</span> <span class="number">0</span> <span class="number">0</span>];</span><br><span class="line">a2=[<span class="number">0</span> <span class="number">1</span> <span class="number">0</span>];</span><br><span class="line">b=[<span class="number">1</span> <span class="number">1</span> <span class="number">1</span>];</span><br><span class="line">p=[<span class="number">1</span> <span class="number">1</span> <span class="number">0</span>];</span><br><span class="line">e=b-p;</span><br><span class="line">quiver3(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,a1(<span class="number">1</span>),a1(<span class="number">2</span>),a1(<span class="number">3</span>),<span class="number">1</span>,<span class="string">'color'</span>,<span class="string">'r'</span>)</span><br><span class="line"><span class="built_in">hold</span> on</span><br><span class="line">quiver3(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,a2(<span class="number">1</span>),a2(<span class="number">2</span>),a2(<span class="number">3</span>),<span class="number">1</span>,<span class="string">'color'</span>,<span class="string">'r'</span>)</span><br><span class="line"><span class="built_in">hold</span> on</span><br><span class="line">quiver3(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,b(<span class="number">1</span>),b(<span class="number">2</span>),b(<span class="number">3</span>),<span class="number">1</span>,<span class="string">'color'</span>,<span class="string">'g'</span>)</span><br><span class="line"><span class="built_in">hold</span> on</span><br><span class="line">quiver3(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,p(<span class="number">1</span>),p(<span class="number">2</span>),p(<span class="number">3</span>),<span class="number">1</span>,<span class="string">'color'</span>,<span class="string">'g'</span>)</span><br><span class="line"><span class="built_in">hold</span> on</span><br><span class="line">quiver3(p(<span class="number">1</span>),p(<span class="number">2</span>),p(<span class="number">3</span>),e(<span class="number">1</span>),e(<span class="number">2</span>),e(<span class="number">3</span>),<span class="number">1</span>,<span class="string">'color'</span>,<span class="string">'b'</span>)</span><br></pre></td></tr></table></figure>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>Linear Algebra</tag>
      </tags>
  </entry>
  <entry>
    <title>【线性代数】正交向量与正交子空间</title>
    <url>/2014/11/16/%5B20141116%5D/</url>
    <content><![CDATA[<p>在前面文章<a href="http://blog.csdn.net/tengweitw/article/details/40950001" target="_blank" rel="noopener">《矩阵的四个基本子空间》</a>中提到：</p>
<p>​    一个秩为$r$，$m\times n$的矩阵$A$中，其行空间和列空间的维数为$r$，零空间和左零空间的维数分别为$n-r$，$m-r$，并且有行空间与零空间正交，列空间与左零空间正交。</p>
<p>​    “掌握上面的这个结论就掌握了线性代数的半壁江山！”，MIT教授如是说。那么什么是正交子空间呢？我们首先从我们熟悉的正交向量说起。</p>
<a id="more"></a>
<hr>
<h4 id="正交向量"><a href="#正交向量" class="headerlink" title="正交向量"></a>正交向量</h4><p>  我们都知道，如果两个向量$x,y$正交，则其夹角为$90$度，可表示为表达式：</p>
<script type="math/tex; mode=display">
x^Ty=0</script><p><strong>注意</strong>：$x, y$的顺序没有区别，即下式也成立：</p>
<script type="math/tex; mode=display">
y^Tx=0</script><p><strong>两个向量正交，可以表示为下图：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20141116/20141116_fig001.jpg" width="200" height="150" title="图1" alt="图1" ></p>
<p>由勾股定理可知：</p>
<script type="math/tex; mode=display">
\Vert x\Vert^2+\Vert y\Vert^2=\Vert x+y\Vert^2</script><p>将上式展开得：</p>
<script type="math/tex; mode=display">
x^Tx+y^Ty=(x+y)^T(x+y)=x^Tx+y^Ty+x^Ty+y^Tx\\
0=x^Ty+y^Tx\rightarrow x^Ty=y^Tx=0</script><p><strong>我们举例说明</strong>：假设两个向量分别为$x, y, z=x+y$：</p>
<script type="math/tex; mode=display">
x=\left[\begin{array}{c}1\\2\\3\end{array}\right],
y=\left[\begin{array}{c}2\\-1\\0\end{array}\right],
z=x+y=\left[\begin{array}{c}3\\1\\3\end{array}\right],</script><p>其中$x, y$满足下式：</p>
<script type="math/tex; mode=display">
x^Ty=y^Tx=0</script><p>则<strong>向量的长度（即向量的$2$范数）的平方</strong>为：</p>
<script type="math/tex; mode=display">
\Vert x\Vert^2=14, \Vert y\Vert^2=5,\Vert z\Vert^2=19</script><p>显然满足勾股定理. 上面的推导，已证明勾股定理，自己可以仔细领会。</p>
<hr>
<h4 id="正交子空间"><a href="#正交子空间" class="headerlink" title="正交子空间"></a>正交子空间</h4><p><strong>定义：</strong>两个子空间正交即两个子空间的任意两个向量正交。</p>
<p>文章开头说到，行空间与零空间正交，列空间与左零空间正交。下面我们来证明行空间与零空间正交，列空间与左零空间正交。</p>
<p><em>行空间与零空间正交的证明</em>   </p>
<p>  在<a href="http://blog.csdn.net/tengweitw/article/details/40039373" target="_blank" rel="noopener">《矩阵的零空间》</a>一文中，我们知道，$Ax=0$的解就是矩阵的零空间，则：</p>
<script type="math/tex; mode=display">
Ax=0\rightarrow x=\left[\begin{array}{c}row_1\\row_2\\\vdots\\row_3\end{array}\right]x=0</script><p>展开可得：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\left\{  
             \begin{array}{**lr**}  
             row_1^Tx=0 \\  
             row_2^Tx=0 \\  
             row_3^Tx=0   
             \end{array}  
\right. \rightarrow

             \begin{array}{**lr**}  
             row_1^Tx+row_2^Tx+\cdots+row_n^T=0 
             \end{array}  

\end{aligned}</script><p>上式说明，矩阵的每一行向量都与零空间正交，而矩阵的行空间就是其行向量的线性组合，则说明行空间与零空间正交。同理，我们亦可以证明列空间与左零空间正交，在此就不重复了。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>Linear Algebra</tag>
      </tags>
  </entry>
  <entry>
    <title>【线性代数】图与网络</title>
    <url>/2014/11/13/%5B20141113%5D/</url>
    <content><![CDATA[<p>前面的关于线性代数的文章都是从数学的角度来讲解的，本文将换个角度来讲解问题。导师时常告诉我，凡事都要想想它的物理或实际意义，需要透过现象看本质，这样就能更加深刻的理解，这样就可以看看线性代数有什么实际的用途。</p>
<a id="more"></a>
<p>假设有如下电路网络：</p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20141113/20141113_fig001.jpg" width="400" height="300" title="图1" alt="图1" ></p>
<p>图中有$1, 2, 3, 4$号节点，$y_1, y_2, y_3, y_4, y_5$五条边，箭头的指向标明可以电流流向。我们假设电流的出发点设为$-1$，到达点设为$1$，<strong>则我们可以通过矩阵来表示上述网络：</strong></p>
<script type="math/tex; mode=display">
A=\left[\begin{array}{cccc}-1&1&0&0\\0&-1&1&0\\-1&0&1&0\\-1&0&0&1\\0&0&-1&1\end{array}\right]</script><hr>
<h2 id="矩阵零空间的物理意义"><a href="#矩阵零空间的物理意义" class="headerlink" title="矩阵零空间的物理意义"></a>矩阵零空间的物理意义</h2><p>我们首先<strong>考虑矩阵$A$的零空间</strong>，则有：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\underbrace{\left[\begin{array}{cccc}-1&1&0&0\\0&-1&1&0\\-1&0&1&0\\-1&0&0&1\\0&0&-1&1\end{array}\right]}_{A}
\underbrace{\left[\begin{array}{c}x_1\\x_2\\x_3\\x_4\end{array}\right]}_{x}
=\left[\begin{array}{c}x_2-x_1\\x_3-x_2\\x_3-x_1\\x_4-x_1\\x_4-x_3\end{array}\right]
=\left[\begin{array}{c}0\\0\\0\\0\\0\end{array}\right]
\end{aligned}</script><p>从上面的式子可以看出<strong>$Ax$的结果是各个节点之间的差值</strong>，假设$x_i$为第$i$点的电势，<strong>那我们就赋予了物理意义：$Ax=0$的意思是当节点电势取何值时，所有的节点之间的电势差为$0$</strong>。很显然，当所有节点等电势时显然成立，即：</p>
<script type="math/tex; mode=display">
Ax=0\rightarrow x=\left[\begin{array}{c}c\\c\\c\\c\end{array}\right]</script><p>我们将图中各边的电流用$b$表示，则有等式$Ax=b$。其中$A$表示了电路节点之间的关系，$x$代表了各点的电势，$b$代表了各边的电流。<strong>这样，我们就将一个物理问题数学化了</strong>。上面讨论中$b=0$，$x$中各个分量相同，<strong>即说明电势相同，网络中没有电流，这与我们的物理常识是一致的：电势差是产生电流的原因。</strong></p>
<hr>
<h2 id="矩阵左零空间的物理意义"><a href="#矩阵左零空间的物理意义" class="headerlink" title="矩阵左零空间的物理意义"></a>矩阵左零空间的物理意义</h2><p> <strong>上面我们看了矩阵$A$的零空间，下面我们讨论矩阵$A$的左零空间</strong>，为了给我们的式子赋予实际意义，在下式中，我们假设$y$为每条边的电流，$b$为每个节点的电流值，$b=0$说明电流为$0$。</p>
<script type="math/tex; mode=display">
A^Ty=0</script><p><strong>该式反应的是电流中的基尔霍夫电流定律</strong>：流入一个节点的电流与流出的是相等的，即合电流为$0$:</p>
<script type="math/tex; mode=display">
A^Ty=0\rightarrow\left[\begin{array}{cccc}-1&0&-1&-1&0\\1&-1&0&0&0\\0&1&1&0&-1\\0&0&0&1&1\end{array}\right]
\left[\begin{array}{c}y_1\\y_2\\y_3\\y_4\\y_5\end{array}\right]=
\left[\begin{array}{c}-y_1-y_3-y_4\\y_1-y_2\\y_2+y_3-y_5\\y_4+y_5\end{array}\right]=\left[\begin{array}{c}0\\0\\0\\0\end{array}\right]</script><hr>
<p>举例说明，$-y_1-y_3-y_4=0$说明的是$1$号节点满足KCL的条件。<strong>我们可以通过高斯消元法求得解，但是我们可以通过图来得到解：</strong></p>
<p>在电路网络图中，我们可以看到，$1, 2, 3$号节点构成一个回路，$1, 3, 4$号也构成一个回路，为了满足基尔霍夫电流定律，我们可以只让电流在回路中循环流动，即：我们可以得到两个特解：</p>
<script type="math/tex; mode=display">
\left[\begin{array}{c}1\\1\\-1\\0\\0\end{array}\right],
\left[\begin{array}{c}0\\0\\1\\-1\\1\end{array}\right]</script><p>那么左零空间可以表示为上述两个特解的线性组合。</p>
<p>对$A^T$进行消元，我们可以发现其秩是$3$，即列中有三行是线性无关的。<strong>由上面的两个特解，我们知道第$1, 2, 3$列是相关的，第$3, 4, 5$列是相关的，除此之外的任意三列都是线性无关的</strong>。我们发现$y_1, y_2, y_3$恰好构成回路，$y_3, y_4, y_5$也恰好构成回路，<strong>这说明相关性是由回路产生的。</strong></p>
<hr>
<h2 id="欧拉公式的证明"><a href="#欧拉公式的证明" class="headerlink" title="欧拉公式的证明"></a>欧拉公式的证明</h2><p><strong>欧拉公式：回路数=边数-顶点数+1</strong></p>
<p>前面文章说过，如果一个$m\times n$的矩阵$A$的秩为$r$，则其左零空间的维数为$m-r$。在这里，左零空间的维数代表的是不相关的回路数，$m$代表的是边数，由于矩阵$A$的零空间是$1$维的，则列空间的维数为$r=n-1$。所以有下式成立（即欧拉公式）：</p>
<p>   不相关的回路数=边数-顶点数+1</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>Linear Algebra</tag>
      </tags>
  </entry>
  <entry>
    <title>【线性代数】矩阵的四个基本子空间</title>
    <url>/2014/11/10/%5B20141110%5D/</url>
    <content><![CDATA[<h4 id="零空间"><a href="#零空间" class="headerlink" title="零空间"></a>零空间</h4><p>矩阵$A$的零空间就$Ax=0$的解的集合。假设矩阵的秩为$r$，矩阵为$m\times n$的矩阵，则零空间的维数为$n-r$。因为秩为$r$，则自由变量的个数为$n-r$，有几个自由变量，零空间就可以表示层几个特解的线性组合，也即是零空间的维数为自由变量的个数。</p>
<a id="more"></a>
<hr>
<h4 id="列空间"><a href="#列空间" class="headerlink" title="列空间"></a>列空间</h4><p>矩阵$A$的列空间就是矩阵$A$中各列的线性组合。假设矩阵的秩为$r$，矩阵为$m\times n$的矩阵，则列空间可以表示为$r$个主元的线性组合，即列空间的维数为$r$。</p>
<hr>
<h4 id="行空间"><a href="#行空间" class="headerlink" title="行空间"></a>行空间</h4><p>在线性代数中，我们一般习惯将矩阵看出是一组列向量的组合，matlab中矩阵的存储是按列存储的(c中不是)。因此，我们可以将矩阵$A$进行转置后来讨论行空间和左零空间。假设转置后的矩阵为$A^T$，则$A$的行空间就是$A^T$的列空间，$A$的左零空间为$A^T$的零空间。注意这里$A^T$为$n\times m$的矩阵，则此时行空间的维数为$r$。</p>
<hr>
<h4 id="左零空间"><a href="#左零空间" class="headerlink" title="左零空间"></a>左零空间</h4><p>左零空间是$A^Tx=0$的解的集合。由于秩为$r$，则自由变量的个数为$m-r$，即左零空间的维数为$m-r$。</p>
<p>上面都是一些定理结果，下面来举例说明上述定理：</p>
<p>假设矩阵为$A$:</p>
<script type="math/tex; mode=display">
A=\left[\begin{array}{cccc}1&2&3&1\\1&1&2&1\\1&2&3&1\end{array}\right]</script><p>经过高斯消元得到行最简式$R$:</p>
<script type="math/tex; mode=display">
A=\left[\begin{array}{cccc}1&2&3&1\\1&1&2&1\\1&2&3&1\end{array}\right]\rightarrow
R=\left[\begin{array}{cccc}1&0&1&1\\0&1&1&0\\0&0&0&0\end{array}\right]</script><p>于是我们知道矩阵$A$的秩为$2$，则其列空间，行空间的维数都是$2$，零空间的维数为$4-2=2$，左零空间的维数为$3-2=1$。</p>
<p>很明显，矩阵$A$的列中，前两列是线性无关的，则其列空间可以由前两列来表示。同理，前两行是线性无关的，其行空间可以有前两行来表示。由于只有两个主元，则自由变量个数为$4-2=2$，所以零空间的特解有两个，零空间可以由这两个特解的线性组合来表示。由于左零空间可以看成是$A^Tx=0$的线性组合，则有：</p>
<script type="math/tex; mode=display">
A^Tx=0\rightarrow (A^Tx)^T=0^T\rightarrow x^TA=0</script><p>我们知道初等行变换不改变矩阵的行空间，但可能改变其列空间(因为行变换是行向量的线性组合)，并且消元过程可以表示如下：</p>
<script type="math/tex; mode=display">
\begin{aligned}
EA&=R\rightarrow
\underbrace{\left[\begin{array}{ccc}-1&2&0\\1&-1&0\\-1&0&1\end{array}\right]}_{E}
\underbrace{\left[\begin{array}{cccc}1&2&3&1\\1&1&2&1\\1&2&3&1\end{array}\right]}_{A}
=\underbrace{\left[\begin{array}{cccc}1&0&1&1\\0&1&1&0\\0&0&0&0\end{array}\right]}_{R}
\end{aligned}</script><p>我们可以看出，初等矩阵$E$的第三行与$A$相乘得到的是$0$向量即：</p>
<script type="math/tex; mode=display">
\left[\begin{array}{ccc}-1&0&1\end{array}\right]
\left[\begin{array}{cccc}1&2&3&1\\1&1&2&1\\1&2&3&1\end{array}\right]=
\left[\begin{array}{cccc}0&0&0&0\end{array}\right]</script><p>对比下式：</p>
<script type="math/tex; mode=display">
x^TA=0</script><p>可以求得$x$的值：</p>
<script type="math/tex; mode=display">
x=\left[\begin{array}{c}-1\\0\\1\end{array}\right]</script><p>这个$x$就是左零空间的基，因此左零空间的维数为$3-2=1$。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>Linear Algebra</tag>
      </tags>
  </entry>
  <entry>
    <title>【线性代数】线性相关性、基和维数</title>
    <url>/2014/11/09/%5B20141109%5D/</url>
    <content><![CDATA[<h4 id="线性相关性"><a href="#线性相关性" class="headerlink" title="线性相关性"></a>线性相关性</h4><p>什么情况下，向量$x_1,x_2,\cdots,x_n$是线性无关的？</p>
<p>答：当向量$x_1,x_2,\cdots,x_n$的线性组合(线性组合时系数不能全为$0$)不为零向量时，它们是线性无关的。即方程</p>
<script type="math/tex; mode=display">
[x_1,x_2,\cdots,x_n]x=0</script><p>不存在非零解。</p>
<p>对于一个矩阵$A$来说，当$A$总各列向量是线性无关时，则$Ax=0$的解只有$0$向量，即矩阵$A$的零空间只有零向量。 如果各列向量是相关的，则矩阵$A$的零空间中还存在一些其他的向量。</p>
<p>当矩阵$A$各列是线性无关的，则矩阵$A$各列都有主元，自由变量的个数为$0$。</p>
<hr>
<h4 id="空间的基"><a href="#空间的基" class="headerlink" title="空间的基"></a>空间的基</h4><p>我们知道，矩阵各列的线性组合生成矩阵的列向量。但是，矩阵的各列有可能不是线性相关的。我们关心的是这样的一组向量：既能生成空间，又是线性无关的。这样的向量我们称为空间的基。</p>
<p>如果要确定一个空间，我们只需要知道该空间的基，就了解了该空间的所有信息。例如：在三维空间中，向量的一个基是：</p>
<script type="math/tex; mode=display">
\left[\begin{array}{c}1\\0\\0\end{array}\right],
\left[\begin{array}{c}0\\1\\0\end{array}\right],
\left[\begin{array}{c}0\\0\\1\end{array}\right].</script><p>当然，我们还可以写出其他的基，只需要满足基的两个性质：1、生成空间；2、线性无关。但是基中向量的个数是一样的。对于一个n阶的方阵A的各列想要成为$n$维空间的基的话，该方阵必须是可逆的。</p>
<hr>
<h4 id="空间的维数"><a href="#空间的维数" class="headerlink" title="空间的维数"></a>空间的维数</h4><p><em>维数的定义</em>：空间内任意基内向量个数称为空间的维数。</p>
<p>空间内所有的基内向量个数是相同的，都指空间的维数。    </p>
<p>下面我们来举例说明上述概念：假设矩阵为$A$:</p>
<script type="math/tex; mode=display">
A=\left[\begin{array}{cccc}1&2&3&1\\1&1&2&1\\1&2&3&1\end{array}\right]</script><p> 矩阵$A$的各列生成矩阵$A$的列空间。</p>
<p> 矩阵$A$的各列不是$A$的列空间的基，因为它们线性相关，列空间的一个基是矩阵的第一、二列。</p>
<p>我们可以通过消元知道，该矩阵的秩为$2$，该列空间的维数为$2$。即矩阵的秩是列空间的维数！</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>Linear Algebra</tag>
      </tags>
  </entry>
  <entry>
    <title>【线性代数】线性方程组的求解</title>
    <url>/2014/11/08/%5B20141108%5D/</url>
    <content><![CDATA[<p>​    <a href="http://blog.csdn.net/tengweitw/article/details/40039373" target="_blank" rel="noopener">上一篇文章</a>讲述了$Ax=0$的解和矩阵$A$的零空间，<strong>这里我们讨论$Ax=b$的解以及矩阵$A$的列空间。</strong></p>
<p>​    $Ax=0$是肯定有解的，因为总存在$x$为全零向量，使得方程组成立。而$Ax=b$是不一定有解的，我们需要高斯消元来确定。我们还是利用上一篇讲述了$Ax=0$的解的矩阵$A$来举例说明：</p>
<script type="math/tex; mode=display">
x_1+2x_2+2x_3+2x_4=b_1\\
2x_1+4x_2+6x_3+8x_4=b_2\\
3x_1+6x_2+8x_3+10x_4=b_3</script><a id="more"></a>
<p>我们可以得到上述方程组的增广矩阵(<strong>等式右侧不是全零向量，消元时值会改变，所以需要用增广矩阵</strong>)如下：</p>
<script type="math/tex; mode=display">
\left[\begin{array}{ccccc}1&2&2&2&b_1\\2&4&6&8&b_2\\3&6&8&10&b_3\end{array}\right]</script><p>然后我们进行高斯消元可以得到：</p>
<script type="math/tex; mode=display">
\left[\begin{array}{ccccc}1&2&2&2&b_1\\0&0&2&4&b_2-2b_1\\0&0&0&0&b_3-b_2-b_1\end{array}\right]</script><p>从上面的矩阵可以看出，<strong>等式成立必须有</strong>：</p>
<script type="math/tex; mode=display">
b_3-b_2-b_1=0</script><p>我们假设一个满足上面条件的b向量，例如：$b=[1, 5, 1+5]$;并且令两个自由变量$x_2=0, x_4=0$，则我们将消元后的矩阵写成方程组的形式如下：</p>
<script type="math/tex; mode=display">
x_1+2x_3=1\rightarrow x_1=-2\\
2x_3=3\rightarrow x_3=3/2</script><p><strong>得到的解为：</strong></p>
<script type="math/tex; mode=display">
x_c=\left[\begin{array}{c}-2\\0\\3/2\\0\end{array}\right]</script><p>$x_c$是这个方程组的一个特解，因为当$x_2, x_4$取不同的值时，会得到不同的特解。那么我们如何得到方程的同解呢？即怎样用一般形式来表示所有的特解？</p>
<p><strong>求解$Ax=b$的过程：</strong></p>
<p>1、求解特解$x_c$</p>
<p>2、求解$Ax=0$的解$x_n$</p>
<p>$Ax=b$的解就是特解$x_c+x_n$，证明如下：</p>
<script type="math/tex; mode=display">
Ax_p=b, Ax_n=0\rightarrow A(x_p+x_n)=b</script><p>$x_c$我们上面已经得到，$x_n$在<a href="http://blog.csdn.net/tengweitw/article/details/40039373" target="_blank" rel="noopener">上一篇文章</a>中得到，则<strong>通解可以表示为：</strong></p>
<script type="math/tex; mode=display">
x_c=x_p+x_n=\left[\begin{array}{c}-2\\0\\3/2\\0\end{array}\right]
+c_1\left[\begin{array}{c}-2\\1\\0\\0\end{array}\right]
+c_2\left[\begin{array}{c}2\\0\\-2\\1\end{array}\right]</script><p>至此，我们就得到了$Ax=b$的解。</p>
<p>通过上面的分析求解，我们知道当$b$满足下式时，方程组有解：</p>
<p>$b_3-b_2-b_1=0$</p>
<p><strong>实际上，方程有解的条件是向量$b$属于矩阵$A$的列空间，即向量$b$可以表示为矩阵$A$的各列的线性组合。</strong>例如上面的例子：</p>
<script type="math/tex; mode=display">
b=\left[\begin{array}{c}1\\5\\6\end{array}\right]
=-2\left[\begin{array}{c}1\\2\\3\end{array}\right]
+0\left[\begin{array}{c}2\\3\\6\end{array}\right]
+\frac{3}{2}\left[\begin{array}{c}2\\6\\8\end{array}\right]
+0\left[\begin{array}{c}2\\8\\10\end{array}\right]</script><p>方程的解就是矩阵$A$中各列前面的系数。</p>
<hr>
<p><strong>下面推广到更一般的情况，我们以矩阵$A$的不同情况来看解的结构(假设矩阵$A$为$m\times n$的矩阵,秩为$r$)：</strong></p>
<p><strong><em>1、$r=n&lt; m$，即列满秩(所有列都有主元)</em></strong></p>
<p>   由于所有列都有主元，则自由变量的个数为$0$，矩阵$A$的零空间中只有零向量。$Ax=b$的解的个数为$0$个或者$1$个.</p>
<p>   举例说明：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\underbrace{\left[\begin{array}{cc}1&3\\2&1\\5&1\\6&1\end{array}\right]}_{A}
{\longrightarrow}\underbrace{\left[\begin{array}{cc}1&0\\0&1\\0&0\\0&0\end{array}\right]}_{R}
{\longrightarrow}\left[\begin{array}{c}I_{2\times 2}\\0_{2\times 2}\end{array}\right]
\end{aligned}</script><p> 当$b=[4, 3, 6, 7]$时，$Ax=b$的唯一解为$x=[1, 1]$。</p>
<p><strong><em>2、$r=m&lt;n$，即行满秩(所有行都有主元)</em></strong></p>
<p>   由于所有行都有主元，消元后不会出现全为$0$的行，则$Ax=b$有无穷多解。且自由变量的个数为$n-r$，矩阵$A$的零空间中不只有零向量。</p>
<p>   例如：</p>
<script type="math/tex; mode=display">
A=\left[\begin{array}{cccc}1&2&5&6\\3&1&1&1\end{array}\right]\rightarrow
R=\left[\begin{array}{cccc}1&0&-0.6&-0.8\\0&1&2.8&3.4\end{array}\right]\rightarrow
R=[I\quad F]</script><p><strong><em>3、$r=m=n$，即列、行都满秩(矩阵可逆)</em></strong></p>
<p>   由于列、行都满秩，则具有列满秩，行满秩的一些性质：零空间只有零向量，方程总有解且解唯一。</p>
<script type="math/tex; mode=display">
A=\left[\begin{array}{cccc}1&2\\3&1\end{array}\right]\rightarrow
R=I_{2\times 2}</script><p><strong><em>4、$r&lt;m, r&lt;n$，非满秩矩阵</em></strong></p>
<script type="math/tex; mode=display">
A\rightarrow R=\left[\begin{array}{cccc}I&F\\0&0\end{array}\right]</script><p>$Ax=b$有无穷多解或则没有解。</p>
<hr>
<p><strong>从上面的四种情况的讨论，我们可以总结如下：</strong></p>
<p>如果想看一个线性方程组的解的情况，我们可以通过高斯消元法得到矩阵$A$的最简形式$R$，$R$的可能情况如下：</p>
<script type="math/tex; mode=display">
\left[\begin{array}{c}I\\0\end{array}\right],
\left[\begin{array}{cc}I&F\end{array}\right],
\left[\begin{array}{c}I\end{array}\right],
\left[\begin{array}{cc}I&F\\0&0\end{array}\right].</script><p>这四种情况分别对应的解的情况为：</p>
<ol>
<li>唯一解或无解</li>
<li>无穷多解</li>
<li>唯一解</li>
<li>无解或无穷多解</li>
</ol>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>Linear Algebra</tag>
      </tags>
  </entry>
  <entry>
    <title>【算法导论】多项式求和</title>
    <url>/2014/10/26/%5B20141026%5D/</url>
    <content><![CDATA[<p>一般情况下，一元$n$次多项式可写成：</p>
<script type="math/tex; mode=display">
P_n(x)=p_1x^{e_1}+p_2x^{e_2}+\cdots+p_mx^{e_m}</script><p>其中，$p_i$是指数为$e_i$的项的非零系数，且满足</p>
<script type="math/tex; mode=display">
0\le e_1\le e_2\le\cdots\le e_m=n</script><p>因此，我们可以采用<strong>线性表（定义：线性表是由$n$个数据元素构成的有限序列，比如数组、向量、链表等等）</strong>来表示：</p>
<script type="math/tex; mode=display">
P=(p_0,p_1,\cdots,p_n)</script><p>其中，<strong>每一项的指数$i$可以用其系数$p_i$的序号表示。</strong></p>
<a id="more"></a>
<hr>
<p><strong>在通常的应用中，多项式的次数比较大，使得线性表的长度很难确定，因此我们可以考虑链表，向量也可以（c++中）</strong>。举例说明：假如我们用数组来表示下面的多项式：</p>
<script type="math/tex; mode=display">
S_4(x)=5x^{1548}-19x^{123}+2x^2+1</script><p>​    可见，我们需要一个大小为$1549$的数组来表示，而实际有用的信息只有数组中的$4$个元素，其他地方都是$0$，所以造成了空间浪费。并且如果我们事先不知道多项式的最高次项的指数，则我们需要定义一个足够大的数组来存储，这样做显然浪费了很多内存空间。我们可以使用链表来解决上述问题：</p>
<p>在计算机内，<strong>我们用一个结点来存放多项式的一项，为了节约空间，并和书写习惯一致，只需保留非零系数的项</strong>。每个结点分<strong>系数、指数和指针</strong>三个域，如下图所示，其中的指针next指明下一项的位置:</p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20141026/20141026_fig001.jpg" width="250" height="80" title="图1" alt="图1" ></p>
<p>例如，下面多项式分别为$A,B$:</p>
<script type="math/tex; mode=display">
A_4(x)=7+3x+9x^8+5x^{17}\\
B_3(x)=8x+22x^7-9x^8</script><p><strong>用循环链表可以表示如下：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20141026/20141026_fig002.jpg" width="500" height="150" title="图2" alt="图2" ></p>
<p>​    两个多项式相加的运算规则很简单，对所有指数相同的项，将其对应系数相加，若和不为零，则构成和多项式中的一项；将所有指数不相同的项复制到和多项式中。<strong>具体实现时，我们以上面的多项式$A$，$B$为测试样例。可采用另建链表来存储和的多项式的方法，或采用把一个多项式归并入另一个多项式的方法</strong>。我们以后种方法为例,即将$A+B$的和多项式存储到$A$中。<strong>具体程序实现如下（我采用了循环链表）：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;conio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">pnode</span>//用链表来存储多项式信息</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">float</span> coef;<span class="comment">//多项式系数</span></span><br><span class="line">	<span class="keyword">int</span>   <span class="built_in">exp</span>;<span class="comment">//多项式指数</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pnode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;polynode;</span><br><span class="line"></span><br><span class="line"><span class="function">polynode *<span class="title">Create</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">float</span> coef;</span><br><span class="line">	<span class="keyword">int</span> <span class="built_in">exp</span>;</span><br><span class="line">	polynode *head,*s,*r;</span><br><span class="line">	head=(polynode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(polynode));</span><br><span class="line">	head-&gt;coef=<span class="number">0</span>;</span><br><span class="line">	head-&gt;<span class="built_in">exp</span>=<span class="number">-1</span>;</span><br><span class="line">	r=head;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"请输入各项的系数和指数：\n"</span>);</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%f %d"</span>,&amp;coef,&amp;<span class="built_in">exp</span>);</span><br><span class="line">		<span class="keyword">if</span>(coef!=<span class="number">0</span>)<span class="comment">//输入0 0来结束输入</span></span><br><span class="line">		&#123;</span><br><span class="line">			s=(polynode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(polynode));</span><br><span class="line">			s-&gt;coef=coef;<span class="comment">//s用来保存当前节点</span></span><br><span class="line">			s-&gt;<span class="built_in">exp</span>=<span class="built_in">exp</span>;</span><br><span class="line">			r-&gt;next=s;</span><br><span class="line">			r=s;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	r-&gt;next=head;<span class="comment">//构造循环链表</span></span><br><span class="line">	<span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">polynode*<span class="title">PolyAdd</span><span class="params">(polynode* pa,polynode* pb)</span><span class="comment">//进行多项式相加</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	polynode *p,*q,*r,*s;</span><br><span class="line">	<span class="keyword">float</span> x;</span><br><span class="line">	p=pa-&gt;next;<span class="comment">//分别指向多项式的第一项</span></span><br><span class="line">	q=pb-&gt;next;</span><br><span class="line">	s=pa;<span class="comment">//s用于保存当前节点</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>((p!=pa)&amp;&amp;(q!=pb))<span class="comment">//没有结束，回到链表头</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(p-&gt;<span class="built_in">exp</span>&lt;q-&gt;<span class="built_in">exp</span>)<span class="comment">//p的指数小于q的指数，将p放入链表中</span></span><br><span class="line">		&#123;</span><br><span class="line">			s=p;</span><br><span class="line">			p=p-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(p-&gt;<span class="built_in">exp</span>&gt;q-&gt;<span class="built_in">exp</span>)<span class="comment">//p的指数大于q的指数，将q放入链表中</span></span><br><span class="line">		&#123;</span><br><span class="line">			r=q-&gt;next;</span><br><span class="line">			q-&gt;next=p;</span><br><span class="line">			s-&gt;next=q;</span><br><span class="line">			s=q;</span><br><span class="line">			q=r;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span><span class="comment">//当两者指数相同时，进行合并</span></span><br><span class="line">		&#123;</span><br><span class="line">			x=p-&gt;coef+q-&gt;coef;</span><br><span class="line">			<span class="keyword">if</span>(x!=<span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				p-&gt;coef=x;</span><br><span class="line">				s=p;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span><span class="comment">//若合并结果为0，将该节点移除</span></span><br><span class="line">			&#123;</span><br><span class="line">				s-&gt;next=p-&gt;next;</span><br><span class="line">				<span class="built_in">free</span>(p);</span><br><span class="line">			&#125;</span><br><span class="line">					p=s-&gt;next;</span><br><span class="line">		r=q;</span><br><span class="line">		q=q-&gt;next;</span><br><span class="line">		<span class="built_in">free</span>(r);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(q!=pb)<span class="comment">//如果多项式b的项数少于多项式a的情况</span></span><br><span class="line">	&#123;</span><br><span class="line">		r=q;</span><br><span class="line">		<span class="keyword">while</span>(r-&gt;next!=pb)</span><br><span class="line">			r=r-&gt;next;</span><br><span class="line">		s-&gt;next=q;</span><br><span class="line">		r-&gt;next=pa;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> pa;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Output</span><span class="params">(polynode *head)</span><span class="comment">// 输出多项式信息</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	polynode *p;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"系数和指数分别为："</span>);</span><br><span class="line">	p=head-&gt;next;</span><br><span class="line">	<span class="keyword">while</span>(p!=head)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%.1f , %d    "</span>,p-&gt;coef,p-&gt;<span class="built_in">exp</span>);</span><br><span class="line">		p=p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	polynode* ha,*hb;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\n建立多项式A:"</span>);</span><br><span class="line">	ha=Create();</span><br><span class="line">	Output(ha);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\n建立多项式B:"</span>);</span><br><span class="line">	hb=Create();</span><br><span class="line">	Output(hb);</span><br><span class="line"></span><br><span class="line">	ha=PolyAdd(ha,hb);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\n多项式A+B："</span>);</span><br><span class="line">    Output(ha);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20141026/20141026_fig003.jpg" width="700" height="480" title="图3" alt="图3" ></p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>Algorithm Design</tag>
      </tags>
  </entry>
  <entry>
    <title>【Qt编程】3D迷宫游戏</title>
    <url>/2014/10/18/%5B20141018%5D/</url>
    <content><![CDATA[<p>​    说起迷宫想必大家都很熟悉，个人感觉迷宫对人的方向感是很大的考验，至少我的方向感是不好的，尤其是在三维空间中。由于这段时间帮导师做项目用到了三维作图，便心血来潮想做个三维迷宫玩玩。要想画出三维的迷宫游戏，我们需要先从二维开始。</p>
<a id="more"></a>
<h2 id="二维迷宫："><a href="#二维迷宫：" class="headerlink" title="二维迷宫："></a>二维迷宫：</h2><p><strong>迷宫的程序描述：</strong></p>
<p>​    现实生活中，我们经常将问题用数学的方法来描述并解决（数学建模）。同样的，我们想用程序来解决问题，就得把问题程序化。废话不多说，进入正题：</p>
<p>​    <strong>我们可以用一个矩阵matrix来描绘整个迷宫</strong>：<strong>元素为1，代表是空的，元素为0代表墙</strong>。<strong>为了描述问题的方便，下面都采用9行9列的矩阵来说明问题，并且假设（0，0）为入口，（1，1）为出口。</strong></p>
<p>​    <strong>网上也有一些常见的迷宫程序，但是它们都有一种特点，就是生成的迷宫可能没有从入口到出口的可达路径(可以通过循环来生成迷宫，直到有可达路径)，或则从入口到出口有几条可达路径(如果想要只有唯一可达路径，就不行了)</strong>。这些算法大多数是通过随机数来产生迷宫矩阵matrix(随机产生0，1元素)，然后通过迭代、回溯算法来找入口到出口的路径。由于矩阵matrix是随机的，这就不能保证入口到出口是可达的，这就是导致上面问题。</p>
<hr>
<p><strong>算法思想：</strong></p>
<p>​    想必大家都学过<strong>树(关于树的相关操作可以看我之前的文章)</strong>这种数据结构，比如说树的遍历DFS、BFS，树的深度等等操作。当然树的类型也有很多，如完全二叉树、红黑树、B树等等。但是我现在要说的不是这些，<strong>而是另一个我发现的性质：一个节点到另一个节点的路径有且只有一条！</strong> 现在就能和前面我说的那个问题联系起来了。<strong>下面看看是怎么联系的：</strong></p>
<p>​    我们首先将整个矩阵matrix的元素初始化为0即认为全都是墙，<strong>我们的任务就是拆墙（使元素等于1）来构成迷宫。怎么拆墙是我们算法的关键！</strong></p>
<ul>
<li><p><strong>首先</strong>，我们随便在矩阵中找一个初始点A（4，4），将该点的值设为1，即将该点的墙拆掉。 </p>
</li>
<li><p><strong>然后</strong>，产生一个0到3的随机整数randnum（0，1，2，3分布代表上下左右四个方向），在随机数randnum表示的方向进行拆墙（<strong>注意是连拆两块</strong>），如果该方向上与目前位置隔一块的位置没有墙，就不能拆，则需要再产生随机数，在其他方向上拆墙。（<strong>注意拆墙的前提是该方向隔一块的位置是墙</strong>）  </p>
</li>
<li><p>最后，在上一步骤中，一直循环，直到当前位置四个方向的隔一块的位置都没有墙可拆，就进行回溯（回退到当前位置的上一个位置），然后进行上一步骤的操作，直至没有墙可拆！</p>
</li>
</ul>
<hr>
<p>​    我一直相信图像是比文字更能说话的，下面我们用图像来说明上述步骤：</p>
<p>​    <strong>在强调一下：我们举例都采用9行9列的矩阵，初始点为（4，4）。</strong></p>
<ul>
<li>最开始时，只有初始点处的墙被拆掉<br><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20141018/20141018_fig001.jpg" width="400" height="300" title="图1" alt="图1" ></li>
</ul>
<ul>
<li><p>随机数randnum=2，开始向左边拆墙，由于（4，2）为0（有墙），可以拆，于是拆掉（4，2）、（4，3）位置的墙，则结果如下：<br><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20141018/20141018_fig002.jpg" width="400" height="300" title="图2" alt="图2" ></p>
</li>
<li><p>接着产生随机数randnum=1,开始向下拆墙，由于（6，2）为0（有墙），可以拆，于是拆掉（5，2）、（6，2）位置的墙，结果如下：<br><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20141018/20141018_fig003.jpg" width="400" height="300" title="图3" alt="图3" ></p>
</li>
</ul>
<ul>
<li>继续产生随机数randnum=0,开始向上拆墙，由于（4，2）为1没有墙，不可以拆，于是重新产生随机数，结果与上一张图一样：<br><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20141018/20141018_fig004.jpg" width="400" height="300" title="图4" alt="图4" ></li>
</ul>
<ul>
<li>继续产生随机数randnum=3,开始向右拆墙，由于（6，4）为0有墙，可以拆，于是拆掉（6，3）、（6，4）位置的墙，结果如下：<br><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20141018/20141018_fig005.jpg" width="400" height="300" title="图5" alt="图5" ></li>
</ul>
<p><strong>按照上述步骤重复下去，最终得到一个可能的迷宫矩阵如下：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20141018/20141018_fig006.jpg" width="400" height="300" title="图6" alt="图6" ></p>
<p><strong>注意事项：</strong></p>
<p>1、迷宫矩阵的行和列必须为基数，初始点的位置必须为偶数。（这是由算法决定的，因为算法总是从初始点出发，步长为2，到达入口点和出口点，所以初始点与入口点、出口点的横纵坐标的距离都应该是步长2的倍数）。</p>
<p>2、初始点的选择最好在矩阵的中间位置，可以这样想象：算法的本质就是从初始点出发到达其他点，中间会产生分支（回溯的原因，如果回溯到初始点，则是在初始点就产生分支）到达其它点（包括入口点和出口点）。因此我们可以描述成一棵树，而初始点便是树的根节点。为了更快的找到出口点与入口点的可达路径，应使树的深度较小，这样就应该将初始点选在中间位置。</p>
<p>3、在进行判断时，为什么要选择看隔一块是否是墙，而不是相邻块、或则隔几块？因为隔一块的话，路与墙的宽度就一样了（取相邻块或则隔几块的情况大家可以实验推导一下！）</p>
<hr>
<p><strong>上面我用图文并茂的方法讲述了如何生成迷宫，下面我们来看看如何生成入口到出口的可达路径：</strong></p>
<p>如上一张图所示，黄色部分就是可达路径（是唯一一条），由于迷宫较小，我们可以一眼看出，当迷宫较大时，我们就要靠矩阵来计算了。在上面的迷宫生成算法中，我们可以在拆墙的时候来记录节点，则当拆到入口时，便记录了从初始点到入口的路径，同理，我们也可以得到初始点到出口的路径，这样根据这两条路径就很容易得到入口到出口的路径了。<strong>前面我也说过，整个算法就是生成树的过程，其中初始点为根节点，找到可达路径相当于找到树中入口节点到出口节点的路径。前面我也提到，该树中任意两个节点的可达路径是唯一的，所以该算法生成的迷宫的入口到出口的路径是唯一的。</strong></p>
<p>至此，我们已经讲述了整个的算法思想和流程，下面给出源代码(c++,vs2010实现),源文件给出了详细的注释，就不过多解释。<strong>程序总共5个文件</strong>：1、Maze.h  2、Maze.cpp  3、MazeStack.h  4、MazeStack.cpp  5、main.cpp。<strong>具体内容如下：</strong></p>
<p><strong>1、Maze.h</strong></p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        Maze.h 源代码：
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M 9<span class="comment">//迷宫的行</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 9<span class="comment">//迷宫的列</span></span></span><br><span class="line"><span class="comment">//构造迷宫类型//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MazeStack</span>;</span><span class="comment">//申明该类</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Maze</span>//定义迷宫节点信息。</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    <span class="keyword">int</span> state;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MazeMat</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Maze matrix[M][N];<span class="comment">//迷宫矩阵</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;Maze&gt; EntryPath;<span class="comment">//从初始点到入口的路径</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;Maze&gt; ExitPath;<span class="comment">//从初始点到出口的路径</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;Maze&gt; FinalPath;<span class="comment">//从入口到出口的路径</span></span><br><span class="line">    MazeStack *mazeStack;<span class="comment">//定义栈</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">initMaze</span><span class="params">()</span></span>;<span class="comment">//初始化迷宫矩阵</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">createMaze</span><span class="params">()</span></span>;<span class="comment">//产生迷宫矩阵</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">displayMaze</span><span class="params">()</span></span>;<span class="comment">//显示迷宫矩阵</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">FindWay</span><span class="params">()</span></span>;<span class="comment">//寻找入口到出口的路径</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//////////////////</span></span><br></pre></td></tr></table></figure>

    </div>
</div>
<p><strong>2、Maze.cpp</strong></p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        Maze.cpp 源代码：
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"MazeStack.h"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> MazeMat::initMaze()<span class="comment">//初始化迷宫矩阵</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;M;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;N;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            matrix[i][j].i=i;</span><br><span class="line">            matrix[i][j].j=j;</span><br><span class="line">            matrix[i][j].state=<span class="number">0</span>;<span class="comment">//初始化迷宫矩阵元素为0，即全为墙</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mazeStack=<span class="keyword">new</span> MazeStack();</span><br><span class="line"></span><br><span class="line">        EntryPath.clear();<span class="comment">//初始化各个路径</span></span><br><span class="line">        ExitPath.clear();</span><br><span class="line">        FinalPath.clear();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> MazeMat::createMaze()<span class="comment">//产生迷宫矩阵，中间也记录了从初始点到入口、出口的路径</span></span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">4</span>;<span class="comment">//初始点设定，注意i,j必须为偶数</span></span><br><span class="line">    <span class="keyword">int</span> j=<span class="number">4</span>;</span><br><span class="line">    <span class="keyword">bool</span> Left=<span class="literal">false</span>;<span class="comment">//初始化四个方向，false代表可以朝这个方向搜索</span></span><br><span class="line">    <span class="keyword">bool</span> Right=<span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">bool</span> Up=<span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">bool</span> Down=<span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    matrix[i][j].state=<span class="number">1</span>;<span class="comment">//设置初始点是空的，即不是墙</span></span><br><span class="line">    srand((<span class="keyword">int</span>)time(<span class="number">0</span>));<span class="comment">//产生随机数种子，使得每次运行情况不同</span></span><br><span class="line">    Maze temp;</span><br><span class="line"></span><br><span class="line">    temp.i=i;</span><br><span class="line">    temp.j=j;</span><br><span class="line">    temp.state=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> count1=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> num1=<span class="number">0</span>;</span><br><span class="line">   </span><br><span class="line">    </span><br><span class="line">    mazeStack-&gt;Push(temp);<span class="comment">//将初始点进栈</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)<span class="comment">//不断循环搜索可行方向，形成迷宫</span></span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">        temp.i=i;</span><br><span class="line">        temp.j=j;</span><br><span class="line">        <span class="keyword">int</span> randNum=<span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        randNum=rand()%<span class="number">4</span>;<span class="comment">//0,1,2,3</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//我们假设迷宫矩阵的第一个元素(0,0)为入口，最后一个元素（M-1,N-2）为出口</span></span><br><span class="line">        <span class="keyword">if</span>(temp.i==<span class="number">0</span>&amp;&amp;temp.j==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            EntryPath.clear();</span><br><span class="line">          <span class="keyword">while</span>(mazeStack-&gt;isEmpty() == <span class="literal">false</span>)</span><br><span class="line">          &#123;</span><br><span class="line">              </span><br><span class="line">             EntryPath.push_back(mazeStack-&gt;GetTop());<span class="comment">//获得从初始点到入口的路径</span></span><br><span class="line">             mazeStack-&gt;Pop();</span><br><span class="line">            </span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> ii=EntryPath.size()<span class="number">-1</span>;ii&gt;=<span class="number">0</span>;ii--)</span><br><span class="line">          &#123;</span><br><span class="line">              mazeStack-&gt;Push(EntryPath[ii]);<span class="comment">//还原栈</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(temp.i==M<span class="number">-1</span>&amp;&amp;temp.j==N<span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ExitPath.clear();</span><br><span class="line">          <span class="keyword">while</span>(mazeStack-&gt;isEmpty() == <span class="literal">false</span>)</span><br><span class="line">          &#123;</span><br><span class="line">              </span><br><span class="line">             ExitPath.push_back(mazeStack-&gt;GetTop());<span class="comment">//获得从初始点到出口的路径</span></span><br><span class="line">             mazeStack-&gt;Pop();</span><br><span class="line">            </span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> i=ExitPath.size()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">          &#123;</span><br><span class="line">              mazeStack-&gt;Push(ExitPath[i]);<span class="comment">//还原栈</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span>(randNum)</span><br><span class="line">        &#123;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:<span class="comment">//向上搜索</span></span><br><span class="line">            <span class="keyword">if</span>(Up==<span class="literal">false</span>&amp;&amp;i&gt;<span class="number">1</span>&amp;&amp;matrix[i<span class="number">-2</span>][j].state!=<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                mazeStack-&gt;Push(temp);</span><br><span class="line">                matrix[i<span class="number">-1</span>][j].state=<span class="number">1</span>;</span><br><span class="line">                matrix[i<span class="number">-2</span>][j].state=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                i=i<span class="number">-2</span>;</span><br><span class="line">                Left=<span class="literal">false</span>;</span><br><span class="line">                Right=<span class="literal">false</span>;</span><br><span class="line">                Up=<span class="literal">false</span>;</span><br><span class="line">                Down=<span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                Up=<span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:<span class="comment">//向下搜索</span></span><br><span class="line">            <span class="keyword">if</span>(Down==<span class="literal">false</span>&amp;&amp;i&lt;M<span class="number">-2</span>&amp;&amp;matrix[i+<span class="number">2</span>][j].state!=<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                mazeStack-&gt;Push(temp);</span><br><span class="line">                matrix[i+<span class="number">1</span>][j].state=<span class="number">1</span>;</span><br><span class="line">                matrix[i+<span class="number">2</span>][j].state=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                i=i+<span class="number">2</span>;</span><br><span class="line">                Left=<span class="literal">false</span>;</span><br><span class="line">                Right=<span class="literal">false</span>;</span><br><span class="line">                Up=<span class="literal">false</span>;</span><br><span class="line">                Down=<span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                Down=<span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">case</span> <span class="number">2</span>:<span class="comment">//向左搜索</span></span><br><span class="line">             <span class="keyword">if</span>(Left==<span class="literal">false</span>&amp;&amp;j&gt;<span class="number">1</span>&amp;&amp;matrix[i][j<span class="number">-2</span>].state!=<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                mazeStack-&gt;Push(temp);</span><br><span class="line">                matrix[i][j<span class="number">-1</span>].state=<span class="number">1</span>;</span><br><span class="line">                matrix[i][j<span class="number">-2</span>].state=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                j=j<span class="number">-2</span>;</span><br><span class="line">                Left=<span class="literal">false</span>;</span><br><span class="line">                Right=<span class="literal">false</span>;</span><br><span class="line">                Up=<span class="literal">false</span>;</span><br><span class="line">                Down=<span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                Left=<span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">case</span> <span class="number">3</span>:<span class="comment">//向右搜索</span></span><br><span class="line">             <span class="keyword">if</span>(Right==<span class="literal">false</span>&amp;&amp;j&lt;N<span class="number">-2</span>&amp;&amp;matrix[i][j+<span class="number">2</span>].state!=<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                mazeStack-&gt;Push(temp);</span><br><span class="line">                matrix[i][j+<span class="number">1</span>].state=<span class="number">1</span>;</span><br><span class="line">                matrix[i][j+<span class="number">2</span>].state=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                j=j+<span class="number">2</span>;</span><br><span class="line">                Left=<span class="literal">false</span>;</span><br><span class="line">                Right=<span class="literal">false</span>;</span><br><span class="line">                Up=<span class="literal">false</span>;</span><br><span class="line">                Down=<span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                Right=<span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;<span class="comment">//end switch</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(Left&amp;&amp;Right&amp;&amp;Up&amp;&amp;Down)   <span class="comment">//当上下左右都不可行时，进行回溯</span></span><br><span class="line">          &#123;   </span><br><span class="line">              <span class="keyword">if</span>(mazeStack-&gt;isEmpty()) <span class="comment">//回溯完毕，生成迷宫 </span></span><br><span class="line">               &#123;</span><br><span class="line">                    <span class="keyword">return</span> ;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">else</span>    <span class="comment">//进行出栈操作</span></span><br><span class="line">               &#123;   </span><br><span class="line">                    i = mazeStack-&gt;GetTop().i;   </span><br><span class="line">                    j = mazeStack-&gt;GetTop().j;</span><br><span class="line">                    mazeStack-&gt;Pop();</span><br><span class="line">                  </span><br><span class="line">                    Left=<span class="literal">false</span>;</span><br><span class="line">                    Right=<span class="literal">false</span>;</span><br><span class="line">                    Up=<span class="literal">false</span>;</span><br><span class="line">                    Down=<span class="literal">false</span>;  </span><br><span class="line">               &#125;  </span><br><span class="line">              </span><br><span class="line">          &#125;   </span><br><span class="line"></span><br><span class="line">    &#125;<span class="comment">//end while</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> MazeMat::displayMaze()<span class="comment">//显示迷宫</span></span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">     matrix[<span class="number">0</span>][<span class="number">0</span>].state = matrix[M<span class="number">-1</span>][N<span class="number">-1</span>].state = <span class="number">2</span>;<span class="comment">//2表示入口和出口   </span></span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;FinalPath.size();i++)</span><br><span class="line">     &#123;</span><br><span class="line">         matrix[FinalPath.at(i).i][FinalPath.at(i).j].state=<span class="number">3</span>;<span class="comment">//3表示可达路径点</span></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="built_in">cout</span>&lt;&lt;<span class="string">"左上角为入口，右下角为出口，oo代表可达路径."</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;N+<span class="number">2</span>;k++)<span class="comment">//在迷宫矩阵的外围墙</span></span><br><span class="line">         <span class="built_in">cout</span>&lt;&lt;<span class="string">"■"</span>;</span><br><span class="line">     <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M; i++)   </span><br><span class="line">     &#123;   </span><br><span class="line">          <span class="built_in">cout</span>&lt;&lt;<span class="string">"■"</span>;</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;N; j++) </span><br><span class="line">          &#123;</span><br><span class="line">              <span class="keyword">switch</span> ( matrix[i][j].state )   </span><br><span class="line">                &#123;   </span><br><span class="line">                   <span class="keyword">case</span> <span class="number">0</span>:<span class="built_in">cout</span>&lt;&lt;<span class="string">"■"</span>;<span class="keyword">break</span>;<span class="comment">// 显示墙 </span></span><br><span class="line">                   <span class="keyword">case</span> <span class="number">1</span>:<span class="built_in">cout</span>&lt;&lt;<span class="string">"  "</span>;<span class="keyword">break</span>;<span class="comment">//显示空</span></span><br><span class="line">                   <span class="keyword">case</span> <span class="number">2</span>:<span class="built_in">cout</span>&lt;&lt;<span class="string">"↘"</span>;<span class="keyword">break</span>;<span class="comment">//显示入口和出口</span></span><br><span class="line">                   <span class="keyword">case</span> <span class="number">3</span>:<span class="built_in">cout</span>&lt;&lt;<span class="string">"oo"</span>;<span class="keyword">break</span>;<span class="comment">//显示可达路径</span></span><br><span class="line">                &#125; </span><br><span class="line">          &#125;</span><br><span class="line">          <span class="built_in">cout</span>&lt;&lt;<span class="string">"■"</span>;</span><br><span class="line">          <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;   </span><br><span class="line">     &#125;  </span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;N+<span class="number">2</span>;k++)</span><br><span class="line">         <span class="built_in">cout</span>&lt;&lt;<span class="string">"■"</span>;</span><br><span class="line">     <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> MazeMat::FindWay()<span class="comment">//寻找可达路径</span></span><br><span class="line">&#123;</span><br><span class="line">    FinalPath.clear();<span class="comment">//清零</span></span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i=EntryPath.size()<span class="number">-1</span>,j=ExitPath.size()<span class="number">-1</span>;i&gt;=<span class="number">0</span>&amp;&amp;j&gt;=<span class="number">0</span>;i--,j--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(EntryPath.at(i).i!=ExitPath.at(j).i||EntryPath.at(i).j!=ExitPath.at(j).j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">0</span>)<span class="comment">//初始点到出口的路径中经过入口</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=ExitPath.size()-EntryPath.size()<span class="number">-1</span>;k&gt;=<span class="number">0</span>;k--)</span><br><span class="line">        &#123;</span><br><span class="line">            FinalPath.push_back(ExitPath.at(k));</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(j&lt;<span class="number">0</span>)<span class="comment">//初始点到入口的路径中经过出口</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=EntryPath.size()-ExitPath.size()<span class="number">-1</span>;k&gt;=<span class="number">0</span>;k--)</span><br><span class="line">        &#123;</span><br><span class="line">            FinalPath.push_back(EntryPath.at(k));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span><span class="comment">//初始点到入口、出口的路径有部分重叠或则没有重叠</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;=i+<span class="number">1</span>;k++)</span><br><span class="line">        &#123;</span><br><span class="line">            FinalPath.push_back(EntryPath.at(k));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=j;k&gt;=<span class="number">0</span>;k--)</span><br><span class="line">        &#123;</span><br><span class="line">            FinalPath.push_back(ExitPath.at(k));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </div>
</div>
<p><strong>3、MazeStack.h</strong></p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        MazeStack.h 源代码：
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"Maze.h"</span></span></span><br><span class="line"><span class="keyword">typedef</span> Maze ElementType;</span><br><span class="line"><span class="comment">//这里是栈的定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElementType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;Node;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MazeStack</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MazeStack():bottom(<span class="literal">NULL</span>),top(<span class="literal">NULL</span>),Size(<span class="literal">NULL</span>)&#123;&#125;</span><br><span class="line">    ~MazeStack()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isEmpty</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Push</span><span class="params">(ElementType e)</span></span>;</span><br><span class="line">    <span class="function">ElementType <span class="title">GetTop</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">ElementType <span class="title">Pop</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Node *bottom;</span><br><span class="line">    Node *top;</span><br><span class="line">    <span class="keyword">int</span> Size;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

    </div>
</div>
<p><strong>4、MazeStack.cpp</strong></p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        MazeStack.cpp 源代码：
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"MazeStack.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> MazeStack::isEmpty()<span class="comment">//判断栈是否为空</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(top==bottom)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> MazeStack::Push(Maze m)<span class="comment">//进栈</span></span><br><span class="line">&#123;</span><br><span class="line">    Node *temp;</span><br><span class="line">    temp=top;</span><br><span class="line">    top=<span class="keyword">new</span> Node();</span><br><span class="line">    <span class="keyword">if</span>(!top)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    top-&gt;data=m;</span><br><span class="line">    top-&gt;next=temp;</span><br><span class="line">    Size++;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Maze MazeStack::Pop()<span class="comment">//出栈</span></span><br><span class="line">&#123;</span><br><span class="line">    Node temp;</span><br><span class="line">    temp.data=top-&gt;data;</span><br><span class="line">    temp.next=top-&gt;next;</span><br><span class="line">    <span class="keyword">delete</span> top;</span><br><span class="line">    top=temp.next;</span><br><span class="line">    Size--;</span><br><span class="line">    <span class="keyword">return</span> temp.data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Maze MazeStack::GetTop()<span class="comment">//取栈顶元素</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> top-&gt;data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </div>
</div>
<p><strong>5、main.cpp</strong></p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        main.cpp 源代码：
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"MazeStack.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MazeMat matrix;</span><br><span class="line">    matrix.initMaze();</span><br><span class="line">    matrix.createMaze();</span><br><span class="line">    </span><br><span class="line">    matrix.FindWay();</span><br><span class="line">    matrix.displayMaze();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </div>
</div>
<p><strong>具体的程序截图如下：</strong></p>
<p><strong>1、9行9列的迷宫：</strong><br><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20141018/20141018_fig007.jpg" width="500" height="350" title="图7" alt="图7" ></p>
<p><strong>2、19行19列的迷宫：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20141018/20141018_fig008.jpg" width="500" height="350" title="图8" alt="图8" ></p>
<p><strong>3、29行29列的迷宫：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20141018/20141018_fig009.jpg" width="500" height="450" title="图9" alt="图9" ></p>
<hr>
<h2 id="2维到3维的转化"><a href="#2维到3维的转化" class="headerlink" title="2维到3维的转化"></a>2维到3维的转化</h2><p>​    上面的程序实现是在二维平面上用控制台通过c++实现的，显然不够生动形象。<strong>于是我用Qt5+opengl实现了3d效果</strong>，并且可以通过鼠标操作。之所以选择Qt是因为它也是用c++编程的，所以前面写的程序几乎不用改动就可以直接运行。</p>
<p><strong>编程思想：</strong></p>
<p>1、首先是利用前面的程序生成迷宫矩阵matrix。</p>
<p>2、利用迷宫矩阵信息生成三维的图像</p>
<p>3、利用视角改变函数gluLookat不断的来改变视角，从而模拟走迷宫的场景</p>
<p><strong>使用指南：</strong></p>
<p>1、上下键控制前进、后退</p>
<p>2、左右键控制左转、右转</p>
<p>3、开始时，处于俯视图状态，可以看清地图的全貌以及自己在地图的位置（黄色）。</p>
<p>4、按下I键进入游戏模式，即可进行走迷宫，按下O键退出游戏模式，进入俯视图模式查看信息。</p>
<p>5、按p键，可以显示从入口到出口的可达路径（绿色）</p>
<p>6、分别用红色、绿色表示入口、出口</p>
<p><strong>具体的显示效果如下：</strong></p>
<p>1、初始情况（俯视图）：</p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20141018/20141018_fig010.jpg" width="500" height="400" title="图10" alt="图10" ></p>
<p>2、俯视图下显示可达路径：</p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20141018/20141018_fig011.jpg" width="500" height="400" title="图11" alt="图11" ></p>
<p>3、游戏模式中：</p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20141018/20141018_fig012.jpg" width="500" height="400" title="图12" alt="图12" ></p>
<p>4、游戏模式中显示可达路径：</p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20141018/20141018_fig013.jpg" width="500" height="400" title="图13" alt="图13" ></p>
<p>5、游戏模式转到俯视图查看当前位置：</p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20141018/20141018_fig014.jpg" width="500" height="400" title="图14" alt="图14" ></p>
<p>6、到达出口：</p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20141018/20141018_fig015.jpg" width="500" height="400" title="图15" alt="图15" ></p>
<p>3D效果的不足之处：由于采用纹理轮廓不明显，导致转角处显示不明显，移动的步幅有点大，未经多次测试，可能存在bug。</p>
<p><strong>由于篇幅有限，就不在此粘贴代码，具体源代码和可执行程序见下面链接：</strong></p>
<p><a href="http://download.csdn.net/detail/tengweitw/8154195" target="_blank" rel="noopener">http://download.csdn.net/detail/tengweitw/8154195</a></p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>Qt Coding</tag>
      </tags>
  </entry>
  <entry>
    <title>【线性代数】矩阵的零空间</title>
    <url>/2014/10/13/%5B20141013%5D/</url>
    <content><![CDATA[<p>矩阵A的零空间就$Ax=0$的解的集合。</p>
<p><strong>零空间的求法：</strong>对矩阵$A$进行消元求得主变量和自由变量；给自由变量赋值得到特解；对特解进行线性组合得到零空间。</p>
<a id="more"></a>
<p>假设矩阵如下：</p>
<script type="math/tex; mode=display">
A=\left[\begin{array}{cccc}1&2&2&2\\2&4&6&8\\3&6&8&10\end{array}\right]</script><p>对矩阵$A$进行高斯消元得到上三角矩阵$U$，继续化简得到最简矩阵$R$：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\underbrace{\left[\begin{array}{cccc}1&2&2&2\\2&4&6&8\\3&6&8&10\end{array}\right]}_{A}
{\longrightarrow}\underbrace{\left[\begin{array}{cccc}1&2&2&2\\0&0&2&4\\0&0&0&0\end{array}\right]}_{U}
{\longrightarrow}\underbrace{\left[\begin{array}{cccc}1&2&0&-2\\0&0&1&2\\0&0&0&0\end{array}\right]}_{R}
\end{aligned}</script><p><strong>由于方程$Ax=0$的右侧是零向量，所以只对矩阵$A$进行消元不会影响解,因此不需要增广矩阵，所以有：</strong></p>
<script type="math/tex; mode=display">
Ax=0\rightarrow Ux=0\rightarrow Rx=0</script><p>从上面的高斯消元的结果可以看出，矩阵$A$的秩为$2$，其中第$1$，$3$列为主元列，$2$，$4$列为自由列，对应于方程主来说，形式转变如下：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\left\{  
             \begin{array}{**lr**}  
             x_1+2x_2+2x_3+2x_4=0 \\  
             2x_1+4x_2+6x_3+8x_4=0\\  
             3x_1+6x_2+8x_3+10x_4=0   
             \end{array}  
\right. \rightarrow
\left\{  
             \begin{array}{**lr**}  
             x_1+2x_2-2x_4=0 \\  
             x_3+2x_4=0  
             \end{array}  
\right. 
\end{aligned}</script><p>从上式可以看出，$x_2,x_4$是自由变量，我们可以随意赋值，$x_2=0, x_4=1$；$x_2=1,x_4=0$可以分别得到两个特解（<strong>几个自由变量就有几个特解</strong>）：</p>
<script type="math/tex; mode=display">
x_1=\left[\begin{array}{c}-2\\1\\0\\0\end{array}\right],
x_2=\left[\begin{array}{c}2\\0\\-2\\1\end{array}\right]</script><p>然后我们将<strong>两组特解进行线性组合就得到了矩阵$A$的零空间：</strong></p>
<script type="math/tex; mode=display">
x=
c\left[\begin{array}{c}-2\\1\\0\\0\end{array}\right]+
d\left[\begin{array}{c}2\\0\\-2\\1\end{array}\right]</script><p><strong>上面我们从数值解的角度描述了矩阵零空间的求法，下面从公式角度分析：</strong></p>
<p>上面我们经过消元（<strong>行变换，不改变行空间和零空间，只改变列空间</strong>）得到了最简形式$R$。我们将$R$经过列变换得到如下矩阵：</p>
<script type="math/tex; mode=display">
\bar R=\left[\begin{array}{cccc}1&0&2&-2\\0&1&0&2\\0&0&0&0\end{array}\right]</script><p>我们可以对方程式作如下变形：</p>
<script type="math/tex; mode=display">
x=[x_1,x_2,x_3,x_4]\\
\bar x=[x_1,x_3,x_2,x_4]\\
Rx=0\rightarrow\bar R\bar x=0</script><p>$\bar R$是将$R$的第2,3列交换得到的，我们同样将$x$的2,3列交换得到$\bar x$, 这在方程式中可以表示为交换$x_2,x_3$，这样对解的结果没有影响，只是顺序交换了。</p>
<p><strong>我们之所以进行上述变换，是为了有更好的表示形式（不进行列变换也行，但是要记住哪一列是单位矩阵I中的，哪一列是自由变量矩阵$F$中的）：</strong></p>
<script type="math/tex; mode=display">
\bar R=\left[\begin{array}{cccc}1&0&2&-2\\0&1&0&2\\0&0&0&0\end{array}\right]</script><script type="math/tex; mode=display">
I_{2\times 2}=\left[\begin{array}{cc}1&0\\0&1\end{array}\right],
F_{2\times 2}=\left[\begin{array}{cc}2&-2\\0&2\end{array}\right],
\bar R=\left[\begin{array}{cc}I_{2\times 2}&F_{2\times 2}\\0_{1\times 2}&0_{1\times 2}\end{array}\right]</script><p>这样我们代入方程式可以得到零空间矩阵：</p>
<script type="math/tex; mode=display">
\bar R\bar x=0_{3\times 1}\rightarrow\left[\begin{array}{cc}I_{2\times 2}&F_{2\times 2}\\0_{1\times 2}&0_{1\times 2}\end{array}\right]\left[\begin{array}{c}-F_{2\times 2}\\I_{2\times 2}\end{array}\right]=
-I_{2\times 2}F_{2\times 2}+F_{2\times 2}I_{2\times 2}=0\\
\rightarrow\bar x=\left[\begin{array}{c}-F_{2\times 2}\\I_{2\times 2}\end{array}\right]=\left[\begin{array}{cc}-2&2\\0&-2\\1&0\\0&1\end{array}\right]</script><p>从上面的推导可以看出，得到的零空间矩阵的每一列就是我们前面的特解(注意要变换顺序！交换第$2$，$3$行,结果便和前面相同)。因此，我们可以从通过消元法得到最简式$R$，然后就可以直接得到零空间矩阵，则<strong>零空间就是零空间矩阵各列向量的线性组合</strong>，而不需要像前面那样先给$x_2$,$x_4$赋值，然后回代到方程中得到两个特解，从而得到矩阵的零空间。</p>
<p>下面再举一例：</p>
<script type="math/tex; mode=display">
\begin{aligned}
A=\left[\begin{array}{ccc}1&2&3\\2&4&6\\2&6&8\\2&8&10\end{array}\right]
{\longrightarrow}\underbrace{\left[\begin{array}{ccc}1&2&3\\0&2&2\\0&0&0\\0&0&0\end{array}\right]}_{U}
{\longrightarrow}\underbrace{\left[\begin{array}{ccc}1&0&1\\0&1&1\\0&0&0\\0&0&0\end{array}\right]}_{R}
\end{aligned}</script><p>由于$R$本来就具有很好的形式，就不用进行列变换了：</p>
<script type="math/tex; mode=display">
I_{2\times 2}=\left[\begin{array}{cc}1&0\\0&1\end{array}\right],
F_{2\times 1}=\left[\begin{array}{c}1\\1\end{array}\right],
R_{4\times 3}=\left[\begin{array}{cc}I_{2\times 2}&F_{2\times 1}\\0_{2\times 2}&0_{2\times 1}\end{array}\right]</script><p>于是通过解方程得到零空间矩阵：</p>
<script type="math/tex; mode=display">
R_{4\times 3}x_{3\times 1}=0_{4\times 1}\rightarrow
\left[\begin{array}{cc}I_{2\times 2}&F_{2\times 1}\\0_{2\times 2}&0_{2\times 1}\end{array}\right]
\left[\begin{array}{c}-F_{2\times 1}\\I_{1\times 1}\end{array}\right]=
\left[\begin{array}{c}-I_{2\times 2}F_{2\times 1}+F_{2\times 1}I_{1\times 1}=0_{2\times 1}\\0_{2\times 1}\end{array}\right]\\
x_{3\times 1}=\left[\begin{array}{c}-F_{2\times 1}\\I_{1\times 1}\end{array}\right]=\left[\begin{array}{c}-1\\-1\\1\end{array}\right]</script><p><strong>注：最简矩阵$R$和零空间矩阵$x$在MATLAB中可以分别用命令<code>rref(A)</code>，<code>null(A,&#39;r&#39;)</code>得到</strong></p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>Linear Algebra</tag>
      </tags>
  </entry>
  <entry>
    <title>【线性代数】向量空间</title>
    <url>/2014/10/04/%5B20141004%5D/</url>
    <content><![CDATA[<h2 id="对称矩阵"><a href="#对称矩阵" class="headerlink" title="对称矩阵"></a>对称矩阵</h2><p>假设有一矩阵$A$，其中$A<em>{ij}=A</em>{ji}$,则称这个矩阵为对称矩阵。</p>
<p>对称矩阵有如下性质：</p>
<script type="math/tex; mode=display">
A^{T}=A^{-1}</script><script type="math/tex; mode=display">
A=RR^{T}\leftarrow(R^TR)^T=R^T(R^T)^T=R^TR</script><p>也就是说：1、一个对称矩阵的转置和其逆是相等的；2、一个对称矩阵可以由一个矩阵和其转置矩阵相乘得到。</p>
<hr>
<h2 id="向量空间"><a href="#向量空间" class="headerlink" title="向量空间"></a>向量空间</h2><p>向量空间即空间中向量的四则运算得到的向量人在空间中。</p>
<p>  1、二维情况下，其子空间有</p>
<p>   a、零向量(0,0)</p>
<p>   b、过零点的直线</p>
<p>   c、$\mathbb R^2$整个空间</p>
<p>  2、三维情况下，其子空间有</p>
<p>   a、零向量(0,0,0)</p>
<p>   b、过（0,0,0）的平面</p>
<p>   c、过(0,0,0)的直线</p>
<p>   d、$\mathbb R^3$整个空间</p>
<hr>
<h2 id="列空间"><a href="#列空间" class="headerlink" title="列空间"></a>列空间</h2><p>假设有一个矩阵$A$：</p>
<script type="math/tex; mode=display">
A=\left[\begin{array}{cc}1&3\\2&3\\4&1\end{array}\right]</script><p>则$A$的列空间为$A$中各列向量的线性组合。</p>
<p><strong>问题一</strong>：对于任意的$b,Ax=b$是否有解？</p>
<p>答：不一定，$3$个列向量的线性组合不能充满四维空间</p>
<p><strong>问题二</strong>：对怎样的$b$，$Ax=b$有解？</p>
<p>答：当$b$属于$A$中列向量的线性组合，即$b$属于$A$的列空间</p>
<h2 id="零空间"><a href="#零空间" class="headerlink" title="零空间"></a>零空间</h2><p>假设有一个矩阵$A$：</p>
<script type="math/tex; mode=display">
A=\left[\begin{array}{ccc}1&1&2\\2&1&3\\3&1&4\\4&1&5\end{array}\right]</script><p>则$A$的零空间就是使得$Ax=0$的解的集合。由于$A$比较特殊（第一列+第二列=第三列），我们可以直接给出下式：</p>
<script type="math/tex; mode=display">
\left[\begin{array}{ccc}1&1&2\\2&1&3\\3&1&4\\4&1&5\end{array}\right]
\left[\begin{array}{c}C\\C\\-C\end{array}\right]
=\left[\begin{array}{c}0\\0\\0\\0\end{array}\right]</script><p>则零空间为：</p>
<script type="math/tex; mode=display">
X=C\left[\begin{array}{c}1\\1\\-1\end{array}\right]</script><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>Linear Algebra</tag>
      </tags>
  </entry>
  <entry>
    <title>【线性代数】矩阵的乘法与求逆</title>
    <url>/2014/09/17/%5B20140917%5D/</url>
    <content><![CDATA[<h2 id="矩阵乘法的几种种表示方法"><a href="#矩阵乘法的几种种表示方法" class="headerlink" title="矩阵乘法的几种种表示方法"></a>矩阵乘法的几种种表示方法</h2><p><strong>1、一般形式</strong></p>
<script type="math/tex; mode=display">
AB=C\\
C_{ij}=\sum\limits_{k=1}^{K}a_{ik}b_{kj}</script><p><strong>2、矩阵与列向量相乘</strong></p>
<script type="math/tex; mode=display">
\left[ \begin{array}{cc}
1 & 2 \\
3 & 4 \\
\end{array} 
\right ]
\left[ \begin{array}{cc}
1 & 2 \\
3 & 4 \\
\end{array} 
\right ]=
\left[ \begin{array}{cc}
7 & 10 \\
15 & 22 \\
\end{array} 
\right ]</script><script type="math/tex; mode=display">
\left[ \begin{array}{cc}
1 & 2 \\
3 & 4 \\
\end{array} 
\right ]
\left[ \begin{array}{c}
1  \\
3  \\
\end{array} 
\right ]=
\left[ \begin{array}{cc}
7 \\
15 \\
\end{array} 
\right ]</script><script type="math/tex; mode=display">
\left[ \begin{array}{cc}
1 & 2 \\
3 & 4 \\
\end{array} 
\right ]
\left[ \begin{array}{c}
2  \\
4  \\
\end{array} 
\right ]=
\left[ \begin{array}{cc}
10 \\
22 \\
\end{array} 
\right ]</script><p><strong>3、矩阵与行向量相乘</strong></p>
<script type="math/tex; mode=display">
\left[ \begin{array}{cc}
1 & 2 \\
3 & 4 \\
\end{array} 
\right ]
\left[ \begin{array}{cc}
1 & 2 \\
3 & 4 \\
\end{array} 
\right ]=
\left[ \begin{array}{cc}
7 & 10 \\
15 & 22 \\
\end{array} 
\right ]</script><script type="math/tex; mode=display">
\left[ \begin{array}{cc}
1 & 2 \\
\end{array} 
\right ]
\left[ \begin{array}{cc}
1 & 2 \\
3 & 4 \\
\end{array} 
\right ]=
\left[ \begin{array}{cc}
7 & 10 \\
\end{array} 
\right ]</script><script type="math/tex; mode=display">
\left[ \begin{array}{cc}
3 & 4 \\
\end{array} 
\right ]
\left[ \begin{array}{cc}
1 & 2 \\
3 & 4 \\
\end{array} 
\right ]=
\left[ \begin{array}{cc}
15 & 22 \\
\end{array} 
\right ]</script><p><strong>4、矩阵分块相乘</strong></p>
<script type="math/tex; mode=display">
A_1=B_1=\left[ \begin{array}{cc}
1 & 1 \\
1 & 1 \\
\end{array} 
\right ],
A_2=B_2=\left[ \begin{array}{cc}
2 & 2 \\
2 & 2 \\
\end{array} 
\right ]</script><script type="math/tex; mode=display">
A_3=B_3=\left[ \begin{array}{cc}
3 & 3 \\
3 & 3 \\
\end{array} 
\right ],
A_4=B_4=\left[ \begin{array}{cc}
4 & 4 \\
4 & 4 \\
\end{array} 
\right ]</script><script type="math/tex; mode=display">
A=\left[ \begin{array}{cc}
A_1 & A_2 \\
A_3 & A_4 \\
\end{array} 
\right ],
B=\left[ \begin{array}{cc}
B_1 & B_2 \\
B_3 & B_4 \\
\end{array} 
\right ]</script><script type="math/tex; mode=display">
AB=\left[ \begin{array}{cc}
A_1B_1+A_2B_3 & A_1B_2+A_2B_4 \\
A_3B_1+A_4B_3 & A_3B_2+A_4B_4 \\
\end{array} 
\right ]</script><hr>
<h2 id="矩阵的逆"><a href="#矩阵的逆" class="headerlink" title="矩阵的逆"></a>矩阵的逆</h2><p><strong>对于方阵，左逆=右逆</strong></p>
<script type="math/tex; mode=display">
A^{-1}A=I</script><p>原矩阵乘以其逆矩阵得到单位矩阵</p>
<p>判断是否可逆的几种方法：</p>
<ul>
<li><p>行列式为$0$</p>
</li>
<li><p>单位矩阵的各列是矩阵各列的线性组合</p>
</li>
<li><p>下式成立时，矩阵$A$不可逆：</p>
<script type="math/tex; mode=display">
AX=0,</script><p>其中$X$不是零向量。</p>
<p><strong>证明：</strong></p>
<script type="math/tex; mode=display">
A^{-1}AX=A^{-1}0</script><p>$X=0$与假设矛盾，说明$A$不可逆。</p>
</li>
</ul>
<hr>
<h2 id="矩阵求逆-高斯-若尔当消元法"><a href="#矩阵求逆-高斯-若尔当消元法" class="headerlink" title="矩阵求逆(高斯-若尔当消元法)"></a>矩阵求逆(高斯-若尔当消元法)</h2><p>假设矩阵为$A$:</p>
<script type="math/tex; mode=display">
A=\left[ \begin{array}{cc}
1 & 3 \\
2 & 7 \\
\end{array} 
\right ]</script><p><strong>消元过程如下</strong>：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\underbrace{\left[\begin{array}{cc|cc}1&3&1&0\\2&7&0&1\end{array}\right]}_{[A | I]}
{\longrightarrow}\left[\begin{array}{cccc}1&3&1&0\\0&1&-2&1\end{array}\right]
{\longrightarrow}\underbrace{\left[\begin{array}{cc|cc}1&0&7&-3\\0&1&-2&1\end{array}\right]}_{[I|A^{-1}]}
\end{aligned}</script><p><strong>通过消元，我们将矩阵$A$变成了单位矩阵$I$，则与此同时，矩阵$I$变成了$A$的逆矩阵</strong>。<strong>证明</strong>如下：</p>
<script type="math/tex; mode=display">
E[A|I]=[EA|EI]=[I|E]=[I|A^{-1}]\\
EA=I\rightarrow E=A^{-1}\\
EI=E=A^{-1}</script><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>Linear Algebra</tag>
      </tags>
  </entry>
  <entry>
    <title>【线性代数】矩阵消元-高斯消元法</title>
    <url>/2014/09/12/%5B20140912%5D/</url>
    <content><![CDATA[<h2 id="一、高斯消元法"><a href="#一、高斯消元法" class="headerlink" title="一、高斯消元法"></a>一、高斯消元法</h2><p> <strong>能使用消元法的情况：每次消元过程中，对角线元素始终不能为0，即矩阵可逆</strong></p>
<p>  我们一般利用<strong>高斯消元法</strong>进行矩阵的消元。下面我们通过举例说明：</p>
<script type="math/tex; mode=display">
\begin{aligned}
x+2y+z=2\\
3x+8y+z=12\\
0x+4y+z=2
\end{aligned}</script><p> 如果按照我们初中所学的解法，一般是先用第三个方程将$z$用$y$表示，然后代入到第二个方程就可以用$x$来表示$y$和$z$，最后代入第一个方程就可以求得$x,y,z$。这个算法的核心就是消元！<strong>下面我们看看矩阵形式的消元法。</strong></p>
<p>​    首先将上面的三元一次方程组表示为矩阵形式为：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\left[\begin{array}{ccc}1&2&1\\3&8&1\\0&4&1\end{array}\right]\left[\begin{array}{c}x\\y\\z\end{array}\right]=\left[\begin{array}{c}2\\12\\2\end{array}\right]
\end{aligned}</script><p>为了方便，我们将等式右边的向量放到左边，构成增广矩阵（可以百度看看什么是增广矩阵）。<strong>下面是消元的具体步骤：</strong></p>
<script type="math/tex; mode=display">
\begin{aligned}
\underbrace{\left[\begin{array}{cccc}1&2&1&2\\3&8&1&12\\0&4&1&2\end{array}\right]}_{A}
\stackrel{E_{21}}{\longrightarrow}\underbrace{\left[\begin{array}{cccc}1&2&1&2\\0&2&-2&6\\0&4&1&2\end{array}\right]}_{B}
\stackrel{E_{32}}{\longrightarrow}\underbrace{\left[\begin{array}{cccc}1&2&1&2\\0&2&-2&6\\0&0&5&-10\end{array}\right]}_{C}
\end{aligned}</script><p>其中，上图中的第一个矩阵就是所说的增广矩阵，我们记作$A$，经过步骤$E<em>{21}$得到的矩阵为$B$，经过步骤$E</em>{32}$得到的矩阵为$C$。</p>
<p>​    步骤$E<em>{21}$的目的是$A</em>{21}=0$，这里是指用第二行减去第一行的三倍</p>
<p>​    步骤$E<em>{32}$的目的是使$A</em>{32}=0$，这里是指用第三行减去第二行的两倍</p>
<p><strong>注：</strong>高斯消元的<strong>目的</strong>是使原矩阵(<strong>不要考虑最后一列，这一列是等式右边的，matlab是分别对左右两边进行消元的，我这里写在一起是为了方便</strong>)对角线下面的元素为0，变成上三角矩阵，<strong>在上面例子中本应该在步骤$E<em>{21}$和步骤$E</em>{32}$中还有步骤$E<em>{31}$,使得$A</em>{31}=0$。但是原矩阵的$A_{31}=0$，所以没有必要进行操作</strong>。尽管这一步骤没有必要，但matlab会进行操作（没有人机智）。</p>
<p>​    通过消元得到的结果矩阵$C$（上图中的第三个矩阵），我们可以写出其方程组的形式：</p>
<script type="math/tex; mode=display">
\begin{aligned}
x+2y+z&=2\\
0x+2y-2z&=6\\
0x+0y+5z&=-10
\end{aligned}</script><p>上面方程组可以直接看出，$z=-2$,然后代入第二个方程得到$y=1$,再代入第一个方程得到$x=2$。</p>
<p>​    在上面的消元过程中，原始矩阵$A$经过步骤$E<em>{21}$得到矩阵$B$，矩阵$B$经过步骤$E</em>{32}$得到矩阵$C$，<strong>我们用矩阵来表示步骤$E<em>{21}$，步骤$E</em>{32}$</strong>，则可以得到：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\underbrace{\left[\begin{array}{ccc}1&0&0\\-3&1&0\\0&0&1\end{array}\right]}_{E_{21}}
\underbrace{\left[\begin{array}{cccc}1&2&1&2\\3&8&1&12\\0&4&1&2\end{array}\right]}_{A}
=\underbrace{\left[\begin{array}{cccc}1&2&1&2\\0&2&-2&6\\0&4&1&2\end{array}\right]}_{B}
\end{aligned}</script><script type="math/tex; mode=display">
\begin{aligned}
\underbrace{\left[\begin{array}{ccc}1&0&0\\0&1&0\\0&-2&1\end{array}\right]}_{E_{32}}
\underbrace{\left[\begin{array}{cccc}1&2&1&2\\0&2&-2&6\\0&4&1&2\end{array}\right]}_{B}
=\underbrace{\left[\begin{array}{cccc}1&2&1&2\\0&2&-2&6\\0&0&5&-10\end{array}\right]}_{C}
\end{aligned}</script><p>把这两步综合起来得到：</p>
<script type="math/tex; mode=display">
E_{32}(E_{21}A)=C\rightarrow EA=C</script><script type="math/tex; mode=display">
E=E_{32}E_{21}=\underbrace{\left[\begin{array}{ccc}1&0&0\\0&1&0\\0&-2&1\end{array}\right]}_{E_{32}}\underbrace{\left[\begin{array}{ccc}1&0&0\\-3&1&0\\0&0&1\end{array}\right]}_{E_{21}}=
\left[\begin{array}{ccc}1&0&0\\-3&1&0\\6&-2&1\end{array}\right]</script><p>总结，<strong>我们令方程组左边的矩阵为$D$，用初等矩阵$E$来表示消元操作，用上三角矩阵$U$表示消元得到的结果</strong>，则以上式为例：</p>
<script type="math/tex; mode=display">
D=\left[\begin{array}{ccc}1&2&1\\3&8&1\\0&4&1\end{array}\right],
E=\left[\begin{array}{ccc}1&0&0\\-3&1&0\\6&-2&1\end{array}\right]</script><script type="math/tex; mode=display">
U=ED=\left[\begin{array}{ccc}1&2&1\\0&2&-2\\0&0&5\end{array}\right]</script><hr>
<h2 id="置换矩阵"><a href="#置换矩阵" class="headerlink" title="置换矩阵"></a>置换矩阵</h2><p>   <strong>1、行交换：左乘</strong></p>
<script type="math/tex; mode=display">
\left[\begin{array}{cc}0&1\\1&0\end{array}\right]\left[\begin{array}{cc}a&b\\c&d\end{array}\right]=\left[\begin{array}{cc}c&d\\a&b\end{array}\right]</script><p>   <strong>2、列交换：右乘</strong></p>
<script type="math/tex; mode=display">
\left[\begin{array}{cc}a&b\\c&d\end{array}\right]
\left[\begin{array}{cc}0&1\\1&0\end{array}\right]
=\left[\begin{array}{cc}b&a\\d&c\end{array}\right]</script><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>Linear Algebra</tag>
      </tags>
  </entry>
  <entry>
    <title>【线性代数】方程组的几何解释</title>
    <url>/2014/09/10/%5B20140910%5D/</url>
    <content><![CDATA[<h2 id="二维情况"><a href="#二维情况" class="headerlink" title="二维情况"></a>二维情况</h2><p>首先，给出如下的二元一次方程组：</p>
<script type="math/tex; mode=display">
\begin{aligned}
2x-y=0\\
-x+2y=3
\end{aligned}</script><p>我们初中就对上面的二元一次方程组进行过求解，求解很简单。但是我们现在利用线性代数来表示这个式子，上式可以表示为：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\underbrace{\left[ \begin{array}{cc}
2 & -1 \\
-1 & 2 \\
\end{array} 
\right ]}_{A}\underbrace{\left[\begin{array}{c}x\\y\end{array}\right]}_{\hat x}
=\underbrace{\left[\begin{array}{c}0\\3\end{array}\right]}_{b}
\end{aligned}</script><p>我们这里假设用小写字母表示向量，大写字母表示矩阵。上面可以二元一次方程组便转化为求解$x$,$y$。</p>
<a id="more"></a>
<p>下面我们从几种不同的角度来求解上面的方程组：</p>
<p>1、<strong>从行的角度看</strong>，也就是画出上面两个方程的图像：</p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20140910/20140910_fig001.jpg" width="500" height="400" title="图1" alt="图1" ></p>
<p>很明显的可以看出方程的解是$x=1, y=2$。</p>
<p>2、<strong>从列的角度看</strong>，<strong>方程组可以表现为列的线性组合</strong>：</p>
<script type="math/tex; mode=display">
\begin{aligned}
x\left[\begin{array}{c}2\\-1\end{array}\right]+y\left[\begin{array}{c}-1\\2\end{array}\right]=\left[\begin{array}{c}0\\3\end{array}\right]
\end{aligned}</script><p>令向量$a=[2,-1]’, b=[-1, 2]’, c=[0, 3]’$，则<strong>问题变为找到适当的$x,y$将向量$a, b$ 进行线性组合得到向量$c$</strong>。同样我们可以通过作图求解：</p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20140910/20140910_fig002.jpg" width="500" height="400" title="图2" alt="图2" ></p>
<p>从上图可以看到$(2,-1)+2(-1,2)=(0,3)$，从而得到$x=1,y=2$。</p>
<hr>
<h2 id="三维情况"><a href="#三维情况" class="headerlink" title="三维情况"></a>三维情况</h2><p>上面的问题都是在二维平面上进行求解的，下面来看看三维下的情况：首先，给出三元一次方程组：</p>
<script type="math/tex; mode=display">
\begin{aligned}
2x-y+0z&=0\\
-x+2y-z&=-1\\
0x-3y+4z&=4
\end{aligned}</script><p>同样可以得到其矩阵的表示形式：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\left[\begin{array}{ccc}2&-1&0\\-1&2&-1\\0&-3&4\end{array}\right]\left[\begin{array}{c}x\\y\\z\end{array}\right]=\left[\begin{array}{c}0\\-1\\4\end{array}\right]
\end{aligned}</script><p>还是按照上面的方法分析：</p>
<hr>
<p>1、<strong>从行的角度看</strong>，也就是画出上面三个方程的图像（在这里变成了三维空间的平面）：</p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20140910/20140910_fig003.jpg" width="500" height="400" title="图3" alt="图3" ></p>
<p>上图的matlab代码为：</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="built_in">figure</span></span><br><span class="line">t=<span class="number">-10</span>:<span class="number">.1</span>:<span class="number">10</span>;</span><br><span class="line">[x,z]=<span class="built_in">meshgrid</span>(t);</span><br><span class="line">y=<span class="number">2</span>*x;</span><br><span class="line">mesh(x,y,z);</span><br><span class="line"><span class="built_in">hold</span> on</span><br><span class="line">y=(x+z<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line">mesh(x,y,z)</span><br><span class="line"><span class="built_in">hold</span> on</span><br><span class="line">y=-(<span class="number">4</span><span class="number">-4</span>*z)/<span class="number">3</span>;</span><br><span class="line">mesh(x,y,z)</span><br></pre></td></tr></table></figure>
<p>然后人工进行一些修正即可。从图中可以看出，三个平面交于一点$(0, 0, 1)$也就是方程组的解：$x=0, y=0, z=1$。</p>
<hr>
<p>2、<strong>同样从列的角度考虑该问题</strong>：</p>
<script type="math/tex; mode=display">
\begin{aligned}
x\left[\begin{array}{c}2\\-1\\0\end{array}\right]+y\left[\begin{array}{c}-1\\2\\3\end{array}\right]+z\left[\begin{array}{c}0\\-1\\4\end{array}\right]=\left[\begin{array}{c}0\\-1\\4\end{array}\right]
\end{aligned}</script><p><strong>不用通过计算或作图，我们从上式就可以轻易得到$x=y=0,z=1$，这比上面一种方法要简单得多。</strong></p>
<p>画出上面四个列向量的图（其中后两个列向量相同$(0,-1, 4)’$）:</p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20140910/20140910_fig004.jpg" width="500" height="400" title="图4" alt="图4" ></p>
<p>上图的matlab代码为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a&#x3D;[2 -1 0];</span><br><span class="line">b&#x3D;[-1 2 3];</span><br><span class="line">c&#x3D;[0 -1 4];</span><br><span class="line">quiver3(0,0,0,a(1),a(2),a(3),&#39;color&#39;,&#39;r&#39;)</span><br><span class="line">hold on</span><br><span class="line">quiver3(0,0,0,b(1),b(2),b(3),&#39;color&#39;,&#39;g&#39;)</span><br><span class="line">hold on</span><br><span class="line">quiver3(0,0,0,c(1),c(2),c(3),&#39;color&#39;,&#39;b&#39;)</span><br></pre></td></tr></table></figure>
<p>然后人工标上箭头，当然也可以通过命令标上箭头。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>Linear Algebra</tag>
      </tags>
  </entry>
  <entry>
    <title>【Qt编程】基于Qt的词典开发系列--无边框窗口的拖动</title>
    <url>/2014/08/25/%5B20140825%5D/</url>
    <content><![CDATA[<p>​    在上一篇文章中，我们讲述了如何进行无边框窗口的缩放与拖动，<strong>而在一些情况下，我们的窗口只需要进行拖动也不需要改变其大小</strong>，比如：QQ的登录窗口。本来在上一篇文章中已经讲述了如何进行窗口的拖动，但是却与窗口的缩放相关的程序放在一起，<strong>下面专门单独分离出来。</strong></p>
<p>​    窗口的拖放只涉及到鼠标事件：按下操作、释放操作和移动操作，因此只需要重写这三个函数。由于程序比较简单，并且注释也比较详细，就不作过多介绍。新建一个基类为QWidget的Qt Gui应用程序，<strong>只需修改widget.h和widget.cpp文件如下</strong>：</p>
<p><strong>1、widget.h文件</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> WIDGET_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WIDGET_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QWidget&gt;//注意我使用的是Qt5，Qt4与Qt5的区别可以参考http://qt-project.org/wiki/Transition_from_Qt_4.x_to_Qt5</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;QMouseEvent&gt;</span></span></span><br><span class="line"><span class="keyword">namespace</span> Ui &#123;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> :</span> <span class="keyword">public</span> QWidget</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Widget</span><span class="params">(QWidget *parent = <span class="number">0</span>)</span></span>;</span><br><span class="line">    ~Widget();</span><br><span class="line"></span><br><span class="line">    QPoint move_point; <span class="comment">//移动的距离</span></span><br><span class="line">    <span class="keyword">bool</span> mouse_press; <span class="comment">//鼠标按下</span></span><br><span class="line">    <span class="comment">//鼠标按下事件</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mousePressEvent</span><span class="params">(QMouseEvent *event)</span></span>;</span><br><span class="line">   <span class="comment">//鼠标释放事件</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mouseReleaseEvent</span><span class="params">(QMouseEvent *event)</span></span>;</span><br><span class="line">   <span class="comment">//鼠标移动事件</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mouseMoveEvent</span><span class="params">(QMouseEvent *event)</span></span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Ui::Widget *ui;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// WIDGET_H</span></span></span><br></pre></td></tr></table></figure>
<p><strong>2、widget.cpp文件</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"widget.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ui_widget.h"</span></span></span><br><span class="line"></span><br><span class="line">Widget::Widget(QWidget *parent) :</span><br><span class="line">    QWidget(parent),</span><br><span class="line">    ui(<span class="keyword">new</span> Ui::Widget)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;setupUi(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">this</span>-&gt;setMouseTracking(<span class="literal">false</span>);</span><br><span class="line">     setWindowFlags(Qt::FramelessWindowHint | Qt::WindowStaysOnTopHint);<span class="comment">//设置主窗口无边框</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Widget::~Widget()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Widget::mousePressEvent(QMouseEvent *event)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(event-&gt;button() == Qt::LeftButton)</span><br><span class="line">     &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;setMouseTracking(<span class="literal">true</span>);</span><br><span class="line">          mouse_press = <span class="literal">true</span>;</span><br><span class="line">          <span class="comment">//鼠标相对于窗体的位置（或者使用event-&gt;globalPos() - this-&gt;pos()）</span></span><br><span class="line">          move_point = event-&gt;pos();;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Widget::mouseReleaseEvent(QMouseEvent *event)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//设置鼠标为未被按下</span></span><br><span class="line">        mouse_press = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Widget::mouseMoveEvent(QMouseEvent *event)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//若鼠标左键被按下</span></span><br><span class="line">  <span class="comment">//  qDebug()&lt;&lt;"mouse_press="&lt;&lt;event-&gt;globalPos();</span></span><br><span class="line">        <span class="keyword">if</span>(mouse_press)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//鼠标相对于屏幕的位置</span></span><br><span class="line">            QPoint move_pos = event-&gt;globalPos();</span><br><span class="line"></span><br><span class="line">           <span class="comment">//移动主窗体位置</span></span><br><span class="line">           <span class="keyword">this</span>-&gt;move(move_pos - move_point);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>基于Qt的词典开发系列</strong></p>
<ol>
<li><a href="http://blog.csdn.net/tengweitw/article/details/44757875" target="_blank" rel="noopener">词典框架设计及成品展示</a></li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/45014771" target="_blank" rel="noopener">本地词典的设计</a></li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/45099867" target="_blank" rel="noopener">开始菜单的设计</a></li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/38758051" target="_blank" rel="noopener">无边框窗口的缩放与拖动</a></li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/38817595" target="_blank" rel="noopener">无边框窗口的拖动</a></li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/45223931" target="_blank" rel="noopener">界面美化设计</a></li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/45484803" target="_blank" rel="noopener">调用网络API</a></li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/45932429" target="_blank" rel="noopener">用户登录及API调用的实现</a></li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/45932429" target="_blank" rel="noopener">JSON数据解析</a></li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/23294533" target="_blank" rel="noopener">国际音标的显示</a></li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/38237203" target="_blank" rel="noopener">系统托盘的显示</a></li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/38306803" target="_blank" rel="noopener">调用讲述人</a></li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/38555787" target="_blank" rel="noopener">音频播放</a></li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/38689745" target="_blank" rel="noopener">自动补全功能</a></li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/38734201" target="_blank" rel="noopener">HTML特殊字符及正则表达式</a></li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/46563781" target="_blank" rel="noopener">后序</a></li>
</ol>
<p><strong>作品下载地址（发布版）</strong>：<a href="http://download.csdn.net/detail/tengweitw/8548767" target="_blank" rel="noopener">http://download.csdn.net/detail/tengweitw/8548767</a></p>
<p><strong>作品下载地址（绿色版）</strong>：<a href="http://download.csdn.net/detail/tengweitw/8830495" target="_blank" rel="noopener">http://download.csdn.net/detail/tengweitw/8830495</a></p>
<p><strong>源码下载地址</strong>：<a href="http://download.csdn.net/detail/tengweitw/8830503" target="_blank" rel="noopener">http://download.csdn.net/detail/tengweitw/8830503</a></p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>Qt Coding</tag>
      </tags>
  </entry>
  <entry>
    <title>【Qt编程】基于Qt的词典开发系列--无边框窗口的缩放与拖动</title>
    <url>/2014/08/22/%5B20140822%5D/</url>
    <content><![CDATA[<p>​    在现在，绝大多数软件都向着简洁，时尚发展。就拿有道的单词本和我做的单词本来说，绝大多数用户肯定喜欢我所做的单词本(就单单界面，关于颜色搭配和布局问题，大家就不要在意了)。</p>
<p>有道的单词本：</p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20140822/20140822_fig001.jpg" width="500" height="350" title="图1" alt="图1" ></p>
<p>我所做的单词本：</p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20140822/20140822_fig002.jpg" width="500" height="350" title="图2" alt="图2" ></p>
<a id="more"></a>
<p>很明显，两者的主要区别就是周围的边框问题。你可以对比QQ以前的版本和这几年的版本，就会发现都倾向于下面这种窗口模式。下面我们就说说如何用Qt实现无边框窗口的缩放与拖动。</p>
<p>​    对于无边框窗口的拖动其实很简单，其基本思想是，在鼠标移动前后记录鼠标的坐标，然后将窗口移动这两个坐标之差的距离即可，具体实现可以看代码，就非常清楚了。下面主要讲讲如何实现鼠标改变窗口的大小，首先，我们将一个窗口分为以下9个区域，其中只有鼠标在22区域时无法改变其形状，不能改变窗口大小。当鼠标在其它区域时，鼠标改变形状并可以改变窗口大小。窗口区域分类如下图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20140822/20140822_fig003.jpg" width="300" height="250" title="图3" alt="图3" ></p>
<p><strong>具体实现如下代码(widget.ui未做任何改变)：</strong></p>
<p><strong>1、widget.h文件</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> WIDGET_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WIDGET_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QWidget&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MARGIN 20<span class="comment">//四个角的长度</span></span></span><br><span class="line"><span class="keyword">namespace</span> Ui &#123;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> :</span> <span class="keyword">public</span> QWidget</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Widget</span><span class="params">(QWidget *parent = <span class="number">0</span>)</span></span>;</span><br><span class="line">    ~Widget();</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countFlag</span><span class="params">(QPoint p, <span class="keyword">int</span> row)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setCursorType</span><span class="params">(<span class="keyword">int</span> flag)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countRow</span><span class="params">(QPoint p)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mousePressEvent</span><span class="params">(QMouseEvent *event)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mouseReleaseEvent</span><span class="params">(QMouseEvent *event)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mouseDoubleClickEvent</span><span class="params">(QMouseEvent *event)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mouseMoveEvent</span><span class="params">(QMouseEvent *event)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Ui::Widget *ui;</span><br><span class="line">    <span class="keyword">bool</span> isLeftPressed;</span><br><span class="line">    <span class="keyword">int</span> curPos;</span><br><span class="line">    QPoint pLast;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// WIDGET_H</span></span></span><br></pre></td></tr></table></figure>
<p><strong>2、widget.cpp文件</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"widget.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ui_widget.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;QMouseEvent&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;QDebug&gt;</span></span></span><br><span class="line"></span><br><span class="line">Widget::Widget(QWidget *parent) :</span><br><span class="line">    QWidget(parent),</span><br><span class="line">    ui(<span class="keyword">new</span> Ui::Widget)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;setupUi(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">this</span>-&gt;setMouseTracking(<span class="literal">true</span>);</span><br><span class="line">    <span class="comment">//设置在不按鼠标的情况下也触发鼠标移动事件，注意QMainWindow的情况:centralWidget()-&gt;setMouseTracking(true);</span></span><br><span class="line">    isLeftPressed=<span class="literal">false</span>;</span><br><span class="line">    curPos=<span class="number">0</span>;<span class="comment">//标记鼠标左击时的位置</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;setMinimumSize(<span class="number">400</span>,<span class="number">300</span>);<span class="comment">//设置最小尺寸</span></span><br><span class="line">    QCursor cursor;</span><br><span class="line">    cursor.setShape(Qt::ArrowCursor);<span class="comment">//设置鼠标为箭头形状</span></span><br><span class="line">   <span class="comment">// ui-&gt;pushButton-&gt;setCursor(cursor);//当放在按钮上时，为箭头</span></span><br><span class="line">   <span class="comment">// cursor.setShape(Qt::OpenHandCursor);</span></span><br><span class="line">    QWidget::setCursor(cursor);<span class="comment">//当放在主窗口上时，为手形</span></span><br><span class="line">    qDebug()&lt;&lt;<span class="string">"h="</span>&lt;&lt;<span class="keyword">this</span>-&gt;height();</span><br><span class="line">    setWindowFlags(Qt::FramelessWindowHint);<span class="comment">//设置主窗口无边框</span></span><br><span class="line">    qDebug()&lt;&lt;<span class="keyword">this</span>-&gt;minimumHeight();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Widget::~Widget()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> Widget::mousePressEvent(QMouseEvent *event)<span class="comment">//鼠标按下事件</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(event-&gt;button()==Qt::LeftButton)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;isLeftPressed=<span class="literal">true</span>;</span><br><span class="line">        QPoint temp=event-&gt;globalPos();</span><br><span class="line">        pLast=temp;</span><br><span class="line">        curPos=countFlag(event-&gt;pos(),countRow(event-&gt;pos()));</span><br><span class="line">        event-&gt;ignore();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Widget::mouseReleaseEvent(QMouseEvent *event)<span class="comment">//鼠标释放事件</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(isLeftPressed)</span><br><span class="line">        isLeftPressed=<span class="literal">false</span>;</span><br><span class="line">    QApplication::restoreOverrideCursor();<span class="comment">//恢复鼠标指针性状</span></span><br><span class="line">    event-&gt;ignore();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Widget::mouseDoubleClickEvent(QMouseEvent *event)<span class="comment">//鼠标双击 全屏</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(event-&gt;button()==Qt::LeftButton)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(windowState()!=Qt::WindowFullScreen)</span><br><span class="line">            setWindowState(Qt::WindowFullScreen);</span><br><span class="line">        <span class="keyword">else</span> setWindowState(Qt::WindowNoState);<span class="comment">//恢复正常模式</span></span><br><span class="line">    &#125;</span><br><span class="line">    event-&gt;ignore();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Widget::mouseMoveEvent(QMouseEvent *event)<span class="comment">//鼠标移动事件</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> poss=countFlag(event-&gt;pos(),countRow(event-&gt;pos()));</span><br><span class="line">    setCursorType(poss);</span><br><span class="line">    <span class="keyword">if</span>(isLeftPressed)<span class="comment">//是否左击</span></span><br><span class="line">    &#123;</span><br><span class="line">        QPoint ptemp=event-&gt;globalPos();</span><br><span class="line">        ptemp=ptemp-pLast;</span><br><span class="line">        <span class="keyword">if</span>(curPos==<span class="number">22</span>)<span class="comment">//移动窗口</span></span><br><span class="line">        &#123;</span><br><span class="line">            ptemp=ptemp+pos();</span><br><span class="line">            move(ptemp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            QRect wid=geometry();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">switch</span>(curPos)<span class="comment">//改变窗口的大小</span></span><br><span class="line">            &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="number">11</span>:wid.setTopLeft(wid.topLeft()+ptemp);<span class="keyword">break</span>;<span class="comment">//左上角</span></span><br><span class="line">            <span class="keyword">case</span> <span class="number">13</span>:wid.setTopRight(wid.topRight()+ptemp);<span class="keyword">break</span>;<span class="comment">//右上角</span></span><br><span class="line">            <span class="keyword">case</span> <span class="number">31</span>:wid.setBottomLeft(wid.bottomLeft()+ptemp);<span class="keyword">break</span>;<span class="comment">//左下角</span></span><br><span class="line">            <span class="keyword">case</span> <span class="number">33</span>:wid.setBottomRight(wid.bottomRight()+ptemp);<span class="keyword">break</span>;<span class="comment">//右下角</span></span><br><span class="line">            <span class="keyword">case</span> <span class="number">12</span>:wid.setTop(wid.top()+ptemp.y());<span class="keyword">break</span>;<span class="comment">//中上角</span></span><br><span class="line">            <span class="keyword">case</span> <span class="number">21</span>:wid.setLeft(wid.left()+ptemp.x());<span class="keyword">break</span>;<span class="comment">//中左角</span></span><br><span class="line">            <span class="keyword">case</span> <span class="number">23</span>:wid.setRight(wid.right()+ptemp.x());<span class="keyword">break</span>;<span class="comment">//中右角</span></span><br><span class="line">            <span class="keyword">case</span> <span class="number">32</span>:wid.setBottom(wid.bottom()+ptemp.y());<span class="keyword">break</span>;<span class="comment">//中下角</span></span><br><span class="line">            &#125;</span><br><span class="line">            setGeometry(wid);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        pLast=event-&gt;globalPos();<span class="comment">//更新位置</span></span><br><span class="line">    &#125;</span><br><span class="line">    event-&gt;ignore();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Widget::countFlag(QPoint p,<span class="keyword">int</span> row)<span class="comment">//计算鼠标在哪一列和哪一行</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(p.y()&lt;MARGIN)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">10</span>+row;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(p.y()&gt;<span class="keyword">this</span>-&gt;height()-MARGIN)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">30</span>+row;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">20</span>+row;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Widget::setCursorType(<span class="keyword">int</span> flag)<span class="comment">//根据鼠标所在位置改变鼠标指针形状</span></span><br><span class="line">&#123;</span><br><span class="line">    Qt::CursorShape cursor;</span><br><span class="line">    <span class="keyword">switch</span>(flag)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">11</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">33</span>:</span><br><span class="line">        cursor=Qt::SizeFDiagCursor;<span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">13</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">31</span>:</span><br><span class="line">        cursor=Qt::SizeBDiagCursor;<span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">21</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">23</span>:</span><br><span class="line">        cursor=Qt::SizeHorCursor;<span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">12</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">32</span>:</span><br><span class="line">        cursor=Qt::SizeVerCursor;<span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">22</span>:</span><br><span class="line">        cursor=Qt::OpenHandCursor;<span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">       <span class="comment">//  QApplication::restoreOverrideCursor();//恢复鼠标指针性状</span></span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    setCursor(cursor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Widget::countRow(QPoint p)<span class="comment">//计算在哪一列</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (p.x()&lt;MARGIN)?<span class="number">1</span>:(p.x()&gt;(<span class="keyword">this</span>-&gt;width()-MARGIN)?<span class="number">3</span>:<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>3、main.cpp文件</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;QtWidgets&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"widget.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line">    Widget w;</span><br><span class="line">    w.show();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> a.exec();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>程序运行截图如下：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20140822/20140822_fig004.jpg" width="500" height="350" title="图4" alt="图4" ></p>
<p>​    当你将鼠标放在窗口的边缘时，鼠标会变化形状，表示可以拖动窗口。由于没有关闭窗口，只能在强制关闭窗口。如果想做到和不同窗口实现最小化和关闭窗口的画，我们可以在窗口左上角放置两个ToolButton，并设置autorise属性，加上图片即可。下面给出使用上面的无边框窗口所做的词典软件的主界面：</p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20140822/20140822_fig005.jpg" width="500" height="350" title="图5" alt="图5" ></p>
<p><strong>基于Qt的词典开发系列</strong></p>
<ol>
<li><a href="http://blog.csdn.net/tengweitw/article/details/44757875" target="_blank" rel="noopener">词典框架设计及成品展示</a></li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/45014771" target="_blank" rel="noopener">本地词典的设计</a></li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/45099867" target="_blank" rel="noopener">开始菜单的设计</a></li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/38758051" target="_blank" rel="noopener">无边框窗口的缩放与拖动</a></li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/38817595" target="_blank" rel="noopener">无边框窗口的拖动</a></li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/45223931" target="_blank" rel="noopener">界面美化设计</a></li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/45484803" target="_blank" rel="noopener">调用网络API</a></li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/45932429" target="_blank" rel="noopener">用户登录及API调用的实现</a></li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/45932429" target="_blank" rel="noopener">JSON数据解析</a></li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/23294533" target="_blank" rel="noopener">国际音标的显示</a></li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/38237203" target="_blank" rel="noopener">系统托盘的显示</a></li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/38306803" target="_blank" rel="noopener">调用讲述人</a></li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/38555787" target="_blank" rel="noopener">音频播放</a></li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/38689745" target="_blank" rel="noopener">自动补全功能</a></li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/38734201" target="_blank" rel="noopener">HTML特殊字符及正则表达式</a></li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/46563781" target="_blank" rel="noopener">后序</a></li>
</ol>
<p><strong>作品下载地址（发布版）</strong>：<a href="http://download.csdn.net/detail/tengweitw/8548767" target="_blank" rel="noopener">http://download.csdn.net/detail/tengweitw/8548767</a></p>
<p><strong>作品下载地址（绿色版）</strong>：<a href="http://download.csdn.net/detail/tengweitw/8830495" target="_blank" rel="noopener">http://download.csdn.net/detail/tengweitw/8830495</a></p>
<p><strong>源码下载地址</strong>：<a href="http://download.csdn.net/detail/tengweitw/8830503" target="_blank" rel="noopener">http://download.csdn.net/detail/tengweitw/8830503</a></p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>Qt Coding</tag>
      </tags>
  </entry>
  <entry>
    <title>【Qt编程】基于Qt的词典开发系列html特殊字符及正则表达式</title>
    <url>/2014/08/21/%5B20140821%5D/</url>
    <content><![CDATA[<p><strong>1、html特殊字符的显示</strong></p>
<p>   我们知道html语言和C语言一样也有一些特殊字符，它们是不能正常显示的，必须经过转义，在网上可以查到如何显示这些字符，如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20140821/20140821_fig001.jpg" width="300" height="200" title="图1" alt="图1" ></p>
<a id="more"></a>
<p>上图给了最常用的特殊字符的显示，下面我们来实验一下：</p>
<p>首先在记事本中写入一句：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">blue</span>&gt;</span>程序例<span class="tag">&lt;/<span class="name">font</span>&gt;</span>#include<span class="tag">&lt;<span class="name">stdio.h</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>然后就文本后缀名改为.html后</strong>，用浏览器打开，显示如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20140821/20140821_fig002.jpg" width="350" height="160" title="图2" alt="图2" ></p>
<p>我们从上图可以发现include后面没有显示，但是当我们在文本中写入：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">blue</span>&gt;</span>程序例<span class="tag">&lt;/<span class="name">font</span>&gt;</span>#include<span class="tag">&lt;<span class="name">stdio.h</span>&gt;</span>   </span><br><span class="line">或</span><br><span class="line"><span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">blue</span>&gt;</span>程序例<span class="tag">&lt;/<span class="name">font</span>&gt;</span>#include<span class="tag">&lt;<span class="name">stdio.h</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这时就能正常显示了。显示结果如下图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20140821/20140821_fig003.jpg" width="350" height="150" title="图3" alt="图3" ></p>
<p>​    我们知道Qt能够支持html语言，但是我在编写可以查询c语言函数(肯定有#include后面&lt;&gt;的特殊字符的显示问题)的时候发现使用上面的方法仍然不能显示特殊字符，后来灵机一动，就决定<strong>用全角＜＞来代替半角&lt;&gt;</strong>。这样就不会当成是特殊字符了，就可以正常显示了。半角和全角的转换只需要点击下图中的第3个按钮：</p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20140821/20140821_fig004.jpg" width="300" height="80" title="图4" alt="图4" ></p>
<p>虽然说，使用全角后看起来不是很协调，但还看得过去，如果读者有什么好的方法，请不吝赐教。</p>
<p><strong>2、正则表达式</strong></p>
<p>​    接着上面的问题继续说，比如我有一个C语言函数词典库，我取其中一段来举例：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;font color=blue&gt;程序例&lt;/font&gt;:&lt;br&gt;#include &lt;span style="color:#ff0000;"&gt;&lt;&lt;/span&gt;stdio.h &lt;span style="color:#ff0000;"&gt;&gt;&lt;/span&gt;&lt;br&gt;#include &lt;span style="color:#ff0000;"&gt;&lt;&lt;/span&gt; stdlib.h &lt;span style="color:#ff0000;"&gt;&gt;&lt;/span&gt;&lt;br&gt;int main(void)&lt;br&gt;</span><br></pre></td></tr></table></figure>
<p>因为我们需要将上述半角的&lt;&gt;转换为全角的＜＞，并且<strong>只是替换处于头文件的半角&lt;&gt;</strong>，<strong>即字符串中为红色的部分</strong>。当然当文件比较小的时候，可以手动查找替换，但是由于词典一半都有十几M，这时就必须使用正则表达式了。</p>
<p>​    在Qt中，使用了QRegExp来支持正则表达式。关于正则表达式的语法，网上都有很多教程，我就不细说了。从上面的实例字符串的内容，我们知道包含了几个头文件，所以我们在匹配时，要分别匹配各个头文件两边的半角&lt;&gt;，<strong>即我们要使用非贪婪模式</strong>，否则就会从第一个头文件的&lt;匹配到最后一个头文件的&gt;。我们知道，在正则表达式中，非贪婪模式是由’?’来指定的，但是对于QRegExp类来说，？是不合法的。<strong>在QRegExp中，要使用setMinimal函数来指定贪婪模式</strong>。<strong>setMinimal(true)就是非贪婪模式，setMinimal(false)就是贪婪模式。</strong></p>
<p>​    通过上面两部分的讲解，就可以完成C语言函数库词典的显示了。下面通过代码实现，新建Qt Gui应用程序，选择基类为QWidget，其中只需要修改widget.cpp里的内容即可（需要在widget.ui界面中，添加两个label,分别命名为label和label1）。</p>
<p>widget.cpp文件：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"widget.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ui_widget.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;QString&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;QRegExp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;QDebug&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;QLabel&gt;</span></span></span><br><span class="line"></span><br><span class="line">Widget::Widget(QWidget *parent) :</span><br><span class="line">    QWidget(parent),</span><br><span class="line">    ui(<span class="keyword">new</span> Ui::Widget)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;setupUi(<span class="keyword">this</span>);</span><br><span class="line">    QString str=<span class="string">"&lt;font color=blue&gt;程序例&lt;/font&gt;:&lt;br&gt;#include &lt;stdio.h &gt;&lt;br&gt;#include &lt; stdlib.h &gt;&lt;br&gt;int main(void)&lt;br&gt;"</span>;</span><br><span class="line">    ui-&gt;label-&gt;setText(str);  <span class="comment">//由于Qt也能识别html格式，而&lt; &gt;是html的特殊字符，因此不处理的话，就会出现显示出错</span></span><br><span class="line"></span><br><span class="line">    <span class="function">QRegExp <span class="title">rx</span><span class="params">(<span class="string">"#include (&lt;(.*.h )&gt;)"</span>)</span></span>;<span class="comment">//正则表达式里的括号是为了获取匹配的内容</span></span><br><span class="line">    rx.setMinimal(<span class="literal">true</span>);<span class="comment">//非贪婪模式</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> pos=<span class="number">0</span>;<span class="comment">//从字符串的开始部分</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;str.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        pos=rx.indexIn(str,<span class="number">0</span>);<span class="comment">//得到匹配字符串的位置</span></span><br><span class="line">        <span class="keyword">while</span>(pos!=<span class="number">-1</span>)<span class="comment">//匹配成功</span></span><br><span class="line">        &#123;</span><br><span class="line">        str.replace(rx.cap(<span class="number">1</span>),<span class="string">"＜"</span>+rx.cap(<span class="number">2</span>)+<span class="string">"＞"</span>);<span class="comment">//这里是进行替换，如果不明白rx.cap是什么，可以qDebug显示内容</span></span><br><span class="line">        pos=rx.indexIn(str,pos+rx.matchedLength());<span class="comment">//从当前位置，继续往后进行匹配</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">ui-&gt;label1-&gt;setText(str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Widget::~Widget()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>程序运行结果如下：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20140821/20140821_fig005.jpg" width="500" height="380" title="图5" alt="图5" ></p>
<p><strong>下面放一张查单词软件用到的特殊字符显示和使用正则表达式后的截图：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20140821/20140821_fig006.jpg" width="500" height="380" title="图6" alt="图6" ></p>
<p>注意：我使用的平台为QT5,如果转移到Qt4上有错的话，可以反向参考<a href="http://qt-project.org/wiki/Transition_from_Qt_4.x_to_Qt5" target="_blank" rel="noopener">http://qt-project.org/wiki/Transition_from_Qt_4.x_to_Qt5</a></p>
<p><strong>基于Qt的词典开发系列</strong></p>
<ol>
<li><a href="http://blog.csdn.net/tengweitw/article/details/44757875" target="_blank" rel="noopener">词典框架设计及成品展示</a></li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/45014771" target="_blank" rel="noopener">本地词典的设计</a></li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/45099867" target="_blank" rel="noopener">开始菜单的设计</a></li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/38758051" target="_blank" rel="noopener">无边框窗口的缩放与拖动</a></li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/38817595" target="_blank" rel="noopener">无边框窗口的拖动</a></li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/45223931" target="_blank" rel="noopener">界面美化设计</a></li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/45484803" target="_blank" rel="noopener">调用网络API</a></li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/45932429" target="_blank" rel="noopener">用户登录及API调用的实现</a></li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/45932429" target="_blank" rel="noopener">JSON数据解析</a></li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/23294533" target="_blank" rel="noopener">国际音标的显示</a></li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/38237203" target="_blank" rel="noopener">系统托盘的显示</a></li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/38306803" target="_blank" rel="noopener">调用讲述人</a></li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/38555787" target="_blank" rel="noopener">音频播放</a></li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/38689745" target="_blank" rel="noopener">自动补全功能</a></li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/38734201" target="_blank" rel="noopener">HTML特殊字符及正则表达式</a></li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/46563781" target="_blank" rel="noopener">后序</a></li>
</ol>
<p><strong>作品下载地址（发布版）</strong>：<a href="http://download.csdn.net/detail/tengweitw/8548767" target="_blank" rel="noopener">http://download.csdn.net/detail/tengweitw/8548767</a></p>
<p><strong>作品下载地址（绿色版）</strong>：<a href="http://download.csdn.net/detail/tengweitw/8830495" target="_blank" rel="noopener">http://download.csdn.net/detail/tengweitw/8830495</a></p>
<p><strong>源码下载地址</strong>：<a href="http://download.csdn.net/detail/tengweitw/8830503" target="_blank" rel="noopener">http://download.csdn.net/detail/tengweitw/8830503</a></p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>Qt Coding</tag>
      </tags>
  </entry>
  <entry>
    <title>【Qt编程】基于Qt的词典开发系列自动补全功能</title>
    <url>/2014/08/19/%5B20140819%5D/</url>
    <content><![CDATA[<p>最近写了一个查单词的类似有道词典的软件，里面就有一个自动补全功能（即当你输入一个字母时，就会出现几个候选项）。这个自动补全功能十分常见，百度搜索关键词时就会出现。不过它们这些补全功能都是与你输入的进行首字匹配，有时也会不方便。例如，如果我输入一个“好”，如果是首字匹配的话会出现下图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20140819/20140819_fig001.jpg" width="400" height="300" title="图1" alt="图1" ></p>
<p>如果是句中匹配的话，则是这种情况：</p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20140819/20140819_fig002.jpg" width="400" height="300" title="图2" alt="图2" ></p>
<p>你可以根据自己的要求进行选择哪一种模式。</p>
<a id="more"></a>
<p>Qt中自带QCompleter类来实现上面的自动补全功能，读者可以在Qt自带的demo中很容易的学会该类的使用。<strong>下面我要讲的是自己构造一个比QCompleter更强大的类</strong>。有人会说，为什么有现成的不用，要自己写一个类呢？因为，我用QCompleter类的时候发现，它只有句首匹配模式（可能是我没仔细看文档，不知道可以改变模式），其次，当我的词库非常大的时候，有的时候就不会出现下拉自动补全列表，具体原因也不清楚。所以自己写了一个类，来实现QCompleter类所没有功能。废话不多说，直接见代码（代码注解比较详细，就不仔细讲解了，widget.ui文件也不给出了，就是一个空的界面）：</p>
<p>1、widget.h</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> WIDGET_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WIDGET_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QWidget&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;QMouseEvent&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Ui &#123;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> :</span> <span class="keyword">public</span> QWidget</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Widget</span><span class="params">(QWidget *parent = <span class="number">0</span>)</span></span>;</span><br><span class="line">    ~Widget();</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mousePressEvent</span><span class="params">(QMouseEvent *event)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Ui::Widget *ui;</span><br><span class="line">signals:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">movesignal</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// WIDGET_H</span></span></span><br></pre></td></tr></table></figure>
<p>2.completelineedit.h</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> COMPLETELINEEDIT_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> COMPLETELINEEDIT_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QLineEdit&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QStringList&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;QFile&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;QTextCodec&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;QDebug&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QListView</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QStringListModel</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QModelIndex</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CompleteLineEdit</span> :</span> <span class="keyword">public</span> QLineEdit &#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    CompleteLineEdit(QStringList words, QWidget *parent = <span class="number">0</span>);</span><br><span class="line"><span class="keyword">public</span> slots:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setCompleter</span><span class="params">(<span class="keyword">const</span> QString &amp;text)</span></span>; <span class="comment">// 动态的显示完成列表</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">completeText</span><span class="params">(<span class="keyword">const</span> QModelIndex &amp;index)</span></span>; <span class="comment">// 点击完成列表中的项，使用此项自动完成输入的单词</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">keyPressEvent</span><span class="params">(QKeyEvent *e)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">focusOutEvent</span><span class="params">(QFocusEvent *e)</span></span>;</span><br><span class="line"><span class="keyword">private</span> slots:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">replyMoveSignal</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    QStringList words; <span class="comment">// 整个完成列表的单词</span></span><br><span class="line">    QListView *listView; <span class="comment">// 完成列表</span></span><br><span class="line">    QStringListModel *model; <span class="comment">// 完成列表的model</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// COMPLETELINEEDIT_H</span></span></span><br></pre></td></tr></table></figure>
<p>3.widget.cpp</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"widget.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ui_widget.h"</span></span></span><br><span class="line"></span><br><span class="line">Widget::Widget(QWidget *parent) :</span><br><span class="line">    QWidget(parent),</span><br><span class="line">    ui(<span class="keyword">new</span> Ui::Widget)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;setupUi(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Widget::~Widget()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Widget::mousePressEvent(QMouseEvent *event)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">emit <span class="title">movesignal</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4.completelineedit.cpp</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"CompleteLineEdit.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QKeyEvent&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QListView&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QStringListModel&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QDebug&gt;</span></span></span><br><span class="line">CompleteLineEdit::CompleteLineEdit(QStringList words, QWidget *parent)</span><br><span class="line">    : QLineEdit(parent), words(words)</span><br><span class="line">&#123;</span><br><span class="line">    listView = <span class="keyword">new</span> QListView(<span class="keyword">this</span>);<span class="comment">//用于显示下拉列表</span></span><br><span class="line">    model = <span class="keyword">new</span> QStringListModel(<span class="keyword">this</span>);</span><br><span class="line">    listView-&gt;setWindowFlags(Qt::ToolTip);<span class="comment">//设置下拉列表的样式</span></span><br><span class="line">    connect(<span class="keyword">this</span>, SIGNAL(textChanged(<span class="keyword">const</span> QString &amp;)), <span class="keyword">this</span>, SLOT(setCompleter(<span class="keyword">const</span> QString &amp;)));</span><br><span class="line">    connect(listView, SIGNAL(clicked(<span class="keyword">const</span> QModelIndex &amp;)), <span class="keyword">this</span>, SLOT(completeText(<span class="keyword">const</span> QModelIndex &amp;)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> CompleteLineEdit::focusOutEvent(QFocusEvent *e)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//  listView-&gt;hide();//当输入行不是焦点时，隐藏自动补全的下拉列表</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> CompleteLineEdit::replyMoveSignal()</span><br><span class="line">&#123;</span><br><span class="line">    listView-&gt;hide();<span class="comment">//当输入行不是焦点时，隐藏自动补全的下拉列表</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> CompleteLineEdit::keyPressEvent(QKeyEvent *e)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!listView-&gt;isHidden())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> key = e-&gt;key();</span><br><span class="line">        <span class="keyword">int</span> count = listView-&gt;model()-&gt;rowCount();</span><br><span class="line">        QModelIndex currentIndex = listView-&gt;currentIndex();</span><br><span class="line">        <span class="keyword">if</span> (Qt::Key_Down == key)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 按向下方向键时</span></span><br><span class="line">            <span class="keyword">int</span> row = currentIndex.row() + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (row &gt;= count)</span><br><span class="line">            &#123;</span><br><span class="line">                row = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            QModelIndex index = listView-&gt;model()-&gt;index(row, <span class="number">0</span>);</span><br><span class="line">            listView-&gt;setCurrentIndex(index);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Qt::Key_Up == key)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 按向下方向键时</span></span><br><span class="line">            <span class="keyword">int</span> row = currentIndex.row() - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (row &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                row = count - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            QModelIndex index = listView-&gt;model()-&gt;index(row, <span class="number">0</span>);</span><br><span class="line">            listView-&gt;setCurrentIndex(index);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Qt::Key_Escape == key)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 按下Esc键时隐藏完成列表</span></span><br><span class="line">            listView-&gt;hide();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Qt::Key_Enter == key || Qt::Key_Return == key)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 按下回车键时，使用完成列表中选中的项，并隐藏完成列表</span></span><br><span class="line">            <span class="keyword">if</span> (currentIndex.isValid())</span><br><span class="line">            &#123;</span><br><span class="line">                QString text = listView-&gt;currentIndex().data().toString();</span><br><span class="line">                setText(text);</span><br><span class="line">            &#125;</span><br><span class="line">            listView-&gt;hide();</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">           <span class="comment">// 其他情况，隐藏完成列表，并使用QLineEdit的键盘按下事件</span></span><br><span class="line">            listView-&gt;hide();</span><br><span class="line">            QLineEdit::keyPressEvent(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        QLineEdit::keyPressEvent(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> CompleteLineEdit::setCompleter(<span class="keyword">const</span> QString &amp;text)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (text.isEmpty())<span class="comment">//没有输入内容的情况</span></span><br><span class="line">    &#123;</span><br><span class="line">        listView-&gt;hide();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((text.length() &gt; <span class="number">1</span>) &amp;&amp; (!listView-&gt;isHidden()))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果完整的完成列表中的某个单词包含输入的文本，则加入要显示的完成列表串中</span></span><br><span class="line">    QStringList sl;</span><br><span class="line">    foreach(QString word, words)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//填充模式一</span></span><br><span class="line">        <span class="keyword">if</span> (word.contains(text))<span class="comment">//只要包含该输入内容就显示，这里也可以设置大小写不敏感</span></span><br><span class="line">        &#123;</span><br><span class="line">            sl &lt;&lt; word;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//填充模式二</span></span><br><span class="line"><span class="comment">//        if(word.indexOf(text,0,Qt::CaseInsensitive)==0)//必需与句首内容相同</span></span><br><span class="line"><span class="comment">//            sl&lt;&lt;word;</span></span><br><span class="line">    &#125;</span><br><span class="line">    model-&gt;setStringList(sl);</span><br><span class="line">    listView-&gt;setModel(model);</span><br><span class="line">    <span class="keyword">if</span> (model-&gt;rowCount() == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置列表的显示位置及大小</span></span><br><span class="line">    listView-&gt;setMinimumWidth(width());</span><br><span class="line">    listView-&gt;setMaximumWidth(width());</span><br><span class="line">    <span class="function">QPoint <span class="title">p</span><span class="params">(<span class="number">0</span>, height())</span></span>;</span><br><span class="line">    <span class="keyword">int</span> x = mapToGlobal(p).x();</span><br><span class="line">    <span class="keyword">int</span> y = mapToGlobal(p).y() + <span class="number">1</span>;</span><br><span class="line">    listView-&gt;move(x, y);</span><br><span class="line">    listView-&gt;show();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> CompleteLineEdit::completeText(<span class="keyword">const</span> QModelIndex &amp;index)</span><br><span class="line">&#123;</span><br><span class="line">    QString text = index.data().toString();</span><br><span class="line">    setText(text);</span><br><span class="line">    listView-&gt;hide();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>5.main.cpp</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"CompleteLineEdit.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"widget.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    QStringList sl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    QFile *inFile=<span class="keyword">new</span> QFile (<span class="string">"input.txt"</span>);<span class="comment">//这个是你自己的词库</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!inFile-&gt;open(QIODevice::ReadOnly|QIODevice::Text))</span><br><span class="line">    &#123;</span><br><span class="line">        qDebug()&lt;&lt;<span class="string">"cannot read!"</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!inFile-&gt;atEnd())</span><br><span class="line">    &#123;</span><br><span class="line">        QByteArray line = inFile-&gt;readLine();</span><br><span class="line">        QTextCodec* gbk_codec = QTextCodec::codecForName(<span class="string">"GBK"</span>);</span><br><span class="line">          QString gbk_string = gbk_codec-&gt;toUnicode(line);</span><br><span class="line">        <span class="keyword">if</span> (!line.isEmpty())</span><br><span class="line">            sl &lt;&lt; gbk_string.trimmed();<span class="comment">//将文件中的词汇输入到sl中</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    inFile-&gt;close();<span class="comment">//关闭文件</span></span><br><span class="line">    sl&lt;&lt; <span class="string">"你好"</span> &lt;&lt; <span class="string">"好的"</span> &lt;&lt; <span class="string">"好吗"</span> &lt;&lt; <span class="string">"你的"</span> &lt;&lt; <span class="string">"真好啊"</span> &lt;&lt; <span class="string">"天真"</span> &lt;&lt; <span class="string">"你好吗"</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Widget *w= <span class="keyword">new</span> Widget();</span><br><span class="line">    CompleteLineEdit * edit= <span class="keyword">new</span> CompleteLineEdit(sl,w);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    w-&gt;show();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">// QObject::connect(w,SIGNAL(movesignal()),edit,SLOT(replyMoveSignal()));</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a.exec();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后放两张查单词软件用到的自动补全功能的截图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20140819/20140819_fig003.jpg" width="600" height="500" title="图3" alt="图3" ></p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20140819/20140819_fig004.jpg" width="600" height="500" title="图4" alt="图4" ></p>
<p><strong>基于Qt的词典开发系列</strong></p>
<ol>
<li><a href="http://blog.csdn.net/tengweitw/article/details/44757875" target="_blank" rel="noopener">词典框架设计及成品展示</a></li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/45014771" target="_blank" rel="noopener">本地词典的设计</a></li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/45099867" target="_blank" rel="noopener">开始菜单的设计</a></li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/38758051" target="_blank" rel="noopener">无边框窗口的缩放与拖动</a></li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/38817595" target="_blank" rel="noopener">无边框窗口的拖动</a></li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/45223931" target="_blank" rel="noopener">界面美化设计</a></li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/45484803" target="_blank" rel="noopener">调用网络API</a></li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/45932429" target="_blank" rel="noopener">用户登录及API调用的实现</a></li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/45932429" target="_blank" rel="noopener">JSON数据解析</a></li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/23294533" target="_blank" rel="noopener">国际音标的显示</a></li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/38237203" target="_blank" rel="noopener">系统托盘的显示</a></li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/38306803" target="_blank" rel="noopener">调用讲述人</a></li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/38555787" target="_blank" rel="noopener">音频播放</a></li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/38689745" target="_blank" rel="noopener">自动补全功能</a></li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/38734201" target="_blank" rel="noopener">HTML特殊字符及正则表达式</a></li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/46563781" target="_blank" rel="noopener">后序</a></li>
</ol>
<p><strong>作品下载地址（发布版）</strong>：<a href="http://download.csdn.net/detail/tengweitw/8548767" target="_blank" rel="noopener">http://download.csdn.net/detail/tengweitw/8548767</a></p>
<p><strong>作品下载地址（绿色版）</strong>：<a href="http://download.csdn.net/detail/tengweitw/8830495" target="_blank" rel="noopener">http://download.csdn.net/detail/tengweitw/8830495</a></p>
<p><strong>源码下载地址</strong>：<a href="http://download.csdn.net/detail/tengweitw/8830503" target="_blank" rel="noopener">http://download.csdn.net/detail/tengweitw/8830503</a></p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>Qt Coding</tag>
      </tags>
  </entry>
  <entry>
    <title>【Qt编程】基于Qt的词典开发系列音频播放</title>
    <url>/2014/08/14/%5B20140814%5D/</url>
    <content><![CDATA[<p>在上一篇文章中，我是在Qt4平台上调用本地发音的，后来由于用到JSON解析，就将平台转到了Qt5，因为Qt5自带解析JSON的类。然后发现上一篇文章的方法无法运行，当然网上可以找到解决方法，我在这里直接调用Qt自带的类进行网络音频播放和本地播放。<strong>比较适用于单词的网上发音和无网情况下的本地发音，而不用将音频文件下载下来，占用太多内存。</strong></p>
<a id="more"></a>
<p>为了简便起见，工程里只有一个main.cpp文件，不要忘了在.pro文件中加入下面两行：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">QT +=  multimedia</span><br><span class="line">CONFIG += qaxcontainer</span><br></pre></td></tr></table></figure>
<p><strong>下面给出main.cpp文件：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"widget.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;QtMultimedia/QMediaPlayer&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;QUrl&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;ActiveQt/QAxObject&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line">    </span><br><span class="line">    QMediaPlayer *player = <span class="keyword">new</span> QMediaPlayer();</span><br><span class="line">    player-&gt;setMedia(QUrl(<span class="string">"http://media.shanbay.com/audio/us/hello.mp3"</span>));</span><br><span class="line">    player-&gt;play();</span><br><span class="line"></span><br><span class="line">    QAxObject *speech= <span class="keyword">new</span> QAxObject();</span><br><span class="line">    speech-&gt;setControl(<span class="string">"SAPI.SpVoice"</span>);</span><br><span class="line">    speech-&gt;dynamicCall(<span class="string">"Speak(QString,uint)"</span>,<span class="string">"good"</span>,<span class="number">1</span>);<span class="comment">//这里换成中文也可以</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a.exec();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行后，你会发现本地发音肯定没网络发音好，本地发音是电脑发音，这也是缺点之一。</p>
<p><strong>基于Qt的词典开发系列</strong></p>
<ol>
<li><a href="http://blog.csdn.net/tengweitw/article/details/44757875" target="_blank" rel="noopener">词典框架设计及成品展示</a></li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/45014771" target="_blank" rel="noopener">本地词典的设计</a></li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/45099867" target="_blank" rel="noopener">开始菜单的设计</a></li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/38758051" target="_blank" rel="noopener">无边框窗口的缩放与拖动</a></li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/38817595" target="_blank" rel="noopener">无边框窗口的拖动</a></li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/45223931" target="_blank" rel="noopener">界面美化设计</a></li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/45484803" target="_blank" rel="noopener">调用网络API</a></li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/45932429" target="_blank" rel="noopener">用户登录及API调用的实现</a></li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/45932429" target="_blank" rel="noopener">JSON数据解析</a></li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/23294533" target="_blank" rel="noopener">国际音标的显示</a></li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/38237203" target="_blank" rel="noopener">系统托盘的显示</a></li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/38306803" target="_blank" rel="noopener">调用讲述人</a></li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/38555787" target="_blank" rel="noopener">音频播放</a></li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/38689745" target="_blank" rel="noopener">自动补全功能</a></li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/38734201" target="_blank" rel="noopener">HTML特殊字符及正则表达式</a></li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/46563781" target="_blank" rel="noopener">后序</a></li>
</ol>
<p><strong>作品下载地址（发布版）</strong>：<a href="http://download.csdn.net/detail/tengweitw/8548767" target="_blank" rel="noopener">http://download.csdn.net/detail/tengweitw/8548767</a></p>
<p><strong>作品下载地址（绿色版）</strong>：<a href="http://download.csdn.net/detail/tengweitw/8830495" target="_blank" rel="noopener">http://download.csdn.net/detail/tengweitw/8830495</a></p>
<p><strong>源码下载地址</strong>：<a href="http://download.csdn.net/detail/tengweitw/8830503" target="_blank" rel="noopener">http://download.csdn.net/detail/tengweitw/8830503</a></p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>Qt Coding</tag>
      </tags>
  </entry>
  <entry>
    <title>【Qt编程】基于Qt的词典开发系列调用讲述人</title>
    <url>/2014/07/30/%5B20140730%5D/</url>
    <content><![CDATA[<p>​    我们知道，win7系统自带有讲述人，即可以机器读出当前内容，具体可以将电脑锁定，然后点击左下角的按钮即可。之前在用Matlab写扫雷游戏的时候，也曾经调用过讲述人来进行游戏的语音提示。<strong>具体的Matlab脚本文件如下：</strong></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">sp=actxserver('SAPI.SpVoice');</span><br><span class="line">sp.Speak('你好，欢迎来到西安电子科技大学！Hello,Welcome to XD University!')</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>Qt调用讲述人，需要使用专门的类，具体可以参考<a href="http://lynxline.com/qtspeech-say-hello-world一文，文中大致介绍了该类的使用方法。下面我就通过使用该类来实现讲述人的调用。" target="_blank" rel="noopener">http://lynxline.com/qtspeech-say-hello-world  </a> 一文，文中大致介绍了该类的使用方法。下面我就通过使用该类来实现讲述人的调用。</p>
<p>  首先建立一个dialog类型的gui项目，将上面所说的类QtSpeech类的头文件speech.h和源文件speech.cpp添加到工程中，<strong>这样项目中就有5个文件</strong>：dialog.h、speech.h、main.cpp、dialog.cpp、speech.cpp。当然还有界面文件dialog.ui。在界面文件中<strong>添加QTextEdit控件</strong>用于输入你要读取的文字，然后在其槽函数中添加QtSpeech的发音功能，<strong>添加QPushButton控件</strong>来控制发音。<strong>具体的各个文件源代码如下：</strong></p>
<p><strong>1、dialog.h</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> DIALOG_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DIALOG_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QDialog&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"speech.h"</span></span></span><br><span class="line"><span class="keyword">namespace</span> Ui &#123;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dialog</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dialog</span> :</span> <span class="keyword">public</span> QDialog</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Dialog</span><span class="params">(QWidget *parent = <span class="number">0</span>)</span></span>;</span><br><span class="line">    ~Dialog();</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span> slots:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">on_pushButton_clicked</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Ui::Dialog *ui;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// DIALOG_H</span></span></span><br></pre></td></tr></table></figure>
<p><strong>2、speech.h</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> SPEECH_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SPEECH_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QObject&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QtSpeech</span> :</span> <span class="keyword">public</span> QObject &#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 处理异常情况</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Error</span> &#123;</span> QString msg; Error(QString s):msg(s) &#123;&#125; &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">InitError</span> :</span> Error &#123; InitError(QString s):Error(s) &#123;&#125; &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LogicError</span> :</span> Error &#123; LogicError(QString s):Error(s) &#123;&#125; &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CloseError</span> :</span> Error &#123; CloseError(QString s):Error(s) &#123;&#125; &#125;;</span><br><span class="line">    <span class="comment">//定义数据类型</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">VoiceName</span> &#123;</span> QString id; QString name; &#125;;</span><br><span class="line">    <span class="keyword">typedef</span> QList&lt;VoiceName&gt; VoiceNames;</span><br><span class="line">    <span class="comment">//定义构造函数</span></span><br><span class="line">    QtSpeech(QObject * parent);</span><br><span class="line">    QtSpeech(VoiceName n = VoiceName(), QObject * parent =<span class="number">0L</span>);</span><br><span class="line">    <span class="keyword">virtual</span> ~QtSpeech();</span><br><span class="line">    <span class="function"><span class="keyword">const</span> VoiceName &amp; <span class="title">name</span><span class="params">()</span> <span class="keyword">const</span></span>; <span class="comment">//要读的内容</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> VoiceNames <span class="title">voices</span><span class="params">()</span></span>;     <span class="comment">//要读的内容</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">say</span><span class="params">(QString)</span> <span class="keyword">const</span></span>;                                    <span class="comment">//同步发音</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">tell</span><span class="params">(QString)</span> <span class="keyword">const</span></span>;                                   <span class="comment">//异步发音</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">tell</span><span class="params">(QString, QObject * obj, <span class="keyword">const</span> <span class="keyword">char</span> * slot)</span> <span class="keyword">const</span></span>; <span class="comment">//发音结束时，有停顿</span></span><br><span class="line">    <span class="comment">/*******************/</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pause</span><span class="params">(<span class="keyword">void</span>)</span> <span class="keyword">const</span></span>;<span class="comment">//暂停</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">resume</span><span class="params">(<span class="keyword">void</span>)</span> <span class="keyword">const</span></span>;<span class="comment">//从暂停中恢复</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">stop</span><span class="params">(<span class="keyword">void</span>)</span> <span class="keyword">const</span></span>;<span class="comment">//停止发音</span></span><br><span class="line">    <span class="comment">/******************/</span></span><br><span class="line">signals:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">finished</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">timerEvent</span><span class="params">(QTimerEvent *)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Private</span>;</span></span><br><span class="line">    Private * d;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// SPEECH_H</span></span></span><br></pre></td></tr></table></figure>
<p><strong>3、main.cpp</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"dialog.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line">    Dialog dlg;</span><br><span class="line">    dlg.show();</span><br><span class="line">    <span class="keyword">return</span> app.exec();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>4、dialog.cpp</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"dialog.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ui_dialog.h"</span></span></span><br><span class="line">Dialog::Dialog(QWidget *parent) :</span><br><span class="line">    QDialog(parent),</span><br><span class="line">    ui(<span class="keyword">new</span> Ui::Dialog)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;setupUi(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">Dialog::~Dialog()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> Dialog::on_pushButton_clicked()</span><br><span class="line">&#123;</span><br><span class="line">    QtSpeech *speaker = <span class="keyword">new</span> QtSpeech(<span class="keyword">this</span>);</span><br><span class="line">    speaker-&gt;tell(ui-&gt;textEdit-&gt;toPlainText(),speaker,SLOT(onSpeechFinished()));</span><br><span class="line">   <span class="comment">// speaker.stop();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>5、speech.cpp</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"speech.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QString&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QPointer&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QList&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QTimerEvent&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> UNICODE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sapi.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sphelper.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;comdef.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UNICODE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windowsx.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;commctrl.h&gt;</span></span></span><br><span class="line"><span class="comment">// some defines for throwing exceptions</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Where QString(<span class="meta-string">"%1:%2:"</span>).arg(__FILE__).arg(__LINE__)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SysCall(x,e) &#123;\</span></span><br><span class="line">    HRESULT hr = x;\</span><br><span class="line">    <span class="keyword">if</span> (FAILED(hr)) &#123;\</span><br><span class="line">        QString msg = #e;\</span><br><span class="line">        msg += <span class="string">":"</span>+QString(__FILE__);\</span><br><span class="line">        msg += <span class="string">":"</span>+QString::number(__LINE__)+<span class="string">":"</span>+#x+<span class="string">":"</span>;\</span><br><span class="line">        msg += _com_error(hr).ErrorMessage();\</span><br><span class="line">        <span class="keyword">throw</span> e(msg);\</span><br><span class="line">    &#125;\</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// internal data</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QtSpeech</span>:</span>:Private &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Private()</span><br><span class="line">        :onFinishSlot(<span class="number">0L</span>),waitingFinish(<span class="literal">false</span>) &#123;&#125;</span><br><span class="line">    VoiceName name;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> QString VoiceId;</span><br><span class="line">    <span class="keyword">typedef</span> QPointer&lt;QtSpeech&gt; Ptr;</span><br><span class="line">    <span class="keyword">static</span> QList&lt;Ptr&gt; ptrs;</span><br><span class="line">    CComPtr&lt;ISpVoice&gt; voice;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> * onFinishSlot;</span><br><span class="line">    QPointer&lt;QObject&gt; onFinishObj;</span><br><span class="line">    <span class="keyword">bool</span> waitingFinish;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">WCHAR_Holder</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        WCHAR * w;</span><br><span class="line">        WCHAR_Holder(QString s)</span><br><span class="line">            :w(<span class="number">0</span>) &#123;</span><br><span class="line">            w = <span class="keyword">new</span> WCHAR[s.length()+<span class="number">1</span>];</span><br><span class="line">            s.toWCharArray(w);</span><br><span class="line">            w[s.length()] =<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ~WCHAR_Holder() &#123; <span class="keyword">delete</span>[] w; &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> QString QtSpeech::Private::VoiceId = QString(<span class="string">"win:%1"</span>);</span><br><span class="line">QList&lt;QtSpeech::Private::Ptr&gt; QtSpeech::Private::ptrs = QList&lt;QtSpeech::Private::Ptr&gt;();</span><br><span class="line"><span class="comment">//类的定义</span></span><br><span class="line">QtSpeech::QtSpeech(QObject * parent)</span><br><span class="line">    :QObject(parent), d(<span class="keyword">new</span> Private)</span><br><span class="line">&#123;</span><br><span class="line">    CoInitialize(<span class="literal">NULL</span>);</span><br><span class="line">    SysCall( d-&gt;voice.CoCreateInstance( CLSID_SpVoice ), InitError);</span><br><span class="line">    VoiceName n;</span><br><span class="line">    WCHAR * w_id = <span class="number">0L</span>;</span><br><span class="line">    WCHAR * w_name = <span class="number">0L</span>;</span><br><span class="line">    CComPtr&lt;ISpObjectToken&gt; voice;</span><br><span class="line">    SysCall( d-&gt;voice-&gt;GetVoice(&amp;voice), InitError);</span><br><span class="line">    SysCall( SpGetDescription(voice, &amp;w_name), InitError);</span><br><span class="line">    SysCall( voice-&gt;GetId(&amp;w_id), InitError);</span><br><span class="line">    n.name = QString::fromWCharArray(w_name);</span><br><span class="line">    n.id = QString::fromWCharArray(w_id);</span><br><span class="line">    voice.Release();</span><br><span class="line">    <span class="keyword">if</span> (n.id.isEmpty())</span><br><span class="line">        <span class="keyword">throw</span> InitError(Where+<span class="string">"No default voice in system"</span>);</span><br><span class="line">    d-&gt;name = n;</span><br><span class="line">    d-&gt;ptrs &lt;&lt; <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">QtSpeech::QtSpeech(VoiceName n, QObject * parent)</span><br><span class="line">    :QObject(parent), d(<span class="keyword">new</span> Private)</span><br><span class="line">&#123;</span><br><span class="line">    ULONG count = <span class="number">0</span>;</span><br><span class="line">    CComPtr&lt;IEnumSpObjectTokens&gt; voices;</span><br><span class="line">    CoInitialize(<span class="literal">NULL</span>);</span><br><span class="line">    SysCall( d-&gt;voice.CoCreateInstance( CLSID_SpVoice ), InitError);</span><br><span class="line">    <span class="keyword">if</span> (n.id.isEmpty()) &#123;</span><br><span class="line">        WCHAR * w_id = <span class="number">0L</span>;</span><br><span class="line">        WCHAR * w_name = <span class="number">0L</span>;</span><br><span class="line">        CComPtr&lt;ISpObjectToken&gt; voice;</span><br><span class="line">        SysCall( d-&gt;voice-&gt;GetVoice(&amp;voice), InitError);</span><br><span class="line">        SysCall( SpGetDescription(voice, &amp;w_name), InitError);</span><br><span class="line">        SysCall( voice-&gt;GetId(&amp;w_id), InitError);</span><br><span class="line">        n.name = QString::fromWCharArray(w_name);</span><br><span class="line">        n.id = QString::fromWCharArray(w_id);</span><br><span class="line">        voice.Release();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        SysCall( SpEnumTokens(SPCAT_VOICES, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;voices), InitError);</span><br><span class="line">        SysCall( voices-&gt;GetCount(&amp;count), InitError);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">0</span>; i&lt; count; ++i) &#123;</span><br><span class="line">            WCHAR * w_id = <span class="number">0L</span>;</span><br><span class="line">            CComPtr&lt;ISpObjectToken&gt; voice;</span><br><span class="line">            SysCall( voices-&gt;Next( <span class="number">1</span>, &amp;voice, <span class="literal">NULL</span> ), InitError);</span><br><span class="line">            SysCall( voice-&gt;GetId(&amp;w_id), InitError);</span><br><span class="line">            QString id = QString::fromWCharArray(w_id);</span><br><span class="line">            <span class="keyword">if</span> (id == n.id) d-&gt;voice-&gt;SetVoice(voice);</span><br><span class="line">            voice.Release();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n.id.isEmpty())</span><br><span class="line">        <span class="keyword">throw</span> InitError(Where+<span class="string">"No default voice in system"</span>);</span><br><span class="line">    d-&gt;name = n;</span><br><span class="line">    d-&gt;ptrs &lt;&lt; <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">QtSpeech::~QtSpeech()</span><br><span class="line">&#123;</span><br><span class="line">    d-&gt;ptrs.removeAll(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">delete</span> d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> QtSpeech::VoiceName &amp; QtSpeech::name() <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> d-&gt;name;</span><br><span class="line">&#125;</span><br><span class="line">QtSpeech::VoiceNames QtSpeech::voices()</span><br><span class="line">&#123;</span><br><span class="line">    VoiceNames vs;</span><br><span class="line">    ULONG count = <span class="number">0</span>;</span><br><span class="line">    CComPtr&lt;IEnumSpObjectTokens&gt; voices;</span><br><span class="line">    CoInitialize(<span class="literal">NULL</span>);</span><br><span class="line">    SysCall( SpEnumTokens(SPCAT_VOICES, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;voices), LogicError);</span><br><span class="line">    SysCall( voices-&gt;GetCount(&amp;count), LogicError);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt; count; ++i) &#123;</span><br><span class="line">        WCHAR * w_id = <span class="number">0L</span>;</span><br><span class="line">        WCHAR * w_name = <span class="number">0L</span>;</span><br><span class="line">        CComPtr&lt;ISpObjectToken&gt; voice;</span><br><span class="line">        SysCall( voices-&gt;Next( <span class="number">1</span>, &amp;voice, <span class="literal">NULL</span> ), LogicError);</span><br><span class="line">        SysCall( SpGetDescription(voice, &amp;w_name), LogicError);</span><br><span class="line">        SysCall( voice-&gt;GetId(&amp;w_id), LogicError);</span><br><span class="line">        QString id = QString::fromWCharArray(w_id);</span><br><span class="line">        QString name = QString::fromWCharArray(w_name);</span><br><span class="line">        VoiceName n = &#123; id, name &#125;;</span><br><span class="line">        vs &lt;&lt; n;</span><br><span class="line">        voice.Release();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vs;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> QtSpeech::tell(QString text) <span class="keyword">const</span> &#123;</span><br><span class="line">    tell(text, <span class="number">0L</span>,<span class="number">0L</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> QtSpeech::tell(QString text, QObject * obj, <span class="keyword">const</span> <span class="keyword">char</span> * slot) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (d-&gt;waitingFinish)</span><br><span class="line">        <span class="keyword">throw</span> LogicError(Where+<span class="string">"Already waiting to finish speech"</span>);</span><br><span class="line">    d-&gt;onFinishObj = obj;</span><br><span class="line">    d-&gt;onFinishSlot = slot;</span><br><span class="line">    <span class="keyword">if</span> (obj &amp;&amp; slot)</span><br><span class="line">        connect(<span class="keyword">const_cast</span>&lt;QtSpeech *&gt;(<span class="keyword">this</span>), SIGNAL(finished()), obj, slot);</span><br><span class="line">    d-&gt;waitingFinish = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">const_cast</span>&lt;QtSpeech *&gt;(<span class="keyword">this</span>)-&gt;startTimer(<span class="number">100</span>);</span><br><span class="line">    Private::<span class="function">WCHAR_Holder <span class="title">w_text</span><span class="params">(text)</span></span>;</span><br><span class="line">    SysCall( d-&gt;voice-&gt;Speak( w_text.w, SPF_ASYNC | SPF_IS_NOT_XML, <span class="number">0</span>), LogicError);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> QtSpeech::say(QString text) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    Private::<span class="function">WCHAR_Holder <span class="title">w_text</span><span class="params">(text)</span></span>;</span><br><span class="line">    SysCall( d-&gt;voice-&gt;Speak( w_text.w, SPF_IS_NOT_XML, <span class="number">0</span>), LogicError);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> QtSpeech::timerEvent(QTimerEvent * te)</span><br><span class="line">&#123;</span><br><span class="line">    QObject::timerEvent(te);</span><br><span class="line">    <span class="keyword">if</span> (d-&gt;waitingFinish) &#123;</span><br><span class="line">        SPVOICESTATUS es;</span><br><span class="line">        d-&gt;voice-&gt;GetStatus( &amp;es, <span class="literal">NULL</span> );</span><br><span class="line">        <span class="keyword">if</span> (es.dwRunningState == SPRS_DONE) &#123;</span><br><span class="line">            d-&gt;waitingFinish = <span class="literal">false</span>;</span><br><span class="line">            killTimer(te-&gt;timerId());</span><br><span class="line">            finished();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/************************/</span></span><br><span class="line"><span class="keyword">void</span> QtSpeech::pause(<span class="keyword">void</span>) <span class="keyword">const</span>&#123;<span class="comment">//暂停</span></span><br><span class="line">    SysCall( d-&gt;voice-&gt;Pause(), LogicError);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> QtSpeech::resume() <span class="keyword">const</span>&#123;<span class="comment">//恢复</span></span><br><span class="line">    SysCall(d-&gt;voice-&gt;Resume(), LogicError);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> QtSpeech::stop() <span class="keyword">const</span>&#123;<span class="comment">//停止</span></span><br><span class="line">    SysCall(d-&gt;voice-&gt;Speak(<span class="literal">NULL</span>, SPF_PURGEBEFORESPEAK, <span class="number">0</span>), LogicError)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/***************************/</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br></pre></td></tr></table></figure>
<p><strong>程序结果如下：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20140730/20140730_fig001.jpg" width="500" height="200" title="图1" alt="图1" ></p>
<p><strong>基于Qt的词典开发系列</strong></p>
<ol>
<li><a href="http://blog.csdn.net/tengweitw/article/details/44757875" target="_blank" rel="noopener">词典框架设计及成品展示</a></li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/45014771" target="_blank" rel="noopener">本地词典的设计</a></li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/45099867" target="_blank" rel="noopener">开始菜单的设计</a></li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/38758051" target="_blank" rel="noopener">无边框窗口的缩放与拖动</a></li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/38817595" target="_blank" rel="noopener">无边框窗口的拖动</a></li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/45223931" target="_blank" rel="noopener">界面美化设计</a></li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/45484803" target="_blank" rel="noopener">调用网络API</a></li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/45932429" target="_blank" rel="noopener">用户登录及API调用的实现</a></li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/45932429" target="_blank" rel="noopener">JSON数据解析</a></li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/23294533" target="_blank" rel="noopener">国际音标的显示</a></li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/38237203" target="_blank" rel="noopener">系统托盘的显示</a></li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/38306803" target="_blank" rel="noopener">调用讲述人</a></li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/38555787" target="_blank" rel="noopener">音频播放</a></li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/38689745" target="_blank" rel="noopener">自动补全功能</a></li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/38734201" target="_blank" rel="noopener">HTML特殊字符及正则表达式</a></li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/46563781" target="_blank" rel="noopener">后序</a></li>
</ol>
<p><strong>作品下载地址（发布版）</strong>：<a href="http://download.csdn.net/detail/tengweitw/8548767" target="_blank" rel="noopener">http://download.csdn.net/detail/tengweitw/8548767</a></p>
<p><strong>作品下载地址（绿色版）</strong>：<a href="http://download.csdn.net/detail/tengweitw/8830495" target="_blank" rel="noopener">http://download.csdn.net/detail/tengweitw/8830495</a></p>
<p><strong>源码下载地址</strong>：<a href="http://download.csdn.net/detail/tengweitw/8830503" target="_blank" rel="noopener">http://download.csdn.net/detail/tengweitw/8830503</a></p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>Qt Coding</tag>
      </tags>
  </entry>
  <entry>
    <title>【Qt编程】基于Qt的词典开发系列系统托盘的显示</title>
    <url>/2014/07/28/%5B20140728%5D/</url>
    <content><![CDATA[<p>  本文主要讨论Qt中的系统托盘的设置。系统托盘想必大家都不陌生，最常用的就是QQ。系统托盘以简单、小巧的形式能让人们较快的打开软件。废话不多说，下面开始具体介绍。</p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20140728/20140728_fig001.jpg" width="300" height="40" title="图1" alt="图1" ></p>
<a id="more"></a>
<p>  首先，新建一个Qt Gui项目，类型选择QMainWindow，类名也选择默认的mainwindow。这时，<strong>工程项目中就有3个文件(界面文件不用管)</strong>：mainwindow.h mainwindow.cpp main.cpp。然后，<strong>分别修改3个文件如下</strong>：</p>
<p><strong>1、mainwindow.h</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> MAINWINDOW_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAINWINDOW_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QMainWindow&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;QSystemTrayIcon&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;QMenu&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;QCloseEvent&gt;</span></span></span><br><span class="line"><span class="keyword">namespace</span> Ui &#123;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainWindow</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainWindow</span> :</span> <span class="keyword">public</span> QMainWindow</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">MainWindow</span><span class="params">(QWidget *parent = <span class="number">0</span>)</span></span>;</span><br><span class="line">    ~MainWindow();</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Ui::MainWindow *ui;</span><br><span class="line">    QSystemTrayIcon *trayicon;<span class="comment">//将系统托盘及菜单定义为窗口的私有成员</span></span><br><span class="line">    QMenu *trayiconMenu;</span><br><span class="line">signals:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">exitsignal</span><span class="params">()</span></span>;<span class="comment">//发射程序退出信号</span></span><br><span class="line"><span class="keyword">private</span> slots:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onSystemTrayIconClicked</span><span class="params">(QSystemTrayIcon::ActivationReason reason)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">exit</span><span class="params">()</span></span>;<span class="comment">//与退出按钮对应的槽</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">closeEvent</span><span class="params">(QCloseEvent *event)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// MAINWINDOW_H</span></span></span><br></pre></td></tr></table></figure>
<p><strong>2、mainwindow.cpp</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mainwindow.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ui_mainwindow.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;QtGui&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;QEvent&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;QDebug&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;QAction&gt;</span></span></span><br><span class="line">MainWindow::MainWindow(QWidget *parent) :</span><br><span class="line">    QMainWindow(parent),</span><br><span class="line">    ui(<span class="keyword">new</span> Ui::MainWindow)</span><br><span class="line">&#123;</span><br><span class="line">     ui-&gt;setupUi(<span class="keyword">this</span>);</span><br><span class="line">    trayicon=<span class="keyword">new</span> QSystemTrayIcon(<span class="keyword">this</span>);</span><br><span class="line">    QAction *quit=<span class="keyword">new</span> QAction(tr(<span class="string">"exit"</span>), <span class="keyword">this</span>);</span><br><span class="line">    <span class="function">QIcon <span class="title">icon</span><span class="params">(<span class="string">"D:/studytool/Qt/workspace/myTray/tengweitw.jpg"</span>)</span></span>;<span class="comment">//注意修改这里的图片目录</span></span><br><span class="line">    setWindowIcon(icon);</span><br><span class="line"><span class="comment">//    setMinimumSize(200,100);//窗口最大化和最小化一样大小。所以窗口不能放大也不能缩小</span></span><br><span class="line"><span class="comment">//    setMaximumSize(200,100);</span></span><br><span class="line">    trayiconMenu=<span class="keyword">new</span> QMenu(<span class="keyword">this</span>);</span><br><span class="line">    trayiconMenu-&gt;addAction(quit);<span class="comment">//这里可以添加多个菜单</span></span><br><span class="line">   <span class="comment">// trayiconMenu-&gt;addSeparator();</span></span><br><span class="line">    trayicon-&gt;setIcon(icon);</span><br><span class="line">    trayicon-&gt;setToolTip(tr(<span class="string">"我爱记单词"</span>));</span><br><span class="line">    trayicon-&gt;setContextMenu(trayiconMenu);</span><br><span class="line">    connect(quit,SIGNAL(triggered(<span class="keyword">bool</span>)),<span class="keyword">this</span>,SLOT(<span class="built_in">exit</span>()));</span><br><span class="line">    connect(trayicon, SIGNAL(activated(QSystemTrayIcon::ActivationReason)), <span class="keyword">this</span>, SLOT(onSystemTrayIconClicked(QSystemTrayIcon::ActivationReason)));</span><br><span class="line">    trayicon-&gt;show();</span><br><span class="line">&#125;</span><br><span class="line">MainWindow::~MainWindow()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//下面处理不同情况下，单击托盘图标的操作</span></span><br><span class="line"><span class="keyword">void</span> MainWindow::onSystemTrayIconClicked(QSystemTrayIcon::ActivationReason reason)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">switch</span>(reason)</span><br><span class="line">  &#123;</span><br><span class="line">  <span class="comment">//单击</span></span><br><span class="line">  <span class="keyword">case</span> QSystemTrayIcon::Trigger:</span><br><span class="line">    <span class="comment">//  qDebug()&lt;&lt;this-&gt;isEnabled();</span></span><br><span class="line">  <span class="comment">//双击</span></span><br><span class="line"> <span class="comment">//     flag=!flag;</span></span><br><span class="line"> <span class="comment">// case QSystemTrayIcon::DoubleClick:</span></span><br><span class="line">      <span class="comment">//恢复窗口显示</span></span><br><span class="line">      <span class="keyword">if</span>(<span class="keyword">this</span>-&gt;isVisible())<span class="comment">//判断窗口是否可见</span></span><br><span class="line">      &#123;</span><br><span class="line">          <span class="keyword">if</span>(<span class="keyword">this</span>-&gt;isMinimized())<span class="comment">//窗口是否是最小化</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">this</span>-&gt;setWindowFlags(Qt::WindowStaysOnTopHint);<span class="comment">//置顶</span></span><br><span class="line">            <span class="comment">//  this-&gt;setWindowFlags(Qt::Widget);//取消置顶</span></span><br><span class="line">                <span class="keyword">this</span>-&gt;setWindowState(Qt::WindowActive);</span><br><span class="line">                <span class="keyword">this</span>-&gt;setGeometry(<span class="keyword">this</span>-&gt;geometry());<span class="comment">//使得每次显示窗口为上次的位置</span></span><br><span class="line">                <span class="keyword">this</span>-&gt;show();</span><br><span class="line">            &#125;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">this</span>-&gt;hide();</span><br><span class="line">      &#125;</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">          <span class="keyword">this</span>-&gt;setWindowFlags(Qt::WindowStaysOnTopHint);<span class="comment">//置顶</span></span><br><span class="line">            <span class="comment">//  this-&gt;setWindowFlags(Qt::Widget);//取消置顶</span></span><br><span class="line">                <span class="keyword">this</span>-&gt;setWindowState(Qt::WindowActive);</span><br><span class="line">                <span class="keyword">this</span>-&gt;setGeometry(<span class="keyword">this</span>-&gt;geometry());</span><br><span class="line">                <span class="keyword">this</span>-&gt;show();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> MainWindow::<span class="built_in">exit</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">emit <span class="title">exitsignal</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> MainWindow::closeEvent(QCloseEvent *event)<span class="comment">//处理窗口关闭事件</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(trayicon-&gt;isVisible())</span><br><span class="line">  &#123;</span><br><span class="line">      hide();</span><br><span class="line">      <span class="keyword">this</span>-&gt;close();</span><br><span class="line">      event-&gt;ignore();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>3、main.cpp</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QtGui/QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mainwindow.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;QTextCodec&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line">    QTextCodec::setCodecForTr(QTextCodec::codecForLocale());<span class="comment">//防止中文乱码</span></span><br><span class="line">    MainWindow w;</span><br><span class="line">    w.show();</span><br><span class="line">    QObject::connect(&amp;w,SIGNAL(exitsignal()),&amp;a,SLOT(quit()));<span class="comment">//将退出按钮与退出函数绑定</span></span><br><span class="line">    <span class="keyword">return</span> a.exec();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面程序的主要部分都给了注释，在这就不一一分析了。运行结果如下：<br>1、界面如下（这不是我们关注的地方）：</p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20140728/20140728_fig002.jpg" width="400" height="340" title="图2" alt="图2" ></p>
<p>2、托盘显示如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20140728/20140728_fig003.jpg" width="300" height="40" title="图3" alt="图3" ></p>
<p>3、托盘的菜单显示如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20140728/20140728_fig004.jpg" width="300" height="50" title="图4" alt="图4" ></p>
<p><strong>基于Qt的词典开发系列</strong></p>
<ol>
<li><a href="http://blog.csdn.net/tengweitw/article/details/44757875" target="_blank" rel="noopener">词典框架设计及成品展示</a></li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/45014771" target="_blank" rel="noopener">本地词典的设计</a></li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/45099867" target="_blank" rel="noopener">开始菜单的设计</a></li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/38758051" target="_blank" rel="noopener">无边框窗口的缩放与拖动</a></li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/38817595" target="_blank" rel="noopener">无边框窗口的拖动</a></li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/45223931" target="_blank" rel="noopener">界面美化设计</a></li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/45484803" target="_blank" rel="noopener">调用网络API</a></li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/45932429" target="_blank" rel="noopener">用户登录及API调用的实现</a></li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/45932429" target="_blank" rel="noopener">JSON数据解析</a></li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/23294533" target="_blank" rel="noopener">国际音标的显示</a></li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/38237203" target="_blank" rel="noopener">系统托盘的显示</a></li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/38306803" target="_blank" rel="noopener">调用讲述人</a></li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/38555787" target="_blank" rel="noopener">音频播放</a></li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/38689745" target="_blank" rel="noopener">自动补全功能</a></li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/38734201" target="_blank" rel="noopener">HTML特殊字符及正则表达式</a></li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/46563781" target="_blank" rel="noopener">后序</a></li>
</ol>
<p><strong>作品下载地址（发布版）</strong>：<a href="http://download.csdn.net/detail/tengweitw/8548767" target="_blank" rel="noopener">http://download.csdn.net/detail/tengweitw/8548767</a></p>
<p><strong>作品下载地址（绿色版）</strong>：<a href="http://download.csdn.net/detail/tengweitw/8830495" target="_blank" rel="noopener">http://download.csdn.net/detail/tengweitw/8830495</a></p>
<p><strong>源码下载地址</strong>：<a href="http://download.csdn.net/detail/tengweitw/8830503" target="_blank" rel="noopener">http://download.csdn.net/detail/tengweitw/8830503</a></p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>Qt Coding</tag>
      </tags>
  </entry>
  <entry>
    <title>【LaTeX排版】LaTeX论文模版</title>
    <url>/2014/06/28/%5B20140628%5D/</url>
    <content><![CDATA[<p>本文是对前面LaTeX论文排版文章的总结。前面的几篇文章是分别从论文的几个方面来讲述LaTeX的排版问题，这里综合了前面的内容，<strong>给出了论文排版的模版。</strong></p>
<a id="more"></a>
<p><strong>模版的使用：</strong></p>
<p><strong>1、首先建立一个main.tex文件，该文件用于管理论文的整体构架，文件代码为：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\documentclass[a4paper,12pt]&#123;book&#125;</span><br><span class="line">\usepackage&#123;ctexcap&#125;</span><br><span class="line">\usepackage&#123;amsmath&#125;</span><br><span class="line">\usepackage&#123;graphicx&#125;</span><br><span class="line">\usepackage&#123;fancyhdr&#125;</span><br><span class="line">\usepackage[super,square,comma,sort&amp;compress]&#123;natbib&#125;%设置参考文献的格式</span><br><span class="line">%%%设置页边距</span><br><span class="line">\usepackage&#123;geometry&#125;</span><br><span class="line">\geometry&#123;left&#x3D;4cm,right&#x3D;2cm,top&#x3D;3cm,bottom&#x3D;2cm&#125;</span><br><span class="line">\newcommand&#123;\tabincell&#125;[2]&#123;\begin&#123;tabular&#125;&#123;@&#123;&#125;#1@&#123;&#125;&#125;#2\end&#123;tabular&#125;&#125;% 设置换行</span><br><span class="line">\graphicspath&#123;&#123;pics&#x2F;&#125;,&#123;figs&#x2F;&#125;&#125;</span><br><span class="line">\usepackage&#123;float&#125;%是图片悬浮</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">\usepackage&#123;bm&#125;</span><br><span class="line">\usepackage&#123;times&#125;</span><br><span class="line">\usepackage&#123;mathptmx&#125; %设置为罗马体</span><br><span class="line">\usepackage&#123;caption&#125;</span><br><span class="line">\captionsetup&#123;labelsep&#x3D;space&#125;</span><br><span class="line">%\usepackage[colorlinks,dvipdfm,  %电子版时使用这个包</span><br><span class="line">%            bookmarksopenlevel&#x3D;2,</span><br><span class="line">%            pdfpagemode&#x3D;UseNone,</span><br><span class="line">%            pdfstartview&#x3D;FitB,</span><br><span class="line">%            linkcolor&#x3D;black,</span><br><span class="line">%            citecolor&#x3D;blue,</span><br><span class="line">%            linkcolor&#x3D;black,</span><br><span class="line">%            hyperindex&#x3D;true,</span><br><span class="line">%            pagebackref&#x3D;true,</span><br><span class="line">%            CJKbookmarks&#x3D;true,</span><br><span class="line">%            colorlinks]&#123;hyperref&#125;</span><br><span class="line"></span><br><span class="line">\renewcommand&#123;\captionfont&#125;&#123;\zihao&#123;5&#125;\songti&#125;</span><br><span class="line">\renewcommand\theequation&#123;\thechapter-\arabic&#123;equation&#125;&#125;%公式编号</span><br><span class="line">\usepackage&#123;setspace&#125;%使用间距宏包</span><br><span class="line">\usepackage&#123;comment&#125;</span><br><span class="line">\linespread&#123;1.5&#125;</span><br><span class="line"></span><br><span class="line">\CTEXsetup[beforeskip&#x3D;&#123;0pt&#125;]&#123;chapter&#125;</span><br><span class="line">\CTEXsetup[nameformat&#x3D;&#123;\heiti\zihao&#123;3&#125;\centering&#125;]&#123;chapter&#125;%章标题格式</span><br><span class="line">\CTEXsetup[titleformat&#x3D;&#123;\heiti\zihao&#123;3&#125;\centering&#125;]&#123;chapter&#125;%章标题格式</span><br><span class="line">\CTEXsetup[format&#x3D;&#123;\songti\zihao&#123;4&#125;\centering&#125;]&#123;section&#125;% 节标题格式</span><br><span class="line">\CTEXsetup[format&#x3D;&#123;\songti\zihao&#123;-4&#125;&#125;]&#123;subsection&#125;%小节标题格式</span><br><span class="line">\CTEXsetup[format&#x3D;&#123;\songti\zihao&#123;-4&#125;&#125;]&#123;subsubsection&#125;%小节标题格式</span><br><span class="line">\usepackage&#123;titletoc&#125;</span><br><span class="line"></span><br><span class="line">\begin&#123;document&#125;\songti\zihao&#123;-4&#125;%设置正文字体格式</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">\pagenumbering&#123;Roman&#125;</span><br><span class="line"></span><br><span class="line">\include&#123;Abstract&#125;</span><br><span class="line">\songti\zihao&#123;-4&#125;</span><br><span class="line">\setcounter&#123;tocdepth&#125;&#123;2&#125;%设置目录深度</span><br><span class="line">\thispagestyle&#123;plain&#125;</span><br><span class="line">\titlecontents&#123;chapter&#125;</span><br><span class="line">              [0.0em]</span><br><span class="line">              &#123;\songti\zihao&#123;-4&#125;\bfseries\addvspace&#123;10bp minus 0bp&#125;&#125;  %\song</span><br><span class="line">              &#123;\thecontentslabel\hspace&#123;0.5em&#125;&#125;</span><br><span class="line">              &#123;&#125;</span><br><span class="line">              &#123;\normalfont\dotfill\textrm&#123;\contentspage[&#123;\bfseries\thecontentspage&#125;]&#125;&#125;</span><br><span class="line">\newgeometry&#123;bottom&#x3D;3cm,top&#x3D;3cm&#125;</span><br><span class="line">\tableofcontents</span><br><span class="line">\restoregeometry</span><br><span class="line">%\include&#123;chapter1&#125;</span><br><span class="line"></span><br><span class="line">%\include&#123;chapter2&#125;</span><br><span class="line">%\include&#123;chapter3&#125;</span><br><span class="line">%\include&#123;chapter4&#125;</span><br><span class="line">%\include&#123;chapter5&#125;</span><br><span class="line"></span><br><span class="line">%\include&#123;thanks&#125;</span><br><span class="line">%\include&#123;appendix&#125;</span><br><span class="line">%\include&#123;reference&#125;</span><br><span class="line"></span><br><span class="line">\end&#123;document&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的代码中，我将\include命令都给了注释，可以根据你论文的章节来去掉对应的%。比如说，我的论文有5章，还有致谢、附录和参考文献部分，则我需要将上面代码中include命令前的%去掉。同时，我需要新建chapter1.tex……chapter5.tex来编写1-5章的内容，thanks.tex对应致谢部分，appendix.tex对应附录部分，reference.tex对应参考文献部分。你可以根据实际情况来增、删、改相应的部分。</p>
<p><strong>2、对于每一章的内容，大体形式如下（以第一章chapter1.tex的框架为例）：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\chapter&#123;绪论&#125;</span><br><span class="line">\section&#123;研究背景及意义&#125;</span><br><span class="line">\subsection&#123;无线频谱的分配与利用&#125;</span><br><span class="line">\subsection&#123;提高频谱利用效率的方法&#125;</span><br><span class="line">\section&#123;认知无线电概述&#125;</span><br><span class="line">\subsection&#123;认知无线电的定义&#125;</span><br><span class="line">\subsection&#123;认知无线电的关键技术&#125;</span><br><span class="line">\subsection&#123;国内外认知无线电的研究现状&#125;</span><br><span class="line">\section&#123;论文内容及结构&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的每条命令语句下插入该标题的相关内容即可，<strong>效果显示如下图：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20140628/20140628_fig001.jpg" width="600" height="450" title="图1" alt="图1" ></p>
<p>  到现在为止，LaTeX论文排版终于告一段落了，虽然这些文章只讲解了一些简单的问题，但是用来排版毕设论文已经足够了。离毕设答辩都过去半个多月了，由于比较忙，到现在才刚将关于论文排版的文章写完。说也惭愧，英语学习停止了大概一个多月了，下个月要将其补回来。BTW，前天举办了毕业典礼，有幸得到校长颁发学位证的机会，今天学院又进行了授位仪式，是真的要毕业了。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>LaTeX Coding</tag>
      </tags>
  </entry>
  <entry>
    <title>【Matlab编程】Matlab让电脑失而复得</title>
    <url>/2014/06/25/%5B20140625%5D/</url>
    <content><![CDATA[<p>在学校经常有同学电脑失窃，大抵都是粗细大意。据说iPhone手机失窃后可以获取小偷的照片，从而将照片找到。现在用matlab写一个程序使得当小偷使用电脑上网时，电脑自动将电脑前面的人的照片发到你指定的邮箱。前提是你的电脑装有摄像头并且有网！先用下面代码测试你邮箱是否正确设置：</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clear</span><br><span class="line"> myaddress=<span class="string">'sender@qq.com'</span>;</span><br><span class="line"><span class="comment">%这里sender为你发邮箱的qq号，注意你的邮箱要已经提供SMTP服务，没有也没关系，qq邮箱会提醒设置设置的mypassword='password';%这里为你邮上面邮箱对应的密码（一般和QQ密码相同）</span></span><br><span class="line">to = <span class="string">'receiver@qq.com'</span>; <span class="comment">%这里为你要发送到的邮箱</span></span><br><span class="line">setpref(<span class="string">'Internet'</span>,<span class="string">'E_mail'</span>,myaddress);</span><br><span class="line">setpref(<span class="string">'Internet'</span>,<span class="string">'SMTP_Server'</span>,<span class="string">'smtp.qq.com'</span>);</span><br><span class="line">setpref(<span class="string">'Internet'</span>,<span class="string">'SMTP_Username'</span>,myaddress);</span><br><span class="line">setpref(<span class="string">'Internet'</span>,<span class="string">'SMTP_Password'</span>,mypassword);</span><br><span class="line">props = java.lang.System.getProperties;</span><br><span class="line">props.setProperty(<span class="string">'mail.smtp.auth'</span>,<span class="string">'true'</span>);</span><br><span class="line">subject =<span class="string">'电脑小偷'</span>;</span><br><span class="line"> </span><br><span class="line">obj = videoinput(<span class="string">'winvideo'</span>);</span><br><span class="line">h=preview(obj);</span><br><span class="line">set(gcf,<span class="string">'Visible'</span>,<span class="string">'off'</span>)</span><br><span class="line">set(h,<span class="string">'Visible'</span>,<span class="string">'on'</span>)</span><br><span class="line">start(obj);</span><br><span class="line">pause(<span class="number">10</span>);</span><br><span class="line">photo=getsnapshot(obj);</span><br><span class="line">imwrite(photo, <span class="string">'thief.jpg'</span>)</span><br><span class="line"> sendmail(to, subject,[],<span class="string">'thief.jpg'</span>);</span><br></pre></td></tr></table></figure>
<p>在matlab中执行上述脚本文件，看是否发送邮件</p>
<p>以下四步是进行电脑跟踪：程序代码如下：</p>
<p><strong>第一步：</strong>设置自己的相片(注意所有操作都是在你matlab当前目录下)</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">obj = videoinput(<span class="string">'winvideo'</span>);</span><br><span class="line">h=preview(obj);</span><br><span class="line">set(gcf,<span class="string">'Visible'</span>,<span class="string">'off'</span>)</span><br><span class="line">set(h,<span class="string">'Visible'</span>,<span class="string">'on'</span>)</span><br><span class="line">start(obj);</span><br><span class="line">pause(<span class="number">10</span>) <span class="comment">% 如果你的电脑调用摄像头的时间非常短，可以不用这句</span></span><br><span class="line">photo=getsnapshot(obj);</span><br><span class="line">imwrite(photo, <span class="string">'yourpicture.jpg'</span>);</span><br></pre></td></tr></table></figure>
<p><strong>第二步：</strong>获取当前电脑前人的相片并与自己的图片进行比较，若相似度不高，则会发送当前电脑前人的相片到你指定的邮箱</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%文件名为sendemail.m</span></span><br><span class="line">clear</span><br><span class="line"> myaddress=<span class="string">'sender@qq.com'</span>;  </span><br><span class="line"><span class="comment">%这里sender为你发邮箱的qq号，注意你的邮箱要已经提供SMTP服务，没有也没关系，qq邮箱会提醒设置设置的mypassword='password';           %这里为你邮上面邮箱对应的密码（一般和QQ密码相同）</span></span><br><span class="line">to =  <span class="string">'receiver@qq.com'</span>;              <span class="comment">%这里为你要发送到的邮箱</span></span><br><span class="line">setpref(<span class="string">'Internet'</span>,<span class="string">'E_mail'</span>,myaddress);</span><br><span class="line">setpref(<span class="string">'Internet'</span>,<span class="string">'SMTP_Server'</span>,<span class="string">'smtp.qq.com'</span>);</span><br><span class="line">setpref(<span class="string">'Internet'</span>,<span class="string">'SMTP_Username'</span>,myaddress);</span><br><span class="line">setpref(<span class="string">'Internet'</span>,<span class="string">'SMTP_Password'</span>,mypassword);</span><br><span class="line">props = java.lang.System.getProperties;</span><br><span class="line">props.setProperty(<span class="string">'mail.smtp.auth'</span>,<span class="string">'true'</span>);</span><br><span class="line">subject =<span class="string">'电脑小偷'</span>;   <span class="comment">%邮件主题</span></span><br><span class="line"> </span><br><span class="line">obj = videoinput(<span class="string">'winvideo'</span>);</span><br><span class="line">h=preview(obj);</span><br><span class="line">set(gcf,<span class="string">'Visible'</span>,<span class="string">'off'</span>)</span><br><span class="line">set(h,<span class="string">'Visible'</span>,<span class="string">'on'</span>)</span><br><span class="line">start(obj);</span><br><span class="line">pause(<span class="number">10</span>) <span class="comment">% 如果你的电脑调用摄像头的时间非常短，可以不用这句</span></span><br><span class="line">photo=getsnapshot(obj);</span><br><span class="line">imwrite(photo, <span class="string">'thief.jpg'</span>)</span><br><span class="line">pause(<span class="number">10</span>)<span class="comment">%如果你的电脑调用摄像头的时间非常短，可以不用这三句</span></span><br><span class="line">photo=getsnapshot(obj);</span><br><span class="line">imwrite(photo, <span class="string">'thief.jpg'</span>)</span><br><span class="line"> a=imread(<span class="string">'yourpicture.jpg'</span>);<span class="comment">%这里的'yourpicture.jpg为你自己的照片</span></span><br><span class="line">a1=rgb2gray(a);</span><br><span class="line">aa=imread(<span class="string">'thief.jpg'</span>);</span><br><span class="line">aa1=rgb2gray(aa);</span><br><span class="line">corr= corr2(a1,aa1);</span><br><span class="line"><span class="keyword">if</span> corr&lt;<span class="number">0.85</span>   <span class="comment">%0.85可以自己设置0-1的范围，值越小表示两幅图很容易匹配，最好取值为0.8-0.9</span></span><br><span class="line">sendmail(to, subject,[],<span class="string">'thief.jpg'</span>);</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p><strong>第二步：</strong>将step2中的程序编译生成exe文件 </p>
<p>可以直接上网找到方法，我在这里示范一种，操作如下：首先去掉黑框: 在命令窗口输入：cd(prefdir) edit compopts.bat在打开的文件最后添加以下语句(前提是在下面图解的安装编译器选择的是vc编译器,若选择其它编译器，自己百度方法)：    set LINKFLAGS=%LINKFLAGS%/SUBSYSTEM:WINDOWS /ENTRY:mainCRTStartup</p>
<p>编译器的安装如下图： </p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20140625/20140625_fig001.jpg" width="600" height="400" title="图1" alt="图1" ></p>
<p> <code>mcc -m sendemail</code> (sendemail 为step2中的文件)这一命令可能会编译几分钟，请耐心等待,执行完后会生成sendemail.exe文件 </p>
<p> <strong>第四步：</strong>创建任务计划     </p>
<p>右击我的计算机，单击管理，在左边栏中选中“任务计划程序”。在右边栏中选中“创建任务“，弹出创建任务对话框，为任务填个名称，勾选下方隐藏，配置选为，windows7那一项，触发器选项卡中单击“新建”，选择“登录时”，“每天”，勾选延迟任务，设定延迟时间为3分钟，确定。“操作”选项卡，单击新建，选择“启动程序”，单击“浏览”，选择matlab目录下生成的exe文件，确定。“条件”选项卡中只需勾选“只有在以下网络连接可用时才启动”，然后在下拉列表中选择“任何连接”（这个设置很重要，只有在电脑联网的情况下才能发送邮件），确定。后面两个选项卡，自己看样子办。然后注销用户重新登录。在三分钟内连接上网络，三分钟后，程序会自动运行，整个过程结束。 </p>
<p>程序说明：由于程序中有preview，导致拍摄图像时会显示出窗口，容易被小偷发现，如果你的摄像头启动十分快可以将Step2中的程序改为：</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clear</span><br><span class="line">myaddress=<span class="string">'sender@qq.com'</span>;</span><br><span class="line">mypassword=<span class="string">'password'</span>;</span><br><span class="line">to = <span class="string">'receiver@qq.com'</span>;setpref(<span class="string">'Internet'</span>,<span class="string">'E_mail'</span>,myaddress);</span><br><span class="line">setpref(<span class="string">'Internet'</span>,<span class="string">'SMTP_Server'</span>,<span class="string">'smtp.qq.com'</span>);</span><br><span class="line">setpref(<span class="string">'Internet'</span>,<span class="string">'SMTP_Username'</span>,myaddress);</span><br><span class="line">setpref(<span class="string">'Internet'</span>,<span class="string">'SMTP_Password'</span>,mypassword);</span><br><span class="line">props = java.lang.System.getProperties;</span><br><span class="line">props.setProperty(<span class="string">'mail.smtp.auth'</span>,<span class="string">'true'</span>);</span><br><span class="line">subject =<span class="string">'电脑小偷'</span>;</span><br><span class="line"> </span><br><span class="line">obj = videoinput(<span class="string">'winvideo'</span>);</span><br><span class="line"><span class="comment">%h=preview(obj);</span></span><br><span class="line">set(gcf,<span class="string">'Visible'</span>,<span class="string">'off'</span>)</span><br><span class="line"><span class="comment">%set(h,'Visible','on')start(obj);</span></span><br><span class="line">pause(<span class="number">2</span>);</span><br><span class="line">photo=getsnapshot(obj);</span><br><span class="line">imwrite(photo, <span class="string">'thief.jpg'</span>)</span><br><span class="line">a=imread(<span class="string">'yourpicture.jpg'</span>);</span><br><span class="line">a1=rgb2gray(a);</span><br><span class="line">aa=imread(<span class="string">'thief.jpg'</span>);</span><br><span class="line">aa1=rgb2gray(aa);</span><br><span class="line">corr= corr2(a1,aa1);</span><br><span class="line"><span class="keyword">if</span> corr&lt;<span class="number">0.85</span></span><br><span class="line">sendmail(to, subject,[],<span class="string">'thief.jpg'</span>);</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>上面程序的图像匹配不准确，希望在以后通过图像识别来精确地辨别电脑主人。在Step4中你也可以根据自己的需求改变任务创建计划，比如说，设置在每天的具体时间点启动任务，获取图像并发送。在这种情况下，就没有必要进行图像匹配了，就可以只使用本文最前面的一段程序就可以了。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>Matlab Coding</tag>
      </tags>
  </entry>
  <entry>
    <title>【Matlab编程】马氏链随机模拟</title>
    <url>/2014/06/24/%5B20140624%5D/</url>
    <content><![CDATA[<p>本文是利用蒙特卡罗算法对马氏链过程的模拟。假设有10个状态，从每个状态到与之相邻状态的概率是相同的，仿真次数为1000，及进行了1000次状态转移。我们以动画的形式再现了状态转移的过程，并记录了到达每个状态的次数，具体实现如下：</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">close all;clc;clear; </span><br><span class="line">figure; </span><br><span class="line">s&#x3D;1;</span><br><span class="line">n&#x3D;1000;</span><br><span class="line">r&#x3D;1; % 圆圈的半径</span><br><span class="line">title(&#39;等概率情况的计算机模拟&#39;)</span><br><span class="line">set(gcf,&#39;doublebuffer&#39;,&#39;on&#39;); % 设置图形渲染效果</span><br><span class="line">xlabel(&#39;Please press &quot;space&quot; key and see the result!&#39;,... </span><br><span class="line">   &#39;fontsize&#39;,14,&#39;color&#39;,&#39;r&#39;); % 添加标注文字</span><br><span class="line">hold on;axis equal; % 设置坐标轴属性</span><br><span class="line">axis([-16,16,-16,16]); % 设置坐标轴范围</span><br><span class="line">fill(r*sin(0:.1:2*pi)-7,r*cos(0:.1:2*pi)+13,&#39;w&#39;); % 画出固定点P1</span><br><span class="line">hold on</span><br><span class="line">fill(r*sin(0:.1:2*pi)-11,r*cos(0:.1:2*pi)+9,&#39;w&#39;);hold on % 画出固定点P2 </span><br><span class="line">fill(r*sin(0:.1:2*pi)-3,r*cos(0:.1:2*pi)+9,&#39;w&#39;); hold on% 画出固定点P3</span><br><span class="line">fill(r*sin(0:.1:2*pi)+5,r*cos(0:.1:2*pi)+9,&#39;w&#39;);hold on % 画出固定点P4 </span><br><span class="line">fill(r*sin(0:.1:2*pi)+9,r*cos(0:.1:2*pi)+5,&#39;w&#39;);hold on % 画出固定点P5</span><br><span class="line">fill(r*sin(0:.1:2*pi)-15,r*cos(0:.1:2*pi)-3,&#39;w&#39;);hold on % 画出固定点P6</span><br><span class="line">fill(r*sin(0:.1:2*pi)+1,r*cos(0:.1:2*pi)-3,&#39;w&#39;); hold on% 画出固定点P7</span><br><span class="line">fill(r*sin(0:.1:2*pi)+13,r*cos(0:.1:2*pi)-3,&#39;w&#39;);hold on % 画出固定点P8</span><br><span class="line">fill(r*sin(0:.1:2*pi)-7,r*cos(0:.1:2*pi)-11,&#39;w&#39;);hold on % 画出固定点P9</span><br><span class="line">fill(r*sin(0:.1:2*pi)+5,r*cos(0:.1:2*pi)-15,&#39;w&#39;);hold on % 画出固定点P10</span><br><span class="line">text(-15.4,-3,&#39;6&#39;,&#39;FontSize&#39;,18);hold on</span><br><span class="line">text(-11.4,9,&#39;2&#39;,&#39;FontSize&#39;,18);hold on</span><br><span class="line">text(-7.4,13,&#39;1&#39;,&#39;FontSize&#39;,18);hold on</span><br><span class="line">text(-7.4,-11,&#39;9&#39;,&#39;FontSize&#39;,18);hold on</span><br><span class="line">text(-3.4,9,&#39;3&#39;,&#39;FontSize&#39;,18);hold on</span><br><span class="line">text(0.6,-3,&#39;7&#39;,&#39;FontSize&#39;,18);hold on</span><br><span class="line">text(4.6,9,&#39;4&#39;,&#39;FontSize&#39;,18);hold on</span><br><span class="line">text(4.1,-15,&#39;10&#39;,&#39;FontSize&#39;,18);hold on</span><br><span class="line">text(8.6,5,&#39;5&#39;,&#39;FontSize&#39;,18);hold on</span><br><span class="line">text(12.6,-3,&#39;8&#39;,&#39;FontSize&#39;,18);hold on</span><br><span class="line">hold on</span><br><span class="line">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span><br><span class="line">%plot([8.5,6],[6,8.3],&#39;r-&#39;)</span><br><span class="line">hold on</span><br><span class="line">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span><br><span class="line">x45&#x3D;fliplr(8.3:-0.1:5.8);</span><br><span class="line">y45&#x3D;fliplr(linspace(5.9,8.2,length(x45)));</span><br><span class="line">x54&#x3D;8.3:-0.1:5.8;</span><br><span class="line">y54&#x3D;linspace(5.9,8.2,length(x54));</span><br><span class="line">x85&#x3D;fliplr(9.4:0.05:12.4);</span><br><span class="line">y85&#x3D;fliplr(linspace(4.1,-2.2,length(x85)));</span><br><span class="line">x58&#x3D;9.4:0.05:12.4;</span><br><span class="line">y58&#x3D;linspace(4.1,-2.2,length(x58));</span><br><span class="line">x80&#x3D;fliplr(5.8:0.1:12.2);</span><br><span class="line">y80&#x3D;fliplr(linspace(-14.4,-3.8,length(x80)));</span><br><span class="line">x08&#x3D;5.8:0.1:12.2;</span><br><span class="line">y08&#x3D;linspace(-14.4,-3.8,length(x08));</span><br><span class="line">x87&#x3D;fliplr(2:0.1:12);</span><br><span class="line">y87&#x3D;-3*ones(1,length(x87));</span><br><span class="line">x78&#x3D;2:0.1:12;</span><br><span class="line">y78&#x3D;-3*ones(1,length(x78));</span><br><span class="line">x79&#x3D;fliplr(-6.2:0.1:0.4);</span><br><span class="line">y79&#x3D;fliplr(linspace(-10.4,-3.8,length(x79)));</span><br><span class="line">x97&#x3D;-6.2:0.1:0.4;</span><br><span class="line">y97&#x3D;linspace(-10.4,-3.8,length(x97));</span><br><span class="line">x73&#x3D;fliplr(-2.6:0.06:0.9);</span><br><span class="line">y73&#x3D;fliplr(linspace(7.9,-2,length(x73)));</span><br><span class="line">x37&#x3D;-2.6:0.06:0.9;</span><br><span class="line">y37&#x3D;linspace(7.9,-2,length(x37));</span><br><span class="line">x13&#x3D;-6.4:0.1:-3.8;</span><br><span class="line">y13&#x3D;linspace(12.2,9.6,length(x13));</span><br><span class="line">x31&#x3D;fliplr(-6.4:0.1:-3.8);</span><br><span class="line">y31&#x3D;linspace(9.6,12.2,length(x31));</span><br><span class="line">x67&#x3D;-14:.11:0;</span><br><span class="line">y67&#x3D;-3*ones(1,length(x67));</span><br><span class="line">x76&#x3D;0:-0.11:-14;</span><br><span class="line">y76&#x3D;-3*ones(1,length(x76));</span><br><span class="line">x21&#x3D;-10.1:.1:-7.8;</span><br><span class="line">y21&#x3D;linspace(9.5,12.4,length(x21));</span><br><span class="line">x12&#x3D;-7.8:-0.1:-10.1;</span><br><span class="line">y12&#x3D;fliplr(linspace(9.5,12.4,length(x12)));</span><br><span class="line">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span><br><span class="line">t6&#x3D;text(-15.3,-5,&#39;0&#39;,&#39;FontSize&#39;,12,&#39;Color&#39;,[1 0 0]);</span><br><span class="line">t2&#x3D;text(-11.4,7,&#39;0&#39;,&#39;FontSize&#39;,12,&#39;Color&#39;,[1 0 0]);</span><br><span class="line">t1&#x3D;text(-7.2,11,&#39;0&#39;,&#39;FontSize&#39;,12,&#39;Color&#39;,[1 0 0]);</span><br><span class="line">t9&#x3D;text(-7.3,-13,&#39;0&#39;,&#39;FontSize&#39;,12,&#39;Color&#39;,[1 0 0]);</span><br><span class="line">t3&#x3D;text(-4,7,&#39;0&#39;,&#39;FontSize&#39;,12,&#39;Color&#39;,[1 0 0]);</span><br><span class="line">t7&#x3D;text(0.6,-5,&#39;0&#39;,&#39;FontSize&#39;,12,&#39;Color&#39;,[1 0 0]);</span><br><span class="line">t4&#x3D;text(4.7,7,&#39;0&#39;,&#39;FontSize&#39;,12,&#39;Color&#39;,[1 0 0]);</span><br><span class="line">t10&#x3D;text(4.3,-13,&#39;0&#39;,&#39;FontSize&#39;,12,&#39;Color&#39;,[1 0 0]);</span><br><span class="line">t5&#x3D;text(8.3,3,&#39;0&#39;,&#39;FontSize&#39;,12,&#39;Color&#39;,[1 0 0]);</span><br><span class="line">t8&#x3D;text(12.6,-5,&#39;0&#39;,&#39;FontSize&#39;,12,&#39;Color&#39;,[1 0 0]);</span><br><span class="line">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span><br><span class="line"></span><br><span class="line">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span><br><span class="line">for i&#x3D;1:length(x45)</span><br><span class="line">    plot(x45(i),y45(i),&#39;*&#39;)</span><br><span class="line">    </span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">for i&#x3D;1:length(x54)</span><br><span class="line">    plot(x54(i),y54(i),&#39;*&#39;)</span><br><span class="line">  </span><br><span class="line">end</span><br><span class="line"> </span><br><span class="line">for i&#x3D;1:length(x85)</span><br><span class="line">    plot(x85(i),y85(i),&#39;*&#39;)</span><br><span class="line">   </span><br><span class="line">end</span><br><span class="line"> </span><br><span class="line">for i&#x3D;1:length(x58)</span><br><span class="line">    plot(x58(i),y58(i),&#39;*&#39;)</span><br><span class="line">  </span><br><span class="line">end</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">for i&#x3D;1:length(x80)</span><br><span class="line">    plot(x80(i),y80(i),&#39;.&#39;)</span><br><span class="line">    </span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">for i&#x3D;1:length(x08)</span><br><span class="line">    plot(x08(i),y08(i),&#39;*&#39;)</span><br><span class="line">end</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">for i&#x3D;1:length(x87)</span><br><span class="line">    plot(x87(i),y87(i),&#39;*&#39;)</span><br><span class="line"> </span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">for i&#x3D;1:length(x78)</span><br><span class="line">    plot(x78(i),y78(i),&#39;*&#39;)</span><br><span class="line">end</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">for i&#x3D;1:length(x79)</span><br><span class="line">    plot(x79(i),y79(i),&#39;.&#39;)</span><br><span class="line">   </span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">for i&#x3D;1:length(x97)</span><br><span class="line">    plot(x97(i),y97(i),&#39;*&#39;)</span><br><span class="line">   </span><br><span class="line">end</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">for i&#x3D;1:length(x73)</span><br><span class="line">    plot(x73(i),y73(i),&#39;*&#39;)</span><br><span class="line">   </span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">for i&#x3D;1:length(x37)</span><br><span class="line">    plot(x37(i),y37(i),&#39;.&#39;)</span><br><span class="line">  </span><br><span class="line">end</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">for i&#x3D;1:length(x31)</span><br><span class="line">    plot(x31(i),y31(i),&#39;*&#39;)</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">for i&#x3D;1:length(x13)</span><br><span class="line">    plot(x13(i),y13(i),&#39;*&#39;)</span><br><span class="line">  </span><br><span class="line">end</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">for i&#x3D;1:length(x67)</span><br><span class="line">    plot(x67(i),y67(i),&#39;*&#39;)</span><br><span class="line"> </span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">for i&#x3D;1:length(x76)</span><br><span class="line">    plot(x76(i),y76(i),&#39;*&#39;)</span><br><span class="line">    </span><br><span class="line">end</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">for i&#x3D;1:length(x21)</span><br><span class="line">    plot(x21(i),y21(i),&#39;*&#39;)</span><br><span class="line"> </span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">for i&#x3D;1:length(x12)</span><br><span class="line">    plot(x12(i),y12(i),&#39;*&#39;)</span><br><span class="line">    </span><br><span class="line">end</span><br><span class="line">plot(x45,y45,&#39;w.&#39;)</span><br><span class="line">plot(x85,y85,&#39;w.&#39;)</span><br><span class="line">plot(x80,y80,&#39;w.&#39;)</span><br><span class="line">plot(x87,y87,&#39;w.&#39;)</span><br><span class="line">plot(x79,y79,&#39;w.&#39;)</span><br><span class="line">plot(x73,y73,&#39;w.&#39;)</span><br><span class="line">plot(x31,y31,&#39;w.&#39;)</span><br><span class="line">plot(x21,y21,&#39;w.&#39;)</span><br><span class="line">plot(x67,y67,&#39;w.&#39;)</span><br><span class="line">  plot(x54,y54,&#39;w.&#39;)</span><br><span class="line">plot(x58,y58,&#39;w.&#39;)</span><br><span class="line">plot(x08,y08,&#39;w.&#39;)</span><br><span class="line">plot(x78,y78,&#39;w.&#39;)</span><br><span class="line">plot(x97,y97,&#39;w.&#39;)</span><br><span class="line">plot(x37,y37,&#39;w.&#39;)</span><br><span class="line">plot(x13,y13,&#39;w.&#39;)</span><br><span class="line">plot(x12,y12,&#39;w.&#39;)</span><br><span class="line">plot(x76,y76,&#39;w.&#39;)  </span><br><span class="line">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span><br><span class="line">   s&#x3D;1;</span><br><span class="line">    p1&#x3D;0;%pn为到达n村庄的次数</span><br><span class="line"> p2&#x3D;0;p3&#x3D;0;p4&#x3D;0;p5&#x3D;0;p6&#x3D;0;p7&#x3D;0;p8&#x3D;0;p9&#x3D;0;p10&#x3D;0;</span><br><span class="line"></span><br><span class="line">%plot([-14,0],[-3,-3],&#39;b&#39;,&#39;linewidth&#39;,3)</span><br><span class="line">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span><br><span class="line">for i&#x3D;1:n</span><br><span class="line">    m&#x3D;get(gcf,&#39;currentkey&#39;); % 获取键入按键的名称</span><br><span class="line">   if strcmp(m,&#39;space&#39;); % 检查按下的按键是否为空格键</span><br><span class="line">       break;</span><br><span class="line">   end </span><br><span class="line">    if s&#x3D;&#x3D;1</span><br><span class="line">        possible&#x3D;round(rand(1));</span><br><span class="line">        if possible&#x3D;&#x3D;1</span><br><span class="line">        s&#x3D;3;</span><br><span class="line">        p3&#x3D;p3+1;</span><br><span class="line">        for i&#x3D;1:length(x13)</span><br><span class="line">            plot(x13(i),y13(i),&#39;.&#39;)</span><br><span class="line">            pause(0.00000000001)</span><br><span class="line">        end</span><br><span class="line">        delete(t3);</span><br><span class="line">        t3&#x3D;text(-4,7,num2str(p3),&#39;FontSize&#39;,12,&#39;Color&#39;,[1 0 0]);</span><br><span class="line">        else</span><br><span class="line">            s&#x3D;2;</span><br><span class="line">            p2&#x3D;p2+1;</span><br><span class="line">         for i&#x3D;1:length(x12)</span><br><span class="line">            plot(x12(i),y12(i),&#39;.&#39;)</span><br><span class="line">            pause(0.00000000001)</span><br><span class="line">         end</span><br><span class="line">          delete(t2)</span><br><span class="line">          t2&#x3D;text(-11.4,7,num2str(p2),&#39;FontSize&#39;,12,&#39;Color&#39;,[1 0 0]);</span><br><span class="line">         </span><br><span class="line">        end</span><br><span class="line">        </span><br><span class="line">    </span><br><span class="line">    elseif s&#x3D;&#x3D;2</span><br><span class="line">           s&#x3D;1;</span><br><span class="line">           p1&#x3D;p1+1;</span><br><span class="line">           for i&#x3D;1:length(x21)</span><br><span class="line">                plot(x21(i),y21(i),&#39;.&#39;)</span><br><span class="line">                pause(0.00000000001)</span><br><span class="line">           end</span><br><span class="line">            delete(t1)</span><br><span class="line">            t1&#x3D;text(-7.2,11,num2str(p1),&#39;FontSize&#39;,12,&#39;Color&#39;,[1 0 0]);</span><br><span class="line">    elseif s&#x3D;&#x3D;3</span><br><span class="line">        possible&#x3D;round(rand(1));</span><br><span class="line">        if possible&#x3D;&#x3D;1</span><br><span class="line">        s&#x3D;7;</span><br><span class="line">        p7&#x3D;p7+1;</span><br><span class="line">        for i&#x3D;1:length(x37)</span><br><span class="line">        plot(x37(i),y37(i),&#39;.&#39;)</span><br><span class="line">        pause(0.00000000001)</span><br><span class="line">        end</span><br><span class="line">        delete(t7)</span><br><span class="line">        t7&#x3D;text(0.6,-5,num2str(p7),&#39;FontSize&#39;,12,&#39;Color&#39;,[1 0 0]);</span><br><span class="line">        </span><br><span class="line">        else</span><br><span class="line">            s&#x3D;1;</span><br><span class="line">            p1&#x3D;p1+1;</span><br><span class="line">            for i&#x3D;1:length(x31)</span><br><span class="line">                plot(x31(i),y31(i),&#39;.&#39;)</span><br><span class="line">                pause(0.00000000001)</span><br><span class="line">            end</span><br><span class="line">            delete(t1)</span><br><span class="line">             t1&#x3D;text(-7.2,11,num2str(p1),&#39;FontSize&#39;,12,&#39;Color&#39;,[1 0 0]);</span><br><span class="line">        end</span><br><span class="line">        </span><br><span class="line">    elseif s&#x3D;&#x3D;4</span><br><span class="line">           s&#x3D;5;</span><br><span class="line">           p5&#x3D;p5+1;</span><br><span class="line">        for i&#x3D;1:length(x45)</span><br><span class="line">            plot(x45(i),y45(i),&#39;.&#39;)</span><br><span class="line">            pause(0.00000000001)</span><br><span class="line">        end</span><br><span class="line">        delete(t5)</span><br><span class="line">        t5&#x3D;text(8.3,3,num2str(p5),&#39;FontSize&#39;,12,&#39;Color&#39;,[1 0 0]);</span><br><span class="line">        </span><br><span class="line">    elseif s&#x3D;&#x3D;5</span><br><span class="line">        possible&#x3D;round(rand(1));</span><br><span class="line">        if possible&#x3D;&#x3D;1</span><br><span class="line">        s&#x3D;8;</span><br><span class="line">        p8&#x3D;p8+1;</span><br><span class="line">        for i&#x3D;1:length(x58)</span><br><span class="line">            plot(x58(i),y58(i),&#39;.&#39;)</span><br><span class="line">            pause(0.00000000001)</span><br><span class="line">        end</span><br><span class="line">        delete(t8)</span><br><span class="line">        t8&#x3D;text(12.6,-5,num2str(p8),&#39;FontSize&#39;,12,&#39;Color&#39;,[1 0 0]);</span><br><span class="line">        </span><br><span class="line">        else</span><br><span class="line">            s&#x3D;4;</span><br><span class="line">            p4&#x3D;p4+1;</span><br><span class="line">            for i&#x3D;1:length(x54)</span><br><span class="line">                plot(x54(i),y54(i),&#39;.&#39;)</span><br><span class="line">                pause(0.00000000001)</span><br><span class="line">            end</span><br><span class="line">            delete(t4)</span><br><span class="line">            t4&#x3D;text(4.7,7,num2str(p4),&#39;FontSize&#39;,12,&#39;Color&#39;,[1 0 0]);</span><br><span class="line">            </span><br><span class="line">            end</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    elseif s&#x3D;&#x3D;6</span><br><span class="line">         s&#x3D;7;</span><br><span class="line">           p7&#x3D;p7+1;</span><br><span class="line">           for i&#x3D;1:length(x67)</span><br><span class="line">                plot(x67(i),y67(i),&#39;.&#39;)</span><br><span class="line">                pause(0.00000000001)</span><br><span class="line">           end</span><br><span class="line">           delete(t7)</span><br><span class="line">           t7&#x3D;text(0.6,-5,num2str(p7),&#39;FontSize&#39;,12,&#39;Color&#39;,[1 0 0]);</span><br><span class="line">    elseif s&#x3D;&#x3D;7</span><br><span class="line">        possible&#x3D;floor(rand(1)*4);</span><br><span class="line">        if possible&#x3D;&#x3D;0</span><br><span class="line">            s&#x3D;6;</span><br><span class="line">            p6&#x3D;p6+1;</span><br><span class="line">            for i&#x3D;1:length(x76)</span><br><span class="line">                plot(x76(i),y76(i),&#39;.&#39;)</span><br><span class="line">                pause(0.00000000001)</span><br><span class="line">            end</span><br><span class="line">            delete(t6)</span><br><span class="line">            t6&#x3D;text(-15.3,-5,num2str(p6),&#39;FontSize&#39;,12,&#39;Color&#39;,[1 0 0]);</span><br><span class="line">            </span><br><span class="line">        elseif possible&#x3D;&#x3D;1</span><br><span class="line">            s&#x3D;3;</span><br><span class="line">            p3&#x3D;p3+1;</span><br><span class="line">            for i&#x3D;1:length(x73)</span><br><span class="line">                plot(x73(i),y73(i),&#39;.&#39;)</span><br><span class="line">                pause(0.00000000001)</span><br><span class="line">            end</span><br><span class="line">            delete(t3)</span><br><span class="line">            t3&#x3D;text(-4,7,num2str(p3),&#39;FontSize&#39;,12,&#39;Color&#39;,[1 0 0]);</span><br><span class="line">            </span><br><span class="line">        elseif possible&#x3D;&#x3D;2</span><br><span class="line">            s&#x3D;9;</span><br><span class="line">            p9&#x3D;p9+1;</span><br><span class="line">            for i&#x3D;1:length(x79)</span><br><span class="line">                plot(x79(i),y79(i),&#39;.&#39;)</span><br><span class="line">                pause(0.00000000001)</span><br><span class="line">            end</span><br><span class="line">            delete(t9)</span><br><span class="line">            t9&#x3D;text(-7.3,-13,num2str(p9),&#39;FontSize&#39;,12,&#39;Color&#39;,[1 0 0]);</span><br><span class="line">        else</span><br><span class="line">            s&#x3D;8;</span><br><span class="line">            p8&#x3D;p8+1;</span><br><span class="line">            for i&#x3D;1:length(x78)</span><br><span class="line">                plot(x78(i),y78(i),&#39;.&#39;)</span><br><span class="line">                pause(0.00000000001)</span><br><span class="line">            end</span><br><span class="line">            delete(t8)</span><br><span class="line">            t8&#x3D;text(12.6,-5,num2str(p8),&#39;FontSize&#39;,12,&#39;Color&#39;,[1 0 0]);</span><br><span class="line">            </span><br><span class="line">        end</span><br><span class="line">        </span><br><span class="line">    elseif s&#x3D;&#x3D;8</span><br><span class="line">         possible&#x3D;floor(rand(1)*3);</span><br><span class="line">        if possible&#x3D;&#x3D;0</span><br><span class="line">            s&#x3D;7;</span><br><span class="line">            p7&#x3D;p7+1;</span><br><span class="line">            for i&#x3D;1:length(x87)</span><br><span class="line">                plot(x87(i),y87(i),&#39;.&#39;)</span><br><span class="line">                pause(0.00000000001)</span><br><span class="line">            end</span><br><span class="line">            delete(t7)</span><br><span class="line">            t7&#x3D;text(0.6,-5,num2str(p7),&#39;FontSize&#39;,12,&#39;Color&#39;,[1 0 0]);</span><br><span class="line">        elseif possible&#x3D;&#x3D;1</span><br><span class="line">            s&#x3D;5;</span><br><span class="line">            p5&#x3D;p5+1;</span><br><span class="line">            for i&#x3D;1:length(x85)</span><br><span class="line">                plot(x85(i),y85(i),&#39;.&#39;)</span><br><span class="line">                pause(0.00000000001)</span><br><span class="line">            end</span><br><span class="line">            delete(t5)</span><br><span class="line">            t5&#x3D;text(8.3,3,num2str(p5),&#39;FontSize&#39;,12,&#39;Color&#39;,[1 0 0]);</span><br><span class="line">            </span><br><span class="line">        else </span><br><span class="line">            s&#x3D;10;</span><br><span class="line">            p10&#x3D;p10+1;</span><br><span class="line">            for i&#x3D;1:length(x80)</span><br><span class="line">                plot(x80(i),y80(i),&#39;.&#39;)</span><br><span class="line">                pause(0.00000000001)</span><br><span class="line">            end</span><br><span class="line">            delete(t10)</span><br><span class="line">            t10&#x3D;text(4.3,-13,num2str(p10),&#39;FontSize&#39;,12,&#39;Color&#39;,[1 0 0]);</span><br><span class="line">        end</span><br><span class="line">        </span><br><span class="line">    elseif s&#x3D;&#x3D;9</span><br><span class="line">        s&#x3D;7;</span><br><span class="line">        p7&#x3D;p7+1;</span><br><span class="line">        for i&#x3D;1:length(x97)</span><br><span class="line">            plot(x97(i),y97(i),&#39;.&#39;)</span><br><span class="line">            pause(0.00000000001)</span><br><span class="line">        end</span><br><span class="line">        delete(t7)</span><br><span class="line">        t7&#x3D;text(0.6,-5,num2str(p7),&#39;FontSize&#39;,12,&#39;Color&#39;,[1 0 0]);</span><br><span class="line">    </span><br><span class="line">    else </span><br><span class="line">        s&#x3D;8;</span><br><span class="line">        p8&#x3D;p8+1;</span><br><span class="line">        for i&#x3D;1:length(x08)</span><br><span class="line">            plot(x08(i),y08(i),&#39;.&#39;)</span><br><span class="line">            pause(0.00000000001)</span><br><span class="line">        end</span><br><span class="line">        delete(t8)</span><br><span class="line">        t8&#x3D;text(12.6,-5,num2str(p8),&#39;FontSize&#39;,12,&#39;Color&#39;,[1 0 0]);</span><br><span class="line">        </span><br><span class="line">    end</span><br><span class="line">plot(x45,y45,&#39;w.&#39;)</span><br><span class="line">plot(x85,y85,&#39;w.&#39;)</span><br><span class="line">plot(x80,y80,&#39;w.&#39;)</span><br><span class="line">plot(x87,y87,&#39;w.&#39;)</span><br><span class="line">plot(x79,y79,&#39;w.&#39;)</span><br><span class="line">plot(x73,y73,&#39;w.&#39;)</span><br><span class="line">plot(x31,y31,&#39;w.&#39;)</span><br><span class="line">plot(x21,y21,&#39;w.&#39;)</span><br><span class="line">plot(x67,y67,&#39;w.&#39;)</span><br><span class="line">plot(x54,y54,&#39;w.&#39;)</span><br><span class="line">plot(x58,y58,&#39;w.&#39;)</span><br><span class="line">plot(x08,y08,&#39;w.&#39;)</span><br><span class="line">plot(x78,y78,&#39;w.&#39;)</span><br><span class="line">plot(x97,y97,&#39;w.&#39;)</span><br><span class="line">plot(x37,y37,&#39;w.&#39;)</span><br><span class="line">plot(x13,y13,&#39;w.&#39;)</span><br><span class="line">plot(x12,y12,&#39;w.&#39;)</span><br><span class="line">plot(x76,y76,&#39;w.&#39;)  </span><br><span class="line">end</span><br><span class="line"> </span><br><span class="line">for j&#x3D;i:n</span><br><span class="line">    if s&#x3D;&#x3D;1</span><br><span class="line">        possible&#x3D;round(rand(1));</span><br><span class="line">        if possible&#x3D;&#x3D;1</span><br><span class="line">        s&#x3D;3;</span><br><span class="line">        p3&#x3D;p3+1;</span><br><span class="line">        else</span><br><span class="line">            s&#x3D;2;</span><br><span class="line">            p2&#x3D;p2+1;</span><br><span class="line">        end</span><br><span class="line">        </span><br><span class="line">    </span><br><span class="line">    elseif s&#x3D;&#x3D;2</span><br><span class="line">           s&#x3D;1;</span><br><span class="line">           p1&#x3D;p1+1;</span><br><span class="line">           </span><br><span class="line">    elseif s&#x3D;&#x3D;3</span><br><span class="line">        possible&#x3D;round(rand(1));</span><br><span class="line">        if possible&#x3D;&#x3D;1</span><br><span class="line">        s&#x3D;7;</span><br><span class="line">        p7&#x3D;p7+1;</span><br><span class="line">        else</span><br><span class="line">            s&#x3D;1;</span><br><span class="line">            p1&#x3D;p1+1;</span><br><span class="line">        end</span><br><span class="line">        </span><br><span class="line">    elseif s&#x3D;&#x3D;4</span><br><span class="line">           s&#x3D;5;</span><br><span class="line">           p5&#x3D;p5+1;</span><br><span class="line">        </span><br><span class="line">    elseif s&#x3D;&#x3D;5</span><br><span class="line">        possible&#x3D;round(rand(1));</span><br><span class="line">        if possible&#x3D;&#x3D;1</span><br><span class="line">        s&#x3D;8;</span><br><span class="line">        p8&#x3D;p8+1;</span><br><span class="line">        else</span><br><span class="line">            s&#x3D;4;</span><br><span class="line">            p4&#x3D;p4+1;</span><br><span class="line">        end</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    elseif s&#x3D;&#x3D;6</span><br><span class="line">         s&#x3D;7;</span><br><span class="line">           p7&#x3D;p7+1;</span><br><span class="line">           </span><br><span class="line">    elseif s&#x3D;&#x3D;7</span><br><span class="line">        possible&#x3D;floor(rand(1)*4);</span><br><span class="line">        if possible&#x3D;&#x3D;0</span><br><span class="line">            s&#x3D;6;</span><br><span class="line">            p6&#x3D;p6+1;</span><br><span class="line">        elseif possible&#x3D;&#x3D;1</span><br><span class="line">            s&#x3D;3;</span><br><span class="line">            p3&#x3D;p3+1;</span><br><span class="line">        elseif possible&#x3D;&#x3D;2</span><br><span class="line">            s&#x3D;9;</span><br><span class="line">            p9&#x3D;p9+1;</span><br><span class="line">        else</span><br><span class="line">            s&#x3D;8;</span><br><span class="line">            p8&#x3D;p8+1;</span><br><span class="line">        end</span><br><span class="line">        </span><br><span class="line">    elseif s&#x3D;&#x3D;8</span><br><span class="line">         possible&#x3D;floor(rand(1)*3);</span><br><span class="line">        if possible&#x3D;&#x3D;0</span><br><span class="line">            s&#x3D;7;</span><br><span class="line">            p7&#x3D;p7+1;</span><br><span class="line">        elseif possible&#x3D;&#x3D;1</span><br><span class="line">            s&#x3D;5;</span><br><span class="line">            p5&#x3D;p5+1;</span><br><span class="line">        else </span><br><span class="line">            s&#x3D;10;</span><br><span class="line">            p10&#x3D;p10+1;</span><br><span class="line">        end</span><br><span class="line">        </span><br><span class="line">    elseif s&#x3D;&#x3D;9</span><br><span class="line">        s&#x3D;7;</span><br><span class="line">        p7&#x3D;p7+1;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    else </span><br><span class="line">        s&#x3D;8;</span><br><span class="line">        p8&#x3D;p8+1;</span><br><span class="line">    end</span><br><span class="line">     </span><br><span class="line">    </span><br><span class="line">end</span><br><span class="line">delete(t1)</span><br><span class="line">delete(t2)</span><br><span class="line">delete(t3)</span><br><span class="line">delete(t4)</span><br><span class="line">delete(t5)</span><br><span class="line">delete(t6)</span><br><span class="line">delete(t7)</span><br><span class="line">delete(t8)</span><br><span class="line">delete(t9)</span><br><span class="line">delete(t10)</span><br><span class="line">t6&#x3D;text(-15.3,-5,num2str(p6),&#39;FontSize&#39;,12,&#39;Color&#39;,[1 0 0]);</span><br><span class="line">t2&#x3D;text(-11.4,7,num2str(p2),&#39;FontSize&#39;,12,&#39;Color&#39;,[1 0 0]);</span><br><span class="line">t1&#x3D;text(-7.2,11,num2str(p1),&#39;FontSize&#39;,12,&#39;Color&#39;,[1 0 0]);</span><br><span class="line">t9&#x3D;text(-7.3,-13,num2str(p9),&#39;FontSize&#39;,12,&#39;Color&#39;,[1 0 0]);</span><br><span class="line">t3&#x3D;text(-4,7,num2str(p3),&#39;FontSize&#39;,12,&#39;Color&#39;,[1 0 0]);</span><br><span class="line">t7&#x3D;text(0.6,-5,num2str(p7),&#39;FontSize&#39;,12,&#39;Color&#39;,[1 0 0]);</span><br><span class="line">t4&#x3D;text(4.7,7,num2str(p4),&#39;FontSize&#39;,12,&#39;Color&#39;,[1 0 0]);</span><br><span class="line">t10&#x3D;text(4.3,-13,num2str(p10),&#39;FontSize&#39;,12,&#39;Color&#39;,[1 0 0]);</span><br><span class="line">t5&#x3D;text(8.3,3,num2str(p5),&#39;FontSize&#39;,12,&#39;Color&#39;,[1 0 0]);</span><br><span class="line">t8&#x3D;text(12.6,-5,num2str(p8),&#39;FontSize&#39;,12,&#39;Color&#39;,[1 0 0]);</span><br></pre></td></tr></table></figure>
<p>仿真过程如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20140624/20140624_fig001.jpg" width="600" height="400" title="图1" alt="图1" ></p>
<p>最终的结果如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20140624/20140624_fig002.jpg" width="600" height="400" title="图1" alt="图1" ></p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>Matlab Coding</tag>
      </tags>
  </entry>
  <entry>
    <title>【Java编程】Java在dos窗口编译与执行的批处理</title>
    <url>/2014/06/21/%5B20140621%5D/</url>
    <content><![CDATA[<p>​    最近在Java编程过程中，常用到dos窗口对程序进行编译与运行。但是不方便之处在于每次都要输入命令进入将要编译的程序的目录(其实也有简单的方法，在文章末尾给出)。于是编写了一个配置文件，可以一次修改，经常使用。（只需要在下面程序中将路径修改为你所经常存放程序的目录）。前提当然是你已正确配置环境变量。具体方法为：将下面的程序放在新建的文本文件中，并将后缀名改为.bat.然后双击该文件，按提示操作即可！</p>
<a id="more"></a>
<p>程序源码如下：(红色字体是需要根据你的存放路径修改的)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> off</span><br><span class="line">cls</span><br><span class="line">title Java在dos窗口的编译与执行</span><br><span class="line">color 0a </span><br><span class="line">rem 将路径改为你将要编译执行的文件目录 例如：我的文件目录为<span class="string">"D:\studytool\Java\classes"</span>(<span class="built_in">shift</span>+右键 单击你的文件目录选择<span class="string">"复制为路径"</span>)</span><br><span class="line">D:</span><br><span class="line"><span class="built_in">cd</span> D:\</span><br><span class="line"><span class="built_in">cd</span> studytool\Java\classes</span><br><span class="line"><span class="built_in">set</span> cd1=%<span class="built_in">cd</span>%</span><br><span class="line"><span class="built_in">echo</span> 当前目录%cd1%下已有的文件：</span><br><span class="line">dir /b</span><br><span class="line">:cx </span><br><span class="line"><span class="built_in">set</span> /p filename=请选择要编译或执行的文件名(需写后缀名,按quit退出程序)：</span><br><span class="line"><span class="keyword">if</span> <span class="string">"%filename%"</span>==<span class="string">"quit"</span> (<span class="built_in">exit</span>)</span><br><span class="line"><span class="built_in">set</span> <span class="string">"leixing=%filename:~-5%"</span></span><br><span class="line"><span class="built_in">set</span> <span class="string">"leixing1=%filename:~0,-5%"</span></span><br><span class="line"><span class="built_in">set</span> <span class="string">"leixing2=%filename:~0,-6%"</span></span><br><span class="line"><span class="keyword">if</span> <span class="string">"%leixing%"</span>==<span class="string">".java"</span>  (</span><br><span class="line"><span class="built_in">echo</span> 请选择:(1.编译；2.执行；3.编译和执行）</span><br><span class="line">choice /c 123</span><br><span class="line"><span class="keyword">if</span> errorlevel 3 (</span><br><span class="line"><span class="built_in">echo</span> 正在编译……</span><br><span class="line">javac %filename%</span><br><span class="line"><span class="built_in">echo</span> 正在执行……</span><br><span class="line"><span class="built_in">echo</span> 执行结果为：</span><br><span class="line">java %leixing1% </span><br><span class="line">goto cx</span><br><span class="line">)</span><br><span class="line"><span class="keyword">if</span> errorlevel 2  (</span><br><span class="line"><span class="built_in">echo</span> 该文件为.java文件，不能直接执行！</span><br><span class="line">goto cx</span><br><span class="line"> )</span><br><span class="line"><span class="keyword">if</span> errorlevel 1 (</span><br><span class="line"><span class="built_in">echo</span> 正在编译……</span><br><span class="line">javac %filename%</span><br><span class="line">goto cx</span><br><span class="line">)</span><br><span class="line"><span class="built_in">echo</span> 此时目录%cd1%下已有的文件：</span><br><span class="line">dir /b</span><br><span class="line">goto cx</span><br><span class="line">)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> <span class="string">"%leixing%"</span>==<span class="string">"class"</span> (</span><br><span class="line"><span class="built_in">echo</span> 请选择:(1.编译；2.执行；3.编译和执行）</span><br><span class="line">choice /c 123</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> errorlevel 3 (</span><br><span class="line"><span class="built_in">echo</span>  该文件为.class文件，不能编译！</span><br><span class="line">goto cx</span><br><span class="line"> )</span><br><span class="line"><span class="keyword">if</span> errorlevel 2  (</span><br><span class="line"><span class="built_in">echo</span> 正在执行……</span><br><span class="line"><span class="built_in">echo</span> 执行结果为：</span><br><span class="line">java %leixing2% </span><br><span class="line">goto cx</span><br><span class="line">)</span><br><span class="line"><span class="keyword">if</span> errorlevel 1 (</span><br><span class="line"><span class="built_in">echo</span>  该文件为.class文件，不能编译！</span><br><span class="line">goto cx</span><br><span class="line">)</span><br><span class="line"><span class="built_in">echo</span> 此时目录%cd1%下已有的文件：</span><br><span class="line">dir /b</span><br><span class="line">goto cx</span><br><span class="line">) <span class="keyword">else</span> (<span class="built_in">echo</span> 你输入的文件名有误！</span><br><span class="line">goto cx)</span><br><span class="line"> </span><br><span class="line">pause</span><br></pre></td></tr></table></figure>
<p><strong>我的运行截图如下：</strong></p>
<ul>
<li>编译.java文件<br><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20140621/20140621_fig001.jpg" width="600" height="400" title="图1" alt="图1" ></li>
</ul>
<ul>
<li><p>执行.class文件</p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20140621/20140621_fig002.jpg" width="600" height="400" title="图2" alt="图2" ></p>
</li>
<li><p>处理异常和退出<br><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20140621/20140621_fig003.jpg" width="600" height="400" title="图3" alt="图3" ></p>
</li>
</ul>
<p>​    虽然上述方法比较人性化，但是也有不足之处：不能运行Java小程序。现在有一种更简单的方法能避免在dos窗口下进入程序所在目录的繁琐过程：将cmd.exe文件拷贝到程序的目录下即可。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>Java Coding</tag>
      </tags>
  </entry>
  <entry>
    <title>【LaTeX排版】LaTeX论文排版&lt;四&gt;</title>
    <url>/2014/06/19/%5B20140619%5D/</url>
    <content><![CDATA[<h2 id="表格的插入"><a href="#表格的插入" class="headerlink" title="表格的插入"></a>表格的插入</h2><p>  一般的表格插入的代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> \begin&#123;table&#125;[H]</span><br><span class="line">  \centering</span><br><span class="line">  \begin&#123;tabular&#125;&#123;|c|c|c|&#125;</span><br><span class="line">  \hline</span><br><span class="line">   感知方法&amp;优点&amp;缺点\\ \hline</span><br><span class="line">   单用户检测&amp;计算与执行简单&amp; \tabincell&#123;c&#125;&#123;隐藏终端问题\\多径与阴影效应&#125;\\ \hline</span><br><span class="line">   多用户合作检测&amp; \tabincell&#123;c&#125;&#123;精度高、感知时间短\\避免了阴影效应和隐藏终端问题&#125;&amp; \tabincell&#123;c&#125;&#123;复杂度高\\流量开销大、带宽需求高&#125;\\ \hline</span><br><span class="line">\end&#123;tabular&#125;</span><br><span class="line">   \caption&#123;单用户检测与多用户合作检测优缺点对比&#125;\label&#123;table21&#125;</span><br><span class="line">\end&#123;table&#125;</span><br><span class="line">%注意要在导言区加入\newcommand&#123;\tabincell&#125;[2]&#123;\begin&#123;tabular&#125;&#123;@&#123;&#125;#1@&#123;&#125;&#125;#2\end&#123;tabular&#125;&#125;来容许表格内可以换行</span><br></pre></td></tr></table></figure>
<p><strong>结果显示如下：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20140619/20140619_fig001.jpg" width="500" height="200" title="图1" alt="图1" ></p>
<p><strong>在表格前加入行序号</strong>，源代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\newcounter&#123;Rownumber&#125; \newcommand&#123;\Rown&#125;&#123;\stepcounter&#123;Rownumber&#125;\theRownumber&#125;</span><br><span class="line">\begin&#123;tabular&#125;&#123;|c|c|c|&#125;\hline</span><br><span class="line">序号&amp;材料&amp;电阻温度系数\\ \hline</span><br><span class="line">\Rown&amp;银&amp;0.0038 \\ \hline</span><br><span class="line">\Rown&amp;铜&amp;0.0039 \\ \hline</span><br><span class="line">\Rown&amp;铝&amp;0.0039 \\ \hline</span><br><span class="line">\end&#123;tabular&#125;</span><br></pre></td></tr></table></figure>
<p>显示结果如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20140619/20140619_fig002.jpg" width="300" height="150" title="图2" alt="图2" ></p>
<p><strong>将多行变为一行</strong>，源代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\begin&#123;tabular&#125;&#123;|c|c|&#125;\hline</span><br><span class="line"></span><br><span class="line">\multirow&#123;4&#125;*&#123;宇宙中的力&#125;</span><br><span class="line"></span><br><span class="line">&amp;万有引力 \\ \cline&#123;2-2&#125;</span><br><span class="line"></span><br><span class="line">&amp;电磁力 \\ \cline&#123;2-2&#125;</span><br><span class="line"></span><br><span class="line">&amp;弱相互作用力 \\ \cline&#123;2-2&#125;</span><br><span class="line"></span><br><span class="line">&amp;强相互作用力 \\ \cline&#123;2-2&#125;</span><br><span class="line"></span><br><span class="line">\hline</span><br><span class="line"></span><br><span class="line">\end&#123;tabular&#125;</span><br></pre></td></tr></table></figure>
<p>注意在导言区加入包<code>\usepackage{multirow}</code>, 效果如下图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20140619/20140619_fig003.jpg" width="300" height="150" title="图3" alt="图3" ></p>
<hr>
<h2 id="参考文献的使用"><a href="#参考文献的使用" class="headerlink" title="参考文献的使用"></a>参考文献的使用</h2><p>   参考文献可以写在一个子文件中，内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\begin&#123;thebibliography&#125;&#123;99&#125;%这里的参数99可以自己随意设置，但需要大于文献个数</span><br><span class="line"></span><br><span class="line">    \bibitem&#123;1&#125;李建东，杨家玮, 个人通信. 北京：人民邮电出版社, 1998年.%注意在每两条文献中加入空行，以便索引时不会出错</span><br><span class="line"></span><br><span class="line">    \bibitem&#123;2&#125;郭梯云，杨家玮，李建东, 数字移动通信（修订本）. 北京：人民邮电出版社, 2001年.</span><br><span class="line"></span><br><span class="line">    \end&#123;thebibliography&#125;</span><br></pre></td></tr></table></figure>
<p> 显示结果如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20140619/20140619_fig004.jpg" width="500" height="200" title="图4" alt="图4" ></p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>LaTeX Coding</tag>
      </tags>
  </entry>
  <entry>
    <title>【Matlab编程】Matlab高效编程技巧</title>
    <url>/2014/06/16/%5B20140616%5D/</url>
    <content><![CDATA[<ul>
<li><p>默认状态下，matlab显示精度是short型，而默认的计算精度是double型，并且显示精度与计算精度没有关系。</p>
</li>
<li><p>一只失明的猫的问题：注意方法！</p>
</li>
<li><p>给数组预分配空间是基本的高效编程准则之一。如果不预先分配内存具体的动态扩充数组内存的实现方式如下：<br><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20140616/20140616_fig001.jpg" width="600" height="350" title="图1" alt="图1" ></p>
<p>如果预分配空间，则只将新添加的值放入连续的内存中，而不会将整个数组重新分配空间。</p>
</li>
<li><p>matlab也可以使用window命令，只需要在系统命令前加！或者dos:例如<code>！shutdown -s</code> 会关闭电脑，这样可以想到，我们可以用matlab做一个简单的定时关机软件。</p>
</li>
<li><p>逻辑索引的速度大于数值索引：eg:<code>A=rand(1000); a1=A(find(A&gt;0.3)); a2=A(A&gt;0.3);</code> find函数返回的是数值索引。</p>
</li>
<li><p>使用循环时的两种高效方法：1.按列遍历；2.循环次数多的放在内层。</p>
</li>
<li><p>在目前的高版本中，循环已不是耗时的主要原因，而是函数调用。</p>
</li>
<li><p>edit 、type、open可以查看部分函数的源代码，内建函数不行。</p>
</li>
<li><p>匿名函数可以完全更好的替代incline函数。</p>
</li>
<li><p>build-in函数的开销最低。</p>
</li>
<li><p>更多的使用向量化函数。eg: accumarray、arrayfun 、bsxfun 、cellfun 、spfun 、structfun</p>
</li>
<li><p>符号计算虽说语法简单，但是由于精确性，在计算过程中会保留大量的中间结果，这样容易导致内存溢出。</p>
</li>
<li><p>matlab的界面元素都是由Java实现的，可以通过运行<code>matlab -nojvm</code>来启动matlab，从而减少内存消耗。</p>
</li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>Matlab Coding</tag>
      </tags>
  </entry>
  <entry>
    <title>【组合数学】36军官问题</title>
    <url>/2014/06/12/%5B20140612%5D/</url>
    <content><![CDATA[<h2 id="问题描述："><a href="#问题描述：" class="headerlink" title="问题描述："></a>问题描述：</h2><p>  据说普鲁士的腓特列大帝曾组成一支仪仗队，仪仗队共有$36$名军官，来自$6$支部队，每支部队中，上校、中校、少校、上尉、中尉、少尉各一名。他希望这$36$名军官排成$6\times 6$的方阵，方阵的每一行，每一列的$6$名军官来自不同的部队并且军衔各不相同。令他恼火的是，无论怎么绞尽脑汁也排不成。</p>
<p>后来，他去求教瑞士著名的大数学家欧拉。欧拉发现这是一个不可能完成的任务。</p>
<p>来自$n$个部队的$n$种军衔的$n\times n$名军官，如果能排成一个正方形，每一行，每一列的$n$名军官来自不同的部队并且军衔各不相同，那么就称这个方阵叫正交拉丁方阵。欧拉猜测在</p>
<p>$n=2, 6, 10, 14, 18,\cdots$</p>
<p>时，正交拉丁方阵不存在。然而到了上世纪$60$年代，人们用计算机造出了$n=10$的正交拉丁方阵，推翻了欧拉的猜测。现在已经知道，除了$n=2,6$以外，其余的正交拉丁方阵都存在，而且有多种构造的方法</p>
<a id="more"></a>
<h2 id="数学模型的建立："><a href="#数学模型的建立：" class="headerlink" title="数学模型的建立："></a>数学模型的建立：</h2><p>  为了解决上面的排列组合问题，我们可以建立数学模型，将上述问题转化为：能不能把$36$个有序对$(i, j)(i=1, 2, \cdots, 6; j=1, 2, \cdots, 6)$排列成一个$6\times 6$的矩阵，使得该矩阵的每一行每一列上整数$1, 2, \cdots, 6$能够以某种顺序出现？（觉得和数独是不是有点类似，但是有附加条件）</p>
<h2 id="模型的求解："><a href="#模型的求解：" class="headerlink" title="模型的求解："></a>模型的求解：</h2><p>  我们可以将这样的矩阵分割为两个$6\times 6$的矩阵，一个对应于有序对的第一个位置（军衔矩阵），另一个对应有序对的另一个位置（军团矩阵）。这样问题可以描述如下：</p>
<p>  1）这两个矩阵的每一行每一列上整数$1, 2, \cdots, 6$能够以某种顺序出现</p>
<p>  2）当并置这两个矩阵时，所有有序对$(i, j)(i=1, 2, \cdots, 6; j=1, 2, \cdots, 6)$全部出现</p>
<p>上面矩阵比较大，我们以来自$3$个军团$3$个级别军衔的$9$个军官为例，可以得到问题的解（可以笔算得到）如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20140612/20140612_fig001.jpg" width="400" height="150" title="图1" alt="图1" ></p>
<p>从上图可以看出，军衔矩阵和军团矩阵都是$3$阶拉丁方阵，并且两者并置得到的并置矩阵得到了所有可能的$9$个有序对$(i,j)$。这种情况下，我们称军衔矩阵和军团矩阵是正交的，并置矩阵称为正交拉丁方阵。</p>
<p>  很明显，$3$阶正交拉丁方阵是存在的，对于$36$军官问题，也就是要求证$6$阶正交拉丁仿真是否存在。前面已经提到，除了阶数$n=2, 6$以外，其余的正交拉丁方阵都存在，而且有多种构造的方法</p>
<p>对于正交拉丁方阵的构造，由于比较复杂，有时间再研究，下面给出拉丁方阵的具体实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">int</span> n,i,j,count;</span><br><span class="line"> <span class="keyword">int</span> Num[<span class="number">20</span>];<span class="comment">//这里可以输入的阶数n的最大值是，可以自己修改</span></span><br><span class="line"> <span class="built_in">cout</span>&lt;&lt;<span class="string">"请输入方阵阶数:"</span>;</span><br><span class="line"> <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"> <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)      <span class="comment">//给数组赋初始值</span></span><br><span class="line"> &#123;</span><br><span class="line">    Num[i]=i+<span class="number">1</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">for</span> (i = <span class="number">0</span>;i &lt; n;i++)     <span class="comment">//外循环输出n行</span></span><br><span class="line"> &#123;</span><br><span class="line">  <span class="keyword">for</span> (j = i,count=<span class="number">1</span>;count&lt;= n;count++)     <span class="comment">//内循环输出一行的每个数字</span></span><br><span class="line">  &#123;</span><br><span class="line">   <span class="built_in">cout</span>&lt;&lt;Num[j%n]&lt;&lt;<span class="string">'\t'</span>;</span><br><span class="line">    j++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>Mathematics</tag>
      </tags>
  </entry>
  <entry>
    <title>【LaTeX排版】LaTeX论文排版&lt;三&gt;</title>
    <url>/2014/06/11/%5B20140611%5D/</url>
    <content><![CDATA[<p><strong>A picture is worth a thousand words(一图胜千言)。图在论文中的重要性不言而喻，本文主要讲解图的制作与插入。</strong></p>
<a id="more"></a>
<h2 id="图像的插入"><a href="#图像的插入" class="headerlink" title="图像的插入"></a>图像的插入</h2><p>  图像可以分为两大类：<strong>位图和向量图</strong>。</p>
<p>  <strong>位图</strong>：也就是点阵图，使用像素的小方块组成网格来表示图像。每个像素都有自己特定的位置和颜色值。一幅图像的像素数量的大小不变，当放大或缩小时，改变的只是像素尺寸的大小。因此放大或缩小时会出现锯齿现象，造成失真。位图还分为：无损压缩和有损压缩。其中，TIFF、PNG、GIF是无损压缩，JPG是有损压缩。</p>
<p>  <strong>向量图</strong>：由数学公式定义的线段和曲线组成的图形，这些线段和曲线称为向量。向量图和分辨率无关，所以缩放时，图片都不会失真。由于图片是以数学公式保存的，所以向量图片的大小比较小。而计算机显示器只能用网格显示图像，所以位图和向量图都是以像素的方式显示图形的。</p>
<p>  <strong>优缺点比较</strong>：位图图形的占用存储空间大，向量图形的显示速度比位图慢，因为它有一个向量计算的过程。</p>
<p>  想在论文中插入图片，首先需要在导言区(也就是<code>\begin{document}</code>命令前面)加上<code>\usepackage{graphicx}</code>来导入插图宏包。<strong>最常用的插图命令模版如下：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\vspace&#123;-0.8cm&#125;%用于调整与上文的间隔</span><br><span class="line">\begin&#123;figure&#125;[H]%中括号的H会让你的图处于你所插入的位置，否则的话，默认是插在一页的最上端。注意需要在导言区加入\usepackage&#123;float&#125;</span><br><span class="line">   \begin&#123;center&#125;%这里选择图片是居中对齐</span><br><span class="line">   \includegraphics[scale&#x3D;0.8]&#123;pic12.eps&#125;%scale用于将图片进行缩放，这里是缩小为原来的0.8倍。大括号内是要插入的图像文件名</span><br><span class="line">      \setlength\abovecaptionskip&#123;-1cm&#125;%用于调整标题前后的距离，可以自己设置来增加美观。</span><br><span class="line">      \setlength\belowcaptionskip&#123;-1cm&#125;</span><br><span class="line">   \caption&#123;Mitola博士提出的认知环\label&#123;pic12&#125;&#125;%这里是图像的标题，pic12是这个图像的标签，引用该图像时需要</span><br><span class="line"> \end&#123;center&#125;</span><br><span class="line">\end&#123;figure&#125;</span><br><span class="line"> \vspace&#123;-0.8cm&#125;%用于调整与下文的间隔</span><br></pre></td></tr></table></figure>
<p><strong>下面举例说明：</strong></p>
<p>源文件如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\documentclass[a4paper,12pt]&#123;book&#125;%采用book类型（中篇论文一般采用这种类型），A4纸，字体为12磅，默认为10磅</span><br><span class="line">\usepackage&#123;ctexcap&#125;%采用中文标题宏包（标题是中文的）</span><br><span class="line">\usepackage&#123;graphicx&#125;</span><br><span class="line">%\usepackage&#123;ctex&#125;%采用中文字体宏包（标题是英文的）与ctexcap不能同时使用</span><br><span class="line">\usepackage&#123;float&#125;%是图片悬浮,而不是默认在一页的最上端</span><br><span class="line">\usepackage&#123;comment&#125;%使用注释环境需要的宏包</span><br><span class="line">\begin&#123;document&#125;</span><br><span class="line">  Mitola认为软件定义无线电(Software Defined Radio, SDR)是实现认知无线电的理想平台，认知无线电是SDR的智能化延伸。Mitola博士认为，认知无线电是一种智能无线通信系统，可以感知周围的通信环境，学习周围环境变化后，自适应调整内部通信规划，以适应外部环境变化，提高通信的稳定性，提高频谱的利用率。为实现认知无线电与外界环境良好的交互功能，Joseph Mitola III 博士提出了认知环的概念，如图\ref&#123;pic12&#125;所示，</span><br><span class="line">\vspace&#123;-0.1cm&#125;%用于调整与上文的间隔</span><br><span class="line">\begin&#123;figure&#125;[H]%中括号的H会让你的图处于你所插入的位置，否则的话，默认是插在一页的最上端。注意需要在导言区加入\usepackage&#123;float&#125;</span><br><span class="line">   \begin&#123;center&#125;%这里选择图片是居中对齐</span><br><span class="line">   \includegraphics[scale&#x3D;0.8]&#123;pic12.eps&#125;%scale用于将图片进行缩放，这里是缩小为原来的0.8倍。大括号内是要插入的图像文件名</span><br><span class="line">     \setlength\abovecaptionskip&#123;-0.2cm&#125;%用于调整标题前后的距离，可以自己设置来增加美观。</span><br><span class="line">      \setlength\belowcaptionskip&#123;-4cm&#125;</span><br><span class="line">   \caption&#123;Mitola博士提出的认知环\label&#123;pic12&#125;&#125;%这里是图像的标题，pic12是这个图像的标签，引用该图像时需要</span><br><span class="line"> \end&#123;center&#125;</span><br><span class="line">\end&#123;figure&#125;</span><br><span class="line"> \vspace&#123;-0.8cm&#125;%用于调整与下文的间隔</span><br><span class="line"> 在图\ref&#123;pic12&#125;中，外界激励以一种干扰的形式进入认知无线电系统，被分配到认知环中等待响应。认知无线电系统循环地经历观察、定位、计划、决定与执行五中状态，每种状态都涉及到人工智能学习。</span><br><span class="line">\end&#123;document&#125;</span><br></pre></td></tr></table></figure>
<p><strong>结果显示如下：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20140611/20140611_fig001.jpg" width="500" height="500" title="图1" alt="图1" ></p>
<p><strong>注意：</strong>上面例子中的图像文件pic21.eps是与源文件在同一目录的。但是一篇论文要插入的图可能需要很多，这是就有必要单独新建文件夹来放置图片。我在论文编写中就分别用名为figs的文件夹来保存由Matlab生成的仿真图，用名为pics的文件夹来保存用visio画的原理框图和流程图。这时，由于图片与源文件不在同一目录下，插入图片就会出错，我们可以通过在导言区写入<code>\graphicspath</code> (<strong>注意</strong>：括号里的文件夹比如pics、figs需与源文件在同一目录下，不然的话，需要写入绝对路径)来指定存储图片的目录:。</p>
<p>从上面的实例可以看出，<strong>标题中有冒号，这不是我们期望的</strong>，我们可以通过在导言区加入<code>\usepackage{caption}</code>和<code>\captionsetup{labelsep=space}</code>指定图形标题的格式：</p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20140611/20140611_fig002.jpg" width="400" height="300" title="图2" alt="图2" ></p>
<hr>
<h2 id="图像的制作"><a href="#图像的制作" class="headerlink" title="图像的制作"></a>图像的制作</h2><p>  上面主要是讲如何将已有的图片插入到LaTeX中，这里讲讲如何制作好看的图片。</p>
<p>   <strong>1、由visio画原理框图和流程图</strong></p>
<p>​    画原理框图和流程图选用微软的visio还是不错的，因为它可以插入到word和ppt中。<strong>下面介绍具体步骤：</strong></p>
<p>​    1）在visio中画你所需要的图形</p>
<p>​    2）新建word文件，直接将visio中的图形复制粘贴到word中，然后选择另存为PDF文件。</p>
<p>​    3）用Adobe Acrobat Pro打开生成的PDF，点击“文档”菜单，选择“裁剪页面”，选中“删除白边距”确定。</p>
<p>  <img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20140611/20140611_fig003.jpg" width="600" height="400" title="图3" alt="图3" ></p>
<p>4）然后将得到的文件另存为eps文件即可</p>
<p>​    <strong>注意</strong>：如果直接截图，图形为位图，放大后会失真。需要用Adobe Acrobat Pro将PDF进行修改，因此最好使用该软件，个人认为比Adobe Reader好的多。生成的PDF页面大多数地方是空白的，因此我们需要对其进行裁剪，简便起见，可以选择上面提到的“删除白边距”，当然也可以手动调整上下左右的距离。在visio中插入公式或字母：点击“插入按钮”，选择“对象”，里面有各种各样的类型包括MathType。</p>
<p>  <strong>2、由Matlab得到的仿真图</strong></p>
<p>​    由于我的毕设都是使用Matlab进行仿真的，所以这里只讲如何使用Matlab来生成我们需要的矢量图eps文件。</p>
<p>​    大多数人都是直接用截图软件对仿真图进行截图，当然这样很省事，不过前面说过，这样得到的图也是位图，放大会失真。有人会惊奇的发    现，Matlab中的另存为有另存为eps文件选项。但是，当你的图像中有中文时，就会出现乱码！</p>
<p>  <strong>仿真图如下：</strong></p>
<p>​    <img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20140611/20140611_fig004.jpg" width="500" height="400" title="图4" alt="图4" ></p>
<p><strong>如果直接另存为pdf或者eps会得到下面的图形：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20140611/20140611_fig005.jpg" width="500" height="400" title="图5" alt="图5" ></p>
<p><strong>从上面的图形可以看出，虽然得到的是矢量图，但是汉字出现乱码，并且图片不清晰。解决方案如下：</strong></p>
<p>  1、对于汉字乱码，可以使用仿真图左上方的打印按钮，打印成PDF格式即可，然后按照前文的步骤得到eps文件。</p>
<p>  2、对于生成的图像不清晰，可以在仿真的语句最后面加入下面一段：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">%%%%%%%%%%下面操作是为了图的美观%%%%%%%%%%%%%%%%</span><br><span class="line">set(get(gca,&#39;XLabel&#39;),&#39;FontSize&#39;,16,&#39;fontweight&#39;,&#39;bold&#39;);%图上文字为8 point或小5号</span><br><span class="line">set(get(gca,&#39;YLabel&#39;),&#39;FontSize&#39;,16,&#39;fontweight&#39;,&#39;bold&#39;);%图上文字为8 point或小5号</span><br><span class="line">set(get(gca,&#39;TITLE&#39;),&#39;FontSize&#39;,16,&#39;fontweight&#39;,&#39;bold&#39;);</span><br><span class="line"> </span><br><span class="line">set(gca,&#39;fontsize&#39;,16,&#39;fontweight&#39;,&#39;bold&#39;);%设置坐标轴数字的大小</span><br><span class="line">set(gca,&#39;linewidth&#39;,1.5); %坐标线粗1.5磅</span><br><span class="line">set(gca,&#39;box&#39;,&#39;on&#39;);%Controls the box around the plotting area</span><br><span class="line">set(get(gca,&#39;Children&#39;),&#39;linewidth&#39;,2);%设置图中线宽1磅</span><br><span class="line">set(gcf,&#39;color&#39;,&#39;w&#39;)</span><br></pre></td></tr></table></figure>
<p><strong>改进之后的仿真图如下：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20140611/20140611_fig006.jpg" width="500" height="400" title="图6" alt="图6" ></p>
<p><strong>上图看上去线条比较粗，不过经过打印之后就觉得十分美观了，经过打印生成的PDF或eps的图像如下：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20140611/20140611_fig007.jpg" width="500" height="400" title="图7" alt="图7" ></p>
<p>​    通过对比可以看出谁优谁劣了吧。如果觉得图像比较大，可以进行缩放，在前面插入图像这一小节中讲了如何缩小图片。由于是矢量图，缩放是不会失真的！然而论文打印之后是看不出是不是矢量图的，但是通过PDF电子版可以明显分辨。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>LaTeX Coding</tag>
      </tags>
  </entry>
  <entry>
    <title>【LaTeX排版】LaTeX论文排版&lt;二&gt;</title>
    <url>/2014/06/10/%5B20140610%5D/</url>
    <content><![CDATA[<h2 id="目录的生成"><a href="#目录的生成" class="headerlink" title="目录的生成"></a>目录的生成</h2><p>  直接使用命令<code>\tableofcontents</code>即可。其默认格式如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20140610/20140610_fig001.jpg" width="500" height="200" title="图1" alt="图1" ></p>
<a id="more"></a>
<p>我们会发现，这样的格式不一定是我们所期望的。比如说，<strong>我们也希望章标题与页码之间也有点连线，并且也希望将致谢、附录、参考文献也加进目录中</strong>。<strong>这时我们可以通过以下语句来改变目录格式</strong>：</p>
<p>首先在导言区加入包：<code>\usepackage{titletoc}</code></p>
<p>然后设置格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\titlecontents&#123;chapter&#125;%这里可以更改chapter来设置章、节</span><br><span class="line">              [0.0em]</span><br><span class="line">              &#123;\songti\zihao&#123;-4&#125;\bfseries\addvspace&#123;10bp minus 0bp&#125;&#125;  %具体参数的含义可以自己更改后看看效果</span><br><span class="line">              &#123;\thecontentslabel\hspace&#123;0.5em&#125;&#125;</span><br><span class="line">              &#123;&#125;</span><br><span class="line">              &#123;\normalfont\dotfill\textrm&#123;\contentspage[&#123;\bfseries\thecontentspage&#125;]&#125;&#125;</span><br></pre></td></tr></table></figure>
<p> 想要在目录中加入致谢、附录、参考文献，只需要在对应的子文件中加入命令<code>\addcontentsline{toc}{chapter}{这里填致谢或者是参考文献}</code></p>
<p>经过上述更改后的格式如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20140610/20140610_fig002.jpg" width="500" height="200" title="图2" alt="图2" ></p>
<h2 id="摘要的设置"><a href="#摘要的设置" class="headerlink" title="摘要的设置"></a>摘要的设置</h2><p>​    由于我们写的是中篇论文，采用的是book文类，而book文类没有自带摘要环境即不能使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\begin&#123;abstract&#125;</span><br><span class="line">        这是一个中文摘要.</span><br><span class="line">\end&#123;abstract&#125;</span><br></pre></td></tr></table></figure>
<p>​    我们只有使用<code>\chapter*{摘要}</code>以章的形式来生成摘要页，但是我们需要的是中英文摘要，而book文类默认章的起始页是在右侧，而有可能我们的中英文摘要需要在一页的正反两面，这时我们可以通过下面方法解决：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\let\zaiyao\cleardoublepage</span><br><span class="line">\let\cleardoublepage\relax</span><br><span class="line">\chapter*&#123;摘要&#125;</span><br><span class="line">这里是中文摘要部分</span><br><span class="line"></span><br><span class="line">\newpage%转到这一页的反面</span><br><span class="line"></span><br><span class="line">\chapter*&#123;Abstract&#125;</span><br><span class="line">This is English Abstract！</span><br><span class="line"></span><br><span class="line">\let\cleardoublepage\zaiyao</span><br></pre></td></tr></table></figure>
<h2 id="公式的编辑"><a href="#公式的编辑" class="headerlink" title="公式的编辑"></a>公式的编辑</h2><p>​    如果你能记住公式符号的命令的好，那使用命令来输入公式可谓是最快的方法，不过对于我为了写毕设论文而接触LaTeX的人，用命令敲公式的方法显然效率更低，我们可以通过以下方式来插入公式：</p>
<p>  1、latex只带的公式符号按钮，这个可以在工具栏找到</p>
<p>  2、使用LaTeX的在线公式编辑器来编辑，然后粘贴到文件中即可</p>
<p>  3、使用MathType来编辑公式</p>
<p>  我是采用先用MathType来编辑公式的，因为之前用过MathType，用起来比较顺手。<strong>下面说说怎么用MathType在LaTeX中输入公式</strong>：</p>
<p>  <strong>1、打开MahtType的选项菜单，选择复制和粘贴选项，设置如下图：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20140610/20140610_fig003.jpg" width="400" height="250" title="图3" alt="图3" ></p>
<p><strong>2、然后在MathType中编辑好公式，复制粘贴到latex文件中的指定位置</strong>。</p>
<p>​    <strong>需要注意的是</strong>，这时公式是默认为行间公式（前后带有[ ]）改为行内公式只需换为()，如果是放在数学公式环境中，由于已经有了数学环境，则需要去掉[ ]。这里可能说的不明白，<strong>下面举例说明</strong>：</p>
<p>源码如下：（没有写导言部分）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\begin&#123;document&#125;</span><br><span class="line"> 为了完善与巩固州际间的通信，美国议会于1934年成立了联邦通信委员会(Federal Communications Commission, FCC)来完成这一任务。FCC的职责是管理和授权美国的无线电频段，\(E &#x3D; m&#123;c^2&#125;\)例如它给广播电视系统分配了甚高频(VHF)和特高频(UHF)，\[E &#x3D; m&#123;c^2&#125;\]并对其工作方式进行约束。</span><br><span class="line"> \begin&#123;equation&#125;</span><br><span class="line">   E &#x3D; m&#123;c^2&#125;</span><br><span class="line">\end&#123;equation&#125;</span><br><span class="line">随着无线通信技术的飞速发展，世界各国也相继组建了相关部门来管理本国的无线频谱资源，例如中国的无线电管理委员会。</span><br><span class="line">\end&#123;document&#125;</span><br></pre></td></tr></table></figure>
<p>效果如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20140610/20140610_fig004.jpg" width="500" height="250" title="图4" alt="图4" ></p>
<p>​    从MathType直接复制来的内容为[E = m{c^2}]，如果需要改变公式为行内公式或带序号，则需要进行相应的更改。<strong>注意:</strong>有时MathType复制来的命令可能和LaTex的公式命令有出入，这时最好还是用LaTeX的公式按钮，我在编辑公式中，只出现过两种情况，一是上标时需要加上大括号，二是无法输入实心点。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>LaTeX Coding</tag>
      </tags>
  </entry>
  <entry>
    <title>【LaTeX排版】LaTeX论文排版&lt;一&gt;</title>
    <url>/2014/06/09/%5B20140609%5D/</url>
    <content><![CDATA[<p>本文及接下来的几篇文章主要讲关于毕设论文的排版。</p>
<h2 id="论文的整体构架"><a href="#论文的整体构架" class="headerlink" title="论文的整体构架"></a>论文的整体构架</h2><p>  <strong>学校规定论文字数不得少于15000：</strong>说明论文属于中篇论文。一般来说，中长篇论文采用book文类，短篇论文采用article文类。中篇论文的结构一般是以一章作为一个子文件，形式如下：</p>
<p>主源文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\documentclass[a4paper,12pt]&#123;book&#125;</span><br><span class="line">\usepackage&#123;ctexcap&#125;</span><br><span class="line"></span><br><span class="line">\begin&#123;document&#125;\songti\zihao&#123;-4&#125;%设置正文字体格式:宋体四号</span><br><span class="line"></span><br><span class="line">\include&#123;Abstract&#125;%摘要部分</span><br><span class="line">\tableofcontents%生成目录</span><br><span class="line"></span><br><span class="line">\include&#123;chapter1&#125;%第一章</span><br><span class="line">\include&#123;chapter2&#125;%第二章</span><br><span class="line">\include&#123;chapter3&#125;</span><br><span class="line">\include&#123;chapter4&#125;</span><br><span class="line">\include&#123;chapter5&#125;</span><br><span class="line">\include&#123;thanks&#125;  %致谢部分</span><br><span class="line">\include&#123;appendix&#125;%附录部分</span><br><span class="line"></span><br><span class="line">\include&#123;reference&#125;%参考文献部分</span><br><span class="line">\end&#123;document&#125;</span><br></pre></td></tr></table></figure>
<p>每一个include都有一个对应的源文件,由于每一章都会显示这是第几章，而摘要部分、致谢部分、附录部分及参考文献部分不是章节，且不会自动归入目录中，所以<strong>这两者的格式有些不同</strong>：</p>
<p>每一章的格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\chapter&#123;绪论&#125;</span><br><span class="line">这里是章内容</span><br><span class="line"></span><br><span class="line">摘要部分、致谢部分、附录部分及参考文献部分的格式：</span><br><span class="line">\chapter*&#123;摘要&#125;</span><br><span class="line">这里是摘要内容</span><br></pre></td></tr></table></figure>
<p>可以看出两者的区别在于是否加<em>。加</em>之后就不会将其显示为第几章，例如假设thanks.tex文件中写入<code>\chapter{致谢}</code>，那么就会显示“第六章 致谢”，这肯定不是我们所期望的。<strong>值得注意的是，各个子文件不要有导言的内容如导入各种包，也不要有<code>\begin{document}</code>和<code>\end{document}</code>，只需要写文章的内容即可</strong>。</p>
<hr>
<h2 id="论文用纸"><a href="#论文用纸" class="headerlink" title="论文用纸"></a>论文用纸</h2><p>  A4纸、页面设置：上3cm 下2cm  内侧3cm 外侧2cm 装订线1cm</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\usepackage&#123;geometry&#125;</span><br><span class="line">\geometry&#123;left&#x3D;4cm,right&#x3D;2cm,top&#x3D;3cm,bottom&#x3D;2cm&#125;%内侧3cm+装订线1cm&#x3D;4cm</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="论文字体"><a href="#论文字体" class="headerlink" title="论文字体"></a>论文字体</h2><p> 章的标题：黑体、三号</p>
<p> 节的标题：宋体、四号</p>
<p> 正文：    中文为宋体、英文为“Times News Roman” 小四 正文图表名为宋体、五号。</p>
<p><strong>具体代码如下：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\CTEXsetup[beforeskip&#x3D;&#123;0pt&#125;]&#123;chapter&#125;%这里设置的是章标题与上页边距的距离，默认时是比较大的，记得自己设置</span><br><span class="line">\CTEXsetup[nameformat&#x3D;&#123;\heiti\zihao&#123;3&#125;\centering&#125;]&#123;chapter&#125;%章标题格式</span><br><span class="line">\CTEXsetup[titleformat&#x3D;&#123;\heiti\zihao&#123;3&#125;\centering&#125;]&#123;chapter&#125;%章标题格式</span><br><span class="line">\CTEXsetup[format&#x3D;&#123;\songti\zihao&#123;4&#125;\centering&#125;]&#123;section&#125;% 节标题格式</span><br><span class="line">\CTEXsetup[format&#x3D;&#123;\songti\zihao&#123;-4&#125;&#125;]&#123;subsection&#125;%小节标题格式</span><br><span class="line">\CTEXsetup[format&#x3D;&#123;\songti\zihao&#123;-4&#125;&#125;]&#123;subsubsection&#125;%小节标题格式</span><br><span class="line"></span><br><span class="line">\usepackage&#123;mathptmx&#125; %设置英文默认为罗马体</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="字号的大小与字体"><a href="#字号的大小与字体" class="headerlink" title="字号的大小与字体"></a>字号的大小与字体</h2><p>  字体   命令</p>
<p>  宋体   <code>\songti</code></p>
<p>  黑体   <code>\heiti</code></p>
<p>  仿宋   <code>\fangsong</code></p>
<p>  楷书   <code>\kaishu</code></p>
<p>  幼圆   <code>\youyuan</code></p>
<p>  隶书   <code>\lishu</code></p>
<p>  尺寸  命令</p>
<p>  初号  <code>\zihao{0}</code></p>
<p>  小初  <code>\zihao{-0}</code></p>
<p>  一号  <code>\zihao{1}</code></p>
<p>  小一  <code>\zihao{-1}</code></p>
<p>  六号  <code>\zihao{6}</code></p>
<p>  小六  <code>\zihao{-6}</code></p>
<hr>
<h2 id="页眉页脚的设置"><a href="#页眉页脚的设置" class="headerlink" title="页眉页脚的设置"></a>页眉页脚的设置</h2><p>  <strong>页眉：宋体五号，居中排列。左面页眉为论文题目，右面页眉为章次和章标题。页眉底划线的宽度为0.75磅。页码：宋体小五，最外侧，不加任何修饰。</strong></p>
<p>具体代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\pagestyle&#123;myheadings&#125;</span><br><span class="line">\pagestyle&#123;fancy&#125;</span><br><span class="line">\fancyhead&#123;&#125;%清除页眉格式</span><br><span class="line">\fancyfoot&#123;&#125;%清除页脚格式</span><br><span class="line">\fancyhead[RO,LE]&#123;\songti\zihao&#123;-5&#125;\thepage&#125;%在奇数页右侧、偶数页左侧（也就是页面的外侧）设置页码 宋体小五。</span><br><span class="line">\fancyhead[CO]&#123;\songti\zihao&#123;5&#125;\leftmark&#125;%奇数页页眉中心设置章次和章标题</span><br><span class="line">\fancyhead[CE]&#123;\songti\zihao&#123;5&#125;复杂环境下多频段快速频谱感知技术&#125;%偶数页页眉中心设置论文的题目</span><br><span class="line">\renewcommand&#123;\headrulewidth&#125;&#123;0.75pt&#125; % 页眉与正文之间的水平线粗细</span><br><span class="line">% 设置章名和节名的显示方式</span><br><span class="line">\renewcommand&#123;\chaptermark&#125;[1]&#123;\markboth&#123;~第~\chinese&#123;chapter&#125;~章~~~#1~&#125;&#123;&#125;&#125;</span><br><span class="line">%%%%%%%%%%%</span><br><span class="line">\thispagestyle&#123;fancy&#125;%设置本页为指定的页眉页脚格式，默认情况下，每章的第一页都是没有页眉的，需要加上这一句。</span><br></pre></td></tr></table></figure>
<p>至此，西电本科生毕业设计（论文）工作手册（2012版）第9页中第二项：毕业设计的编写格式的要求就满足了。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>LaTex Coding</tag>
      </tags>
  </entry>
  <entry>
    <title>【LaTeX排版】LaTeX使用--入门基础&lt;二&gt;</title>
    <url>/2014/06/04/%5B20140604%5D/</url>
    <content><![CDATA[<p><strong>1.在命令之后留一个空格有下列方式：</strong></p>
<p>源文件如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\documentclass[a4paper,12pt]&#123;book&#125;%采用book类型（中篇论文一般采用这种类型），A4纸，字体为12磅，默认为10磅</span><br><span class="line">\usepackage&#123;ctexcap&#125;%采用中文标题宏包（标题是中文的）</span><br><span class="line">%\usepackage&#123;ctex&#125;%采用中文字体宏包（标题是英文的）与ctexcap不能同时使用</span><br><span class="line"></span><br><span class="line">\begin&#123;document&#125;</span><br><span class="line">&#123;\LaTeX&#125; 是一个排版工具 %命令行后保留空格的三种方法</span><br><span class="line">\par                    %另起一段，首行会缩进</span><br><span class="line">\LaTeX&#123;&#125; 是一个排版工具</span><br><span class="line">\newline                %另起一行，首行不会缩进  </span><br><span class="line"> \LaTeX\ 是一个排版工具%空行也是另起一行 </span><br><span class="line"></span><br><span class="line">\today                  %显示日期</span><br><span class="line"></span><br><span class="line">\end&#123;document&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p><strong>结果如下图：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20140604/20140604_fig001.jpg" width="200" height="100" title="图1" alt="图1" ></p>
<p><strong>2、注释宏包</strong></p>
<p>源文件如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\documentclass[a4paper,12pt]&#123;book&#125;%采用book类型（中篇论文一般采用这种类型），A4纸，字体为12磅，默认为10磅</span><br><span class="line">\usepackage&#123;ctexcap&#125;%采用中文标题宏包（标题是中文的）</span><br><span class="line">%\usepackage&#123;ctex&#125;%采用中文字体宏包（标题是英文的）与ctexcap不能同时使用</span><br><span class="line"></span><br><span class="line">\usepackage&#123;comment&#125;%使用注释环境需要的宏包</span><br><span class="line">\begin&#123;document&#125;</span><br><span class="line"></span><br><span class="line">\begin&#123;comment&#125;</span><br><span class="line">  这里是注释内容</span><br><span class="line">\end&#123;comment&#125;</span><br><span class="line"></span><br><span class="line">\end&#123;document&#125;</span><br></pre></td></tr></table></figure>
<p><strong>3.特殊符号的显示</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\documentclass[a4paper,12pt]&#123;book&#125;%采用book类型（中篇论文一般采用这种类型），A4纸，字体为12磅，默认为10磅</span><br><span class="line">\usepackage&#123;ctexcap&#125;%采用中文标题宏包（标题是中文的）</span><br><span class="line">%\usepackage&#123;ctex&#125;%采用中文字体宏包（标题是英文的）与ctexcap不能同时使用</span><br><span class="line"></span><br><span class="line">\usepackage&#123;comment&#125;%使用注释环境需要的宏包</span><br><span class="line">\begin&#123;document&#125;</span><br><span class="line"></span><br><span class="line">特殊字符的显示：\%\$\#\&#123;\&#125;\&amp;\^&#123;&#125;\_\~&#123;&#125;\verb&quot;\&quot;\texttt&#123;\symbol&#123;&#39;134&#125;&#125;</span><br><span class="line"></span><br><span class="line">%注意在显示&#39;^&#39;和&#39;~&#39;时后面最好带上中括号，否则会出错，显示反斜杠不能用这种在前面</span><br><span class="line">%加反斜杠的方式(\\是换行命令)，可以使用\verb&quot;\&quot;和\texttt&#123;\symbol&#123;&#39;134&#125;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">\end&#123;document&#125;</span><br></pre></td></tr></table></figure>
<p><strong>显示结果如下：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20140604/20140604_fig002.jpg" width="300" height="80" title="图2" alt="图2" ></p>
<p><strong>4、计数器的使用</strong></p>
<p>  在排版过程中，总离不开计数器的使用。论文中的每个章节、插图、表格、公式、脚注和页码等都有一个递增排序的序号，以便区分、查阅和引用。在系统中共内置了23个计数器，其中17个作为序号计数器，6个作为控制计数器。每个计数器的名称与对应的命令名或环境名相同。常见的计数器有：</p>
<p>chapter 章序号计数器</p>
<p>section 节序号计数器</p>
<p>figure  插图序号计数器</p>
<p>table   表格序号计数器</p>
<p>equation 公式序号计数器</p>
<p>page    页码计数器</p>
<p><code>\the计数器</code> 显示计数器的值，例如<code>\thepage</code>可以显示当前页码</p>
<p><strong>计数器的计数形式：</strong></p>
<p><code>\alph{计数器}</code> 用小写英文字母进行计数</p>
<p><code>\Alph{计数器}</code>用大写英文字母进行计数</p>
<p><code>\arabic{计数器}</code>用阿拉伯数字进行计数</p>
<p><code>\chinese{计数器}</code>用中文小写进行计数</p>
<p><code>\roman{计数器}</code> 用小写罗马数字计数</p>
<p><code>\Roman{计数器}</code>用大写罗马数字计数</p>
<p><strong>后注</strong>：LaTeX的功能实在是太丰富了，命令也实在是太多了，LaTaX的学习是循序渐进的过程，在使用过程在慢慢学习。后序文章我将以我在毕业设计的排版一步一步来介绍排版所遇到的问题。这样可以做到在使用中学习，而不是在记忆中学习。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>Machine Learning</tag>
      </tags>
  </entry>
  <entry>
    <title>【Matlab编程】matlab 画图</title>
    <url>/2014/05/30/%5B20140530%5D/</url>
    <content><![CDATA[<ol>
<li><p>不用截图工具就可以将图保存成图像格式，并且没有背景颜色：<code>saveas(gcf ,’outputname’,’png/jpg’)</code>，第三项省略时默认为fig.m文件</p>
<a id="more"></a>
</li>
<li><p>计算形如$(-1)^{2/3}$，应该是默认先算$(-1)^{(1/3)}$，plot的时候命令窗会警告略去了虚部, 为了避免不必要的麻烦$((-1)^2)^{1/3}$这样写,例子如下：</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clear</span><br><span class="line">clc</span><br><span class="line">subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>);</span><br><span class="line">ezplot(<span class="string">'x^2+(y-(x^2)^(1/3))^2-1'</span>,[<span class="number">-2</span>,<span class="number">2</span>]);</span><br><span class="line">subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line">ezplot(<span class="string">'x^2+(y-x^(2/3))^2-1'</span>,[<span class="number">-2</span>,<span class="number">2</span>]);</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取图片纵轴刻度间隔：<code>b=get(gca,&#39;ytick&#39;), y_tick=b(2)-b(1)</code></p>
</li>
<li><p>excel中有三列数据，第一列是横坐标，第二列是纵坐标，第三列是所要画图的点的颜色深浅，第三列的值只有一个，但是如果表示成color，需要三个值，如[0 1 0]表示纯绿色。我在程序中用的是绿色的深浅，你也可以改成别的如红色、蓝色等。<code>Plot(x,y,’*’,’color’,[0 z(i) 0])</code></p>
</li>
<li><p>画出来的总是实线穿过了这些小正方形，标识符，能不能设置成不穿过小正方形markerfacecolor 改成和你的背景颜色一样。<code>plot(0,0,&#39;-b^&#39;,&#39;visible&#39;,&#39;off&#39;)</code>;</p>
</li>
<li><p>原点在右侧：<code>set(gca,&#39;XDir&#39;,&#39;rev&#39;)</code></p>
</li>
<li><p>将第一个图和第三个图合并为一个图</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,[<span class="number">1</span> <span class="number">3</span>])</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">4</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>Ezplot应该写成函数式fplot可以写成等式，例如：<code>ezplot(&#39;exp(x)-3*x^2&#39;)</code>,不要写=0</p>
</li>
<li><p>画图纵坐标全部显示为分数（当然这个可以直接在图像上修改）：<code>set(gca,&#39;XTickLabel&#39;,{&#39;1/2&#39;,&#39;1/5&#39;,&#39;1/10&#39;,&#39;1/15&#39;,&#39;1/20&#39;})</code></p>
</li>
<li><p>ezplot()简易绘图函数，每次绘图的时候会自动清空当前坐标系 ，因此不支持<code>hold on</code>函数。例如：</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">ezplot(<span class="string">'x^2'</span>,[<span class="number">-1</span>,<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">hold</span> on</span><br><span class="line">ezplot(<span class="string">'x^2+1'</span>,[<span class="number">0</span>,<span class="number">1</span>]);</span><br></pre></td></tr></table></figure>
<p>可以修改为：</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">f=@(x)x.^<span class="number">2.</span>*(x&gt;=<span class="number">-1</span>&amp;x&lt;=<span class="number">0</span>)+(x.^<span class="number">2</span>+<span class="number">1</span>).*(x&gt;=<span class="number">0</span>&amp;x&lt;=<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>把colorbar的标度变成log型：</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clear,clc</span><br><span class="line">[x,y] = <span class="built_in">meshgrid</span>(<span class="number">0</span>:<span class="number">.1</span>:<span class="number">10</span>);</span><br><span class="line">z = <span class="number">10.</span>^((x<span class="number">-5</span>).^<span class="number">2</span>+(y<span class="number">-5</span>).^<span class="number">2</span>);</span><br><span class="line">contourf(x,y,<span class="built_in">log10</span>(z))</span><br><span class="line">h = colorbar;</span><br><span class="line">l = get(h,<span class="string">'yticklabel'</span>);</span><br><span class="line">set(h,<span class="string">'yticklabel'</span>,<span class="string">''</span>);</span><br><span class="line">t = arrayfun(@(<span class="built_in">i</span>)[<span class="string">'10^&#123;'</span> l(<span class="built_in">i</span>,:) <span class="string">'&#125;'</span>],<span class="number">1</span>:<span class="built_in">size</span>(l,<span class="number">1</span>),<span class="string">'un'</span>,<span class="built_in">false</span>);</span><br><span class="line">text(<span class="number">2.5</span>*<span class="built_in">ones</span>(<span class="built_in">size</span>(l,<span class="number">1</span>),<span class="number">1</span>),get(h,<span class="string">'ytick'</span>),t,<span class="string">'parent'</span>,h)*</span><br></pre></td></tr></table></figure>
</li>
<li><p>画立体心形：<code>ezsurf(&#39;5-sqrt(1-x^2-(y-abs(x))^2)*cos(30*(1-x^2-(y-abs(x))^2))&#39;,[-1,1,-1,2],100)</code></p>
</li>
<li><p>将横纵坐标改为天数、日期、年份等等，简便的方法就是直接在图形窗口进行可视化修改。如果画的图比较多，可以利用XTickLabel等相关程序语句编写。</p>
</li>
<li><p>坐标的标签：<code>set(gca,&#39;XTick&#39;,-pi:pi/2:pi)</code><br><code>set(gca,&#39;XTickLabel&#39;,{&#39;-pi&#39;,&#39;-pi/2&#39;,&#39;0&#39;,&#39;pi/2&#39;,&#39;pi&#39;})</code></p>
</li>
<li><p>用imagesc函数画图时，出来的图y轴坐标都是反的，解决办法：<code>axis xy</code></p>
</li>
<li><p>画五角星：</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">n=<span class="number">1</span>:<span class="number">2</span>:<span class="number">11</span>;</span><br><span class="line">x=<span class="built_in">sin</span>(<span class="number">0.4</span>*n*<span class="built_in">pi</span>);</span><br><span class="line">y=<span class="built_in">cos</span>(<span class="number">0.4</span>*n*<span class="built_in">pi</span>);</span><br><span class="line"><span class="built_in">plot</span>(x,y);</span><br><span class="line">axis([<span class="number">-1.5</span>,<span class="number">1.5</span>,<span class="number">-1.5</span>,<span class="number">1.5</span>]);</span><br><span class="line">axis square</span><br></pre></td></tr></table></figure>
</li>
</ol>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>Matlab Coding</tag>
      </tags>
  </entry>
  <entry>
    <title>【LaTeX排版】LaTeX使用--入门基础</title>
    <url>/2014/05/29/%5B20140529%5D/</url>
    <content><![CDATA[<p>​    经过两个多星期，毕业论文终于写完了。由于自己对Word软件并不是很熟悉，再加上在数模时见识过LaTex的强大之处，于是就决定用LaTex进行论文的排版。使用LaTex可以避免像Word那样换台机器而出现格式错乱的问题。</p>
<a id="more"></a>
<p>  <strong>首先，我们来讲一讲LaTex的优缺点：</strong></p>
<p>  <strong>优点：</strong></p>
<p>​     1.排版质量高： 通过LaTex可以对字距、词距、行距、段距以及版面的精确控制。当插入公式时，不会出现Word中出现的行距不同的情况。</p>
<p>​     2.具有注释功能：在写作和修改论文时，有时会将某些语句、段落和公式删除，可以事后有觉得不妥，这样在Word中恢复是很困难的(撤销操作可能将现有的内容删除)，在LaTex中可以通过注释的方式将这些内容保存下来。</p>
<p>​     3.格式自动处理：LaTex的内容处理和格式处理是分开的，我们只要选定论文的类型，那么论文整体的格式就设计好了，当然，我们也可以修改某些章节的格式。</p>
<p>​     4.数学式精美：Word中不自带公式编辑器，需要借助MathType。在LaTex中，可以自己编辑公式，并且系统可以自动为公式排序编号。</p>
<p>​     5.目录生成与超链接：目录的生成、超链接都只需要一条语句就可以完成，比Word方便的多。</p>
<p>​     6.安全稳定：在Word中如果插入的图十分多，则很打开会非常慢，有可能造成死机。在LaTex中，LaTex的源文件都是纯文本文件，所有插图都是在最后编译时才调用，所以当打开源文件是并不会出现卡机的现象。</p>
<p>​     7.通用性强：LaTex源文件经过编译生成PDF文件，而PDF是一种通用的文件格式，可以无障碍的在各个系统中运行。虽然说，Word也可以转为PDF，可以有可能出现格式错乱的问题。</p>
<p>  <strong>缺点：</strong></p>
<p>​     1.起点门槛高：不像Word那样是“所见即所得”（What You See Is What You Get,WYSIWYG），LaTex需要使用命令来进行操作，即使是编写很简单的文章，也需要花时间学习命令和使用方法。</p>
<p>​     2.可视性差：LaTex写论文需要编译生成PDF后才能看到排版结果。而且当语法不对时会出错，Debug需要自己学会判断分析，所以LaTex也被形容为“所思即所得”（What You Think Is What You Get,WYTIWYG）</p>
<p>源文件的结构：</p>
<p>  <strong>源文件分为导言和正文两部分：</strong></p>
<ul>
<li>​    <code>\documentclass[a4paper,12pt]{book}</code>到<code>\begin{document}</code>之间的所有语句都是导言；</li>
<li>​    <code>\begin{document}</code>到<code>\end{document}</code>之间的所有内容都是正文；</li>
<li>​    <code>\end{document}</code>之后的所有内容在编译时都会忽略;</li>
<li>​    导言中的任何设置命令都会对全局造成影响;</li>
<li>​    正文中的设置命令只会对该语句后面的内容造成影响;</li>
<li>​    当内容比较长时，比如写毕设论文时，我们可以以章为单位，每个子文件负责一个章节的内容，然后通过<code>\include</code>包含进来;</li>
</ul>
<p>​    注意：子文件不要有导言部分和 <code>\begin{document}</code>和<code>\end{document}</code>语句。</p>
<p><strong>下面举例说明</strong>：假设有两个文件：main.tex和chapter1.tex,内容分别如下：</p>
<p><strong>1.main.tex文件：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\documentclass[a4paper,12pt]&#123;book&#125;%采用book类型（中篇论文一般采用这种类型），A4纸，字体为12磅，默认为10磅</span><br><span class="line">\usepackage&#123;ctexcap&#125;%采用中文标题宏包（标题是中文的）</span><br><span class="line">%\usepackage&#123;ctex&#125;%采用中文字体宏包（标题是英文的）与ctexcap不能同时使用</span><br><span class="line"></span><br><span class="line">\begin&#123;document&#125;</span><br><span class="line"></span><br><span class="line">\include&#123;chapter1&#125;</span><br><span class="line"></span><br><span class="line">\end&#123;document&#125;</span><br></pre></td></tr></table></figure>
<p><strong>2.chapter1.tex文件：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Hello,\LaTeX%空一行代表另起一段，还可以使用命令\\ 和\par</span><br><span class="line"></span><br><span class="line">你好，\LaTeX</span><br></pre></td></tr></table></figure>
<p><strong>显示结果如下：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20140529/20140529_fig001.jpg" width="150" height="80" title="图1" alt="图1" ></p>
<hr>
<p><strong>如果要加上章标题的话，只需要更改chapter1.tex的内容为：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\chapter&#123;绪论&#125;</span><br><span class="line">Hello,\LaTeX</span><br><span class="line"></span><br><span class="line">你好，\LaTeX</span><br></pre></td></tr></table></figure>
<p><strong>结果显示为：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20140529/20140529_fig002.jpg" width="350" height="180" title="图2" alt="图2" ></p>
<hr>
<p><strong>如果导入的包是ctex而不是ctexcap的话，章标题会变成英文：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20140529/20140529_fig003.jpg" width="250" height="200" title="图3" alt="图3" ></p>
<hr>
<p>如果不想在表示这是第几章，我们只需要加上<code>*</code>号就可以了。<strong>由于book类型没有摘要选项，我们可以通过这种方式来加入摘要</strong>。结果显示如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20140529/20140529_fig004.jpg" width="350" height="180" title="图4" alt="图4" ></p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>LaTeX Coding</tag>
      </tags>
  </entry>
  <entry>
    <title>【Matlab编程】生日快乐歌(显示歌词)</title>
    <url>/2014/05/24/%5B20140524%5D/</url>
    <content><![CDATA[<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"> clear all</span><br><span class="line"> A4=<span class="number">440</span>;<span class="comment">%标准音A4 不同的曲调音调不同scale的取值范围不同</span></span><br><span class="line"> pt=<span class="number">44100</span>;p0=pt/<span class="number">2</span>;<span class="comment">%频率</span></span><br><span class="line"> scale=A4/<span class="number">2</span>^(<span class="number">9</span>/<span class="number">12</span>)*<span class="number">2.</span>^((<span class="number">-12</span>:<span class="number">11</span>)/<span class="number">12</span>);<span class="comment">%这里可以调节音调高低，eg：改变式子中的-12：11为0：23</span></span><br><span class="line"> map=[<span class="number">1</span> <span class="number">3</span> <span class="number">5</span> <span class="number">6</span> <span class="number">8</span> <span class="number">10</span> <span class="number">12</span> <span class="number">13</span> <span class="number">15</span> <span class="number">17</span> <span class="number">18</span> <span class="number">20</span> <span class="number">22</span> <span class="number">24</span> <span class="number">25</span>];<span class="comment">%音符，这个需要看曲谱编码</span></span><br><span class="line"> score=[<span class="number">5</span> <span class="number">5</span> <span class="number">6</span> <span class="number">5</span> <span class="number">8</span> <span class="number">7</span> <span class="number">5</span> <span class="number">5</span> <span class="number">6</span> <span class="number">5</span> <span class="number">9</span> <span class="number">8</span> <span class="number">5</span> <span class="number">5</span> <span class="number">12</span> <span class="number">10</span> <span class="number">8</span> <span class="number">7</span> <span class="number">6</span> <span class="number">6</span> <span class="number">11</span> <span class="number">11</span> <span class="number">10</span> <span class="number">8</span> <span class="number">9</span> <span class="number">8</span>];</span><br><span class="line"> rhythm=[<span class="number">0.5</span> <span class="number">0.5</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">0.5</span> <span class="number">0.5</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">2</span>  <span class="number">0.5</span> <span class="number">0.5</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span>  <span class="number">0.5</span> <span class="number">0.5</span> <span class="number">2</span> <span class="number">0.5</span> <span class="number">0.5</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">2</span>];<span class="comment">%节拍，这个需要看曲谱编码</span></span><br><span class="line"> lyric=[<span class="string">'祝你生日快乐祝你生日快乐祝你生日快乐祝你生日快乐  '</span>];</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:<span class="built_in">length</span>(score)</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">i</span>&lt;<span class="number">19</span>) </span><br><span class="line">fprintf(<span class="number">1</span>,<span class="string">'%c'</span>,lyric(<span class="built_in">i</span>))</span><br><span class="line"><span class="keyword">elseif</span> (<span class="built_in">i</span>&gt;<span class="number">20</span>) </span><br><span class="line">fprintf(<span class="number">1</span>,<span class="string">'%c'</span>,lyric(<span class="built_in">i</span><span class="number">-2</span>)) </span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">i</span>==<span class="number">6</span>||<span class="built_in">i</span>==<span class="number">12</span>||<span class="built_in">i</span>==<span class="number">18</span>)</span><br><span class="line"><span class="built_in">disp</span>(<span class="string">'!'</span>); </span><br><span class="line">fprintf(<span class="number">1</span>,<span class="string">'\n'</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">i</span>==<span class="number">26</span></span><br><span class="line"><span class="built_in">disp</span>(<span class="string">'!'</span>);</span><br><span class="line"><span class="keyword">end</span>  </span><br><span class="line">wavplay(<span class="built_in">sin</span>((<span class="number">1</span>:rhythm(<span class="built_in">i</span>)*p0)/pt*<span class="number">2</span>*<span class="built_in">pi</span>*scale(map(score(<span class="built_in">i</span>)))),pt);</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>注意：该文章是在2014年所写，代码中的wavplay函数在matlab2014之后的版本被移除，需要自己下载该函数文件，详情见<a href="https://ww2.mathworks.cn/matlabcentral/fileexchange/71798-wavplay?s_tid=srchtitle" target="_blank" rel="noopener">https://ww2.mathworks.cn/matlabcentral/fileexchange/71798-wavplay?s_tid=srchtitle</a></p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>Matlab Coding</tag>
      </tags>
  </entry>
  <entry>
    <title>【算法思想】过河问题(续)</title>
    <url>/2014/05/14/%5B20140514%5D/</url>
    <content><![CDATA[<p>​    前一篇文章用人、狗、鸡、米过河问题介绍了解决过河问题的普适解决方法以及其改进算法。本文先用该算法解决我们常见的六只老虎过河问题，然后用特殊方法解决另外一种过河问题。</p>
<a id="more"></a>
<p><strong>六只老虎过河问题：</strong></p>
<p>  <strong>问题描述</strong>：有三只大虎( A , B , C ) 和三只小虎(a , b, c) , 正好母子三对。要过一条河, 岸边有一条船, 一次最多只能载两只虎. 今知三只大虎和小虎a 能划船。限制条件是,只有自已的母虎在身边, 小虎才能与其他母虎同船、同岸或岸边遭遇, 不然会被吃掉请问怎样往返渡船, 才能使六只虎平安过河？</p>
<p>  <strong>问题分析</strong>：这是一个具有趣味性的数学问题，答案有多个，方法也可以不同。用上一篇文章中的算法来分析：我们可以用一个六维向量来表示所有可能的状态向量，用一个二维向量来表示船上状态的运算向量。过河就是这些可能的状态向量与运算向量进行异或运算。我们用前一篇文章的图论法来解决的话，就是将每一个状态向量作为图的一个顶点，如果一个状态向量能够与另一个状态向量能够通过与运算向量(有限制)相乘得到，就将这两个状态向量用一条边连接起来，这样我们就可以得到一个图。</p>
<p>  <strong>问题解决</strong>：我们可以枚举出可能的状态向量和运算向量：</p>
<p>   运算变量： c =</p>
<blockquote>
<blockquote>
<p>   1   1   0   0   0   0</p>
<p>   1   0   1   0   0   0</p>
<p>   0   1   1   0   0   0</p>
<p>   1   0   0   1   0   0</p>
<p>   0   1   0   0   1   0</p>
<p>   0   0   1   0   0   1</p>
<p>   0   0   0   1   1   0</p>
<p>   0   0   0   1   0   1</p>
<p>   1   0   0   0   0   0</p>
<p>   0   1   0   0   0   0</p>
<p>   0   0   1   0   0   0</p>
<p>   0   0   0   1   0   0</p>
</blockquote>
</blockquote>
<p>   状态向量：ab =</p>
<blockquote>
<blockquote>
<p>   1   1   1   1   1   1</p>
<p>   1   1   1   1   1   0</p>
<p>   1   1   1   1   0   1</p>
<p>   1   1   1   0   1   1</p>
<p>   1   1   1   1   0   0</p>
<p>   1   1   1   0   0   1</p>
<p>   1   1   1   0   1   0</p>
<p>   1   1   1   0   0   0</p>
<p>   1   1   0   1   1   0</p>
<p>   1   0   1   1   0   1</p>
<p>   0   1   1   0   1   1</p>
<p>   0   0   0   0   0   0</p>
<p>   0   0   0   0   0   1</p>
<p>   0   0   0   0   1   0</p>
<p>   0   0   0   1   0   0</p>
<p>   0   0   0   0   1   1</p>
<p>   0   0   0   1   1   0</p>
<p>   0   0   0   1   0   1</p>
<p>   0   0   0   1   1   1</p>
<p>   0   0   1   0   0   1</p>
<p>   0   1   0   0   1   0</p>
<p>   1   0   0   1   0   0</p>
</blockquote>
</blockquote>
<p>有了状态变量和运算变量后，我们就可以根据前面的算法构造图，然后通过图的最短路径算法求解得到，由于时间有限，并且前一篇文章已经实现，我就不再实现了。<strong>下面讲一下，算法中应该注意的地方：</strong></p>
<p> <strong>1、考虑运算变量的选取限制</strong></p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:<span class="built_in">length</span>(ab)<span class="comment">%ab是状态向量的集合</span></span><br><span class="line">    result(:,:,<span class="built_in">i</span>)=xor(<span class="built_in">repmat</span>(ab(<span class="built_in">i</span>,:),<span class="number">12</span>,<span class="number">1</span>),c);<span class="comment">%将ab(i,:)的内容复制12遍，从而与c的维数相同，并且进行异或运算</span></span><br><span class="line">    [x(<span class="built_in">i</span>,:),y(<span class="built_in">i</span>,:)]=<span class="built_in">ismember</span>(result(:,:,<span class="built_in">i</span>),ab,<span class="string">'rows'</span>);<span class="comment">%判断异或运算的结果向量是否在可能的状态变量中</span></span><br><span class="line">    <span class="comment">%下面的方法是考虑运算变量选取的限制问题</span></span><br><span class="line">    mark=[];</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">j</span>=<span class="number">1</span>:<span class="built_in">length</span>(c)</span><br><span class="line">        a1=<span class="built_in">find</span>(ab(<span class="built_in">i</span>,:));<span class="comment">%找到状态向量中为1的位置</span></span><br><span class="line">        a2=<span class="built_in">find</span>(ab(<span class="built_in">i</span>,:)==<span class="number">0</span>);<span class="comment">%找到状态向量中为0的位置</span></span><br><span class="line">        <span class="keyword">if</span>(sum(c(<span class="built_in">j</span>,a1)&gt;=<span class="number">1</span>)&amp;&amp;sum(c(<span class="built_in">j</span>,a2)&gt;=<span class="number">1</span>))<span class="comment">%这里是运算变量的限制条件</span></span><br><span class="line">            mark=[mark <span class="built_in">j</span>];<span class="comment">%将不符合条件的向量标记出来</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    x(<span class="built_in">i</span>,mark)=<span class="number">0</span>;<span class="comment">%祛除不符合的运算向量</span></span><br><span class="line">    y(<span class="built_in">i</span>,mark)=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>根据上面的程序我们可以得到哪些状态向量是可以通过运算向量进行转化的。其中y是一个$22\times 12$的矩阵：</p>
<p>y =</p>
<p>   0   0   0   11   10   9   6   7   0   0   0   4</p>
<p>   0   0   0   0   0   0   8   0   0   0   9   7</p>
<p>   0   0   0   0   0   0   0   8   0   10   0   6</p>
<p>   0   0   0   0   0   0   0   0   11   0   0   1</p>
<p>   0   0   22   0   0   0   0   0   0   0   0   8</p>
<p>  20   0   0   0   0   0   1   0   0   0   0   3</p>
<p>   0   21   0   0   0   0   0   1   0   0   0   2</p>
<p>   0   0   0   0   0   0   2   3   0   0   0   5</p>
<p>  17   0   0   21   22   1   0   0   0   0   2   0</p>
<p>   0   18   0   20   1   22   0   0   0   3   0   0</p>
<p>   0   0   16   1   20   21   0   0   4   0   0   0</p>
<p>   0   0   0   22   21   20   17   18   0   0   0   15</p>
<p>   0   0   0   0   0   0   19   0   0   0   20   18</p>
<p>   0   0   0   0   0   0   0   19   0   21   0   17</p>
<p>   0   0   0   0   0   0   0   0   22   0   0   12</p>
<p>   0   0   11   0   0   0   0   0   0   0   0   19</p>
<p>   9   0   0   0   0   0   12   0   0   0   0   14</p>
<p>   0   10   0   0   0   0   0   12   0   0   0   13</p>
<p>   0   0   0   0   0   0   13   14   0   0   0   16</p>
<p>   6   0   0   10   11   12   0   0   0   0   13   0</p>
<p>   0   7   0   9   12   11   0   0   0   14   0   0</p>
<p>   0   0   5   12   9   10   0   0   15   0   0   0</p>
<p>虽然说上面限制了运算变量的选取，但是还需要满足一个条件：<strong>奇数时，状态变量为1的位置，运算变量对应位置才可以为1；偶数时，状态变量为0的位置，运算变量对应的位置才可以为0，这里是编程需要注意的，本文中没有考虑。</strong></p>
<p><strong>2、如何构造邻接矩阵</strong></p>
<p>y(1,4)=10说明第1个状态向量可以通过与运算向量异或变成第11个运算向量。因此我们可以根据该图构造邻接矩阵。那么我们如何将上面的矩阵变成c语言形式的数组了，只需要在上面程序添加下面三句：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">fid = fopen('y.txt','wt');</span><br><span class="line"></span><br><span class="line">fprintf(fid,'&#123;%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d&#125;,\n',y');</span><br><span class="line"></span><br><span class="line">fclose(fid）</span><br></pre></td></tr></table></figure>
<p>得到的txt文件如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20140514/20140514_fig001.jpg" width="500" height="400" title="图1" alt="图1" ></p>
<p>对于该问题的结果，我就不在给出了，百度上都有结果。下面介绍比较特别的算法。</p>
<p><strong>2.商人、随从过河问题</strong></p>
<p>  <strong>问题提出：</strong>商人各带一名随从要乘一凉最多只能容纳两人的小船过河随从们密约, 在河的任何一岸只要他们的人数超过商人就杀人越货, 但乘船的安排权属于商人且商人知这项密约请你为商人制定一种安全渡河方案.</p>
<p>  <strong>问题分析：</strong>我们同样可以用前面提到的状态转移的图论算法来求解。但是我们可以根据该问题的特殊型来用巧妙的解法：我们可以用坐标轴的方法来求解。假设x轴代表商人的个数，y轴代表随从的个数，可行的状态如下坐标轴的黑点。我们的目的就是从（3，3）到(0 , 0)点。由于小船容纳两人，则在坐标轴中，表示我们可以沿坐标线走一步、或则两步。奇数步时，是将人运到对岸，岸这边的人数是减少的，因此这时只能向左走，或则向下走，偶数步时，反之亦然。图解如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20140514/20140514_fig002.jpg" width="300" height="300" title="图2" alt="图2" ></p>
<p><strong>从上图可以看出，过河方案为：(3,3)——&gt;(3,1)——&gt;(3,2)——&gt;(3,0)——&gt;(3,1)——&gt;(1,1)——&gt;(2,2)——&gt;(0,2)——&gt;(0,3)——&gt;(0,1)——&gt;(0,2)——&gt;(0,0)</strong></p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>Algorithm Design</tag>
      </tags>
  </entry>
  <entry>
    <title>【算法编程】过河问题</title>
    <url>/2014/05/08/%5B20140508%5D/</url>
    <content><![CDATA[<p>  今天偶尔想到了<strong>过河问题</strong>。记得读小学六年级的时候第一次接触到这个问题—六个老虎过河问题(百度上有详细介绍，本文解决的是一个简单的问题，下一篇文章中将讨论该问题)，当时都是从逻辑思维的方法得到正确的解决方法。<strong>本文介绍了普遍适用该类问题的方法以及该方法的改进方法，下一篇文章将介绍问题的变型及解法。</strong></p>
<a id="more"></a>
<p><strong>向量法（</strong>人、狗、鸡、米过河问题）</p>
<p>  <strong>问题描述</strong>：某人带狗、鸡、米用船来过河，只有人会划船(好像是废话，后面问题我们还会假设动物也会划船),另外至多还能载一物，当人不在时，狗要吃鸡(有人可能会质疑：狗吃鸡？，但是我看到的是狗和猫都吃小鸡)，鸡吃米。问人、狗、鸡、米怎么过河？</p>
<p>  我们用一个向量来表示人、狗、鸡、米所处的状态，例如：(1 1 1 1)表示人、狗、鸡、米都在左岸，则对应的(0 0 0 0)表示人、狗、鸡、米都在右岸。这些向量我们称为状态向量，但是由于问题的条件限制，有些状态是允许的，而有些状态是不允许的，例如(0 1 1 1)表示人不在左岸，显然是不允许的。<strong>我们可以穷举出所有允许的状态：</strong></p>
<p>​    (1 1 1 1)    (0 0 0 0)  </p>
<p>​    (1 1 1 0)    (0 0 0 1)</p>
<p>​    (1 1 0 1)    (0 0 1 0)</p>
<p>​    (1 0 1 1)    (0 1 0 0)</p>
<p>​    (1 0 1 0)    (0 1 0 1)</p>
<p><strong>从上面的允许状态中，我们可以发现规律如下：</strong></p>
<p>  当人在时（也就是第一位为1时），不能有相邻的0，例如(1 1 0 0)是不允许的</p>
<p>  当人不在时(也就是第一个为0时)，不能有相邻的1 ，例如(0 1 1 0)是不允许的</p>
<p>  我们将船的一次运载也用向量表示，例如(1 1 0 0)表示人和狗在船上。由于只有人会划船，则允许的<strong>运算向量</strong>为：</p>
<p>​    (1 1 0 0)    (1 0 1 0)    (1 0 0 1)    (1 0 0 0)</p>
<p><strong>因此我们可以将一次过河过程看成是一个状态向量与一个运算向量的异或运算（模2加运算：1+1=0 1+0=1 0+0=0）</strong>。根据上述的向量法的描述，我们可以<strong>将问题简化成</strong>：将状态(1 1 1 1)经过奇数次与运算向量运算，变成状态为(0 0 0 0)的状态转移过程。<strong>下面是过河的图解过程</strong>：</p>
<p>​     开始状态               船上状态                    结果状态</p>
<p> 1    (1 1 1 1)  ———&gt;  (1 0 1 0)   ———&gt;   (0 1 0 1)</p>
<p> 2    (0 1 0 1)  ———&gt;  (1 0 0 0)   ———&gt;   (1 1 0 1)</p>
<p> 3    (1 1 0 1)  ———&gt;  (1 0 0 1)   ———&gt;   (0 1 0 0)</p>
<p> 4     (0 1 0 0)  ———&gt;  (1 0 1 0)   ———&gt;   (1 1 1 0)</p>
<p> 5    (1 1 1 0)  ———&gt;  (1 1 0 0)   ———&gt;   (0 0 1 0)</p>
<p> 6     (0 0 1 0)  ———&gt;  (1 0 0 0)   ———&gt;   (1 0 1 0)</p>
<p> 7    (1 0 1 0)  ———&gt;  (1 0 1 0)   ———&gt;   (0 0 0 0) </p>
<p><strong>奇数次</strong>：去河对岸</p>
<p><strong>偶数次</strong>：回河这边</p>
<p><strong>注意事项：</strong></p>
<p>  在第3次过河时，开始状态为(1 1 0 1)，如果船上状态为(1 1 0 0),则结果状态为(0 0 0 1)，然后经过船上状态(1 0 0 1),结果状态为(1 0 0 0),然后经过船上状态(1 0 0 0)，就可以完成任务(总共5次过河)。<strong>但是这里存在问题</strong>：当开始状态为(0 0 0 1)，船上状态不可能为(1 0 0 1)。因为开始状态(0 0 0 1)表示只有米在左岸，船上状态(1 0 0 1)表示人和米在船上，这是不可能的！因此船上状态的选择是有限制的。奇数时，开始状态为1的位置，船上对应位置才可以为1；偶数时，开始状态为0的位置，船上对应的位置才可以为0.<strong>通俗的说</strong>：奇数时，是将有的东西运到河对岸，偶数时，是将河对岸的东西(河这边没有)运到河这边。这些数学的表述可能太麻烦，<strong>我举例说明</strong>：奇数时，当河这边只有人、狗、米，我们可以从选择人、狗上船或则人、米上船，而不能选择人、鸡上船（鸡在对岸）;当偶数次数时，河这边是狗、河对岸则是人、鸡、米，我们可以人、鸡或则人、米回到河这边，而不能选择人、狗过河。</p>
<p><strong>算法实现：</strong></p>
<p>  上面的实现可用matlab或则c来实现。若用matlab来实现，则那些状态向量以及状态间的异或运算比较容易表示；若用c来实现，则用时较短。两者的难点在于注意事项中的船上变量的选取问题。因此这种方法不适合用计算机实现，在状态变量较少的情况下，我们可以直接用手工进行运算的方法来得到结果(大家可以试试)。</p>
<p><strong>改进型算法</strong>—-图论法</p>
<p>  <strong>算法思路</strong>：将10个状态向量用10个点表示，将这10个状态向量分别与可行的运算向量进行运算，如果结果向量仍为允许的状态向量，则两者间连一条线，从而构成了一个图的问题。我们的目标是找到一条可以从状态(1 1 1 1)到状态(0 0 0 0)的通路。<strong>下面是我运算得到的图:</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20140508/20140508_fig001.jpg" width="500" height="350" title="图1" alt="图1" ></p>
<p><strong>注意：图中的标号用于表示对应的状态</strong></p>
<p><strong>具体算法实现如下：</strong></p>
<p><strong>1、Dijkstra算法</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M 20<span class="comment">//边数</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 10<span class="comment">//顶点数</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 10000</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> dist[][N],<span class="keyword">int</span> D[N],<span class="keyword">int</span> p[N],<span class="keyword">int</span> s[N])</span> </span>;</span><br><span class="line"><span class="keyword">int</span> flag[N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> flag1=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> flag2=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> startvex;</span><br><span class="line">    <span class="keyword">int</span> endvex;</span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line">&#125;edge;<span class="comment">//边的结构体</span></span><br><span class="line">edge T[M];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> dist[N][N]=&#123;&#123;<span class="number">0</span>,MAX,MAX,MAX,MAX,<span class="number">1</span>,MAX,MAX,MAX,MAX&#125;,<span class="comment">//图的邻接矩阵</span></span><br><span class="line">                    &#123;MAX,<span class="number">0</span>,MAX,MAX,MAX,MAX,<span class="number">1</span>,<span class="number">1</span>,MAX,MAX&#125;,</span><br><span class="line">                    &#123;MAX,MAX,<span class="number">0</span>,MAX,MAX,<span class="number">1</span>,<span class="number">1</span>,MAX,<span class="number">1</span>,MAX&#125;,</span><br><span class="line">                    &#123;MAX,MAX,MAX,<span class="number">0</span>,MAX,MAX,MAX,<span class="number">1</span>,<span class="number">1</span>,MAX&#125;,</span><br><span class="line">                    &#123;MAX,MAX,MAX,MAX,<span class="number">0</span>,MAX,MAX,<span class="number">1</span>,MAX,<span class="number">1</span>&#125;,</span><br><span class="line">                    &#123;<span class="number">1</span>,MAX,<span class="number">1</span>,MAX,MAX,<span class="number">0</span>,MAX,MAX,MAX,MAX&#125;,</span><br><span class="line">                    &#123;MAX,<span class="number">1</span>,<span class="number">1</span>,MAX,MAX,MAX,<span class="number">0</span>,MAX,MAX,MAX&#125;,</span><br><span class="line">                    &#123;MAX,<span class="number">1</span>,MAX,<span class="number">1</span>,<span class="number">1</span>,MAX,MAX,<span class="number">0</span>,MAX,MAX&#125;,</span><br><span class="line">                    &#123;MAX,MAX,<span class="number">1</span>,<span class="number">1</span>,MAX,MAX,MAX,MAX,<span class="number">0</span>,MAX&#125;,</span><br><span class="line">                    &#123;MAX,MAX,MAX,MAX,<span class="number">1</span>,MAX,MAX,MAX,MAX,<span class="number">0</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">int</span> D[N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> p[N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> s[N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line">    Dijkstra(<span class="number">0</span>,dist,D, p,s) ;<span class="comment">//0表示从状态(1111)开始</span></span><br><span class="line">&#125;</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> dist[][N],<span class="keyword">int</span> D[N],<span class="keyword">int</span> p[N],<span class="keyword">int</span> s[N])</span> </span></span><br><span class="line"><span class="function"> </span>&#123;     <span class="keyword">int</span> i, j, k, v1, min, max=<span class="number">10000</span>, pre;     <span class="comment">/* Max中的值用以表示dist矩阵中的值*/</span></span><br><span class="line">    v1=v; </span><br><span class="line">    <span class="keyword">for</span>( i=<span class="number">0</span>; i&lt;N; i++)              <span class="comment">/* 各数组进行初始化*/</span></span><br><span class="line">    &#123;    D[i]=dist[v1][i]; </span><br><span class="line">        <span class="keyword">if</span>( D[i] != MAX )  p[i]= v1+<span class="number">1</span>; </span><br><span class="line">        <span class="keyword">else</span> p[i]=<span class="number">0</span>; </span><br><span class="line">        s[i]=<span class="number">0</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    s[v1]=<span class="number">1</span>;                          <span class="comment">/* 将源点送U */</span></span><br><span class="line">      <span class="keyword">for</span>( i=<span class="number">0</span>; i&lt;N<span class="number">-1</span>; i++)      <span class="comment">/* 求源点到其余顶点的最短距离*/</span></span><br><span class="line">    &#123;    min=<span class="number">10001</span>;    <span class="comment">/* min&gt;max, 以保证值为的顶点也能加入U */</span></span><br><span class="line">        <span class="keyword">for</span>( j=<span class="number">0</span>; j&lt;N<span class="number">-1</span>; j++)</span><br><span class="line">              <span class="keyword">if</span> ( ( !s[j] )&amp;&amp;(D[j]&lt;min) ) <span class="comment">/* 找出到源点具有最短距离的边*/</span></span><br><span class="line">                  &#123;min=D[j]; </span><br><span class="line">                        k=j; </span><br><span class="line">                     &#125;</span><br><span class="line">                s[k]=<span class="number">1</span>;  <span class="comment">/* 将找到的顶点k送入U */</span>    </span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">0</span>; j&lt;N; j++)</span><br><span class="line">     <span class="keyword">if</span> ( (!s[j])&amp;&amp;(D[j]&gt;D[k]+dist[k][j]) ) <span class="comment">/* 调整V－U中各顶点的距离值*/</span></span><br><span class="line">        &#123;D[j]=D[k]+dist[k][j]; </span><br><span class="line">        p[j]=k+<span class="number">1</span>;                      <span class="comment">/* k是j的前趋*/</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;                               <span class="comment">/*  所有顶点已扩充到U中*/</span></span><br><span class="line">            <span class="keyword">for</span>( i=<span class="number">0</span>; i&lt;N; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">" %d : %d "</span>, D[i], i);</span><br><span class="line">                pre=p[i]; </span><br><span class="line">            <span class="keyword">while</span> ((pre!=<span class="number">0</span>)&amp;&amp;(pre!=v+<span class="number">1</span>))</span><br><span class="line">            &#123;    <span class="built_in">printf</span> (<span class="string">"&lt;- %d "</span>, pre<span class="number">-1</span>); </span><br><span class="line">                pre=p[pre<span class="number">-1</span>]; </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"&lt;-%d \n"</span>, v); </span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>结果显示如下：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20140508/20140508_fig002.jpg" width="500" height="350" title="图2" alt="图2" ></p>
<p>从上图的第七行可知，从标号为1的状态到标号为10的状态所要经过的过程为(数组下标是从0开始的)：</p>
<p>  <strong>1—-6—-3—-7—-2—-8—-5—-10</strong></p>
<p><strong>2、通过每对顶点之间的最短路径算法实现：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 10 <span class="comment">//顶点个数</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 10000</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Floyd</span><span class="params">(<span class="keyword">int</span> dist[N][N],<span class="keyword">int</span> A[N][N],<span class="keyword">int</span> path[N][N])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;N;j++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;N;k++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">/*if(A[i][j]&gt;(A[i][k]+dist[k][j]))//方法一：计算每一次矩阵</span></span><br><span class="line"><span class="comment">                &#123;</span></span><br><span class="line"><span class="comment">                    A[i][j]=(A[i][k]+dist[k][j]);</span></span><br><span class="line"><span class="comment">                    path[i][j]=path[k][j];</span></span><br><span class="line"><span class="comment">                &#125;*/</span></span><br><span class="line">                <span class="keyword">if</span>(A[i][j]&gt;(A[i][k]+A[k][j]))<span class="comment">//方法二:计算的幂次矩阵</span></span><br><span class="line">                &#123;</span><br><span class="line">                    A[i][j]=(A[i][k]+A[k][j]);</span><br><span class="line">                    path[i][j]=path[k][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> dist[N][N]=&#123;&#123;<span class="number">0</span>,MAX,MAX,MAX,MAX,<span class="number">1</span>,MAX,MAX,MAX,MAX&#125;,<span class="comment">//图的邻接矩阵</span></span><br><span class="line">                    &#123;MAX,<span class="number">0</span>,MAX,MAX,MAX,MAX,<span class="number">1</span>,<span class="number">1</span>,MAX,MAX&#125;,</span><br><span class="line">                    &#123;MAX,MAX,<span class="number">0</span>,MAX,MAX,<span class="number">1</span>,<span class="number">1</span>,MAX,<span class="number">1</span>,MAX&#125;,</span><br><span class="line">                    &#123;MAX,MAX,MAX,<span class="number">0</span>,MAX,MAX,MAX,<span class="number">1</span>,<span class="number">1</span>,MAX&#125;,</span><br><span class="line">                    &#123;MAX,MAX,MAX,MAX,<span class="number">0</span>,MAX,MAX,<span class="number">1</span>,MAX,<span class="number">1</span>&#125;,</span><br><span class="line">                    &#123;<span class="number">1</span>,MAX,<span class="number">1</span>,MAX,MAX,<span class="number">0</span>,MAX,MAX,MAX,MAX&#125;,</span><br><span class="line">                    &#123;MAX,<span class="number">1</span>,<span class="number">1</span>,MAX,MAX,MAX,<span class="number">0</span>,MAX,MAX,MAX&#125;,</span><br><span class="line">                    &#123;MAX,<span class="number">1</span>,MAX,<span class="number">1</span>,<span class="number">1</span>,MAX,MAX,<span class="number">0</span>,MAX,MAX&#125;,</span><br><span class="line">                    &#123;MAX,MAX,<span class="number">1</span>,<span class="number">1</span>,MAX,MAX,MAX,MAX,<span class="number">0</span>,MAX&#125;,</span><br><span class="line">                    &#123;MAX,MAX,MAX,MAX,<span class="number">1</span>,MAX,MAX,MAX,MAX,<span class="number">0</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">int</span> A[N][N];</span><br><span class="line">    <span class="keyword">int</span> path[N][N]=&#123;<span class="number">0</span>&#125;;<span class="comment">//给出两顶点间的路径</span></span><br><span class="line">    <span class="keyword">int</span> pre=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;N;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            A[i][j]=dist[i][j];</span><br><span class="line">            <span class="keyword">if</span>(dist[i][j]!=MAX)</span><br><span class="line">                path[i][j]=i+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                path[i][j]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;<span class="number">7</span>;k++)<span class="comment">//若用方法一，需循环N-3次，若用方法二，需要循环lg(N-1)次</span></span><br><span class="line">        Floyd(dist,A,path);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"每对顶点间的最短路径矩阵为：\n"</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;N;j++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d "</span>,A[i][j]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n每对顶点的具体最短路径为：\n"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;N;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d: %d "</span>,A[i][j],j+<span class="number">1</span>);</span><br><span class="line">        pre=path[i][j];</span><br><span class="line">        <span class="keyword">while</span>((pre!=<span class="number">0</span>)&amp;&amp;(pre!=i+<span class="number">1</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"&lt;- %d "</span>,pre);</span><br><span class="line">            pre=path[i][pre<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">" &lt;- %d\n"</span>,i+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果显示如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20140508/20140508_fig003.jpg" width="500" height="350" title="图3" alt="图3" ></p>
<p>从上图的最短路径矩阵的第一行第10列可知，从状态1到状态10需要7步，从具体最短路径的第10行可知，所要经过的过程为：</p>
<p>  <strong>1—-6—-3—-7—-2—-8—-5—-10</strong></p>
<p><strong>两种方法求得的结果相同，我们可以用图形象的表示如下：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20140508/20140508_fig004.jpg" width="500" height="350" title="图4" alt="图4" ></p>
<p><strong>通过对比可以发现，图论法实质是在向量法的基础上进行改进的算法，无论是在手动计算还是计算机实现上都比向量法更好。</strong></p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>Algorithm Coding</tag>
      </tags>
  </entry>
  <entry>
    <title>【算法思想】循环移动一个数组</title>
    <url>/2014/05/07/%5B20140507%5D/</url>
    <content><![CDATA[<p>问题：如何将一个数组循环左移或者右移k位？</p>
<p>  在下面的解决方案中，<strong>我们以循环左移为例</strong>。 我们最容易想到的是，将前k个元素复制到一个临时的数组中，然后将剩下的n-k个元素向左移动k个位置，然后将之前的k个元素复制到剩下的位置。这种方法使用了k个额外的存储空间。我们想到到另一种方法是，只借助一个临时空间，每次只向左移动1位，循环k次。这种方法产生了多于的运行时间。<strong>前面一篇文章中用程序实现了循环右移一个数组的算法。前面提到的都是比较常规的算法，下面从其它角度来考虑这一问题：</strong></p>
<a id="more"></a>
<p>  循环数组x其实就是交换数组x的子数组a、b得到b、a。例如假设数组x为int x[]={1,2,3,4,5,6,7,8,9,10}; int a[]={1,2,3,4,5}; int b[]={6,7,8,9,10};那么将x循环左移5位则是x1={6,7,8,9,10,1,2,3,4,5};显然就将数组a,b交换后进行拼接在一起。当然这里举的是特例，是为了方便理解。下面是一般情况的分析：假设数组x为int x[]={1,2,3,4,5,6,7,8,9,10}; int a[]={1,2,3,}; int b[]={4,5,6,7,8,9,10};那么将x循环左移3位则是x1={4,5,6,7,8,9,10,1,2,3};因此移动k位，我们就假设a的大小是k位，剩下是b。如果直接交换，那就和上面提到的第一中方法一样了。<strong>下面是一种新的交换方法</strong>：这里假设a的元素比b少，则将b分为两个数组bl,br，其中br与a长度相同，bl为b的左边部分，br为b的右边部分。在上面例子中，bl={4,5,6,7}，br={8,9,10}。</p>
<p>则数组x是由a，bl，br拼接而成。经过左移k位后，结果数组x1是由bl，br，a拼接而成。因此这里需要进行两步交换，首先a与br交换，变成br，bl，a；然后br与bl交换，变成bl，br，a。</p>
<p>  <strong>上面问题的重中之重是进行交换。我们还可以这样进行交换：我们定义a={1,2,3}的反为a’{3,2,1}。那么由ab变成ba,可以通过(a’b’)’得到</strong>。因此我们可以写一个求反的子函数，用于求数组中特定部分元素的反。先对a求反，再对b求反，最后对整体求反，就可以得到结果。这里需要调用求反子函数3次即可。</p>
<p>  本文提到的方法较常规的方法的优点是不用计算移动k位后应该到达的位置。本文提到的方法并不是最好的方法，只是说明我们可以这么做，遇见一个问题，我们可以找到多种方法解决。本文主要是介绍一种思路，程序比较简单，就不具体实现了。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>Algorithm Design</tag>
      </tags>
  </entry>
  <entry>
    <title>【算法编程】循环右移一个数组</title>
    <url>/2014/05/03/%5B20140503%5D/</url>
    <content><![CDATA[<p><strong>仅用一个辅助节点将一个大小为n数组循环右移k位的三种办法：</strong></p>
<p>1、时间复杂度最大：将所有元素每次只移动一位，总共移动k次，程序实现十分容易，在此就不具体实现了。</p>
<p>2、时间复杂度适中：依次将每个元素都放到辅助节点上，然后将其储存到目的节点,具体程序如下：</p>
<a id="more"></a>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n,k;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"请输入数组的维数"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">        <span class="keyword">int</span> *p=<span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">                p[i]=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"请输入移动的位数"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;k;</span><br><span class="line">        k=k%n;</span><br><span class="line">        <span class="keyword">int</span> num=gcd(n,k);</span><br><span class="line">        <span class="keyword">if</span>(num==<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> temp=p[j];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">                j=(j+k)%n;</span><br><span class="line">                temp=temp+p[j];</span><br><span class="line">                p[j]=temp-p[j];</span><br><span class="line">                temp=temp-p[j];</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;num;i++)</span><br><span class="line">                &#123;</span><br><span class="line">                        <span class="keyword">int</span> j=i;</span><br><span class="line">                        <span class="keyword">int</span> temp =p[i];</span><br><span class="line">                        <span class="keyword">for</span>(<span class="keyword">int</span> ii=<span class="number">0</span>;ii&lt;n/num;ii++)</span><br><span class="line">                        &#123;</span><br><span class="line">                                j=(j+k)%n;</span><br><span class="line">                                temp=temp+p[j];</span><br><span class="line">                                p[j]=temp-p[j];</span><br><span class="line">                                temp=temp-p[j];</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;p[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span>    <span class="comment">//欧几里得辗转相除法求两数的最大的公约数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x&lt;y)</span><br><span class="line">        <span class="keyword">return</span> gcd(y,x);</span><br><span class="line"><span class="keyword">if</span>(x%y!=<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> gcd(y,x%y);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3、时间复杂度最小，总共只移动n+1次，具体思路如下：首先将一个元素放入辅助节点，由于要移动k位，肯定有一个元素会移动到刚才的节点，以此类推，最后肯定会空余一个节点，然后将辅助节点的元素放入即可。具体程序实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n,k;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"请输入数组的维数"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">        <span class="keyword">int</span> *p=<span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">                p[i]=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"请输入移动的位数"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;k;</span><br><span class="line">        k=k%n;</span><br><span class="line">        <span class="keyword">int</span> num=gcd(n,k);</span><br><span class="line">        <span class="keyword">if</span>(num==<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">int</span> temp=p[<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)</span><br><span class="line">                &#123;</span><br><span class="line">                        p[j]=p[(j+n-k)%n];</span><br><span class="line">                        j=(j+n-k)%n;</span><br><span class="line">                &#125;</span><br><span class="line">                p[(n<span class="number">-1</span>)*(n-k)%n]=temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;num;i++)</span><br><span class="line">                &#123;</span><br><span class="line">                        <span class="keyword">int</span> j=i;</span><br><span class="line">                        <span class="keyword">int</span> temp =p[j];</span><br><span class="line">                        <span class="keyword">for</span>(<span class="keyword">int</span> ii=<span class="number">0</span>;ii&lt;n/num<span class="number">-1</span>;ii++)</span><br><span class="line">                        &#123;</span><br><span class="line">                                p[j]=p[(j-k+n)%n];</span><br><span class="line">                                j=(j-k+n)%n;</span><br><span class="line">                        &#125;</span><br><span class="line">                        p[((n/num<span class="number">-1</span>)*(n-k)+i)%n]=temp;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;p[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span>   </span></span><br><span class="line"><span class="function">        <span class="comment">//欧几里得辗转相除法求两数的最大的公约数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;y)</span><br><span class="line">                <span class="keyword">return</span> gcd(y,x);</span><br><span class="line">        <span class="keyword">if</span>(x%y!=<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> gcd(y,x%y);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>Algorithm Coding</tag>
      </tags>
  </entry>
  <entry>
    <title>【Java编程】Java中的字符串匹配</title>
    <url>/2014/04/29/%5B20140429%5D/</url>
    <content><![CDATA[<p><strong>在Java中，字符串的匹配可以使用下面两种方法：</strong></p>
<p>​    1、使用正则表达式判断字符串匹配</p>
<p>​    2、使用Pattern类和Matcher类判断字符串匹配</p>
<a id="more"></a>
<p><strong>正则表达式的字符串匹配：</strong></p>
<p>​    <strong>正则表达式</strong>：定义一组字符串的一系列字符和符号，它由常量字符和特殊符号构成。</p>
<p>​    下面是正则表达式的一些预定义字符类，实际上是一些转义字符序列：</p>
<p>​        1、\d  代表任何数字</p>
<p>​        2、\D  代表任何非数字字符</p>
<p>​        3、\w  代表任何单字字符(如：字母、数字、下划线等等)</p>
<p>​        4、\W  代表任何非单字字符</p>
<p>​        5、\s  代表任何空白字符</p>
<p>​        6、\S  代表任何非空白字符</p>
<p>​    <strong>为了匹配一组没有预定义字符类的字符，可以用[]指明</strong></p>
<p>​    正则表达式常用*、+、？等来表示匹配字符的个数</p>
<p>​        1、*  表示匹配字符个数为0个或多个</p>
<p>​        2、+  表示匹配字符个数为1个或多个</p>
<p>​        3、？ 表示匹配字符个数为0个或1个</p>
<p>​        4、{n} 表示匹配字符的个数正好为n个</p>
<p>​        5、{n,} 表示匹配字符个数至少为n个</p>
<p>​        6、{n,m} 表示匹配字符个数至少为n个，最多为m个</p>
<p>​    <strong>上面简要的介绍了正则表达式的语法，下面通过实例来说明具体用法</strong>：</p>
<p>​        定义如下的正则表达式regex:</p>
<p>​        String  regex=”[0]\d{2,3}$[-][1-9]$\d{6,7}​”</p>
<p>​        含义说明如下：</p>
<p>​            1、[0]表示字符串中第一个字符必须是0</p>
<p>​            2、\d{2,3}数字0后面最少2个数字、最多3个数字</p>
<p>​            3、[-]表明这里必须是连字符-</p>
<p>​            4、[1-9]表示只能是数字1~9</p>
<p>​            5、\d{6,7}表示这里最少6个数字，最多7个数字</p>
<p><strong>下面通过Java程序来实现下述实例</strong>：使用正则表达式判断用户输入的电子邮件地址是否有效，假设要求的格式为：大小写字母开头，后0个或则多个单字符(\w*)，然后是[@]，其后是一个或多个单字字符，接着是[.]，然后是至少两个单字字符。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> tengwei.com;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.regex.Pattern;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.swing.JOptionPane;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UseMatchesMethod</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		String input = JOptionPane.showInputDialog(<span class="string">"请输入有效的电子邮件！"</span>);</span><br><span class="line">		String reg = <span class="string">"[a-zA-Z]\\w*[@]\\w+[.]\\w&#123;2,&#125;"</span>;</span><br><span class="line">		<span class="keyword">if</span>(input.matches(reg))</span><br><span class="line">			System.out.println(<span class="string">"是有效的电子邮件！"</span>);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			System.out.println(<span class="string">"不是有效的电子邮件！"</span>);</span><br><span class="line">				</span><br><span class="line">		<span class="keyword">if</span>(Pattern.matches(reg, input))</span><br><span class="line">			System.out.println(<span class="string">"是有效的电子邮件"</span>);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			System.out.println(<span class="string">"不是有效的电子邮件！"</span>);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>使用Pattern类和Matcher类判断字符串匹配</strong></p>
<p>​    类java.util.regex.Pattern用于创建匹配模式(Pattern)和匹配器(Match)。在上面的程序中，我们使用了该类的静态方法matches(reg,input)判断input是否与给定的正则表达式匹配。<strong>对于多次匹配，需要重复调用该方法，因此对于重复匹配而言，它的效率不高</strong>。如果需要多次使用一种模式，<strong>编译一次后重用此模式比每次都调用此方法效率更高</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> tengwei.com;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.Matcher;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.Pattern;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UsePattern</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		String str=<span class="string">"We call this the live-code approach."</span></span><br><span class="line">				+<span class="string">"These examples are available from three locations-they are "</span></span><br><span class="line">				+<span class="string">"on the CD that accompanies this book"</span>;</span><br><span class="line">		Pattern expression = Pattern.compile(<span class="string">"[a-zA-Z]+"</span>);<span class="comment">//创建匹配模式</span></span><br><span class="line">		Matcher matcher=expression.matcher(str);<span class="comment">//通过匹配模式得到匹配器</span></span><br><span class="line">		<span class="comment">//通过这种方式来进行重复匹配的效率较高</span></span><br><span class="line">		String word=<span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">int</span> n=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>(matcher.find())<span class="comment">//扫描是否有匹配的子串,如果匹配器没有重置，则从当前下一个还没进行匹配的字符开始匹配</span></span><br><span class="line">		&#123;</span><br><span class="line">			word=matcher.group();<span class="comment">//得到匹配的子串</span></span><br><span class="line">			System.out.println(word+<span class="string">"\t"</span>);</span><br><span class="line">			<span class="keyword">if</span>((n+<span class="number">1</span>)%<span class="number">4</span>==<span class="number">0</span>)<span class="comment">//每行显示四个单词</span></span><br><span class="line">				System.out.println();</span><br><span class="line">			n++;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		System.out.print(<span class="string">"\n单词总数："</span>+n);</span><br><span class="line">		System.out.println(<span class="string">"\n单词字母9个及以上的单词有："</span>);</span><br><span class="line">		Pattern expression1 = Pattern.compile(<span class="string">"[a-zA-Z]&#123;9,&#125;"</span>);</span><br><span class="line">		Matcher matcher1=expression1.matcher(str);</span><br><span class="line">		<span class="keyword">while</span>(matcher1.find())</span><br><span class="line">		&#123;</span><br><span class="line">			word=matcher1.group();</span><br><span class="line">			System.out.println(word+<span class="string">"\n"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>Java Coding</tag>
      </tags>
  </entry>
  <entry>
    <title>【算法编程】随机数的不重复选择</title>
    <url>/2014/04/24/%5B20140424b%5D/</url>
    <content><![CDATA[<p>​    前一篇文章中，我们在Java中用实现两种不同接口的类，解决了不重复选择随机数的问题。现在我们在C++中，通过几种不同的算法来解决上述问题。在下面的四种算法实现中，用的随机函数都是C的库函数，这个函数产生的随机数的范围是限定的，[0, 32767]。当然我们可以通过四则运算来改变取值范围。具体的算法实现如下：</p>
<a id="more"></a>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/****************************************\</span></span><br><span class="line"><span class="comment">函数功能：从n个数中随机选择m个不同的数</span></span><br><span class="line"><span class="comment">函数输入：n为样本空间，m为选择的个数</span></span><br><span class="line"><span class="comment">函数输出：在屏幕上打印选取的数</span></span><br><span class="line"><span class="comment">算法描述：结果范围在[0,n),呈递增数列，</span></span><br><span class="line"><span class="comment">          当n比较大m比较小时，耗时较大</span></span><br><span class="line"><span class="comment">\****************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">random1</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	srand(time(<span class="literal">NULL</span>));<span class="comment">//使用这个就可以每次运行不同</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(rand()%(n-i)&lt;m)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//随机数结果按递增顺序排列</span></span><br><span class="line">			m--;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/****************************************\</span></span><br><span class="line"><span class="comment">函数功能：从n个数中随机选择m个不同的数</span></span><br><span class="line"><span class="comment">函数输入：n为样本空间，m为选择的个数</span></span><br><span class="line"><span class="comment">函数输出：在屏幕上打印选取的数</span></span><br><span class="line"><span class="comment">算法描述：结果范围在[0,n),思想简单：每生成</span></span><br><span class="line"><span class="comment">		一个随机数就检查是否与已存在的数重合</span></span><br><span class="line"><span class="comment">\****************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">random2</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> *a = <span class="keyword">new</span> <span class="keyword">int</span>[m];</span><br><span class="line">	srand(time(<span class="literal">NULL</span>));<span class="comment">//使用这个就可以每次运行不同</span></span><br><span class="line"></span><br><span class="line">	a[<span class="number">0</span>]=rand()%n;</span><br><span class="line">	<span class="keyword">int</span> temp=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">bool</span> flag=<span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;m;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		temp=rand()%n;</span><br><span class="line">		flag=<span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;i;j++)<span class="comment">//循环遍历是否有重复的数</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(temp==a[j])</span><br><span class="line">			&#123;</span><br><span class="line">				i--;</span><br><span class="line">				flag=<span class="literal">false</span>;</span><br><span class="line">				<span class="keyword">break</span>;<span class="comment">//其实这里可以用goto语句，但是goto语句不推荐使用</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(j==i&amp;&amp;flag)</span><br><span class="line">			a[i]=temp;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;m;k++)</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;a[k]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/****************************************\</span></span><br><span class="line"><span class="comment">函数功能：从n个数中随机选择m个不同的数</span></span><br><span class="line"><span class="comment">函数输入：n为样本空间，m为选择的个数</span></span><br><span class="line"><span class="comment">函数输出：在屏幕上打印选取的数</span></span><br><span class="line"><span class="comment">算法描述：结果范围在[0,n)，从已存在的数组</span></span><br><span class="line"><span class="comment">	      a中选择，当n比较大时，占用空间大</span></span><br><span class="line"><span class="comment">\****************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">random3</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> i;  </span><br><span class="line">	srand(time(<span class="literal">NULL</span>));<span class="comment">//使用这个就可以每次运行不同</span></span><br><span class="line">    <span class="keyword">int</span> *a=<span class="keyword">new</span> <span class="keyword">int</span>[n];  </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)  </span><br><span class="line">        a[i]=i;  </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;i++)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">int</span> j=i+rand()%(n-i); <span class="comment">//随机产生 [i,n-1) 的数作为数组的下标  </span></span><br><span class="line">        <span class="keyword">if</span>(i!=j)  </span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="keyword">int</span> temp=a[i];<span class="comment">//将a[i]与a[j]互换  </span></span><br><span class="line">            a[i]=a[j];  </span><br><span class="line">            a[j]=temp;  </span><br><span class="line">		<span class="comment">//	swap(a[i],a[j]);//上面三行的互换可以调用库函数</span></span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">   <span class="comment">// sort(&amp;a[0],&amp;a[m]); //进行排序</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;i++)  </span><br><span class="line">         <span class="built_in">cout</span>&lt;&lt;a[i]&lt;&lt;<span class="string">" "</span>;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">/****************************************\</span></span><br><span class="line"><span class="comment">函数功能：从n个数中随机选择m个不同的数</span></span><br><span class="line"><span class="comment">函数输入：n为样本空间，m为选择的个数</span></span><br><span class="line"><span class="comment">函数输出：在屏幕上打印选取的数</span></span><br><span class="line"><span class="comment">算法描述：结果范围在[0,n),利用set中</span></span><br><span class="line"><span class="comment">		  没有重复元素的特性</span></span><br><span class="line"><span class="comment">\****************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">random4</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; s; <span class="comment">//利用set中没有重复元素的特性</span></span><br><span class="line">	srand(time(<span class="literal">NULL</span>));<span class="comment">//使用这个就可以每次运行不同</span></span><br><span class="line">    <span class="keyword">while</span>(s.size()&lt;m)  </span><br><span class="line">        s.insert(rand()%n); <span class="comment">//若是重复元素则不插入 </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator iter=s.begin();iter!=s.end();iter++)  </span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;*iter&lt;&lt;<span class="string">" "</span>;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;RAND_MAX&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//随机数的最大范围32767</span></span><br><span class="line">	<span class="comment">//random1(6,4);</span></span><br><span class="line">	<span class="comment">//random2(6,4);</span></span><br><span class="line">	<span class="comment">//random3(6,4);</span></span><br><span class="line">	random4(<span class="number">6</span>,<span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>Algorithm Coding</tag>
      </tags>
  </entry>
  <entry>
    <title>【Java编程】随机数的不重复选择</title>
    <url>/2014/04/24/%5B20140424%5D/</url>
    <content><![CDATA[<p>   随机数的不重复选择就是从$n$个数中随机选取$m(m&lt;n)$个数。在本文中，我们用Java来实现。因此我们先介绍Java的相关知识。</p>
<p>在Java中，Java.util.Set接口和Java.util.List接口一样，都是继承自Java.util.Collection接口。但是两者有不同的特点：</p>
<ul>
<li><p><strong>List接口</strong>：一种<strong>能包含重复元素</strong>的有序集合，具体实现该接口的类有：Vector、Stack、ArrayList、LinkedList等等.</p>
</li>
<li><p><strong>Set接口</strong>：一种<strong>不包含重复元素</strong>的集合，常见的实现该接口的类有：HashSet、LinkedHashSet、TreeSet。</p>
</li>
</ul>
<a id="more"></a>
<p>​    为什么要想决解这个问题呢？因为在我仿真过程中，经常要用到随机数。比如随机的选取几个信道，随机的选取一定范围内的几个值。当然如果只是随机的选取一个值，直接用随机函数就可以了。但是当要选取多个值的时候，就可能出现重复的值（这不是我们所期望的）！<strong>下面分别通过实现上述两个接口的类来实现随机数的不重复选择。</strong></p>
<p><strong>1.用实现List接口的向量来实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> tengwei.com;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UseVector</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		Vector&lt;Integer&gt; vec=selectSeven();<span class="comment">//调用函数</span></span><br><span class="line">		Enumeration&lt;Integer&gt; enu=vec.elements();<span class="comment">//得到向量中所有元素的枚举</span></span><br><span class="line">		<span class="keyword">while</span>(enu.hasMoreElements())<span class="comment">//遍历向量中的所有元素</span></span><br><span class="line">			System.out.println(enu.nextElement()+<span class="string">"\t"</span>);</span><br><span class="line">		Object obj[]=vec.toArray();<span class="comment">//把向量vec转化为Oject数组</span></span><br><span class="line">		Arrays.sort(obj);<span class="comment">//升序排序</span></span><br><span class="line">		System.out.println(<span class="string">"升序排列后："</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;obj.length;i++)</span><br><span class="line">			System.out.println(obj[i]+<span class="string">"\t"</span>);</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/**从1-36中随机选择7个不重复的数 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Vector&lt;Integer&gt; <span class="title">selectSeven</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		Random rd= <span class="keyword">new</span> Random();<span class="comment">//创建随机数对象</span></span><br><span class="line">		Vector&lt;Integer&gt; allNum = <span class="keyword">new</span> Vector&lt;Integer&gt;();<span class="comment">//存放1-36</span></span><br><span class="line">		Vector&lt;Integer&gt; sevenNum = <span class="keyword">new</span> Vector&lt;Integer&gt;();<span class="comment">//存放选择的7个数</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">36</span>;i++)</span><br><span class="line">			allNum.add(<span class="keyword">new</span> Integer(i+<span class="number">1</span>));<span class="comment">//向向量allNum中添加36个数</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">int</span> x;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">7</span>;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			x=rd.nextInt(<span class="number">36</span>-i);<span class="comment">//得到0-（36-i）中随机数，不包含36-i</span></span><br><span class="line">			sevenNum.add(allNum.get(x));</span><br><span class="line">			allNum.remove(x);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> sevenNum;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>   本算法的基本思想就是先用Vector保存你的样本空间（36个数），然后产生一个随机数，以随机数为下标来取出样本空间的数，并且将该数从样本空间删除。<strong>该算法的缺点是原始样本空间不能有重复的数</strong>，当样本空间很大的时候，会占用很多内存空间。当然还有几种算法也可以选择，具体请查看下一篇文章。</p>
<hr>
<p><strong>2.用实现Set接口的HashSet、TreeSet类来实现</strong></p>
<p>​    首先分别介绍HashSet、TreeSet类：</p>
<p>​    <strong>HashSet类</strong>：该类实现了Set接口，由哈希表支持。它不保证集合的迭代顺序。该类不含参数的构造方法构造了一个空的哈希集，默认初始容量是16，加载因子是0.75。</p>
<p>​    <strong>TreeSet类</strong>：该类实现了Set接口的子接口SortedSet。它保证迭代器按照元素递增顺序遍历。插入该类的所有元素必须是可相互比较的,因为它必须保证递增顺序。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> tengwei.com;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UseHashSetTreeSet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		Set&lt;Integer&gt; hashset = hashSelect(<span class="number">7</span>);<span class="comment">//调用函数，返回哈希集</span></span><br><span class="line">		System.out.println(<span class="string">"HashSet中所有元素（未排列）"</span>);</span><br><span class="line">		System.out.println(<span class="string">"\t"</span>+hashset);</span><br><span class="line">		</span><br><span class="line">		SortedSet&lt;Integer&gt; treeset = treeSelect(<span class="number">7</span>);<span class="comment">//调用函数，返回数集</span></span><br><span class="line">		System.out.println(<span class="string">"TreeSet中所有元素（升序）"</span>);</span><br><span class="line">		System.out.println(<span class="string">"\t"</span>+treeset);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Set&lt;Integer&gt; <span class="title">hashSelect</span><span class="params">(<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		Random rd = <span class="keyword">new</span> Random();</span><br><span class="line">		Set&lt;Integer&gt; hs= <span class="keyword">new</span> HashSet&lt;Integer&gt;();</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">while</span>(hs.size()&lt;k)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> x=<span class="number">1</span>+rd.nextInt(<span class="number">36</span>);<span class="comment">//随机1-36之间的数，包括两边</span></span><br><span class="line">			hs.add(<span class="keyword">new</span> Integer(x));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> hs;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SortedSet&lt;Integer&gt; <span class="title">treeSelect</span><span class="params">(<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		Random rd = <span class="keyword">new</span> Random();</span><br><span class="line">		SortedSet&lt;Integer&gt; ts= <span class="keyword">new</span> TreeSet&lt;Integer&gt;();</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">while</span>(ts.size()&lt;k)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> x=<span class="number">1</span>+rd.nextInt(<span class="number">36</span>);</span><br><span class="line">			ts.add(<span class="keyword">new</span> Integer(x));<span class="comment">//当重复时不会添加</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> ts;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的算法比较简单，比较巧妙的用到了Set接口的特性。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>Java Coding</tag>
      </tags>
  </entry>
  <entry>
    <title>【Java编程】Java中的大整数计算</title>
    <url>/2014/04/20/%5B20140420%5D/</url>
    <content><![CDATA[<p>在上一篇文章中，我们实现了c语言中的大整数的运算，并且用Miller-Rabin算法实现了对大素数的测试。本来我准备用Java代码实现大整数的运算，查了一下资料发现Java中java.math的BigInteger可以实现大整数的表示和计算。BigInteger 还提供以下运算：模算术、GCD 计算、质数测试、素数生成、位操作以及一些其他操作。</p>
<a id="more"></a>
<p>下面通过程序来看看具体用法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.math.BigInteger;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BigInt</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">long</span> x=<span class="number">123456789987654321L</span>;</span><br><span class="line">		<span class="keyword">long</span> y=<span class="number">123456789999999L</span>;</span><br><span class="line">		System.out.println(<span class="string">"x*y= "</span>+(x*y));</span><br><span class="line">		</span><br><span class="line">		BigInteger bigX= <span class="keyword">new</span> BigInteger(<span class="string">"123456789987654321"</span>);</span><br><span class="line">		BigInteger bigY= <span class="keyword">new</span> BigInteger(<span class="string">"123456789999999"</span>);</span><br><span class="line">		</span><br><span class="line">		BigInteger bigXY=bigX.multiply(bigY);</span><br><span class="line">		System.out.println(<span class="string">"bigXY= "</span>+bigXY);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">boolean</span> flag=<span class="keyword">false</span>;</span><br><span class="line">		BigInteger primenum=<span class="keyword">new</span> BigInteger(<span class="string">"18446744073709551557"</span>);</span><br><span class="line">		flag=primenum.isProbablePrime(<span class="number">10</span>);<span class="comment">//参数10用于控制准确性</span></span><br><span class="line">		<span class="comment">//如果该调用返回 true，则此 BigInteger 是素数的概率超出 (1 - 1/2^10)。此方法的执行时间与此参数的值是成比例的。</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(flag==<span class="keyword">true</span>)</span><br><span class="line">			System.out.println(primenum+<span class="string">"可能是素数！"</span>);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			System.out.println(primenum+<span class="string">"肯定不是素数"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>结果显示如下：</strong></p>
<p>x*y= -2700643659534631217<br>bigXY= 15241578995579818643499602345679<br>18446744073709551557可能是素数！</p>
<p>​        通过结果我们可以看到，两个长整数相乘的结果超出了long型数据64位的表示范围，截断后的结果出现了负值。通过使用大整数类BigInteger很好的解决了这个问题。我们在前一篇文章中找到了64位的最大的可能素数是18446744073709551557 ，现在通过大整数类测试同样说明这个数是素数，这也间接说明前一篇算法实现的正确性。</p>
<p>附录：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>返回类型</th>
<th>函数名</th>
</tr>
</thead>
<tbody>
<tr>
<td>int</td>
<td><strong><a href="">getLowestSetBit</a></strong>() 返回此 BigInteger 最右端（最低位）1 比特的索引（即从此字节的右端开始到本字节中最右端 1 比特之间的 0 比特的位数）。</td>
</tr>
<tr>
<td>int</td>
<td><strong><a href="">hashCode</a></strong>() 返回此 BigInteger 的哈希码。</td>
</tr>
<tr>
<td>int</td>
<td><strong><a href="">intValue</a></strong>() 将此 BigInteger 转换为 int。</td>
</tr>
<tr>
<td>boolean</td>
<td><strong><a href="">isProbablePrime</a></strong>(int certainty) 如果此 BigInteger 可能为素数，则返回 true，如果它一定为合数，则返回 false。</td>
</tr>
<tr>
<td>long</td>
<td><strong><a href="">longValue</a></strong>() 将此 BigInteger 转换为 long。</td>
</tr>
<tr>
<td><a href="">BigInteger</a></td>
<td><strong><a href="">max</a></strong>(<a href="">BigInteger</a> val) 返回此 BigInteger 和 val 的最大值。</td>
</tr>
<tr>
<td><a href="">BigInteger</a></td>
<td><strong><a href="">min</a></strong>(<a href="">BigInteger</a> val) 返回此 BigInteger 和 val 的最小值。</td>
</tr>
<tr>
<td><a href="">BigInteger</a></td>
<td><strong><a href="">mod</a></strong>(<a href="">BigInteger</a> m) 返回其值为 (this mod m) 的 BigInteger。</td>
</tr>
<tr>
<td><a href="">BigInteger</a></td>
<td><strong><a href="">modInverse</a></strong>(<a href="">BigInteger</a> m) 返回其值为 (this-1 mod m) 的 BigInteger。</td>
</tr>
<tr>
<td><a href="">BigInteger</a></td>
<td><strong><a href="">modPow</a></strong>(<a href="">BigInteger</a> exponent, <a href="">BigInteger</a> m) 返回其值为 (thisexponent mod m) 的 BigInteger。</td>
</tr>
<tr>
<td><a href="">BigInteger</a></td>
<td><strong><a href="">multiply</a></strong>(<a href="">BigInteger</a> val) 返回其值为 (this * val) 的 BigInteger。</td>
</tr>
<tr>
<td><a href="">BigInteger</a></td>
<td><strong><a href="">negate</a></strong>() 返回其值是 (-this) 的 BigInteger。</td>
</tr>
<tr>
<td><a href="">BigInteger</a></td>
<td><strong><a href="">nextProbablePrime</a></strong>() 返回大于此 BigInteger 的可能为素数的第一个整数。</td>
</tr>
<tr>
<td><a href="">BigInteger</a></td>
<td><strong><a href="">not</a></strong>() 返回其值为 (~this) 的 BigInteger。</td>
</tr>
<tr>
<td><a href="">BigInteger</a></td>
<td><strong><a href="">or</a></strong>(<a href="">BigInteger</a> val) 返回其值为 (this &#124;  val) 的 BigInteger。</td>
</tr>
<tr>
<td><a href="">BigInteger</a></td>
<td><strong><a href="">pow</a></strong>(int exponent) 返回其值为 (thisexponent) 的 BigInteger。</td>
</tr>
<tr>
<td>static <a href="">BigInteger</a></td>
<td><strong><a href="">probablePrime</a></strong>(int bitLength, <a href="">Random</a> rnd) 返回有可能是素数的、具有指定长度的正 BigInteger。</td>
</tr>
<tr>
<td><a href="">BigInteger</a></td>
<td><strong><a href="">remainder</a></strong>(<a href="">BigInteger</a> val) 返回其值为 (this % val) 的 BigInteger。</td>
</tr>
<tr>
<td><a href="">BigInteger</a></td>
<td><strong><a href="">setBit</a></strong>(int n) 返回其值与设置了指定位的此 BigInteger 等效的 BigInteger。</td>
</tr>
<tr>
<td><a href="">BigInteger</a></td>
<td><strong><a href="">shiftLeft</a></strong>(int n) 返回其值为 (this &lt;&lt; n) 的 BigInteger。</td>
</tr>
<tr>
<td><a href="">BigInteger</a></td>
<td><strong><a href="">shiftRight</a></strong>(int n) 返回其值为 (this &gt;&gt; n) 的 BigInteger。</td>
</tr>
<tr>
<td>int</td>
<td><strong><a href="">signum</a></strong>() 返回此 BigInteger 的正负号函数。</td>
</tr>
<tr>
<td><a href="">BigInteger</a></td>
<td><strong><a href="">subtract</a></strong>(<a href="">BigInteger</a> val) 返回其值为 (this - val) 的 BigInteger。</td>
</tr>
<tr>
<td>boolean</td>
<td><strong><a href="">testBit</a></strong>(int n) 当且仅当设置了指定的位时，返回 true。</td>
</tr>
<tr>
<td>byte[]</td>
<td><strong><a href="">toByteArray</a></strong>() 返回一个 byte 数组，该数组包含此 BigInteger 的二进制补码表示形式。</td>
</tr>
<tr>
<td><a href="">String</a></td>
<td><strong><a href="">toString</a></strong>() 返回此 BigInteger 的十进制字符串表示形式。</td>
</tr>
<tr>
<td><a href="">String</a></td>
<td><strong><a href="">toString</a></strong>(int radix) 返回此 BigInteger 的给定基数的字符串表示形式。</td>
</tr>
<tr>
<td>static <a href="">BigInteger</a></td>
<td><strong><a href="">valueOf</a></strong>(long val) 返回其值等于指定 long 的值的 BigInteger。</td>
</tr>
<tr>
<td><a href="">BigInteger</a></td>
<td><strong><a href="">xor</a></strong>(<a href="">BigInteger</a> val) 返回其值为 (this ^ val) 的 BigInteger。</td>
</tr>
</tbody>
</table>
</div>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>Java Coding</tag>
      </tags>
  </entry>
  <entry>
    <title>【算法编程】基于Miller-Rabin的大素数测试</title>
    <url>/2014/04/17/%5B20140417%5D/</url>
    <content><![CDATA[<p>基本原理：</p>
<p><strong>费尔马小定理</strong>:如果$p$是一个素数,且$0&lt;a&lt;p$,则$a^{(p-1)}\%p=1$.<br>    利用费尔马小定理,对于给定的整数$n$,可以设计素数判定算法,通过计算$d=a^{(n-1)}\%n$来判断$n$的素性,当$d!=1$时,$n$肯定不是素数,当$d=1$时，$n$ 很可能是素数.</p>
<p><strong>二次探测定理</strong>:如果$p$是一个素数,且$0&lt;x&lt;p$,则方程$x^2\%p=1$的解为:$x=1$或$x=p-1$.<br>    利用二次探测定理,可以再利用费尔马小定理计算$a^{(n-1)}\%n$的过程中增加对整数$n$的二次探测,一旦发现违背二次探测条件,即得出$n$不是素数的结论.</p>
<a id="more"></a>
<p>  如果$n$是素数,则$(n-1)$必是偶数,因此可令$(n-1)=m*(2^q)$,其中$m$是正奇数(若$n$是偶数,则上面的$m\cdot(2^q)$一定可以分解成一个正奇数乘以$2$的$k$次方的形式 ),$q$是非负整数,考察下面的测试:<br>  序列:<br>     $a^m\%n$; $a^{(2m)}%n$; $a^{(4m)}\%n$;$\cdots$;$a^{(m\cdot 2^q)}\%n$</p>
<p>Miller-Rabin素性测试伪代码描述：</p>
<p>1、找出整数$k$,$q$,其中$k&gt;0$,$q$是奇数，使$(n-1=q\cdot 2^k)$。</p>
<p>2、随机选取整数$a$,$1&lt;a&lt;n-1$。</p>
<p>3、If $a^q$ mod $n=1$, printf(“该数可能是素数!\n”);</p>
<p>4、For $j=0$ to $k-1$ , if $a^{(2^j*q)}$ mod $n = n – 1$, printf(“该数可能是素数!\n”);如果步骤3、4都不成立，则printf(“该数肯定不是素数!\n”)</p>
<p>5、当该数可能是素数时，随机选取整数$a$,$1&lt;a&lt;n-1$。若多次都表明可能是素数，则我们有理由相信该数是素数。</p>
<p><strong>具体代码实现</strong>： </p>
<ol>
<li>BigInt.h文件</li>
</ol>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        BigInt.h文件C++源代码：
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _BIGNUM_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _BIGNUM_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE                128  <span class="comment">//一个大整数用个字节保存，最多表示位大整数</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE_2                   2* SIZE</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span>       UCHAR;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">short</span>      USHORT;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">UCHAR <span class="title">atox</span><span class="params">(<span class="keyword">char</span> ch)</span></span>;  <span class="comment">//将一个十六进制的字符(4位)转位数字，转换失败返回xff </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BigNum</span>  //大整数结构</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"></span><br><span class="line">UCHAR data[SIZE];  <span class="comment">//空间为(SIZE * sizeof(UCHAR))，就是SIZE个字节</span></span><br><span class="line"></span><br><span class="line">&#125;BigNum;</span><br><span class="line"></span><br><span class="line"><span class="function">BigNum <span class="title">Init</span><span class="params">(<span class="keyword">char</span> *str)</span></span>;  <span class="comment">//初始化大整数，str为十六进制字符串 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetBitFront</span><span class="params">(BigNum bignum)</span></span>; <span class="comment">//有多少bit (前面的0不算)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetBitEnd</span><span class="params">(BigNum bignum)</span></span>;  <span class="comment">//有多少0(即只算末尾的0个数) </span></span><br><span class="line"></span><br><span class="line"><span class="function">BigNum <span class="title">MovBitLetf</span><span class="params">(BigNum bignum, <span class="keyword">int</span> n)</span></span>;<span class="comment">//向左移n位</span></span><br><span class="line"></span><br><span class="line"><span class="function">BigNum <span class="title">MovBitRight</span><span class="params">(BigNum bignum, <span class="keyword">int</span> n)</span></span>;  <span class="comment">//右移n位</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Cmp</span><span class="params">(BigNum bignum_a, BigNum bignum_b)</span></span>;  <span class="comment">//大整数比较大小，&gt;返回1，&lt;返回-1，==返回0</span></span><br><span class="line"></span><br><span class="line"><span class="function">BigNum <span class="title">Mod</span><span class="params">(BigNum bignum_a, BigNum bignum_b)</span></span>;  <span class="comment">//大整数模运算</span></span><br><span class="line"></span><br><span class="line"><span class="function">BigNum <span class="title">Sub</span><span class="params">(BigNum bignum_a, BigNum bignum_b)</span></span>;  <span class="comment">//大整数减法</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print2</span><span class="params">(BigNum bignum)</span></span>; <span class="comment">//以二进制打印</span></span><br><span class="line"></span><br><span class="line"><span class="function">BigNum <span class="title">Mul</span><span class="params">(BigNum bignum_a, BigNum bignum_b)</span></span>;  <span class="comment">//大整数乘法</span></span><br><span class="line"></span><br><span class="line"><span class="function">BigNum <span class="title">Div</span><span class="params">(BigNum bignum_a, BigNum bignum_b)</span></span>;  <span class="comment">//大整数除法</span></span><br><span class="line"></span><br><span class="line"><span class="function">BigNum <span class="title">Add</span><span class="params">(BigNum bignum_a, BigNum bignum_b)</span></span>;  <span class="comment">//大整数加法</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print10</span><span class="params">(BigNum bignum)</span></span>;<span class="comment">//以十进制打印</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">b2d</span><span class="params">(BigNum bignum)</span></span>;  <span class="comment">//二进制到转十进制</span></span><br><span class="line"></span><br><span class="line"><span class="function">BigNum <span class="title">modMDyn</span><span class="params">(BigNum a, BigNum power, BigNum mod)</span></span>; <span class="comment">//求大整数幂的模</span></span><br><span class="line"></span><br><span class="line"><span class="function">BigNum <span class="title">d2b</span><span class="params">(<span class="keyword">int</span> num)</span></span>; <span class="comment">//十进制转二进制</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">checkprime</span><span class="params">(BigNum n,BigNum a)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

    </div>
</div>
<ol>
<li>BigInt.c文件：</li>
</ol>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        BigInt.c文件C++源代码：
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"BigInt.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"math.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print2</span><span class="params">(BigNum bignum)</span><span class="comment">//以二进制打印</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(GetBitFront(bignum)==<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"0\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=SIZE-GetBitFront(bignum);i&lt;SIZE;i++)</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c"</span>,bignum.data[i]);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="function">BigNum <span class="title">Init</span><span class="params">(<span class="keyword">char</span> *str)</span>  <span class="comment">//高位在0</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">BigNum bignum;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(inti=SIZE-<span class="keyword">int</span>(<span class="built_in">strlen</span>(str));i&lt;SIZE;i++)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">        bignum.data[i]=str[j];</span><br><span class="line"></span><br><span class="line">        j++;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i=SIZE-<span class="keyword">int</span>(<span class="built_in">strlen</span>(str))<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line"></span><br><span class="line">        bignum.data[i]=<span class="string">'0'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> bignum;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetBitFront</span><span class="params">(BigNum bignum)</span>  <span class="comment">//有多少bit(前面的0不算)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> BitOfBigNum = SIZE;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> ((bignum.data[i] == <span class="string">'0'</span>)&amp;&amp; (BitOfBigNum &gt; <span class="number">0</span>))</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">        i++;</span><br><span class="line"></span><br><span class="line">        BitOfBigNum--;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> BitOfBigNum;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetBitEnd</span><span class="params">(BigNum bignum)</span>  <span class="comment">//有多少0(即只算末尾的0个数)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> BitOfBigNum = SIZE;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> ((bignum.data[BitOfBigNum <span class="number">-1</span>] == <span class="string">'0'</span>) &amp;&amp; (BitOfBigNum &gt; <span class="number">0</span>))</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">        num++;</span><br><span class="line"></span><br><span class="line">        BitOfBigNum--;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> num;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="function">BigNum <span class="title">MovBitLetf</span><span class="params">(BigNum bignum, <span class="keyword">int</span> n)</span><span class="comment">//向左移n位</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> bignum_len =GetBitFront(bignum);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i =SIZE- bignum_len; i&lt;SIZE; i++)</span><br><span class="line"></span><br><span class="line">&#123;     </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i - n &lt; <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">               <span class="built_in">printf</span>(<span class="string">"ok\n"</span>);</span><br><span class="line"></span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        bignum.data[i - n] =bignum.data[i];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = SIZE- n; i &lt;SIZE; i++)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">        bignum.data[i] =<span class="string">'0'</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> bignum;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="function">BigNum <span class="title">MovBitRight</span><span class="params">(BigNum bignum, <span class="keyword">int</span> n)</span> <span class="comment">//右移n位</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> bignum_len =GetBitFront(bignum);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = SIZE - <span class="number">1</span>; i &gt;=SIZE-bignum_len; i--)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i&lt;<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        bignum.data[i] =bignum.data[i-n];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i =<span class="number">0</span>; i &lt;SIZE-bignum_len;i++)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">        bignum.data[i] = <span class="string">'0'</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> bignum;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Cmp</span><span class="params">(BigNum bignum_a, BigNum bignum_b)</span>  <span class="comment">//大整数比较大小，&gt;返回1，&lt;返回-1，==返回0</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> bignum_a_len =GetBitFront(bignum_a);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> bignum_b_len =GetBitFront(bignum_b);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(bignum_a_len&gt;bignum_b_len)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(bignum_a_len&lt;bignum_b_len)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(bignum_a_len=bignum_b_len)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> max = bignum_a_len;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i =SIZE-max; i&lt;SIZE; i++)</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">               <span class="keyword">if</span> (bignum_a.data[i]&gt; bignum_b.data[i])</span><br><span class="line"></span><br><span class="line">               &#123;</span><br><span class="line"></span><br><span class="line">                      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               <span class="keyword">if</span> (bignum_a.data[i]&lt; bignum_b.data[i])</span><br><span class="line"></span><br><span class="line">               &#123;</span><br><span class="line"></span><br><span class="line">                      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="function">BigNum <span class="title">Sub</span><span class="params">(BigNum bignum_a, BigNum bignum_b)</span>  <span class="comment">//大整数减法</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">BigNum bignum_c;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> temp=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> temp1=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = SIZE<span class="number">-1</span>; i &gt;=<span class="number">0</span>; i--)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">        temp = bignum_a.data[i] -bignum_b.data[i] -carry;</span><br><span class="line"></span><br><span class="line">        temp1=temp;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(temp==<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">               temp1=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(temp==<span class="number">-2</span>)</span><br><span class="line"></span><br><span class="line">               temp1=<span class="number">0</span>;     </span><br><span class="line"></span><br><span class="line">        bignum_c.data[i] =temp1+<span class="number">48</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(temp&lt;<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        carry=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line"></span><br><span class="line">        carry=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        j++;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> bignum_c;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="function">BigNum <span class="title">Mod</span><span class="params">(BigNum bignum_a, BigNum bignum_b)</span>  <span class="comment">//大整数模运算</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">BigNum bignum_c =Init(<span class="string">"0"</span>);</span><br><span class="line"></span><br><span class="line">BigNum B;</span><br><span class="line"></span><br><span class="line">B = bignum_b;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> bignum_a_len;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> bignum_b_len;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> bignum_c_len;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (Cmp(bignum_b, bignum_c) == <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"错误！除数为\n"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> bignum_c;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bignum_a_len =GetBitFront(bignum_a);</span><br><span class="line"></span><br><span class="line">bignum_b_len =GetBitFront(bignum_b);</span><br><span class="line"></span><br><span class="line">bignum_c_len = bignum_a_len -bignum_b_len;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (bignum_c_len &gt;= <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">&#123;  </span><br><span class="line"></span><br><span class="line">        B = MovBitLetf(bignum_b,bignum_c_len);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> m=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        m=Cmp(bignum_a, B);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (Cmp(bignum_a, B) !=<span class="number">-1</span>)<span class="comment">//大于等于</span></span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">               bignum_a =Sub(bignum_a, B);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        bignum_c_len--; </span><br><span class="line"></span><br><span class="line">&#125;     </span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> bignum_a;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="function">BigNum <span class="title">Mul</span><span class="params">(BigNum bignum_a, BigNum bignum_b)</span>  <span class="comment">//大整数乘法</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">BigNum bignum_c =Init(<span class="string">"0"</span>);</span><br><span class="line"></span><br><span class="line">BigNum bignum=Init(<span class="string">"0"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> wei=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">wei=GetBitFront(bignum_a)+GetBitFront(bignum_b)<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> carry[SIZE_2];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> carry1[SIZE_2];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> mod[SIZE_2];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;=SIZE_2;k++)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">        carry[k]=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        carry1[k]=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        mod[k]=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i=SIZE<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(j=SIZE<span class="number">-1</span>;j&gt;=<span class="number">0</span>;j--)</span><br><span class="line"></span><br><span class="line">          carry[i+j+<span class="number">1</span>]=(bignum_a.data[i]<span class="number">-48</span>)*(bignum_b.data[j]<span class="number">-48</span>)+carry[i+j+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(k=SIZE_2<span class="number">-1</span>;k&gt;=<span class="number">0</span>;k--)</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span>(k==SIZE_2<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">                 carry1[k]=carry[k];  </span><br><span class="line"></span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line"></span><br><span class="line">                 carry1[k]=carry1[k+<span class="number">1</span>]/<span class="number">2</span>+carry[k];</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">       </span><br><span class="line"></span><br><span class="line">        wei=GetBitFront(bignum_a)+GetBitFront(bignum_b)<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        bignum=d2b(carry1[SIZE_2-wei]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(i=SIZE<span class="number">-1</span>,j=SIZE_2-wei;i&gt;=<span class="number">0</span>&amp;&amp;j&gt;=<span class="number">0</span>;i--,j--)</span><br><span class="line"></span><br><span class="line">              carry1[j]=bignum.data[i]<span class="number">-48</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(k=<span class="number">0</span>;k&lt;SIZE_2;k++)</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span>(carry1[k]!=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">                 <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">         </span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(i=SIZE<span class="number">-1</span>,j=SIZE_2<span class="number">-1</span>;j&gt;=k;i--,j--)</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">               bignum_c.data[i]=carry1[j]%<span class="number">2</span>+<span class="number">48</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> bignum_c;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="function">BigNum <span class="title">Div</span><span class="params">(BigNum bignum_a, BigNum bignum_b)</span>  <span class="comment">//大整数除法</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">BigNum bignum_c =Init(<span class="string">"0"</span>);</span><br><span class="line"></span><br><span class="line">BigNum B;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> bignum_a_len;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> bignum_b_len;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> bignum_c_len;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (Cmp(bignum_b, bignum_c) == <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"错误！除数为\n"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> bignum_c;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bignum_a_len =GetBitFront(bignum_a);</span><br><span class="line"></span><br><span class="line">bignum_b_len = GetBitFront(bignum_b);</span><br><span class="line"></span><br><span class="line">bignum_c_len = bignum_a_len -bignum_b_len;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (bignum_c_len &gt;= <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">        B = MovBitLetf(bignum_b,bignum_c_len);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (Cmp(bignum_a, B) !=<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">               bignum_a =Sub(bignum_a, B);</span><br><span class="line"></span><br><span class="line">               bignum_c.data[SIZE<span class="number">-1</span>-bignum_c_len]++;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        bignum_c_len--;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> bignum_c;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="function">BigNum <span class="title">Add</span><span class="params">(BigNum bignum_a, BigNum bignum_b)</span>  <span class="comment">//大整数加法</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">BigNum bignum_c;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> temp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = SIZE<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">        temp = bignum_a.data[i]<span class="number">-48</span>+ bignum_b.data[i]<span class="number">-48</span> + carry;</span><br><span class="line"></span><br><span class="line">       </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(temp==<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">               temp=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            carry=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(temp==<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">               temp=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">               carry=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span> carry=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        bignum_c.data[i] = temp+<span class="number">48</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> bignum_c;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">b2d</span><span class="params">(BigNum bignum)</span> <span class="comment">//二进制转十进制</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">n=GetBitFront(bignum);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=SIZE<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">        result=result+(bignum.data[i]<span class="number">-48</span>)*<span class="built_in">pow</span>(<span class="number">2</span>,j);</span><br><span class="line"></span><br><span class="line">        j++;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print10</span><span class="params">(BigNum bignum)</span>  <span class="comment">//打印十进制大整数</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> temp[SIZE];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> j;</span><br><span class="line"></span><br><span class="line">BigNum c;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (Cmp(bignum,Init(<span class="string">"0"</span>)) == <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">        c=Mod(bignum,Init(<span class="string">"1010"</span>));</span><br><span class="line"></span><br><span class="line">        temp[i] = b2d(c);</span><br><span class="line"></span><br><span class="line">        bignum = Div(bignum,Init(<span class="string">"1010"</span>));</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">        i++;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>,temp[j]);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BigNum <span class="title">modMDyn</span><span class="params">(BigNum a, BigNum power, BigNum mod)</span> <span class="comment">//求大整数幂的模 </span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"></span><br><span class="line">   BigNum temp;</span><br><span class="line"></span><br><span class="line">   BigNum result;</span><br><span class="line"></span><br><span class="line">   BigNum t1;</span><br><span class="line"></span><br><span class="line">   temp=Mod(a,mod);</span><br><span class="line"></span><br><span class="line">   result=Init(<span class="string">"1"</span>);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span>(inti=SIZE<span class="number">-1</span>;i&gt;=SIZE-GetBitFront(power);i--)</span><br><span class="line"></span><br><span class="line">   &#123;</span><br><span class="line"></span><br><span class="line">               <span class="keyword">if</span>(power.data[i]==<span class="string">'1'</span>)</span><br><span class="line"></span><br><span class="line">               &#123;     </span><br><span class="line"></span><br><span class="line">                      t1=Mul(result,temp);</span><br><span class="line"></span><br><span class="line">                   result=Mod(Mul(result,temp),mod);</span><br><span class="line"></span><br><span class="line">               &#125;     </span><br><span class="line"></span><br><span class="line">               temp=Mod(Mul(temp,temp),mod);</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> result; </span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function">BigNum <span class="title">d2b</span><span class="params">(<span class="keyword">int</span> num)</span> <span class="comment">//十进制转二进制</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">BigNum bignum;</span><br><span class="line"></span><br><span class="line">bignum=Init(<span class="string">"0"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> b=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(num&gt;<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">        a=num%<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        num=num/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        bignum.data[SIZE-i]=a+<span class="number">48</span>;</span><br><span class="line"></span><br><span class="line">        i++;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> bignum;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">checkprime</span><span class="params">(BigNum n,BigNum a)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">BigNum k;</span><br><span class="line"></span><br><span class="line">BigNum q;</span><br><span class="line"></span><br><span class="line"><span class="comment">//     BigNum a;</span></span><br><span class="line"></span><br><span class="line">BigNum n1;<span class="comment">//n1=n-1</span></span><br><span class="line"></span><br><span class="line">BigNum num1;<span class="comment">//num1为常数1</span></span><br><span class="line"></span><br><span class="line">BigNum num2;<span class="comment">//num2为常数2</span></span><br><span class="line"></span><br><span class="line">BigNum k2;<span class="comment">//2^k</span></span><br><span class="line"></span><br><span class="line">BigNum k22;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> k1=<span class="number">0</span>; <span class="comment">//末尾0的个数</span></span><br><span class="line"></span><br><span class="line">num1=Init(<span class="string">"1"</span>);</span><br><span class="line"></span><br><span class="line">num2=Init(<span class="string">"10"</span>);</span><br><span class="line"></span><br><span class="line">k=Init(<span class="string">"0"</span>);</span><br><span class="line"></span><br><span class="line">q=Init(<span class="string">"0"</span>);</span><br><span class="line"></span><br><span class="line">n1=Init(<span class="string">"0"</span>);</span><br><span class="line"></span><br><span class="line">k22=Init(<span class="string">"10"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//     a=Init("1010");//选择的数</span></span><br><span class="line"></span><br><span class="line">n1=Sub(n,num1);</span><br><span class="line"></span><br><span class="line">k1=GetBitEnd(n1);</span><br><span class="line"></span><br><span class="line">k=d2b(k1);</span><br><span class="line"></span><br><span class="line">q=MovBitRight(n1,k1);</span><br><span class="line"></span><br><span class="line">k2=Div(n1,q);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(Cmp(modMDyn(a,q,n),num1)==<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    print2(n);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//    printf("该数可能是素数!\n");</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;b2d(k);i++)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">        k22=MovBitLetf(num1,i);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(Cmp(modMDyn(a,Mul(k22,q),n),n1)==<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//           print2(n);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//           printf("该数可能是素数!\n");</span></span><br><span class="line"></span><br><span class="line">               <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">print10(n);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"该数肯定不是素数!\n"</span>);</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span><span class="comment">//主函数的内容可以根据你自己的需求编写！</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">BigNum n;<span class="comment">//n为要判断的素数</span></span><br><span class="line"></span><br><span class="line">BigNum k;</span><br><span class="line"></span><br><span class="line">BigNum q;</span><br><span class="line"></span><br><span class="line">BigNum a;</span><br><span class="line"></span><br><span class="line">BigNum n1;<span class="comment">//n1=n-1</span></span><br><span class="line"></span><br><span class="line">BigNum num1;<span class="comment">//num1为常数1</span></span><br><span class="line"></span><br><span class="line">BigNum num2;<span class="comment">//num2为常数2</span></span><br><span class="line"></span><br><span class="line">BigNum k2;<span class="comment">//2^k</span></span><br><span class="line"></span><br><span class="line">BigNum k22;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> k1=<span class="number">0</span>; <span class="comment">//末尾0的个数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> flag=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> aa=<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">num1=Init(<span class="string">"1"</span>);</span><br><span class="line"></span><br><span class="line">num2=Init(<span class="string">"10"</span>);</span><br><span class="line"></span><br><span class="line">k=Init(<span class="string">"0"</span>);</span><br><span class="line"></span><br><span class="line">q=Init(<span class="string">"0"</span>);</span><br><span class="line"></span><br><span class="line">n1=Init(<span class="string">"0"</span>);</span><br><span class="line"></span><br><span class="line">k22=Init(<span class="string">"10"</span>);</span><br><span class="line"></span><br><span class="line">a=Init(<span class="string">"1010"</span>);<span class="comment">//选择的数</span></span><br><span class="line"></span><br><span class="line">n=Init(<span class="string">"1111111111111111111111111111111111111111111111111111111111111111"</span>);<span class="comment">//最大的64bit数 a可以设128bit内的值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//     n=Init("1111");</span></span><br><span class="line"></span><br><span class="line"> srand(time(<span class="literal">NULL</span>));</span><br><span class="line"></span><br><span class="line">n1=Sub(n,Mul(num2,num1));</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> kk=<span class="number">0</span>;kk&lt;<span class="number">30</span>;kk++)<span class="comment">//这里可以自己设置循环次数</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">n=Sub(n,Mul(num2,num1));<span class="comment">//n每次-2</span></span><br><span class="line"></span><br><span class="line">print10(n);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"第%d次：\n"</span>,kk);</span><br><span class="line"></span><br><span class="line">flag=checkprime(n,a);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(flag==<span class="number">1</span>&amp;&amp;i&lt;<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">        i++;</span><br><span class="line"></span><br><span class="line">        print10(n);</span><br><span class="line"></span><br><span class="line">        aa=rand()%<span class="number">10</span>+<span class="number">5</span>;<span class="comment">//注意!n必须大于a</span></span><br><span class="line"></span><br><span class="line">        a=d2b(aa);</span><br><span class="line"></span><br><span class="line">        flag=checkprime(n,a);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"ok%d\n"</span>,aa);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(i==<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">        i=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        print10(n);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"该数肯定是素数!\n"</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">&#125;      </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </div>
</div>
<p>运行结果如下：</p>
<p>  <img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20140417/20140417_fig001.jpg" width="600" height="450" title="图1" alt="图1" ></p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>Algorithm Coding</tag>
      </tags>
  </entry>
  <entry>
    <title>【Java编程】Java基本数据类型</title>
    <url>/2014/04/13/%5B20140413%5D/</url>
    <content><![CDATA[<p>​    在较前面的一篇博文<a href="http://blog.csdn.net/tengweitw/article/details/8891754" target="_blank" rel="noopener">《C/C++基本数据类型》</a>中，我主要介绍了c/c++的基本数据类型。我们知道C语言没有具体规定各类数据类型所占内存的字节数，只要求long型数据长度不小于int型，short型不大于int型。具体的实现如何，由各计算机系统自行决定。</p>
<p>​    一般情况下，在Turbo C++中，int型和short型都是16位，而long型是32位。而有的c语言编译器给short型分配16位，而int型和long型分配32位。通常的做法是：把long型定为32位，把short型定为16位，而int型可以为16位，也可以是32位。</p>
<a id="more"></a>
<p>​    相比C语言而言，Java的8种基本数据类型的长度与平台无关。因此Java语言具有 “一次编译，到处运行” 的优点。本文主要介绍Java的基本数据类型。<strong>Java语言的基本数据类型总共有以下8种，下面是按照用途划分出的4个类别：</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>类型名</th>
<th>关键字</th>
</tr>
</thead>
<tbody>
<tr>
<td>整数型</td>
<td>byte  short  int  long</td>
</tr>
<tr>
<td>小数型</td>
<td>float         double</td>
</tr>
<tr>
<td>字符型</td>
<td>char</td>
</tr>
<tr>
<td>布尔型</td>
<td>boolean</td>
</tr>
</tbody>
</table>
</div>
<hr>
<p><strong>下面分别介绍这4种类别：</strong></p>
<p><strong>1.整数型</strong></p>
<p>​    整数型是一类代表整数值的类型。当需要代表一个整数的值时，可以根据需要从4种类型中挑选合适的，如果没有特殊要求的话，一般选择int类型。4种整数型区别主要在每个数据在内存中占用的空间大小和代表的数值的范围。具体说明参看下表： </p>
<div class="table-container">
<table>
<thead>
<tr>
<th>类型名称</th>
<th>关键字</th>
<th>占用字节</th>
<th>取值范围</th>
<th>默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td>字节型</td>
<td>byte</td>
<td>1</td>
<td>$-2^7\sim 2^7-1$</td>
<td>0</td>
</tr>
<tr>
<td>短整型</td>
<td>short</td>
<td>2</td>
<td>$-2^{15}\sim 2^{15}-1$</td>
<td>0</td>
</tr>
<tr>
<td>整型</td>
<td>int</td>
<td>4</td>
<td>$-2^{31}\sim 2^{31}-1$</td>
<td>0</td>
</tr>
<tr>
<td>长整型</td>
<td>long</td>
<td>8</td>
<td>$-2^{63}\sim 2^{63}-1$</td>
<td>0</td>
</tr>
</tbody>
</table>
</div>
<p> <strong>说明</strong>：</p>
<ul>
<li>Java中的整数都是有符号数，也就是有正有负。</li>
<li>默认值指在特定的情况下才自动初始化，具体的情况后续将有叙述。</li>
<li>程序中的整数数值默认是int以及int以下类型，如果需要书写long型的值，则需要在数值后面添加字母L，大小写均可。</li>
</ul>
<p><strong>2.小数型</strong></p>
<p>​    小数型是一类代表小数值的类型。当需要代表一个小数的值时，可以根据需要从以下2种类型中挑选合适的。如果没有特殊要求，一般选择double类型。由于小数的存储方式和整数不同，所以小数都有一定的精度，所以在计算机中运算时不够精确。根据精度和存储区间的不同，设计了两种小数类型，具体见下表：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>类型名称</th>
<th>关键字</th>
<th>占用字节</th>
<th>取值范围</th>
<th>默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td>单精度</td>
<td>float</td>
<td>4</td>
<td>$-3.4\cdot 10^{+38}\sim 3.4\cdot 10^{+38}$</td>
<td>0.0f</td>
</tr>
<tr>
<td>双精度</td>
<td>double</td>
<td>8</td>
<td>$-1.7\cdot 10^{+308}\sim 1.7\cdot 10^{+308}$</td>
<td>0.0</td>
</tr>
</tbody>
</table>
</div>
<p> <strong>说明：</strong></p>
<ul>
<li>取值范围以科学计数法形式进行描述。</li>
<li>在程序中，小数的运算速度要低于整数运算。</li>
<li>float类型的小数，需要在小数后加字母f，不区分大小写，例如1.01f。</li>
</ul>
<p><strong>3.字符型</strong></p>
<p>​    字符型代表特定的某个字符，按照前面介绍的知识，计算机中都是以字符集的形式来保存字符的，所以字符型的值实际只是字符集中的编号，而不是实际代表的字符，由计算机完成从编号转换成对应字符的工作。<strong>Java语言中为了更加方便国际化，使用Unicode字符集作为默认的字符集</strong>，该字符集包含各种语言中常见的字符。在程序代码中，字符使用一对单引号加上需要表达的字符来标识，例如”A”, “a”等，当然也可以直接使用字符编码，也就是一个非负整数进行表示。具体见下表：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>类型名称</th>
<th>关键字</th>
<th>占用字节</th>
<th>取值范围</th>
<th>默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td>字符型</td>
<td>char</td>
<td>2</td>
<td>$0\sim 2^{16}-1$</td>
<td>0</td>
</tr>
</tbody>
</table>
</div>
<p>  <strong>说明</strong>：</p>
<ul>
<li>字符型的编号中不包含负数。</li>
<li>字符型由于存储的是编号的数值，所以可以参与数学运算。</li>
<li>字符型可以作为Java语言中的无符号整数使用。</li>
<li>字符型的默认值是编号为0的字符，而不是字符0</li>
</ul>
<p><strong>4.布尔型</strong></p>
<p>​    布尔型代表逻辑中的成立和不成立。Java语言中使用关键字true代表成立，false代表不成立。布尔型是存储逻辑值的类型，其实很多程序中都有逻辑值的概念，Java把逻辑的值用布尔型来进行表达。具体见下表：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>类型名称</th>
<th>关键字</th>
<th>占用字节</th>
<th>取值范围</th>
<th>默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td>布尔型</td>
<td>boolean</td>
<td></td>
<td>true or false</td>
<td>false</td>
</tr>
</tbody>
</table>
</div>
<div class="table-container">
<table>
<thead>
<tr>
<th>类型名称</th>
<th>关键字</th>
<th>占用空间(字节)</th>
<th>取值范围</th>
<th>默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td>布尔型</td>
<td>boolean</td>
<td></td>
<td>true或false</td>
<td>false</td>
</tr>
</tbody>
</table>
</div>
<p><strong>说明：</strong> 布尔型占用的空间取决于Java虚拟机(JVM)的实现，可能是1位也可能是1个字节。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>Java Coding</tag>
      </tags>
  </entry>
  <entry>
    <title>【Java编程】Java学习笔记&lt;二&gt;</title>
    <url>/2014/04/11/%5B20140411b%5D/</url>
    <content><![CDATA[<ol>
<li>Java中类的域共有4种访问权限，而类的访问控制级别只有public和缺省的，当为public时，可以被任何包的其他类访问，当为缺省时，只能被同一包的其他类访问。如果类自身对另一个类是不可见的，即使类的成员声明为public，也没有一个成员是可见的。</li>
<li>Final变量一旦被显式的赋值（不能默认初始化），就不能再赋值了。</li>
<li>用final修辞的应用变量，不能重新引用另一个变量，但是可以所引用对象的数据。</li>
<li>一个类中，静态方法只能处理静态变量；静态方法只能调用静态方法。</li>
<li>方法修饰符abstract和final不能同时使用</li>
<li>每个源文件只能有一个公共类，没有公共类的源文件名可以与其中任意类同名。</li>
<li>子类覆盖父类的同名方法时，访问限制必须相同和更弱，但是不能更强。</li>
<li>子类对象可以自动向父类对象转化，但父类对象转化为子类对象时必须强制转换。</li>
<li>不用abstract修饰的类不能有抽象方法。</li>
<li>Java只有单继承，即一个类只有一个直接的父类。因此Java的类层次结构是树状的，而不是网状的。</li>
<li>Java语言的接口中，只能定义静态常量和抽象方法。接口可以看成一个没有具体实现的类。</li>
<li>接口可以多继承，因此接口使得Java程序实现了与类的多继承相似的功能。</li>
<li>如果接口中有多个抽象方法，类继承时必须为所有的抽象方法编写方法体。接口的定义中通常省略public等修饰符，但是在实现时必须显式地使用public修饰符。</li>
<li>如果实现接口的类是一个抽象类，则接口中的抽象方法可以不被实现。</li>
<li>是谁的实例调用谁的方法和变量。</li>
</ol>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>Java Coding</tag>
      </tags>
  </entry>
  <entry>
    <title>【Java编程】Java学习笔记&lt;一&gt;</title>
    <url>/2014/04/11/%5B20140411%5D/</url>
    <content><![CDATA[<ol>
<li>高级语言的编译和执行方法可以归为两大基本技术：编译执行和解释执行。C/C++/Delphi是编译执行，basic/java/matlab是解释执行。</li>
<li>尽管Java是解释执行的，也需要对源文件进行编译，与c语言的全编译（生成可执行文件）不同的是，Java具有半编译、半执行的特性（生成字节码）。</li>
<li>字节码文件格式是与平台无关的。Java程序并不是直接在操作系统的控制之下运行，而是在JVM的控制之下运行。</li>
<li>//是一行注释、/<em> </em>/是多行注释、/<em>* </em>/是文档注释</li>
<li>Java是严格区分大小写的，但html语言并不区分大小写。</li>
<li>Java应用程序是本机上由Java解释程序激活Java虚拟机，而Java小程序是通过浏览器激活Java虚拟机。</li>
<li>Java的命名规则<br>1）包名：用小写英文单词<br>2）类名和接口名：名词，每个首字母大写<br>3）方法名：动词 驼峰命名<br>4）变量名：与方法名一样<br>5）常量名：字母全大写 单词间下划线</li>
<li>Java语言中的字符型占16位，而c中占8位；Java中整型都是有符号的，c中有无符号的。Java中的基本数据类型的大小是固定的，而c中与平台有关。</li>
<li>布尔常量不能转化成任何数据类型，即不能与1、0比相等。</li>
<li>如果只是声明了一个类的具体对象，而没有使用构造函数，则该对象的值为null，不指向空间。</li>
<li>Java源程序的文件名必须与public类的类名一致</li>
<li>判断两个字符串的内容是否相等，不能用==，只能使用字符串类的equals方法</li>
<li>定义一个方法时，其方法体中不能再定义其它方法；调用一个方法时，其方法体中可以再调用其它方法。即不可重复定义，可以重复调用。</li>
<li>一个Java源文件包含几个类定义时，只能有一个public类，文件名与public类名完全一致。</li>
<li>抽象类没有具体实例，最终类不能有子类</li>
</ol>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>Java Coding</tag>
      </tags>
  </entry>
  <entry>
    <title>【Qt编程】Qt版扫雷</title>
    <url>/2014/04/10/%5B20140410%5D/</url>
    <content><![CDATA[<p>​    学习要学会举一反三。在以前的《用matlab扫扫雷》一文中，我用matlab简单的编写了一个扫雷小程序。当然，与Windows自带的扫雷程序自然是不敢相提并论。今天我就用c++来写个扫雷程序，算是对c++的练习。在那篇文章中提过，扫雷问题是NP完全问题，不能被解决。网上也有人做过扫雷的辅助工具，但也只是指明肯定是雷、和肯定不是雷的位置，不能完全求解。<strong>下面来讲述我的程序设计思路：</strong><br>1.用随机数生成雷分布的矩阵，元素为0表示无雷，1表示有雷。<br>2.通过循环遍历来统计一个元素的周围与之相邻的8个元素的雷的个数。<br>3.当鼠标左击某个按钮时，如果有雷则游戏失败。如果没有雷且其周围8个位置雷的个数为0，则将周围的8个位置打开，如果这8个位置中还有元素的周围8个元素个数为0，则将它周围的8个位置打开，依次类推……。知道将所有雷都标记正确，游戏胜利。</p>
<a id="more"></a>
<p><strong>游戏的缺点:</strong><br>1.由于时间关系，没有对游戏的界面进行美化，因此界面比较简陋。<br>2.与Windows自带的扫雷相比，少了几点功能，如果学了QML可能效果会好一点，但是不影响正常使用。<br>3.没有对代码进行优化，代码可能显得冗余。</p>
<p><strong>在编写过程中想到的：卷积的妙用</strong><br>    在统计一个元素与之相邻的8个元素的雷的总个数的时候，一般最容易想到的是用遍历来统计：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x1,x2,x3,x4,x5,x6,x7,x8;<span class="comment">//分别表示周围的8个位置的行</span></span><br><span class="line">  <span class="keyword">int</span> y1,y2,y3,y4,y5,y6,y7,y8;<span class="comment">//分别表示周围的8个位置的列</span></span><br><span class="line">  <span class="keyword">int</span> count=<span class="number">0</span>;<span class="comment">//统计雷的个数</span></span><br><span class="line">  <span class="keyword">for</span>(row=<span class="number">0</span>;row&lt;<span class="number">9</span>;row++)</span><br><span class="line">    <span class="keyword">for</span>(col=<span class="number">0</span>;col&lt;<span class="number">9</span>;col++)</span><br><span class="line">    &#123;</span><br><span class="line">      x1=row<span class="number">-1</span>;y1=col<span class="number">-1</span>;</span><br><span class="line">      x2=row<span class="number">-1</span>;y2=col;</span><br><span class="line">      x3=row<span class="number">-1</span>;y3=col+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">      x4=row;y4=col<span class="number">-1</span>;</span><br><span class="line">      x5=row;y5=col+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">      x6=row+<span class="number">1</span>;y6=col<span class="number">-1</span>;</span><br><span class="line">      x7=row+<span class="number">1</span>;y7=col;</span><br><span class="line">      x8=row+<span class="number">1</span>;y8=col+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span>(x1&gt;=<span class="number">0</span>&amp;&amp;y1&gt;=<span class="number">0</span>)<span class="comment">//需要判断行和列是否越界</span></span><br><span class="line">        <span class="keyword">if</span>( minefield[x1][y1]==<span class="number">1</span>)</span><br><span class="line">          count=count+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span>(x2&gt;=<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">if</span>( minefield[x2][y2]==<span class="number">1</span>)</span><br><span class="line">             count=count+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (x3&gt;=<span class="number">0</span>&amp;&amp;y3&lt;<span class="number">9</span>)</span><br><span class="line">        <span class="keyword">if</span> (minefield[x3][y3]==<span class="number">1</span>)</span><br><span class="line">           count=count+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (y4&gt;=<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">if</span> (minefield[x4][y4]==<span class="number">1</span>)</span><br><span class="line">           count=count+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (y5&lt;<span class="number">9</span>)</span><br><span class="line">        <span class="keyword">if</span> (minefield[x5][y5]==<span class="number">1</span>)</span><br><span class="line">           count=count+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span>(x6&lt;<span class="number">9</span>&amp;&amp;y6&gt;=<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">if</span> (minefield[x6][y6]==<span class="number">1</span>)</span><br><span class="line">           count=count+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span>(x7&lt;<span class="number">9</span>)</span><br><span class="line">        <span class="keyword">if</span> (minefield[x7][y7]==<span class="number">1</span>)</span><br><span class="line">           count=count+<span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span>(x8&lt;<span class="number">9</span>&amp;&amp;y8&lt;<span class="number">9</span>)</span><br><span class="line">        <span class="keyword">if</span>( minefield[x8][y8]==<span class="number">1</span>)</span><br><span class="line">           count=count+<span class="number">1</span>;</span><br><span class="line">      countnum[row][col]=count;</span><br><span class="line">      count=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>上面的程序通俗易懂，但是需要经过多次的条件判断来保证数组的下标不越界。在matlab中我们可以通过一条语句则可以解决上述问题。</p>
<p>看下面的例子：</p>
<p>  <img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20140410/20140410_fig001.jpg" width="220" height="250" title="图1" alt="图1" ></p>
<p>上图中，a就是雷的分布矩阵，1表示雷区。b是我们自己设置的一个特殊矩阵。c就是我们需要得到的雷的个数的矩阵，其中的含义如下：<br>c[0][0]=2,表示以a[0][0]为中心的九宫格中的雷的个数（自己的没有算在内）。那么c是如何得到的呢?正如上面所说，只需要一条命令即可：c=conv2(a,b,’same’)。也就是求a矩阵和b矩阵的卷积！<br>当然矩阵的卷积我们在《信号与线性系统分析》中没有讲到，但是书中提到了一维向量的卷积。例如：<br>a=[1 2 3];  b=[4 5 6];<br>则a与b的卷积为c=conv(a,b)=[ 4   13   28   27   18];</p>
<p><strong>具体的计算过程可以通过公式计算，下面用比较简单的方法来计算上面的卷积</strong>：</p>
<p>  <img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20140410/20140410_fig002.jpg" width="220" height="250" title="图2" alt="图2" ></p>
<p>上面的计算方法和小学学的乘法好像一样，在我印象中，两个信号这样求卷积的前提好像是这两个信号都是因果信号，唉，具体是什么条件我也不是很清楚了。在这里来说，就不用管这些条件限制。</p>
<p><strong>矩阵的卷积归根到底可以转换成一维向量的卷积，具体的做法是</strong>（以第一次的例子的值为例）：首先，将一个矩阵选择180度，这里我们选择b矩阵，碰巧b矩阵选择后的矩阵b1和原矩阵b一样;然后将b1矩阵每次往下移一行，将b1与a矩阵在同一行的一行分别进行一维向量的卷积运算，然后对应的列相加起来合并为一行。具体过程图解如下：</p>
<p>  <img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20140410/20140410_fig003.jpg" width="220" height="250" title="图3" alt="图3" ></p>
<p>conv([1 0 1],[1 1 1])=[ 1   1   2   1   1]</p>
<p>  <img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20140410/20140410_fig004.jpg" width="250" height="250" title="图4" alt="图4" ><br>conv([1 0 1],[1 0 1])+conv([1 1 1],[1 1 1])= [2   2   5   2   2]</p>
<p>  <img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20140410/20140410_fig005.jpg" width="220" height="200" title="图5" alt="图5" ></p>
<p>conv([1 0 1],[1 1 1])+conv([1 1 1],[1 0 1])+conv([0 1 1],[1 1 1])= [2  3  6  4  3]</p>
<p>  <img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20140410/20140410_fig006.jpg" width="220" height="250" title="图6" alt="图6" ></p>
<p>conv([1 1 1],[1 1 1])+conv([0 1 1],[1 0 1])=[  1   3   4   3   2]</p>
<p>  <img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20140410/20140410_fig007.jpg" width="220" height="250" title="图7" alt="图7" ></p>
<p>conv([0 1 1],[1 1 1])= [0   1   2   2   1]</p>
<p> <strong>综上所述</strong>：a与b的卷积是<br>   1   1   2   1   1</p>
<p>   2   2   5   2   2</p>
<p>   2   3   6   4   3</p>
<p>   1   3   4   3   2</p>
<p>   0   1   2   2   1</p>
<p>这与c=conv2(a,b)的结果相同！而在我的扫雷程序中想要得到的是与a相同维数的矩阵，因此我们可以使用 c=conv2(a,b,’same’)来得到我们的结果。</p>
<p>在前面的讨论中，我们使用的b矩阵是b=[1 1 1;1 0 1;1 1 1]。b的选取与我要的结果有关，如果我需要的是九宫格中所有的雷的个数（包含中心格） ，我们可以令b=[1 1 1;1 1 1;1 1 1];验证结果如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20140410/20140410_fig008.jpg" width="220" height="280" title="图8" alt="图8" ><br>如果我们选择b=[1 1 1;1 1 0;1 1 1],那么相当于不把中心格右边的雷计算在内，验证如下：<br><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20140410/20140410_fig009.jpg" width="220" height="280" title="图9" alt="图9" ><br>到目前为止，其中的规律就不言而喻了。<br>不知不觉一天就过去了，导师的报告还没写，就此搁笔。</p>
<p><strong>由于扫雷程序的代码较多，在此只是讲解了大概思路，具体代码见本文末尾的链接，代码有比较详尽的注释</strong><br> 程序运行截图如下：<br>1.开始的界面：</p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20140410/20140410_fig010.jpg" width="400" height="450" title="图10" alt="图10" ></p>
<p>2.输了的界面：<br><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20140410/20140410_fig011.jpg" width="400" height="450" title="图11" alt="图11" ></p>
<p>3.赢了的界面：</p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20140410/20140410_fig012.jpg" width="320" height="200" title="图12" alt="图12" ></p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20140410/20140410_fig013.jpg" width="400" height="450" title="图13" alt="图13" ></p>
<p><strong>程序下载请访问</strong>： <a href="http://pan.baidu.com/s/1kzntk" target="_blank" rel="noopener">http://pan.baidu.com/s/1kzntk</a></p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>Qt Coding</tag>
      </tags>
  </entry>
  <entry>
    <title>【Qt编程】基于Qt的词典开发系列--国际音标的显示</title>
    <url>/2014/04/09/%5B20140409%5D/</url>
    <content><![CDATA[<p>​    在年前的一篇文章中，我提到要学习Qt.于是在这学期看了一个月的qt。现在大致对qt有了一些了解。但是现在导师又把我调到了android应用开发平台，所以说qt的学习要搁置了。本打算这学期做一个单词查询软件的，目测只有在暑假完成了，现在才刚刚完成了本地词库的查询。目前的工作解决了词库的来源、本地词典的查询功能。日后的工作还有访问网络词库、记单词的算法实现等等。下面来说一说我在本地查词功能实现的问题—显示音标！</p>
<p>我们知道，qt中讲的比较多的是如何显示中文。一般情况都可以用下面代码来解决：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">QTextCodec::setCodecForTr(QTextCodec::codecForName(<span class="string">"UTF-8"</span>));</span><br><span class="line">QTextCodec::setCodecForTr(QTextCodec::codecForLocale());</span><br></pre></td></tr></table></figure>
<p>但是，我们<strong>本文解决的是显示国际音标</strong>。因为当我们从词库中搜索到我们查的单词时，便会显示其音标和意思。但是有一些音标却无法显示，举例如下：</p>
<p>  <img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20140409/20140409_fig001.jpg" width="360" height="400" title="图1" alt="图1" ></p>
<p> <img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20140409/20140409_fig002.jpg" width="360" height="400" title="图2" alt="图2" ></p>
<p><strong>对比两张图就可以看出有一些音标无法显示。</strong></p>
<p><strong>由于Qt可以解析html语言，因此我们可以通过在html语言中设置字体来显示这些特殊的音标</strong>。<strong>一些常用的音标有：</strong></p>
<p>θ ð ʃ ʒ tʃ dʒ ŋ ɪ æ ɔ ʌ ʊ ə ɛ  ɑ:  ʊ:  ɔ  eɪ ɑɪ ɔɪ əʊ oʊ ɑʊ  ɪə eə ʊə ɪə</p>
<p><strong>我们可以通过下面程序来测试：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">QString str2=<span class="string">"&lt;font face=\"Times New Roman\"&gt; θ  ð  ʃ  ʒ  tʃ  dʒ  ŋ ɪ æ  ɔ  ʌ   ʊ  ə  ɛ ɑ: ʊ: ɔ eɪ  ɑɪ  ɔɪ  əʊ  oʊ  ɑʊ ɪə  eə  ʊə  ɪə&lt;/font&gt;"</span>;</span><br></pre></td></tr></table></figure>
<p>然后将上面的字符串放入Qlabel等部件进行显示，在这里就不给出具体程序了。<strong>测试结果如下：</strong></p>
<p> <img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20140409/20140409_fig003.jpg" width="360" height="400" title="图3" alt="图3" ></p>
<p>经过测试如上图，上述特殊音标都可以正常显示。学习过html语言的可以看出上面的字符串是html语言，并且将字体设置为Time New Roman。</p>
<p>举一反三，如果要显示其它特殊字符，只需找出其所在的字体。当然，如果你学过html,你可以在上面的语句中包含多个字体（有备无患）。</p>
<p><strong>基于Qt的词典开发系列</strong></p>
<ol>
<li><a href="http://blog.csdn.net/tengweitw/article/details/44757875" target="_blank" rel="noopener">词典框架设计及成品展示</a></li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/45014771" target="_blank" rel="noopener">本地词典的设计</a></li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/45099867" target="_blank" rel="noopener">开始菜单的设计</a></li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/38758051" target="_blank" rel="noopener">无边框窗口的缩放与拖动</a></li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/38817595" target="_blank" rel="noopener">无边框窗口的拖动</a></li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/45223931" target="_blank" rel="noopener">界面美化设计</a></li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/45484803" target="_blank" rel="noopener">调用网络API</a></li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/45932429" target="_blank" rel="noopener">用户登录及API调用的实现</a></li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/45932429" target="_blank" rel="noopener">JSON数据解析</a></li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/23294533" target="_blank" rel="noopener">国际音标的显示</a></li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/38237203" target="_blank" rel="noopener">系统托盘的显示</a></li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/38306803" target="_blank" rel="noopener">调用讲述人</a></li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/38555787" target="_blank" rel="noopener">音频播放</a></li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/38689745" target="_blank" rel="noopener">自动补全功能</a></li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/38734201" target="_blank" rel="noopener">HTML特殊字符及正则表达式</a></li>
<li><a href="http://blog.csdn.net/tengweitw/article/details/46563781" target="_blank" rel="noopener">后序</a></li>
</ol>
<p><strong>作品下载地址（发布版）</strong>：<a href="http://download.csdn.net/detail/tengweitw/8548767" target="_blank" rel="noopener">http://download.csdn.net/detail/tengweitw/8548767</a></p>
<p><strong>作品下载地址（绿色版）</strong>：<a href="http://download.csdn.net/detail/tengweitw/8830495" target="_blank" rel="noopener">http://download.csdn.net/detail/tengweitw/8830495</a></p>
<p><strong>源码下载地址</strong>：<a href="http://download.csdn.net/detail/tengweitw/8830503" target="_blank" rel="noopener">http://download.csdn.net/detail/tengweitw/8830503</a></p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>Qt Coding</tag>
      </tags>
  </entry>
  <entry>
    <title>【Qt编程】Qt学习之状态栏</title>
    <url>/2014/03/29/%5B20140329%5D/</url>
    <content><![CDATA[<p>​    QStatusBar类提供一个水平条来显示状态信息。所谓状态信息，拿个简单的例子来说，当你在word中编辑时，左下角就会出现页面、字数等等信息。状态信息可以分为三类：<strong>临时信息</strong>，如一般的提示信息；<strong>正常信息</strong>，如页数；<strong>永久信息</strong>，如版本信息。QMainWindow中默认提供了一个状态栏。我们可以使用showMessage()来显示一个临时消息，它会出现在状态栏的最左边。我们一般用addWidget()将一个QLabel加到状态栏上用于显示正常信息，它会生成到状态栏的最左边，<strong>可能会被临时消息覆盖</strong>。我们使用addPermanentWidget()来添加一个QLabel来在状态栏的最右边显示永久信息。<strong>它不会被临时信息所掩盖</strong>。</p>
<a id="more"></a>
<p>​    在状态栏的最右端还有一个QSizeGrip部件用来调整窗口大小，我们可以通过setSizeGripEnabled()函数来禁用它。也许你想通过使用Qt Designer来可视化地完成窗口布局。但是事与愿违，目前的<strong>设计器还不支持直接向状态栏中拖放部件</strong>，所以我们就不能偷懒了，必须使用代码来设置了。下面程序为对状态栏的测试程序，只需要编辑mainwindow的构造函数如下：不要忘记应包含相应的头文件</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">MainWindow::MainWindow(QWidget *parent) :</span><br><span class="line">    QMainWindow(parent),</span><br><span class="line">    ui(<span class="keyword">new</span> Ui::MainWindow)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;setupUi(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//    QLabel *normal=new QLabel("正常信息",this);</span></span><br><span class="line"><span class="comment">//    ui-&gt;statusBar-&gt;addWidget(normal);//显示正常信息</span></span><br><span class="line"></span><br><span class="line">    ui-&gt;statusBar-&gt;setSizeGripEnabled(<span class="literal">false</span>);<span class="comment">//去掉状态栏右下角的三角</span></span><br><span class="line"></span><br><span class="line">    ui-&gt;statusBar-&gt;showMessage(tr(<span class="string">"临时信息!"</span>),<span class="number">2000</span>);<span class="comment">//显示临时信息2000ms 前面的正常信息被覆盖 当去掉后一项时，会一直显示</span></span><br><span class="line"></span><br><span class="line">    QLabel *permanent=<span class="keyword">new</span> QLabel(<span class="keyword">this</span>);</span><br><span class="line">    permanent-&gt;setFrameStyle(QFrame::Box|QFrame::Sunken);</span><br><span class="line">    permanent-&gt;setText(tr(<span class="string">"&lt;a href=\"http://tengweitw.ueuo.com\"&gt;永久信息&lt;/a&gt;"</span>));</span><br><span class="line">    permanent-&gt;setOpenExternalLinks(<span class="literal">true</span>);<span class="comment">//设置可以打开网站链接</span></span><br><span class="line">    ui-&gt;statusBar-&gt;addPermanentWidget(permanent);<span class="comment">//显示永久信息</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>显示结果如下：</p>
<p>  <img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20140329/20140329_fig001.jpg" width="400" height="400" title="图1" alt="图1" ></p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>Qt Coding</tag>
      </tags>
  </entry>
  <entry>
    <title>【Qt编程】Qt 小时钟</title>
    <url>/2014/03/27/%5B20140327%5D/</url>
    <content><![CDATA[<p>​    Hello World! 学习编程语言的最简单最经典的小程序，当然Qt也不例外。在学习画图时，我觉得写个时钟小程序也是个比较好的开始。在之前的《Matlab及Java小时钟》一文中，我也从写时钟程序作为学习画图的开始。三者之间的不同点在于，matlab是通过while循环来进行重绘，Java和Qt事件来处理。实时显示时钟，都是通过改变指针与坐标轴的相对位置来实现的。前两者都是改变指针，而Qt是旋转坐标轴。具体代码如下：</p>
<a id="more"></a>
<p>1.widget.h文件</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> WIDGET_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WIDGET_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QWidget&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Ui &#123;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> :</span> <span class="keyword">public</span> QWidget</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Widget</span><span class="params">(QWidget *parent = <span class="number">0</span>)</span></span>;</span><br><span class="line">    ~Widget();</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Ui::Widget *ui;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">paintEvent</span><span class="params">(QPaintEvent *event)</span></span>;<span class="comment">//添加重绘事件</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// WIDGET_H</span></span></span><br></pre></td></tr></table></figure>
<p>2.main.cpp文件</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QtGui/QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"widget.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;QTextCodec&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;QPainter&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;QtGui&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;QDebug&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line">    QTextCodec::setCodecForTr(QTextCodec::codecForLocale());</span><br><span class="line">    Widget w;</span><br><span class="line">    w.show();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> a.exec();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3.widget.cpp 文件</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"widget.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ui_widget.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;QPainter&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;QtGui&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;QDebug&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;QFont&gt;</span></span></span><br><span class="line"></span><br><span class="line">Widget::Widget(QWidget *parent) :</span><br><span class="line">    QWidget(parent),</span><br><span class="line">    ui(<span class="keyword">new</span> Ui::Widget)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;setupUi(<span class="keyword">this</span>);</span><br><span class="line">    QTimer *timer = <span class="keyword">new</span> QTimer(<span class="keyword">this</span>);<span class="comment">//创建一秒定时器</span></span><br><span class="line">    connect(timer, SIGNAL(timeout()), <span class="keyword">this</span>, SLOT(update()));<span class="comment">//信号与槽关联</span></span><br><span class="line">    timer-&gt;start(<span class="number">1000</span>);</span><br><span class="line">    setWindowTitle(tr(<span class="string">"我的时钟--designed by TW"</span>));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Widget::~Widget()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Widget::paintEvent(QPaintEvent *event)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> side = qMin(width(), height());<span class="comment">//获取窗口的较短边的值</span></span><br><span class="line">    <span class="function">QPainter <span class="title">painter</span><span class="params">(<span class="keyword">this</span>)</span></span>;<span class="comment">//指定画图设备</span></span><br><span class="line">    painter.fillRect(rect(),Qt::yellow);<span class="comment">//设置背景色</span></span><br><span class="line">    painter.setRenderHint(QPainter::Antialiasing);<span class="comment">//开启抗锯齿</span></span><br><span class="line">    painter.translate(width() / <span class="number">2</span>, height() / <span class="number">2</span>);<span class="comment">//将坐标移到窗口正中心</span></span><br><span class="line">    painter.scale(side / <span class="number">200.0</span>, side / <span class="number">200.0</span>);<span class="comment">//进行缩放</span></span><br><span class="line"></span><br><span class="line">    QPen pen;<span class="comment">//设置画笔的，宽度，样式，颜色</span></span><br><span class="line">    pen.setWidth(<span class="number">2</span>);</span><br><span class="line">    pen.setStyle(Qt::SolidLine);</span><br><span class="line">    pen.setColor(Qt::red);</span><br><span class="line"></span><br><span class="line">    painter.setPen(pen);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">12</span>; ++i) <span class="comment">//画表盘时针刻度</span></span><br><span class="line">    &#123;</span><br><span class="line">        painter.drawLine(<span class="number">87</span>, <span class="number">0</span>, <span class="number">95</span>, <span class="number">0</span>);</span><br><span class="line">        painter.rotate(<span class="number">30</span>);<span class="comment">//将坐标进行顺时针选择30度</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pen.setWidth(<span class="number">1</span>);</span><br><span class="line">    pen.setColor(Qt::black);</span><br><span class="line">    painter.setPen(pen);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">60</span>; ++i) <span class="comment">//画表盘时针刻度</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i%<span class="number">5</span>!=<span class="number">0</span>)</span><br><span class="line">          painter.drawLine(<span class="number">90</span>, <span class="number">0</span>, <span class="number">95</span>, <span class="number">0</span>);</span><br><span class="line">        painter.rotate(<span class="number">6</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pen.setColor(Qt::black);</span><br><span class="line">    painter.setPen(pen);</span><br><span class="line">    <span class="function">QFont <span class="title">font</span><span class="params">(<span class="string">"Century"</span>)</span></span>;</span><br><span class="line">    painter.setFont(font);</span><br><span class="line">    <span class="comment">//标时刻的数值</span></span><br><span class="line">    painter.drawText(<span class="number">-6</span>,<span class="number">-75</span>,tr(<span class="string">"12"</span>));</span><br><span class="line">    painter.drawText(<span class="number">-3</span>,<span class="number">80</span>,tr(<span class="string">"6"</span>));</span><br><span class="line">    painter.drawText(<span class="number">75</span>,<span class="number">5</span>,tr(<span class="string">"3"</span>));</span><br><span class="line">    painter.drawText(<span class="number">-80</span>,<span class="number">5</span>,tr(<span class="string">"9"</span>));</span><br><span class="line"></span><br><span class="line">    painter.drawArc(<span class="number">-3</span>,<span class="number">-3</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">360</span>*<span class="number">16</span>);<span class="comment">//画中心小圆环</span></span><br><span class="line">    <span class="comment">/////////////////////////////////////</span></span><br><span class="line">    QTime time = QTime::currentTime();<span class="comment">//获取当前系统时间</span></span><br><span class="line"><span class="comment">//    qDebug()&lt;&lt;time.hour();</span></span><br><span class="line"><span class="comment">//    qDebug()&lt;&lt;time.minute();</span></span><br><span class="line"><span class="comment">//    qDebug()&lt;&lt;time.second();</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//画时针</span></span><br><span class="line">    painter.save();<span class="comment">//在旋转坐标系前，保存原来坐标系</span></span><br><span class="line">    painter.rotate(<span class="number">30.0</span> * ((time.hour() + time.minute() / <span class="number">60.0</span>)));</span><br><span class="line">    pen.setColor(Qt::green);</span><br><span class="line">    pen.setWidth(<span class="number">4</span>);</span><br><span class="line">    painter.setPen(pen);</span><br><span class="line">    painter.drawLine(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">-60</span>);</span><br><span class="line">    painter.restore();<span class="comment">//在旋转坐标系后，恢复原来坐标系</span></span><br><span class="line">    <span class="comment">//画分针</span></span><br><span class="line">    painter.save();</span><br><span class="line">    painter.rotate(<span class="number">6.0</span> * (time.minute() + time.second() / <span class="number">60.0</span>));</span><br><span class="line">    pen.setColor(Qt::blue);</span><br><span class="line">    pen.setWidth(<span class="number">2</span>);</span><br><span class="line">    painter.setPen(pen);</span><br><span class="line">    painter.drawLine(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">-80</span>);</span><br><span class="line">    painter.restore();</span><br><span class="line">    <span class="comment">//画秒针</span></span><br><span class="line">    painter.save();</span><br><span class="line">    painter.rotate(<span class="number">6.0</span> *time.second() );</span><br><span class="line">    pen.setColor(Qt::red);</span><br><span class="line">    pen.setWidth(<span class="number">1</span>);</span><br><span class="line">    painter.setPen(pen);</span><br><span class="line">    <span class="comment">//秒针形状由两条直线和一个小圆环组成</span></span><br><span class="line">    painter.drawArc(<span class="number">-3</span>,<span class="number">-66</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">360</span>*<span class="number">16</span>);</span><br><span class="line">    painter.drawLine(<span class="number">0</span>,<span class="number">20</span>,<span class="number">0</span>,<span class="number">-60</span>);</span><br><span class="line">    painter.drawLine(<span class="number">0</span>,<span class="number">-66</span>,<span class="number">0</span>,<span class="number">-85</span>);</span><br><span class="line">    painter.restore();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>运行结果如下图：</strong></p>
<p>  <img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20140327/20140327_fig001.jpg" width="350" height="450" title="图1" alt="图1" ></p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>Qt Coding</tag>
      </tags>
  </entry>
  <entry>
    <title>【Qt编程】Qt学习笔记&lt;三&gt;</title>
    <url>/2014/03/20/%5B20140320%5D/</url>
    <content><![CDATA[<ul>
<li>如果程序中使用了png以外格式的图片，在发布程序时就要将Qt安装目录下plugins中的imagineformats文件复制到发布文件中。</li>
<li>在函数声明处快速添加函数定义可单击函数名，按下<code>alt+Enter</code>键后，按下<code>Enter</code>键就可以进入到函数定义部分。</li>
<li>关联槽和信号的两种方法：1.直接在设计器中用鼠标拖拽，适合于设计器中的部件间进行。2.在设计器中右击部件进入转到槽，这种方法是自动关联。</li>
<li>我们在进行编程时，应注意：一个文件、一个类、一个界面。</li>
<li>在设置文件过滤器时，在同类别不同格式间用空格，在不同类别中用；；。例如：<br>QString filename=QFileDialog::getOpenFileName(this,tr(“文本对话框”),”F:”,tr(“图片文件(<em>png</em>jpg);;文本文件(*txt)”));</li>
<li>Qt中凡是带有Abstract字样的类都是抽象基类。对于抽象基类，我们不能直接使用，但是可以继承该类实现自己的类，或者使用它提供的子类。</li>
<li>QlineEdit有四种显示模式：Normal正常显示输入的信息；NoEcho不显示任何输入；Password显示为密码样式；PasswordEchoOnEdit在编辑时显示为正常字符，在其它情况显示为密码样式。</li>
<li>当部件加入到一个布局管理器中，然后这个布局管理器再放入到一个窗口部件上时，这个布局管理器以及它所包含的所有部件都会把该窗口部件自动重新定义为自己的父对象。</li>
<li>一个主窗口只能拥有一个状态栏。</li>
<li>Qt的资源系统要求资源文件必须放在与qrc文件同级或子级目录下，如果放在其他地方，添加资源时，会提示将文件复制到有效的位置。</li>
<li>添加资源文件后要注意保存，否则在使用时将看不到图片。</li>
<li>往项目中添加资源文件时会自动往工程文件pro文件中添加RESOURCES+=\myImage.qrc.。其中myImage.qrc为你添加资源文件的名称。如果是添加已有的资源文件，就必须手动添加这行代码。</li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>Qt Coding</tag>
      </tags>
  </entry>
  <entry>
    <title>【Matlab编程】Matlab及Java小时钟</title>
    <url>/2014/03/18/%5B20140318%5D/</url>
    <content><![CDATA[<p>​    一年前曾经用matlab的gui做了一个时钟，由于是直接用GUIDE和ActiveX控件写的，程序虽说有许多行，大多数都是自动生成的，自己写的只有十几行而已。闲着没事，就耗费了下午的时间用matlab和Java分别又写了写。<strong>具体代码如下：<br>1.matlab脚本文件：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">%%%%%%%%%%%%%%%设置图像属性并获取图像句柄%%%%%%%%%%%%%%%%%%%%%%%%%%%</span><br><span class="line">h=figure('name','我的时钟','NumberTitle','off','color',[1 1 0]);</span><br><span class="line">set(h,'menubar','none','position',[200,200,400,450]);</span><br><span class="line">%%%%%%%%%%%%画出时钟的外轮廓%%%%%%%%%%%%%%</span><br><span class="line">s1=[<span class="number">0</span>:pi/<span class="number">1000</span>:<span class="number">2</span>*pi];</span><br><span class="line">hl=plot(2*cos(s1),2*sin(s1),'black','linewidth',1.5);</span><br><span class="line">axis equal</span><br><span class="line">title('我的时钟');</span><br><span class="line">hold on</span><br><span class="line">%%%%%%%%%%%绘制表盘刻度%%%%%%%%%%%%%%%%%%</span><br><span class="line"><span class="keyword">for</span> n=pi*<span class="number">2</span>:-pi/<span class="number">30</span>:pi/<span class="number">30</span>              %绘制表盘，绘制分钟的刻度</span><br><span class="line">    a1=<span class="number">0.95</span>*<span class="built_in">cos</span>(n):<span class="number">0.000005</span>*<span class="built_in">cos</span>(n)/<span class="number">2</span>:<span class="built_in">cos</span>(n);b1=<span class="number">0.95</span>*<span class="built_in">sin</span>(n):<span class="number">0.000005</span>*<span class="built_in">sin</span>(n)/<span class="number">2</span>:<span class="built_in">sin</span>(n);</span><br><span class="line">    plot(2*a1,2*b1,'r-');</span><br><span class="line">end</span><br><span class="line"><span class="keyword">for</span> n=pi*<span class="number">2</span>:-pi/<span class="number">6</span>:pi/<span class="number">30</span>               %绘制表盘，绘制小时的刻度</span><br><span class="line">    a1=<span class="number">0.9</span>*<span class="built_in">cos</span>(n):<span class="number">0.1</span>*<span class="built_in">cos</span>(n)/<span class="number">2</span>:<span class="built_in">cos</span>(n);b1=<span class="number">0.9</span>*<span class="built_in">sin</span>(n):<span class="number">0.1</span>*<span class="built_in">sin</span>(n)/<span class="number">2</span>:<span class="built_in">sin</span>(n);</span><br><span class="line">    plot(2*a1,2*b1,'r-');</span><br><span class="line">end</span><br><span class="line">text(1.5,0,'3','FontSize',12)</span><br><span class="line">text(-0.05,-1.7,'6','FontSize',12)</span><br><span class="line">text(-1.7,0,'9','FontSize',12)</span><br><span class="line">text(-0.1,1.7,'12','FontSize',12)</span><br><span class="line">%%%%%%%%%%%%%%%%获取当前时间并进行角度与弧度转换%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span><br><span class="line"> axis([<span class="number">-2.1</span> <span class="number">2.1</span> <span class="number">-2.1</span> <span class="number">2.1</span>])</span><br><span class="line">     time=datestr(now);</span><br><span class="line">    sec=pi/<span class="number">2</span>-str2num(time(<span class="number">19</span>:<span class="number">20</span>))*pi/<span class="number">30</span>;   </span><br><span class="line">    min=pi/<span class="number">2</span>-(str2num(time(<span class="number">16</span>:<span class="number">17</span>))+sec/<span class="number">60</span>)*pi/<span class="number">30</span>;                                                      </span><br><span class="line">    hour=pi/<span class="number">2</span>-(str2num(time(<span class="number">13</span>:<span class="number">14</span>))+min/<span class="number">60</span>)*pi/<span class="number">6</span>; </span><br><span class="line"> w1=-pi/<span class="number">30</span>; </span><br><span class="line"> w2=-pi/<span class="number">1800</span>;  </span><br><span class="line"> w3=-pi/<span class="number">108000</span>; </span><br><span class="line"> pausetime=<span class="number">1</span>;</span><br><span class="line"> %%%%%%%%%%%%%%%%开始绘图并不断刷新%%%%%%%%%%%%</span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span></span><br><span class="line">    axis off    </span><br><span class="line">    x1=<span class="number">0</span>:<span class="number">0.75</span>*<span class="built_in">cos</span>(sec)/<span class="number">2</span>:<span class="number">0.75</span>*<span class="built_in">cos</span>(sec);y1=<span class="number">0</span>:<span class="number">0.75</span>*<span class="built_in">sin</span>(sec)/<span class="number">2</span>:<span class="number">0.75</span>*<span class="built_in">sin</span>(sec); %根据秒针的位置绘制分针</span><br><span class="line">    x2=<span class="number">0</span>:<span class="number">0.6</span>*<span class="built_in">cos</span>(min)/<span class="number">2</span>:<span class="number">0.6</span>*<span class="built_in">cos</span>(min);y2=<span class="number">0</span>:<span class="number">0.6</span>*<span class="built_in">sin</span>(min)/<span class="number">2</span>:<span class="number">0.6</span>*<span class="built_in">sin</span>(min);  %根据分针的位置绘制分针  </span><br><span class="line">    x3=<span class="number">0</span>:<span class="number">0.45</span>*<span class="built_in">cos</span>(hour)/<span class="number">2</span>:<span class="number">0.45</span>*<span class="built_in">cos</span>(hour);y3=<span class="number">0</span>:<span class="number">0.45</span>*<span class="built_in">sin</span>(hour)/<span class="number">2</span>:<span class="number">0.45</span>*<span class="built_in">sin</span>(hour);  %根据时针的位置绘制分针</span><br><span class="line">    hp1=plot(2*x1,2*y1,'r-','linewidth',1.5);</span><br><span class="line">    hp2=plot(2*x2,2*y2,'b-','linewidth',2);</span><br><span class="line">    hp3=plot(2*x3,2*y3,'g-','linewidth',3.5);</span><br><span class="line">    sec=sec+w1*pausetime;        %计算一秒以后秒针的角度位置</span><br><span class="line">    min=min+w2*pausetime;        %计算一秒以后分针的角度位置</span><br><span class="line">    hour=hour+w3*pausetime;</span><br><span class="line">    pause(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">delete</span>(hp1);</span><br><span class="line">    <span class="keyword">delete</span>(hp2);</span><br><span class="line">    <span class="keyword">delete</span>(hp3);</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p><strong>2.Java应用文件(文件名为MyClock.java)</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.awt.*;</span><br><span class="line"><span class="keyword">import</span> java.util.GregorianCalendar;</span><br><span class="line"><span class="keyword">import</span> javax.swing.*;</span><br><span class="line"><span class="keyword">import</span> javax.swing.Timer;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClock</span> <span class="title">extends</span> <span class="title">JPanel</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"> </span><br><span class="line"> final <span class="keyword">double</span> RAD=Math.PI/<span class="number">180</span>;<span class="comment">//角度与弧度的转化</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">paint</span><span class="params">(Graphics g)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">  super.paint(g);<span class="comment">//调用父类方法</span></span><br><span class="line">     Graphics2D g2=(Graphics2D)g;<span class="comment">//主要用于改变线条粗细</span></span><br><span class="line">     <span class="keyword">int</span>  h=getSize().height;<span class="comment">//获取窗口的长和宽，主要用于当用鼠标改变窗口时，时钟也跟着变化</span></span><br><span class="line">     <span class="keyword">int</span>  w=getSize().width;</span><br><span class="line">  <span class="keyword">int</span> hour,min,sec,hh,mm,ss;</span><br><span class="line">  <span class="keyword">double</span> x,y;</span><br><span class="line">  setBackground(Color.yellow);<span class="comment">//设置背景值</span></span><br><span class="line">        g.setColor(Color.black);<span class="comment">//画笔颜色</span></span><br><span class="line">        <span class="keyword">int</span> r=(Math.min(h, w)/<span class="number">2</span><span class="number">-50</span>);</span><br><span class="line">        <span class="keyword">float</span> x0=w/<span class="number">2</span>;<span class="comment">//时钟中心位置</span></span><br><span class="line">        <span class="keyword">float</span> y0=h/<span class="number">2</span>;</span><br><span class="line">   </span><br><span class="line">        g2.setFont(<span class="keyword">new</span> Font(<span class="string">"楷体"</span>,Font.PLAIN,<span class="number">20</span>));</span><br><span class="line">        g2.drawString(<span class="string">"我的时钟"</span>,<span class="number">165</span>, <span class="number">50</span>);</span><br><span class="line">        g2.setFont(<span class="keyword">new</span> Font(<span class="string">"Times New Roman"</span>,Font.PLAIN,<span class="number">20</span>));</span><br><span class="line">        g2.drawString(<span class="string">"Designed by TW"</span>,<span class="number">235</span>, <span class="number">420</span>);</span><br><span class="line">        </span><br><span class="line">        g.drawString(<span class="string">"12"</span>,(<span class="keyword">int</span>)(w/<span class="number">2</span>)<span class="number">-5</span>,(<span class="keyword">int</span>)(h/<span class="number">2</span>)-r+<span class="number">30</span>);</span><br><span class="line">        g.drawString(<span class="string">"3"</span>,(<span class="keyword">int</span>)(w/<span class="number">2</span>)<span class="number">-25</span>+r,Math.round(h/<span class="number">2</span>)+<span class="number">10</span>);</span><br><span class="line">        g.drawString(<span class="string">"6"</span>,(<span class="keyword">int</span>)(w/<span class="number">2</span>),(<span class="keyword">int</span>)(h/<span class="number">2</span>)+r<span class="number">-20</span>);</span><br><span class="line">        g.drawString(<span class="string">"9"</span>,(<span class="keyword">int</span>)(w/<span class="number">2</span>)-r+<span class="number">20</span>,Math.round(h/<span class="number">2</span>)+<span class="number">10</span>);</span><br><span class="line">      </span><br><span class="line">        <span class="comment">//设置分钟刻度  之所以没有用线条，主要是因为drawline的参数要求是整数，因此刻度会不准确</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">12</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">double</span> buffer=Math.PI*(<span class="number">0.5</span>-i/<span class="number">6.0</span>);</span><br><span class="line">            <span class="keyword">int</span> posX = (<span class="keyword">int</span>)Math.round(x0+r*Math.<span class="built_in">cos</span>(buffer));</span><br><span class="line">            <span class="keyword">int</span> posY = (<span class="keyword">int</span>)Math.round(y0-r*Math.<span class="built_in">sin</span>(buffer));</span><br><span class="line">            g.setColor(Color.red);</span><br><span class="line">            g.fill3DRect(posX, posY, <span class="number">8</span>, <span class="number">8</span>, <span class="literal">true</span>);</span><br><span class="line">           &#125;</span><br><span class="line">        <span class="comment">//设置秒钟刻度</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;<span class="number">60</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i%<span class="number">5</span>!=<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">             <span class="keyword">double</span> buffer= Math.PI*i/<span class="number">30.0</span>;</span><br><span class="line">             <span class="keyword">int</span> posX = (<span class="keyword">int</span>)Math.round(x0+r*Math.<span class="built_in">cos</span>(buffer));</span><br><span class="line">             <span class="keyword">int</span> posY = (<span class="keyword">int</span>)Math.round(y0-r*Math.<span class="built_in">sin</span>(buffer));</span><br><span class="line">             g.setColor(Color.black);</span><br><span class="line">             g.fill3DRect(posX, posY, <span class="number">6</span>, <span class="number">6</span>, <span class="literal">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">       &#125;</span><br><span class="line">      <span class="comment">//获取当前系统时间</span></span><br><span class="line">    </span><br><span class="line">        GregorianCalendar date=<span class="keyword">new</span> GregorianCalendar();</span><br><span class="line">  hour=(<span class="keyword">int</span>)date.get(Calendar.HOUR); </span><br><span class="line">  min=(<span class="keyword">int</span>)date.get(Calendar.MINUTE); </span><br><span class="line">  sec=(<span class="keyword">int</span>)date.get(Calendar.SECOND); </span><br><span class="line"> <span class="comment">// System.out.println(hour);</span></span><br><span class="line"> <span class="comment">// System.out.println(min);</span></span><br><span class="line"> <span class="comment">// System.out.println(sec);</span></span><br><span class="line">  <span class="comment">//进行角度换算</span></span><br><span class="line">  ss=<span class="number">90</span>-sec*<span class="number">6</span>;</span><br><span class="line">        mm=<span class="number">90</span>-min*<span class="number">6</span>;</span><br><span class="line">        hh=<span class="number">90</span>-hour*<span class="number">30</span>-min/<span class="number">2</span>;</span><br><span class="line">       <span class="comment">//画出时分秒的指针 </span></span><br><span class="line">        g2.setStroke(<span class="keyword">new</span> BasicStroke(<span class="number">1.0f</span>));</span><br><span class="line">        x=(<span class="keyword">int</span>)(r*<span class="number">0.9</span>*Math.<span class="built_in">cos</span>(RAD*ss)+x0);</span><br><span class="line">        y=(<span class="keyword">int</span>)(r*<span class="number">0.9</span>*Math.<span class="built_in">sin</span>(RAD*ss)+y0);</span><br><span class="line">        g.setColor(Color.red);</span><br><span class="line">        g.drawLine((<span class="keyword">int</span>)(x0),(<span class="keyword">int</span>)(y0),(<span class="keyword">int</span>)x,(<span class="keyword">int</span>)(h-y));</span><br><span class="line">  </span><br><span class="line">        g2.setStroke(<span class="keyword">new</span> BasicStroke(<span class="number">2.2f</span>));</span><br><span class="line">        x=(<span class="keyword">int</span>)(r*<span class="number">0.7</span>*Math.<span class="built_in">cos</span>(RAD*mm)+x0);</span><br><span class="line">        y=(<span class="keyword">int</span>)(r*<span class="number">0.7</span>*Math.<span class="built_in">sin</span>(RAD*mm)+y0);</span><br><span class="line">        g.setColor(Color.blue);</span><br><span class="line">        g.drawLine((<span class="keyword">int</span>)x0,(<span class="keyword">int</span>)y0,(<span class="keyword">int</span>)x,(<span class="keyword">int</span>)(h-y));</span><br><span class="line">        g2.setStroke(<span class="keyword">new</span> BasicStroke(<span class="number">3.4f</span>));</span><br><span class="line">        x=(<span class="keyword">int</span>)(r*<span class="number">0.5</span>*Math.<span class="built_in">cos</span>(RAD*hh))+x0;</span><br><span class="line">        y=(<span class="keyword">int</span>)(r*<span class="number">0.5</span>*Math.<span class="built_in">sin</span>(RAD*hh))+y0;</span><br><span class="line">        g.setColor(Color.green);</span><br><span class="line">        g.drawLine((<span class="keyword">int</span>)x0,(<span class="keyword">int</span>)y0,(<span class="keyword">int</span>)x,(<span class="keyword">int</span>)(h-y));</span><br><span class="line"> </span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//设置窗口大小</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> Dimension <span class="title">getPreferredSize</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Dimension(<span class="number">400</span>,<span class="number">450</span>);</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">// </span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">   Graphics g=null;</span><br><span class="line">   JFrame frame=<span class="keyword">new</span> JFrame(<span class="string">"我的时钟"</span>);</span><br><span class="line">   Container contentPane=frame.getContentPane();</span><br><span class="line">   final MyClock tw=<span class="keyword">new</span> MyClock();</span><br><span class="line">   contentPane.add(tw,BorderLayout.CENTER);</span><br><span class="line">   frame.pack();</span><br><span class="line">   frame.setVisible(<span class="literal">true</span>);</span><br><span class="line">   <span class="comment">//用于画板的刷新</span></span><br><span class="line">    <span class="keyword">int</span> delay=<span class="number">1000</span>;</span><br><span class="line">      <span class="comment">//创建一个监听事件</span></span><br><span class="line">      ActionListener drawClock=<span class="keyword">new</span> ActionListener()</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="keyword">public</span> <span class="keyword">void</span> actionPerformed(ActionEvent evt)</span><br><span class="line">         &#123;</span><br><span class="line">            tw.repaint();</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//创建一个时间计数器，每一秒触发一次</span></span><br><span class="line">      <span class="keyword">new</span> Timer(delay,drawClock).start();</span><br><span class="line">   </span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>运行结果如下图：</strong></p>
<p>1.matlab时钟界面:<br>  <img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20140318/20140318_fig001.jpg" width="400" height="460" title="图1" alt="图1" ></p>
<p>2.Java时钟界面</p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20140318/20140318_fig002.jpg" width="400" height="460" title="图2" alt="图2" ></p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>Matlab, Java, Coding</tag>
      </tags>
  </entry>
  <entry>
    <title>【Qt编程】Qt学习之窗口间的相互切换</title>
    <url>/2014/03/15/%5B20140315%5D/</url>
    <content><![CDATA[<p>​    在用Qt设计GUI时，经常要设计两个窗口之间的相互切换，即可以从一个窗口跳转到另一个窗口，然后又从另一个窗口跳转回原窗口。下面我们来介绍具体的实现方法：</p>
<p><strong>工程建立及功能描述：</strong></p>
<p>​    首先，我们建立Qt  Gui应用，项目名TwoWindowsHandoff（可以随便取），基类选择QMainWindow。然后右击项目，添加Qt设计器界面类，类名取为logindialog。我们在这里假设一个窗口是登录对话框，另一个窗口是主界面；登录对话框有两个按钮，分别更改显示文本为login，exit；主界面也有两个按钮，分别更改显示文本为relogin，quit.。我们最终的实现功能是：程序运行时，出现登录对话框，点击login按钮进入主界面且登录对话框消失；在主界面点击relogin按钮回到登录对话框且主界面消失，点击exit按钮或quit按钮都会退出程序。</p>
<a id="more"></a>
<p><strong>编程思想：</strong></p>
<p>​    我们可以通过Qt Designer来在两个窗口上分别添加上述按钮，这里不在详细描述。我们主要的问题是如何设计信号和槽。我们先设计两个窗口的退出按钮：分别右击exit和quit按钮，转到槽，在槽函数中发射quit()信号，然后将信号与QApplication对象的quit()槽函数关联。这样我们就设计好了两个退出按钮的退出操作。对于login按钮，我们在其槽函数中发射showmainwindow()信号，隐藏对话框，然后在主窗口类中定义对应的槽函数receivelogin()，在该函数中我们应该显示主窗口。同理对于relogin窗口，我们在其槽函数中发射dlgshow()信号，隐藏主窗口，然后在登录对话框类中定义对应的槽函数receivelshow()，在该函数中我们应该显示登录对话框。</p>
<p><strong>具体的程序实现如下：</strong></p>
<h3 id="1-头文件"><a href="#1-头文件" class="headerlink" title="1.头文件:"></a>1.头文件:</h3><p> <strong>mainwindow.h文件：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> MAINWINDOW_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAINWINDOW_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QMainWindow&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Ui &#123;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainWindow</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainWindow</span> :</span> <span class="keyword">public</span> QMainWindow</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">MainWindow</span><span class="params">(QWidget *parent = <span class="number">0</span>)</span></span>;</span><br><span class="line">    ~MainWindow();</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Ui::MainWindow *ui;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> slots:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">receivelogin</span><span class="params">()</span></span>;<span class="comment">//与login中发射的信号关联的槽函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">on_pushButton_clicked</span><span class="params">()</span></span>;<span class="comment">//与relogin的click()关联的槽函数</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">on_pushButton_2_clicked</span><span class="params">()</span></span>;<span class="comment">//与quit的click()关联的槽函数</span></span><br><span class="line"></span><br><span class="line">signals:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dlgshow</span><span class="params">()</span></span>;<span class="comment">//显示登录对话框信号</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">quit</span><span class="params">()</span></span>;<span class="comment">//退出信号</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// MAINWINDOW_H</span></span></span><br></pre></td></tr></table></figure>
<p><strong>mydialog.h文件：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> MYDIALOG_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MYDIALOG_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QDialog&gt;</span></span></span><br><span class="line"><span class="keyword">namespace</span> Ui &#123;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyDialog</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyDialog</span> :</span> <span class="keyword">public</span> QDialog</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">MyDialog</span><span class="params">(QWidget *parent = <span class="number">0</span>)</span></span>;</span><br><span class="line">    ~MyDialog();</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span> slots:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">on_pushButton_clicked</span><span class="params">()</span></span>;<span class="comment">//与login关联的槽函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">receiveshow</span><span class="params">()</span></span>;<span class="comment">//与relogin中发射的信号关联的槽函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">on_pushButton_2_clicked</span><span class="params">()</span></span>;<span class="comment">//与exit关联的槽函数</span></span><br><span class="line">signals:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showmainwindow</span><span class="params">()</span></span>;<span class="comment">//显示主窗口信号</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">quit</span><span class="params">()</span></span>;<span class="comment">//退出信号</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Ui::MyDialog *ui;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// MYDIALOG_H</span></span></span><br></pre></td></tr></table></figure>
<h3 id="2-源文件："><a href="#2-源文件：" class="headerlink" title="2.源文件："></a>2.源文件：</h3><p><strong>main.cpp文件：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QtGui/QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mainwindow.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"mydialog.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line">    MainWindow w;</span><br><span class="line">    MyDialog dlg;</span><br><span class="line">    dlg.show();</span><br><span class="line">    <span class="comment">//信号与槽之间进行关联</span></span><br><span class="line">    QObject::connect(&amp;dlg,SIGNAL(showmainwindow()),&amp;w,SLOT(receivelogin()));</span><br><span class="line">    QObject::connect(&amp;w,SIGNAL(dlgshow()),&amp;dlg,SLOT(receiveshow()));</span><br><span class="line">    QObject::connect(&amp;w,SIGNAL(quit()),&amp;a,SLOT(quit()));</span><br><span class="line">    QObject::connect(&amp;dlg,SIGNAL(quit()),&amp;a,SLOT(quit()));</span><br><span class="line">    <span class="keyword">return</span> a.exec();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>mainwindow.cpp文件：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mainwindow.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ui_mainwindow.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;QPushButton&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;QHBoxLayout&gt;</span></span></span><br><span class="line"></span><br><span class="line">MainWindow::MainWindow(QWidget *parent) :</span><br><span class="line">    QMainWindow(parent),</span><br><span class="line">    ui(<span class="keyword">new</span> Ui::MainWindow)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;setupUi(<span class="keyword">this</span>);<span class="comment">//默认是类名</span></span><br><span class="line">    setWindowTitle(tr(<span class="string">"myMainWindow"</span>));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MainWindow::~MainWindow()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> MainWindow::receivelogin()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;show();<span class="comment">//显示主窗口</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> MainWindow::on_pushButton_clicked()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;hide();<span class="comment">//隐藏主窗口</span></span><br><span class="line">    <span class="function">emit <span class="title">dlgshow</span><span class="params">()</span></span>;<span class="comment">//发射显示登录对话框信号</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> MainWindow::on_pushButton_2_clicked()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">emit <span class="title">quit</span><span class="params">()</span></span>;<span class="comment">//发射退出信号</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>mydialog.cpp文件：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mydialog.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ui_mydialog.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;QHBoxLayout&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;mainwindow.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">MyDialog::MyDialog(QWidget *parent) :</span><br><span class="line">    QDialog(parent),</span><br><span class="line">    ui(<span class="keyword">new</span> Ui::MyDialog)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;setupUi(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyDialog::~MyDialog()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> MyDialog::on_pushButton_clicked()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;hide();<span class="comment">//隐藏登录对话框</span></span><br><span class="line">    <span class="function">emit <span class="title">showmainwindow</span><span class="params">()</span></span>;<span class="comment">//显示主窗口</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> MyDialog::receiveshow()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;show();<span class="comment">//显示登录对话框</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> MyDialog::on_pushButton_2_clicked()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">emit <span class="title">quit</span><span class="params">()</span></span>;<span class="comment">//发射退出信号</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-ui文件-窗口设计"><a href="#3-ui文件-窗口设计" class="headerlink" title="3.ui文件(窗口设计)"></a>3.ui文件(窗口设计)</h3><p>  <img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20140315/20140315_fig001.jpg" width="400" height="350" title="图1" alt="图1" ></p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20140315/20140315_fig002.jpg" width="400" height="350" title="图2" alt="图2" ></p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>Qt Coding</tag>
      </tags>
  </entry>
  <entry>
    <title>【Qt编程】Qt学习笔记&lt;二&gt;</title>
    <url>/2014/03/04/%5B20140304%5D/</url>
    <content><![CDATA[<ul>
<li><p>QApplication类和QWidget类都包含在QtGui模块中。所以我们可以只包含这个头文件即可。</p>
</li>
<li><p>在c++中，用new分配了内存空间就需要用delete来释放空间，而在Qt中，释放父对象时，会自动销毁子对象。</p>
</li>
<li><p>将光标定位到函数上时，会浮现出提示，按提示按f1就可以进入该函数的帮助文档。</p>
</li>
<li><p>在main.c文件中，程序只有进入了主事件循环后才能接受事件，而show函数会触发显示事件，所以只有在完成a.exe()函数调用进入消息循环后才能正常显示。</p>
</li>
<li><p>使用qDebug(“x:%d”,x)不需要添加<QDebug>头文件的。使用qDebug&lt;&lt;x则需要包含该头文件。</p>
</li>
<li><p>按照运行对话框时，是否还可以和该程序的其它窗口进行交互，可以分为模态和非模态。</p>
</li>
<li><p>在一个函数中定义的变量，等这个函数执行结束后，就自动释放内存了。因此我们一般将子部件定义为指针类型。</p>
</li>
<li><p>要想使一个对话框成为模态对话框，只需要调用它的exec()函数，而要使其成为非模态对话框，可以使用new操作来创建，然后使用show()函数来显示。</p>
</li>
<li><p>信号和槽都是函数，信号只需声明不需要定义。</p>
</li>
<li><p>信号和槽的关联可以分为自动关联和手动关联。自动关联就是使用规定的槽命名，而且必须使用Qt部件已经提供的信号。</p>
</li>
<li><p>快捷更改函数名：在函数上右击，选择重构-&gt;Rename Symbol Under Cursor</p>
</li>
<li><p>Qt 设计器直接生成的槽是自动关联，我们必须在调用setupUi()函数前定义子部件和对象名。因为setupUi调用connectSlotsByName()函数用来支持信号和槽的自动关联，调用时需要使用对象名。</p>
</li>
<li><p>信号和槽的特点：类型是安全的、松耦合的、参数灵活、比回调机制稍慢。</p>
</li>
<li><p>行编辑器的属性栏中还可以设置占位符，就是没有输入信息前的一些提示语句，就是更改编辑器的placeholderText属性。</p>
</li>
<li><p>加速键与快捷键的不同之处：如下图：我们设置’’新建’’的快捷键为<code>ctrl+N</code>,加速键为N，那么我们可以按下<code>ctrl+N</code>来新建文件，也可以先按<code>alt+F</code>激活’’文件’’菜单，然后按N来新建文件。<br><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20140304/20140304_fig001.jpg" width="300" height="150" title="图1" alt="图1" ></p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20140304/20140304_fig002.jpg" width="300" height="200" title="图2" alt="图2" ></p>
</li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>Qt Coding</tag>
      </tags>
  </entry>
  <entry>
    <title>【Matlab编程】Matlab版扫雷</title>
    <url>/2014/03/01/%5B20140301%5D/</url>
    <content><![CDATA[<p>​    我发现有些人平常闲着的时候会玩window自带的游戏，其中最常见的就是扫雷和纸牌。本来想用matlab编写全自动扫雷程序用来作弊，可是后来发现扫雷问题是NP完全问题（正如：旅行商NP难问题一样不能被解决），便放弃了。于是编写了类似扫雷游戏（没有经过大量测试，可能有bug，效率也不高，作弊：在命令窗口输入minefield 其中，值为1的地方为雷区）。大致规则和原来一样，只是做了些改进:加入了音乐和语音提示。具体代码如下（下面有两个文件：一个脚本文件，一个函数文件,只需运行第一个脚本文件即可）：</p>
<a id="more"></a>
<p><strong>1.脚本文件：</strong></p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clear all;</span><br><span class="line">row=<span class="number">10</span>;</span><br><span class="line">col=<span class="number">10</span>;</span><br><span class="line">num=<span class="number">30</span>;</span><br><span class="line">jieshu=<span class="number">0</span>;</span><br><span class="line"><span class="comment">%global flag;</span></span><br><span class="line">flag=<span class="built_in">zeros</span>(row,col);</span><br><span class="line">flag1=<span class="built_in">ones</span>(row,col);</span><br><span class="line">minenum=<span class="built_in">zeros</span>(row,col);</span><br><span class="line">minefield=<span class="built_in">rand</span>(row,col);</span><br><span class="line">[temp,index]=<span class="built_in">sort</span>(minefield(:));</span><br><span class="line">minefield=(minefield&lt;=minefield(index(num)));</span><br><span class="line">count=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:row</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">j</span>=<span class="number">1</span>:col</span><br><span class="line">      x1=<span class="built_in">i</span><span class="number">-1</span>;y1=<span class="built_in">j</span><span class="number">-1</span>;</span><br><span class="line">      x2=<span class="built_in">i</span><span class="number">-1</span>;y2=<span class="built_in">j</span>;</span><br><span class="line">      x3=<span class="built_in">i</span><span class="number">-1</span>;y3=<span class="built_in">j</span>+<span class="number">1</span>;</span><br><span class="line">      x4=<span class="built_in">i</span>;  y4=<span class="built_in">j</span><span class="number">-1</span>;</span><br><span class="line">      x5=<span class="built_in">i</span>;  y5=<span class="built_in">j</span>+<span class="number">1</span>;</span><br><span class="line">      x6=<span class="built_in">i</span>+<span class="number">1</span>;y6=<span class="built_in">j</span><span class="number">-1</span>;</span><br><span class="line">      x7=<span class="built_in">i</span>+<span class="number">1</span>;y7=<span class="built_in">j</span>;</span><br><span class="line">      x8=<span class="built_in">i</span>+<span class="number">1</span>;y8=<span class="built_in">j</span>+<span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span> x1&gt;<span class="number">0</span>&amp;&amp;y1&gt;<span class="number">0</span></span><br><span class="line">          <span class="keyword">if</span> minefield(x1,y1)==<span class="number">1</span></span><br><span class="line">              count=count+<span class="number">1</span>;</span><br><span class="line">          <span class="keyword">end</span></span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">      <span class="keyword">if</span> x2&gt;<span class="number">0</span></span><br><span class="line">          <span class="keyword">if</span> minefield(x2,y2)==<span class="number">1</span></span><br><span class="line">              count=count+<span class="number">1</span>;</span><br><span class="line">          <span class="keyword">end</span></span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">      <span class="keyword">if</span> x3&gt;<span class="number">0</span>&amp;&amp;y3&lt;<span class="number">11</span></span><br><span class="line">          <span class="keyword">if</span> minefield(x3,y3)==<span class="number">1</span></span><br><span class="line">              count=count+<span class="number">1</span>;</span><br><span class="line">          <span class="keyword">end</span></span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">      <span class="keyword">if</span> y4&gt;<span class="number">0</span></span><br><span class="line">          <span class="keyword">if</span> minefield(x4,y4)==<span class="number">1</span></span><br><span class="line">              count=count+<span class="number">1</span>;</span><br><span class="line">          <span class="keyword">end</span></span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">      <span class="keyword">if</span> y5&lt;<span class="number">11</span></span><br><span class="line">          <span class="keyword">if</span> minefield(x5,y5)==<span class="number">1</span></span><br><span class="line">              count=count+<span class="number">1</span>;</span><br><span class="line">          <span class="keyword">end</span></span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">      <span class="keyword">if</span> x6&lt;<span class="number">11</span>&amp;&amp;y6&gt;<span class="number">0</span></span><br><span class="line">          <span class="keyword">if</span> minefield(x6,y6)==<span class="number">1</span></span><br><span class="line">              count=count+<span class="number">1</span>;</span><br><span class="line">          <span class="keyword">end</span></span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">      <span class="keyword">if</span> x7&lt;<span class="number">11</span></span><br><span class="line">          <span class="keyword">if</span> minefield(x7,y7)==<span class="number">1</span></span><br><span class="line">              count=count+<span class="number">1</span>;</span><br><span class="line">          <span class="keyword">end</span></span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">      <span class="keyword">if</span> x8&lt;<span class="number">11</span>&amp;&amp;y8&lt;<span class="number">11</span></span><br><span class="line">          <span class="keyword">if</span> minefield(x8,y8)==<span class="number">1</span></span><br><span class="line">              count=count+<span class="number">1</span>;</span><br><span class="line">          <span class="keyword">end</span></span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">    minenum(<span class="built_in">i</span>,<span class="built_in">j</span>)=count;</span><br><span class="line">    count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">      </span><br><span class="line">hf=<span class="built_in">figure</span>(<span class="string">'NumberTitle'</span>,<span class="string">'off'</span>,<span class="string">'Name'</span>,<span class="string">'扫雷'</span>,<span class="string">'menubar'</span>,<span class="string">'none'</span>);</span><br><span class="line">uh1=uimenu(<span class="string">'label'</span>,<span class="string">'游戏'</span>);</span><br><span class="line">uimenu(uh1,<span class="string">'label'</span>,<span class="string">'背景颜色选择'</span>,<span class="string">'callback'</span>,<span class="string">'c=uisetcolor([0 0 1],''选择颜色'');set(hf,''color'',c);'</span>);</span><br><span class="line">uh2=uimenu(<span class="string">'label'</span>,<span class="string">'帮助'</span>);</span><br><span class="line">uimenu(uh2,<span class="string">'label'</span>,<span class="string">'游戏规则'</span>,<span class="string">'callback'</span>,[<span class="string">'text(-0.05,0,''与window自带的扫雷不同的是：雷用黑色标记，右击时用红色作记号，'',''fontsize'',12,''fontname'',''宋体'');'</span>,...</span><br><span class="line">       <span class="string">'hold on; text(-0.12,-0.07,''输了后，会有音乐和语音提示，赢了后，会有语音提示！'',''fontsize'',12,''fontname'',''宋体'') ; axis off '</span>]);</span><br><span class="line">uimenu(uh2,<span class="string">'label'</span>,<span class="string">'制作信息'</span>,<span class="string">'callback'</span>,<span class="string">'msgbox(''copyright:Wteng  Thanks for using!'')'</span>);</span><br><span class="line"><span class="keyword">for</span> m=<span class="number">1</span>:row;</span><br><span class="line">    <span class="keyword">for</span> n=<span class="number">1</span>:col;</span><br><span class="line">       h(m,n)=uicontrol(gcf,<span class="string">'style'</span>,<span class="string">'push'</span>,...</span><br><span class="line">            <span class="string">'foregroundColor'</span>,<span class="number">0.7</span>*[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>],...</span><br><span class="line">            <span class="string">'string'</span>,strcat(num2str(m),num2str(n)),...</span><br><span class="line">            <span class="string">'unit'</span>,<span class="string">'normalized'</span>,<span class="string">'position'</span>,[<span class="number">0.16</span>+<span class="number">0.053</span>*n,<span class="number">0.9</span><span class="number">-0.073</span>*m,<span class="number">0.05</span>,<span class="number">0.07</span>],...</span><br><span class="line">            <span class="string">'BackgroundColor'</span>,<span class="number">0.7</span>*[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>],<span class="string">'fontsize'</span>,<span class="number">17</span>,...</span><br><span class="line">            <span class="string">'fontname'</span>,<span class="string">'times new roman'</span>,...</span><br><span class="line">            <span class="string">'ButtonDownFcn'</span>,[<span class="string">'if isequal(get(gcf,''SelectionType''),''alt'')'</span>,...</span><br><span class="line">            <span class="string">' if ~get(gco,''Value'') if isequal(get(gco,''Tag''),''y'') '</span>,...</span><br><span class="line">            <span class="string">'set(gco,''style'',''push'',''string'','''',''backgroundcolor'',0.7*[1 1 1]);'</span>,...</span><br><span class="line">            <span class="string">'set(gco,''Tag'',''n''); else set(gco,''style'',''text'',''string'','''',''backgroundcolor'',[1 0 0]);'</span>,...</span><br><span class="line">            <span class="string">'set(gco,''Tag'',''y'');end;end;end'</span>],...</span><br><span class="line">            <span class="string">'Callback'</span>,[<span class="string">'h1=gcbo;[mf,nf]=find(h==h1);search(mf,nf,minenum,h,minefield,flag,jieshu);'</span>...</span><br><span class="line">            <span class="string">'for i=1:10 for j=1:10  hcomp(i,j)=get(h(i,j),''value'');  end;end;comp=(~hcomp==minefield);'</span>,...</span><br><span class="line">            <span class="string">'if  all(comp(:))  mh=msgbox(''你好厉害哟!！'',''提示'');sp=actxserver(''SAPI.SpVoice'');sp.Speak(''你好厉害哟!''); end;'</span>]);</span><br><span class="line">   <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p><strong>2.搜索蔓延函数如下：</strong></p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">search</span><span class="params">(mf,nf,minenum,h,minefield,flag,jieshu)</span></span></span><br><span class="line"><span class="keyword">if</span> flag==minefield</span><br><span class="line">    mh=msgbox(<span class="string">'你好厉害哟！'</span>,<span class="string">'提示'</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">if</span> minefield(mf,nf)==<span class="number">1</span></span><br><span class="line">    set(gco,<span class="string">'style'</span>,<span class="string">'text'</span>,<span class="string">'string'</span>,<span class="string">''</span>,<span class="string">'backgroundcolor'</span>,[<span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]);</span><br><span class="line">    load handel;</span><br><span class="line">    sound(y,Fs)</span><br><span class="line">    pause(<span class="number">10</span>);</span><br><span class="line">    mh=msgbox(<span class="string">'您输了！请再接再厉！'</span>,<span class="string">'提示'</span>);</span><br><span class="line">    sp=actxserver(<span class="string">'SAPI.SpVoice'</span>);</span><br><span class="line">    sp.Speak(<span class="string">'您输了！请再接再厉！'</span>)</span><br><span class="line">    pause(<span class="number">2</span>)</span><br><span class="line">    close all;</span><br><span class="line">    delete(hf);</span><br><span class="line"><span class="keyword">else</span>   </span><br><span class="line"><span class="keyword">if</span> minenum(mf,nf)==<span class="number">0</span></span><br><span class="line">    flag(mf,nf)=<span class="number">1</span>;</span><br><span class="line">    set(h(mf,nf),<span class="string">'string'</span>,<span class="string">''</span>);</span><br><span class="line">    set(h(mf,nf),<span class="string">'value'</span>,<span class="number">1</span>);</span><br><span class="line">    mf1=mf<span class="number">-1</span>;nf1=nf<span class="number">-1</span>;</span><br><span class="line">    mf2=mf<span class="number">-1</span>;nf2=nf;</span><br><span class="line">    mf3=mf<span class="number">-1</span>;nf3=nf+<span class="number">1</span>;</span><br><span class="line">    mf4=mf;  nf4=nf<span class="number">-1</span>;</span><br><span class="line">    mf5=mf;  nf5=nf+<span class="number">1</span>;</span><br><span class="line">    mf6=mf+<span class="number">1</span>;nf6=nf<span class="number">-1</span>;</span><br><span class="line">    mf7=mf+<span class="number">1</span>;nf7=nf;</span><br><span class="line">    mf8=mf+<span class="number">1</span>;nf8=nf+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> mf1&gt;<span class="number">0</span>&amp;&amp;nf1&gt;<span class="number">0</span> &amp;&amp; flag(mf1,nf1)==<span class="number">0</span></span><br><span class="line">    flag(mf1,nf1)=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> minenum(mf1,nf1)==<span class="number">0</span></span><br><span class="line">        set(h(mf1,nf1),<span class="string">'style'</span>,<span class="string">'text'</span>,<span class="string">'string'</span>,<span class="string">''</span>,<span class="string">'backgroundcolor'</span>,[<span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    set(h(mf1,nf1),<span class="string">'string'</span>,num2str(minenum(mf1,nf1)));</span><br><span class="line">    set(h(mf1,nf1), <span class="string">'foregroundColor'</span>,<span class="number">0.1</span>*[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>]);</span><br><span class="line">    set(h(mf1,nf1),<span class="string">'style'</span>,<span class="string">'text'</span>,<span class="string">'backgroundcolor'</span>,[<span class="number">1</span> <span class="number">1</span> <span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">if</span> minenum(mf1,nf1)==<span class="number">0</span></span><br><span class="line">        search(mf1,nf1,minenum,h,minefield,flag,jieshu);</span><br><span class="line">       </span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    set(h(mf1,nf1),<span class="string">'value'</span>,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">if</span> mf2&gt;<span class="number">0</span> &amp;&amp; flag(mf2,nf2)==<span class="number">0</span></span><br><span class="line">    flag(mf2,nf2)=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> minenum(mf2,nf2)==<span class="number">0</span></span><br><span class="line">        set(h(mf2,nf2),<span class="string">'style'</span>,<span class="string">'text'</span>,<span class="string">'string'</span>,<span class="string">''</span>,<span class="string">'backgroundcolor'</span>,[<span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    set(h(mf2,nf2),<span class="string">'string'</span>,num2str(minenum(mf2,nf2)));</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    set(h(mf2,nf2), <span class="string">'foregroundColor'</span>,<span class="number">0.1</span>*[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>]);</span><br><span class="line">    set(h(mf2,nf2),<span class="string">'style'</span>,<span class="string">'text'</span>,<span class="string">'backgroundcolor'</span>,[<span class="number">1</span> <span class="number">1</span> <span class="number">1</span>]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> minenum(mf2,nf2)==<span class="number">0</span></span><br><span class="line">        search(mf2,nf2,minenum,h,minefield,flag,jieshu);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    set(h(mf2,nf2),<span class="string">'value'</span>,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">if</span> mf3&gt;<span class="number">0</span>&amp;&amp;nf3&lt;<span class="number">11</span> &amp;&amp; flag(mf3,nf3)==<span class="number">0</span></span><br><span class="line">    flag(mf3,nf3)=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> minenum(mf3,nf3)==<span class="number">0</span></span><br><span class="line">        set(h(mf3,nf3),<span class="string">'style'</span>,<span class="string">'text'</span>,<span class="string">'string'</span>,<span class="string">''</span>,<span class="string">'backgroundcolor'</span>,[<span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    set(h(mf3,nf3),<span class="string">'string'</span>,num2str(minenum(mf3,nf3)));</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    set(h(mf3,nf3), <span class="string">'foregroundColor'</span>,<span class="number">0.1</span>*[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>]);</span><br><span class="line">    set(h(mf3,nf3),<span class="string">'style'</span>,<span class="string">'text'</span>,<span class="string">'backgroundcolor'</span>,[<span class="number">1</span> <span class="number">1</span> <span class="number">1</span>]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> minenum(mf3,nf3)==<span class="number">0</span></span><br><span class="line">        search(mf3,nf3,minenum,h,minefield,flag,jieshu);</span><br><span class="line">    <span class="keyword">end</span>   </span><br><span class="line">    set(h(mf3,nf3),<span class="string">'value'</span>,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">if</span> nf4&gt;<span class="number">0</span> &amp;&amp; flag(mf4,nf4)==<span class="number">0</span></span><br><span class="line">    flag(mf4,nf4)=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> minenum(mf4,nf4)==<span class="number">0</span></span><br><span class="line">        set(h(mf4,nf4),<span class="string">'style'</span>,<span class="string">'text'</span>,<span class="string">'string'</span>,<span class="string">''</span>,<span class="string">'backgroundcolor'</span>,[<span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    set(h(mf4,nf4),<span class="string">'string'</span>,num2str(minenum(mf4,nf4)));</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    set(h(mf4,nf4), <span class="string">'foregroundColor'</span>,<span class="number">0.1</span>*[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>]);</span><br><span class="line">    set(h(mf4,nf4),<span class="string">'style'</span>,<span class="string">'text'</span>,<span class="string">'backgroundcolor'</span>,[<span class="number">1</span> <span class="number">1</span> <span class="number">1</span>]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> minenum(mf4,nf4)==<span class="number">0</span></span><br><span class="line">        search(mf4,nf4,minenum,h,minefield,flag,jieshu);</span><br><span class="line">    <span class="keyword">end</span>    </span><br><span class="line">    set(h(mf4,nf4),<span class="string">'value'</span>,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">if</span> nf5&lt;<span class="number">11</span> &amp;&amp; flag(mf5,nf5)==<span class="number">0</span></span><br><span class="line">    flag(mf5,nf5)=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> minenum(mf5,nf5)==<span class="number">0</span></span><br><span class="line">        set(h(mf5,nf5),<span class="string">'style'</span>,<span class="string">'text'</span>,<span class="string">'string'</span>,<span class="string">''</span>,<span class="string">'backgroundcolor'</span>,[<span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    set(h(mf5,nf5),<span class="string">'string'</span>,num2str(minenum(mf5,nf5)));</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    set(h(mf5,nf5), <span class="string">'foregroundColor'</span>,<span class="number">0.1</span>*[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>]);</span><br><span class="line">    set(h(mf5,nf5),<span class="string">'style'</span>,<span class="string">'text'</span>,<span class="string">'backgroundcolor'</span>,[<span class="number">1</span> <span class="number">1</span> <span class="number">1</span>]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> minenum(mf5,nf5)==<span class="number">0</span></span><br><span class="line">        search(mf5,nf5,minenum,h,minefield,flag,jieshu);</span><br><span class="line">    <span class="keyword">end</span>    </span><br><span class="line">    set(h(mf5,nf5),<span class="string">'value'</span>,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">if</span> mf6&lt;<span class="number">11</span>&amp;&amp;nf6&gt;<span class="number">0</span> &amp;&amp; flag(mf6,nf6)==<span class="number">0</span></span><br><span class="line">    flag(mf6,nf6)=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> minenum(mf6,nf6)==<span class="number">0</span></span><br><span class="line">        set(h(mf6,nf6),<span class="string">'style'</span>,<span class="string">'text'</span>,<span class="string">'string'</span>,<span class="string">''</span>,<span class="string">'backgroundcolor'</span>,[<span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    set(h(mf6,nf6),<span class="string">'string'</span>,num2str(minenum(mf6,nf6)));</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    set(h(mf6,nf6), <span class="string">'foregroundColor'</span>,<span class="number">0.1</span>*[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>]);</span><br><span class="line">    set(h(mf6,nf6),<span class="string">'style'</span>,<span class="string">'text'</span>,<span class="string">'backgroundcolor'</span>,[<span class="number">1</span> <span class="number">1</span> <span class="number">1</span>]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> minenum(mf6,nf6)==<span class="number">0</span></span><br><span class="line">        search(mf6,nf6,minenum,h,minefield,flag,jieshu);</span><br><span class="line">    <span class="keyword">end</span>   </span><br><span class="line">    set(h(mf6,nf6),<span class="string">'value'</span>,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">if</span> mf7&lt;<span class="number">11</span> &amp;&amp; flag(mf7,nf7)==<span class="number">0</span></span><br><span class="line">    flag(mf7,nf7)=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> minenum(mf7,nf7)==<span class="number">0</span></span><br><span class="line">        set(h(mf7,nf7),<span class="string">'style'</span>,<span class="string">'text'</span>,<span class="string">'string'</span>,<span class="string">''</span>,<span class="string">'backgroundcolor'</span>,[<span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    set(h(mf7,nf7),<span class="string">'string'</span>,num2str(minenum(mf7,nf7))); </span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    set(h(mf7,nf7), <span class="string">'foregroundColor'</span>,<span class="number">0.1</span>*[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>]);</span><br><span class="line">    set(h(mf7,nf7),<span class="string">'style'</span>,<span class="string">'text'</span>,<span class="string">'backgroundcolor'</span>,[<span class="number">1</span> <span class="number">1</span> <span class="number">1</span>]);</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">if</span> minenum(mf7,nf7)==<span class="number">0</span></span><br><span class="line">        search(mf7,nf7,minenum,h,minefield,flag,jieshu);</span><br><span class="line">    <span class="keyword">end</span>    </span><br><span class="line">    set(h(mf7,nf7),<span class="string">'value'</span>,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">if</span> mf8&lt;<span class="number">11</span>&amp;&amp;nf8&lt;<span class="number">11</span> &amp;&amp; flag(mf8,nf8)==<span class="number">0</span></span><br><span class="line">    flag(mf8,nf8)=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> minenum(mf8,nf8)==<span class="number">0</span></span><br><span class="line">        set(h(mf8,nf8),<span class="string">'style'</span>,<span class="string">'text'</span>,<span class="string">'string'</span>,<span class="string">''</span>,<span class="string">'backgroundcolor'</span>,[<span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    set(h(mf8,nf8),<span class="string">'string'</span>,num2str(minenum(mf8,nf8)));</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    set(h(mf8,nf8), <span class="string">'foregroundColor'</span>,<span class="number">0.1</span>*[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>]);</span><br><span class="line">    set(h(mf8,nf8),<span class="string">'style'</span>,<span class="string">'text'</span>,<span class="string">'backgroundcolor'</span>,[<span class="number">1</span> <span class="number">1</span> <span class="number">1</span>]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> minenum(mf8,nf8)==<span class="number">0</span></span><br><span class="line">        search(mf8,nf8,minenum,h,minefield,flag,jieshu);</span><br><span class="line">    <span class="keyword">end</span>    </span><br><span class="line">    set(h(mf8,nf8),<span class="string">'value'</span>,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    set(h(mf,nf),<span class="string">'string'</span>,num2str(minenum(mf,nf)));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">  set(h(mf,nf), <span class="string">'foregroundColor'</span>,<span class="number">0.1</span>*[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>]);</span><br><span class="line">  set(h(mf,nf),<span class="string">'style'</span>,<span class="string">'text'</span>,<span class="string">'backgroundcolor'</span>,[<span class="number">1</span> <span class="number">1</span> <span class="number">1</span>]);  </span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<hr>
<p><strong>1.开始界面</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20140301/20140301_fig001.jpg" width="500" height="400" title="图1" alt="图1" ></p>
<p><strong>2.输了的界面</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20140301/20140301_fig002.jpg" width="500" height="400" title="图2" alt="图2" ></p>
<p><strong>3.赢了的界面</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20140301/20140301_fig003.jpg" width="500" height="400" title="图3" alt="图3" ></p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>Matlab Coding</tag>
      </tags>
  </entry>
  <entry>
    <title>【Qt编程】Qt学习笔记</title>
    <url>/2014/02/27/%5B20140227%5D/</url>
    <content><![CDATA[<ul>
<li><p>在创建项目时，项目名和路径中都不能出现中文。</p>
</li>
<li><p>可以使用<code>Ctrl + “+”</code>和<code>Ctrl + “-”</code>来改变程序的字体大小（Ctrl+鼠标滑轮可达到同样效果），使用<code>Ctrl + “0”</code>可以恢复到默认字体大小。</p>
</li>
<li><p>在设计模式下有几个过滤器，就是写着<code>Filter</code>的行输入框，可以帮助你更快的找到所需要的部件。</p>
</li>
<li><p>如果生成的.exe文件不能运行，并且提示丢失.dll文件，可以按照提示在Qt的安装目录的bin目录下寻找这些.dll文件。还有一种一劳永逸的方法是：将Qt的安装目录的bin目录加到系统的Path环境变量中去，这样程序运行是就可以自动找到那些dll文件。</p>
</li>
<li><p>在Qt Creator 默认下，编译的程序要想发布就需要dll文件，这种编译方式就称为动态编译。静态编译是指将Qt 的库进行重新编译，发布时不需要dll文件.</p>
</li>
<li><p>设置应用程序的图标：</p>
<ul>
<li>将myico.ico(名字可以自己取)图标文件放入工程的目录下，在目录里建立文本文档并写入下面代码<code>IDI_ICON1 ICON DISCARDABLE&quot;myico.ico&quot;</code>然后将该文本文档改为myico.rc (注意更改后缀名)</li>
<li>在项目文件中的pro文件中的最后添加下面代码：<code>RC_FILE += myico.rc</code></li>
</ul>
</li>
<li><p>任何一个QtGUI都需要一个QApplication类对象来管理应用程序的资源。</p>
</li>
<li><p>在默认情况下，新建的可视部件对象是不可见的，我们可以通过<code>show()</code>来显示。</p>
</li>
<li><p>中文显示乱码的解决办法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QTextCodec::setCodecForTr(QTextCodec::codecForName(<span class="string">"UTF-8"</span>));   QTextCodec::setCodecForTr(QTextCodec::codecForLocale());</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>  在Windows系统下，其中一个能正常显示，最好两者都写上。</p>
<ul>
<li><p>Qt Creator的代码补全功能<br>当输入一个比较长得函数或变量名时，可以通过其中的几个字母来定位。比如说，要输入前面讲到的<code>setFocus()</code>函数，那么只需输入首字母s和后面的大写字母F即可，这样可以大大缩减提示列表，如果还没有定位到，那么可以输入F后面的字母。如下图1所示。<br><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20140227/20140227_fig001.jpg" width="400" height="150" title="图1" alt="图1" ></p>
</li>
<li><p>默认的情况下，对话框的左上角是（0，0）。</p>
</li>
<li><p>Ui文件生成的默认头文件的名称是ui_加ui文件的名称；ui文件是使用uic编译工具来编译的。</p>
</li>
<li><p>当有多个项目并存时，我们可以在项目文件右击来设定活动项目。</p>
</li>
<li><p>在项目发布时，不需要包含user文件，如果要打开别人的项目文件，我们应该去掉这种类型的文件。</p>
</li>
<li><p>我们可以将pro文件直接拖向Qt Creator图标来打开项目。</p>
</li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>Qt Coding</tag>
      </tags>
  </entry>
  <entry>
    <title>【算法导论】我的2013--一切从心开始</title>
    <url>/2014/01/05/%5B20140105%5D/</url>
    <content><![CDATA[<p>​    愿乘风破万里浪;甘面壁读廿年书。</p>
<p>​    从保研成功以来，想好好休息一下，却发现生活总是被各种事情占据。</p>
<a id="more"></a>
<p>​    转眼间，已经大四了，大学生活已经过了整整一半了。我时常思考：怎样才能成功，做什么才有前途。作为一名通信工程专业的出生于农村的学生，带着村里人的希望（我们村上大学的就几个，而且都是二本以下）来到了大学的殿堂。父母都感到十分高兴，脸上都有光，尤其是奶奶。记得父母常年在外打工，我是由奶奶从四岁半带到高中毕业的。</p>
<p>​    大学之前，我基本上没接触过计算机，当然也没有QQ。第一次接触到计算机是在初中的电脑课上，当时我们上课就是自己玩，我记得每次去都是玩类似雷电的射击游戏。上了几节课后，不知道什么原因，以后再也没上过。说也惭愧，我连开关机都不会，每次玩游戏都是经常外出上网的同学帮忙开的。记得初二的时候，都是住在学校，很多同学都晚上翻墙出去上网，有时候会被老师逮到，狠狠揍一顿。作为一个好学生，这些事我从来都没做过。我只是每次放学回家，和同学一起玩小霸王游戏机，最喜欢玩的就是魂斗罗和超级玛丽。</p>
<p>​    2007年保送进了 县里最好的高中，但是到了人生的一个低谷。记得当初保送的是县里的前一百名，而在这一百名中，我的排名好像是靠后的。在初中的时候，每次考试都差不多一二名，因此有了很大的落差。在高中三年中，我始终生活在这种阴影中。但是父亲虽然是农村人，但是当过小学老师，每次打电话时，他都讲一些大道理。虽然他不在家，但是我受他的影响很大。每当我考的不好时，就鼓励我；每当我考的好时，就奖励我。我记得初二的时候，因为我考了第一名，爸爸奖励了我一辆自行车。保送到高中时，给我买了部手机。但是，高中学校不让带手机，所以就放在家里给奶奶用，现在奶奶还在用那部已经6年多的Nokia手机。正好我今年保研了，爸爸奖励了我一部lumia手机，我的旧Nokia手机将拿回去给奶奶用。在我的印象中，父母从来都没有打过我，给我的都是慈爱，不知是好是坏。</p>
<p>​    高中的时候，我们班有一个和我初中是同一所中学保送来的同学。记得我们小学是同桌，初中三年分在不同班，她成绩十分好，每次考试基本都是我两争夺一二名。可是到了高中，我却从来没有考过她。我在这里要感谢她，是她让我的成绩得到了进步。我记得在小学时，我和其它同学一样，过一天是一天，没有认识到学习是什么，自然我的成绩也一般。到了六年级，我由于个子不高，坐在前排和她是同桌，开始我也不知道她很行。后来听老师和学生都说她成绩好，我也开始注意她。她基本上每门课都好，我都自叹不如。我便开始知道我要学习了，不能在浑浑噩噩了。终于，我拿到了平生的第一次奖学金5块钱(记得当时我们年级2个班就我拿了)。</p>
<p>​    高考之后，考的不怎么样，没想到考到了班级第二，高中三年从来没有过，我并没有超常发挥，可能是同学没有考好吧。我没有考上理想的大学，记得当初在高中班主任笔记本上写的是要考复旦大学的。当初自己准备冒风险报中山大学的，班主任推荐去中南大学，爸爸说还是去一个比较保险的学校。当时还是想专业第一，学校第二，就上网搜了一下专业排名，报了通信工程专业还不错的西安电子科技大学。高考前，我都没有听说过西电这个学校，我是看专业排名才知道的。但是我的脑子里一直有一个观点，就是进哪个学校不重要，只要自己肯努力，就会有前途的，其实现在想起来，一个学校氛围怎么样还是对人有很大的影响的。我记得高中班上有两个成绩比我好的同学，一个去了川大，一个去了华中师范(成绩一直是班上一二名)，现在去川大的保到北大了，去华中师范的前段时间跟我说要考我们学校的研究生。</p>
<p>​    2010年暑假的时候，就在我过17岁生日那天，高中班主任告诉我西安电子科技大学大学的录取通知书到了，我们一家的高兴不已，这一天我记忆犹新。8月下旬，进入了西安电子科技大学，从此开始了一段新的征程。来到大学之前，我很是憧憬大学的美好。课也没有以前多了，有更多的自由了，可以做自己喜欢的事。我甚至还以为六十分万岁，多一分浪费，以为学习是很轻松的。可是，我想告诉大家的是，大学真的是一个人努力学习的地方，而不是放松的地方。现在已经是我本科的最后一年了。在刚上大学的时候，我认为在大学里当些班干部等等就很好了，所以我也开始积极参加各种面试，可惜最终无所作为。大一的时候根本不知道大学要学什么，天天就是上课。那时候一节课都没人逃，都是天天上课、吃饭、自习、回宿舍。周末常常和同学一玩，日子过得很平淡，感觉很充实。学校每年都会举办星火杯，我也兴致勃勃的参加了。当时我对电路元器件都不了解，就是用发给的图纸上的电路焊电路，最终也没有获奖。那时我知道，在大学不能只学习，更要懂得实践。于是我在学习之余，看了许多关于编程方面的书。希望对以后的实践有帮助。由于大一时星火杯没有获奖，因此我下定决心，争取下届星火杯获奖。于是大一暑假的时候，我总共在家只有十天就回学校学单片机了。暑假时，白天没电，我每天早上跑完步，就去图书馆，看单片机的理论知识，下午吃完饭，休息一会就去跑两圈，然后回宿舍洗澡，之后就是单片机编程，每一天都是如此，日子过得单调但是充实。</p>
<p>​    大二终于到了，我满怀希望地准备着星火杯，一个人天天焊电路、编程，经过几天的努力，作品完成了，可是工作状态不稳定。可能是因为我全部都是焊接的，有两百多条线，也不好排查到底是哪根松动了，或者说是程序哪里有问题了。在班里我也找不到可以请教的人，最终，作品并没有上交。感觉比较失落，我总结了失败的原因：没有队友。有些事不是一个人就可以解决的，我们需要他人的帮助。大二上学期的时候，我也没太注意学习，课余时间都是在看c、c++还有数据结构，期间也写过些程序。结果那学期的成绩考得不好，于是在大二下学期的时候，我觉得我应该努力学习了。因为保研和学习成绩有关，而不会说你程序写的多好就能保研，除非能拿国奖。经过我的努力，在大二学年拿到了励志奖学金。有了奖学金，我买了很多电子元器件和开发学习板。因为我知道要把钱都用在学习上。在大二暑假的时候，我没有回家，而是在学校参加数学建模，因为我始终认为实践是很重要的。在数学建模期间，我在大一暑假学习的matlab起到了作用。最终，经过三天三夜的奋斗，数学建模也取得了不错的成绩。</p>
<p>​    数学建模后，就到了大三了。经过这两年的知识沉淀，也总结了两次星火杯的失败，这次，我又参加了星火杯。因为听说大三要交工程设计，获过奖的可以免修。于是，我一下做了四个不同的星火杯作品：两个硬件，两个软件，结果都获奖了，同时也帮助一些同学免修了工程设计。大三时，学习的都是专业课，我丝毫不敢怠慢，因为这是我以后读研的基础。我把心思都用在了学习上，硬件和软件的学习时间就明显减少了。大三下学期的时候，我去参加了电赛的笔试和复试还有面试，结果由于我之前的实践经历和完成的作品，我被录取了。但是我后来主动退出了，因为电赛时间周期长，并且下学期的课基本上要逃，我对硬件也不是很感兴趣，所以我放弃了。虽然说如果当时我去了，很有可能就保外了，但是我觉得并不后悔，因为我认为自己该做自己感兴趣的事。努力的学习，积极的实践，大三这一学年，我再次获得了国家励志奖学金。自己也可以确定保研了，也许你认为现在终于可以休息了，可是我并不因为保研了而放松，大三暑假的时候，我又只回去了十天。在暑假期间，我看了部分算法导论，并用程序实践了，因为我决定研究生期间主要弄软件算法方面。</p>
<p>​    总的来说，大学期间，我付出了很多，也收获了许多。大学期间，也从未无故逃课。从大一的三等奖学金到一等奖学金再到励志奖学金，我的学习成绩也是逐渐进步的。从星火杯什么都不会到几件作品都获奖，我的实践能力也得到了提升。大学本科生活就要结束了，我就这样地度过了，我失去了许多东西，比如玩游戏、谈恋爱，但是我得到的却是无限的。我暑假总共才回了二十天，当然我也常常想念我的家人，因为我的梦想，我的抱负战胜了一切能够阻挡我的东西，我充分利用每一天的每一分每一秒，我感觉非常的充实。</p>
<p>​    在2013年的下学期，我们也没有课了，每天就是帮老师做项目。九月底的时候，就要面临考研、保研、找工作的问题。当然我决定保研，因为正如文章开头所说，我要读20年书：学前班1年、小学6年、中学6年、大学7年。于是我面临的是保内还是保外的问题。由于保外今年也算竞赛加分，可是我电赛放弃了，于是与保外只差一步之遥。成电通信工程也来我们学校招保送生，我想网上经常比较成电和西电，如果我本科是西电，研究生是成电，那就太好了，在通信界，西电和成电的校友占了绝大多数，以后找工作也方便，于是我就去面试了。我在面试的时候老师就要我了，问我想不想去，成电老师说学通信还是留西电比较好，学光钎去成电比较好，我一想，再怎么说西电通信也有个国家重点实验室，而去成电的话，又去不了国家抗干扰重点实验室，因为他们的通信工程学院和那个实验室是分开的。后来就没去成电。哈尔滨工业大学也来了，可是他们希望去读博士，也就没去成。本来还有机会去香港城市大学读直博的，可是选择了保内就没办法了。于是我就在本校去找导师，这里就遇到了找导师的问题：找一个什么样的导师。是名气大的博导，还是亲自带你的硕导。我想有的人可能知道，基本上没有导师会手把手教你，博导也是一般叫团队的年轻老师带你。所以我选择了西电在宽带无线方面最好的博导，因为我认为，哪个导师关系不大，重要的是实验室的环境，我导师的学生基本都是保送的。可悲的是，我从来没有见过我导师，也没有他的联系方式，这有点搞笑，因为我是由团队的另一个老师推荐过去的，不知道研究生期间有机会见面不，毕竟牛人都是很忙的。下面对我的大学生活的各个方面做简要总结：</p>
<p><strong>考研还是保研？</strong></p>
<p>​    当我知道保外有风险，保内不甘心时，想到了考研，父母都已经四十出头，经不起我冒风险考研，而且保研还有一等奖学金，相当于一年的学费和住宿费。保内的话也可以为父母减轻负担，父母也希望我保本校。</p>
<p><strong>认真学习还是做自己喜欢的事？</strong></p>
<p>​    大一大二的时候，我就开始看课程外的关于算法的书籍以及单片机，因为我认为大学是来学习实践的，来学技术的，只学课本的东西和高中没两样。后来知道，保研是要看成绩排名的，除非竞赛能获得国奖。毕竟这样通过竞赛获奖来保研太冒险，并且当时保外是不算竞赛的，所以我决定好好学习，提高专业课成绩。</p>
<p><strong>艰苦奋斗还是劳逸结合？</strong></p>
<p>​    怎样才能把学习搞好，不同的人有不同的看法。我们班有的人天天上自习，从不看电视剧、电影（太佩服了），成绩也不是很理想，有的人平常玩，考前突击一下，就考得很好。而我呢，就属于两者居中的情况，平时也上上自习，周末就看一部电视剧，想起来，大学三年，我把金庸、古龙的电视剧又差不多看了一遍。</p>
<p><strong>出去玩还是在学校宅？</strong></p>
<p>​    由于新校区在郊区，去市区的916不是一般的挤，也不是常常出去玩。在大一大二的时候，还经常出去，到目前为止，西安的大多数旅游景点都去过了，这两年就基本上没去过了。这两年主要是骑车去秦岭玩，现在还记得还在秦岭里面摘柿子吃、在山间清泉游泳的场景。去的比较远的地方就是在保研之后的十一去甘肃的敦煌、嘉峪关等地方玩。</p>
<p><strong>是继续编程还是研究通信方面？</strong></p>
<p>​    毕竟我是通信工程专业的学生，编程只是工具。与软件专业的相比，软件不行，与电子专业相比，硬件不行。学习编程，只是我个人的爱好而已。现在我的研究方向为认知无线电，需要用到编程仿真，因此编程也不能放下。但是我应该记住，编程只是工具，不能舍本逐末！</p>
<p><strong>怎样保持学习的热情？</strong></p>
<p>​    人总是有惰性，怎样才能持之以恒？我也经常遇到这样的问题。我觉得非常有效的方法是，自己学不进去的时候，看看牛人们都在干什么，去图书馆看看书，一想到图书馆还有这么多书没看过，顿时就有了学习的热情，你也可以看看csdn上一些牛人的博客，看看他们都在干什么，而你在干什么。</p>
<p><strong>做自己想做的事</strong></p>
<p>​    在大学的三次暑假里，我在家的时间总共才20天，其它时间我都是在学校度过。在这段时间里，我都是在学习自己感兴趣的东西，这些日子里，没有作业和考试的烦恼，一心一意地学习，我感觉这段时间是我效率最高的日子。在大四保研后，我一直都忙于导师的项目，暑假看的算法导论我也经常抽时间看看，现在基本看得差不多了。做你想做的事，一切从心开始。</p>
<p>​    大学是我们每个人最宝贵的时间，你付出了四年的时间代价，你也会获得相应的回报。好好上好每一节课，以后可能就没有机会了。年轻人应该有更高的追求，你要为你的将来做好准备，外面的世界很残酷，你能活着已经是非常幸运了，好好珍惜吧！</p>
<p>​    本来打算元旦前夕写这篇文章的，可以忙于模电的仿真，今天终于有时间了，下周完成硬件电路就可以回家了。这一年不管怎样，都即将过去。该留下的，该释怀的，都很明了。来年又是新的一年，决定课外学习界面编程，坚持上自习，坚持锻炼，认同自我，超越自我，从心出发。</p>
<p>既然选择了远方,便只顾风雨兼程！</p>
<p><strong>祝福所有的IT人，新年快乐、身体健康，拥有一个美好的明天！</strong></p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>Algorithm Design</tag>
      </tags>
  </entry>
  <entry>
    <title>【算法导论】最大二分匹配</title>
    <url>/2014/01/04/%5B20140104%5D/</url>
    <content><![CDATA[<p>​    <strong>最大二分匹配问题</strong>在现实生活中比较普遍，常常出现在任务分配上。例如，有5个员工，4个不同的任务，而不同员工能够完成不同或相同的任务。也就是说，有的员工只会做这个任务，有的员工会做那个任务，有的员工会做一些任务。<strong>图解如下</strong>：左边代表员工，右边代表任务，连线代表有能力完成。</p>
<a id="more"></a>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20140104/20140104_fig001.jpg" width="200" height="300" title="图1" alt="图1" ></p>
<p>我们的问题是合理安排员工，尽可能地完成最多的任务数。图1中阴影部分为一种最好的分配方式。前一篇文章中，我们介绍了最大流问题，<strong>在这里我们可以将最大二分匹配问题转变成最大流问题</strong>。具体如下图2所示：</p>
<p> <img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20140104/20140104_fig002.jpg" width="400" height="300" title="图2" alt="图2" ></p>
<p>其中每条边的最大流量限制为1，因此要求能完成的最大任务数，相当于求转变后的网络的最大流，而最大流问题在前面已经提及。</p>
<p><strong>具体的程序实现如下：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 11 <span class="comment">//顶点数 </span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/********************************************************\</span></span><br><span class="line"><span class="comment">函数功能：从残留网络中找到从源点s到汇点t的增广路径</span></span><br><span class="line"><span class="comment">输入：残留网络矩阵、记录前一顶点的矩阵</span></span><br><span class="line"><span class="comment">输出：0表示未找到路径，1表示找到了路径</span></span><br><span class="line"><span class="comment">\********************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span> dist1[N][N],<span class="keyword">int</span> vertex[N])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> <span class="built_in">queue</span>[<span class="number">20</span>]=&#123;<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>&#125;;<span class="comment">//初始化，-1作为标记</span></span><br><span class="line">	<span class="keyword">int</span> flag[N]=&#123;<span class="number">0</span>&#125;;<span class="comment">//标记顶点是否被访问过</span></span><br><span class="line">	<span class="keyword">int</span> front=<span class="number">0</span>;<span class="comment">//队列头指针</span></span><br><span class="line">	<span class="keyword">int</span> rear=<span class="number">0</span>;<span class="comment">//队列尾指针</span></span><br><span class="line">	<span class="keyword">int</span> temp=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="built_in">queue</span>[rear]=<span class="number">0</span>;<span class="comment">//将源点入队列</span></span><br><span class="line">	flag[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">	rear++;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">queue</span>[front]!=<span class="number">-1</span>)<span class="comment">//队列不为空</span></span><br><span class="line">	&#123;</span><br><span class="line">		temp=<span class="built_in">queue</span>[front];<span class="comment">//取队头元素</span></span><br><span class="line">	    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">			<span class="keyword">if</span>(dist1[temp][i]!=<span class="number">0</span>&amp;&amp;flag[i]==<span class="number">0</span>)<span class="comment">//广度搜索法</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">queue</span>[rear++]=i;<span class="comment">//入队</span></span><br><span class="line">				flag[i]=<span class="number">1</span>;</span><br><span class="line">				vertex[i]=temp;<span class="comment">//标记当前节点的上一个节点</span></span><br><span class="line">				<span class="keyword">if</span>(i==<span class="number">10</span>)<span class="comment">//找到汇点后就不用再寻找了</span></span><br><span class="line">					<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		front++;</span><br><span class="line">		<span class="keyword">if</span>(front==N)<span class="comment">//找完所有顶点后停止寻找</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">queue</span>[rear<span class="number">-1</span>]!=<span class="number">10</span>)<span class="comment">//没有找到路径到汇点</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**************************************************************************\</span></span><br><span class="line"><span class="comment">函数功能：修改残余网络矩阵和原始流网络矩阵</span></span><br><span class="line"><span class="comment">输入：原始流网络矩阵、残留网络矩阵、记录前一顶点的矩阵、源点和汇点，最大流值</span></span><br><span class="line"><span class="comment">输出：0表示未找到路径，1表示找到了路径</span></span><br><span class="line"><span class="comment">\***************************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> dist[N][N],<span class="keyword">int</span> dist1[N][N],<span class="keyword">int</span> vertex[N],<span class="keyword">int</span> s,<span class="keyword">int</span> t,<span class="keyword">int</span> flow)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i,j;</span><br><span class="line">	<span class="keyword">int</span> min=<span class="number">10000</span>;<span class="comment">//记录找到的路径所能通过的最大流</span></span><br><span class="line"></span><br><span class="line">	i=vertex[t];</span><br><span class="line">	j=t;</span><br><span class="line">	<span class="keyword">while</span>(j!=s)<span class="comment">//寻找路径所含边的最大流量值中的最小值</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(dist1[i][j]&lt;min)</span><br><span class="line">			min=dist1[i][j];	</span><br><span class="line">		j=i;  </span><br><span class="line">		i=vertex[i];</span><br><span class="line">	&#125;</span><br><span class="line">	i=vertex[t];</span><br><span class="line">	j=t;</span><br><span class="line">	flow=min;<span class="comment">//记录最大流量</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(j!=s)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(dist1[i][j]&gt;<span class="number">0</span>)<span class="comment">//更改残余图</span></span><br><span class="line">			dist1[j][i]=dist1[i][j];</span><br><span class="line">		dist1[i][j]=dist1[i][j]-min;</span><br><span class="line">		dist[i][j]=dist[i][j]+min-dist[j][i];<span class="comment">//更改原始流网路</span></span><br><span class="line">		<span class="keyword">if</span>(dist[i][j]&lt;<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			dist[j][i]=-dist[i][j];</span><br><span class="line">			dist[i][j]=<span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		j=i;</span><br><span class="line">		i=vertex[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"原始流网络矩阵：\n"</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;N;j++)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%d "</span>,dist[i][j]);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"残留网络矩阵：\n"</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;N;j++)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%d "</span>,dist1[i][j]);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FordFulkerson</span><span class="params">(<span class="keyword">int</span> dist[N][N],<span class="keyword">int</span> dist1[N][N])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> vertex[N]=&#123;<span class="number">0</span>&#125;;<span class="comment">//初始化</span></span><br><span class="line">	<span class="keyword">int</span> flow=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(search(dist1,vertex)==<span class="number">1</span>)<span class="comment">//当能找到增广路径时</span></span><br><span class="line">	&#123;    </span><br><span class="line">		flow=flow+modify(dist,dist1,vertex,<span class="number">0</span>,<span class="number">10</span>,<span class="number">0</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"最大流为%d \n"</span>,flow);</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> dist1[N][N]=&#123;&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">					 &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">					 &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">					 &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>&#125;,</span><br><span class="line">				     &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">					 &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">					 &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>&#125;,</span><br><span class="line">					 &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>&#125;,</span><br><span class="line">					 &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>&#125;,</span><br><span class="line">					 &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>&#125;,</span><br><span class="line">					 &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line">	<span class="keyword">int</span> dist[N][N]=&#123;<span class="number">0</span>&#125;;<span class="comment">//初始的流网络为0</span></span><br><span class="line"></span><br><span class="line">	FordFulkerson(dist,dist1);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序结果为最大流为3，与前面的图解一致，但是我们发现结果与图解的不同，这说明最大二分匹配可以有不同的解即有不同的分配方案。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>Algorithm Design</tag>
      </tags>
  </entry>
  <entry>
    <title>【算法导论】最大流算法</title>
    <url>/2014/01/02/%5B20140102%5D/</url>
    <content><![CDATA[<p><strong>最大流问题就是在容量容许的条件下，从源点到汇点所能通过的最大流量。</strong></p>
<p><strong>流网络</strong></p>
<p>​    网络流G=(v, E)是一个有向图，其中每条边(u, v)均有一个非负的容量值，记为c(u, v) ≧ 0。如果(u, v) ∉ E则可以规定c(u, v) = 0。网络流中有两个特殊的顶点，即源点s和汇点t。</p>
<p> 与网络流相关的一个概念是流。设G是一个流网络，其容量为c。设s为网络的源点，t为汇点，那么G的流是一个函数f：V×V →R，满足一下性质：</p>
<ul>
<li><strong>容量限制</strong>：对所有顶点对u，v∈V，满足f(u, v) ≦ c(u, v)；</li>
<li><strong>反对称性</strong>：对所有顶点对u，v∈V，满足f(u, v) = - f(v, u);</li>
<li><strong>流守恒性</strong>：对所有顶点对u∈V-{s, t}，满足Σv∈Vf(u,v)=0。</li>
</ul>
<p>本文开始讨论解决最大流问题的Ford-Fulkerson方法，该方法也称作“扩充路径方法”，该方法是大量算法的基础，有多种实现方法。</p>
<a id="more"></a>
<p><strong>Ford-Fulkerson算法是一种迭代算法</strong>，首先对图中所有顶点对的流大小清零，此时的网络流大小也为0。在每次迭代中，通过寻找一条“增广路径”(augument path)来增加流的值。增广路径可以看作是源点s到汇点t的一条路径，并且沿着这条路径可以增加更多的流。迭代直至无法再找到增广路径位置，此时必然从源点到汇点的所有路径中都至少有一条边的满边（即边的流的大小等于边的容量大小）。</p>
<hr>
<p><strong>基本思想</strong></p>
<p>给定一个流网络G和一个流，流的残留网Gf拥有与原网相同的顶点。原流网络中每条边将对应残留网中一条或者两条边，对于原流网络中的任意边(u, v)，流量为f(u, v)，容量为c(u, v)：</p>
<ul>
<li>如果f(u, v) &gt; 0，则在残留网中包含一条容量为f(u, v)的边(v, u);</li>
<li>如果f(u, v) &lt; c(u, v)，则在残留网中包含一条容量为c(u, v) - f(u, v)的边(u, v)。</li>
</ul>
<hr>
<p>残留网允许我们使用任何广义图搜索算法来找一条增广路径，因为残留网中从源点s到汇点t的路径都直接对应着一条增广路径。在关于基本思想的解读方面，算法导论的理论讲解令我一知半解，后来在网上找到了下面的图解过程，个人觉得十分清晰易懂，<strong>因此借鉴如下</strong>：</p>
<p>以图为例，具体分析增广路径及其相应残留网，如图1-4。</p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20140102/20140102_fig001.jpg" width="500" height="300" title="图1" alt="图1" ></p>
<p>图1为原始图流网络，每条边上的流都为0。因为f(u, v) = 0 &lt; c(u, v)，则在残留网中包含容量为c(u, v)的边(u, v)，所以此时残留图中顶点与原始流网络相同，边也与原始流网络相同，并且边的容量与原始流网络相同。</p>
<p>在残留网中可以找到一条增广路径<v0, v1, v3, v5>，每条边的流为2，此原始流网络和残留网中相应的边会有所变化，如下图2。</p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20140102/20140102_fig002.jpg" width="500" height="300" title="图2" alt="图2" ></p>
<p>图2在图1操作之后，路径<v0, v1, v3, v5>上有了大小为2的流，此时需要对残留图中相应的边做调整：</p>
<ul>
<li>f(0, 1) &gt; 0，在残留图中有容量为2的边(1, 0)；</li>
<li>c(1, 3) &gt; f(1, 3) &gt; 0，在残留图中有容量为1的边(1, 3)和容量为2的边(3, 1)；</li>
<li>f(3, 5) &gt; 0，在残留图中有容量为2的边(5, 3).</li>
</ul>
<p>在残留网中可以找到一条增广路径<v0, v2, v4, v5>，每条边的流为1，此原始流网络和残留网会有所变化，如下图3。</p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20140102/20140102_fig003.jpg" width="500" height="300" title="图3" alt="图3" ></p>
<p>图3在图2操作之后，路径<v0, v2, v4, v5>上有了大小为1的流，此时需要对残留图中相应的边做调整：</p>
<ul>
<li>​    c(0, 2) &gt; f(0, 2) &gt; 0，在残留图中有容量为2的边(0, 2)和容量为1的边(2, 0)；</li>
<li>​    f(2, 4) &gt; 0，在残留图中有容量为1的边(4, 2)；</li>
<li>c(4, 5) &gt; f(4, 5) &gt; 0，在残留图中有容量为2的边(4, 5)和容量为1的边(5, 4).</li>
</ul>
<p>进一步在残留网中可以找到一条增广路径<v0, v2, v3, v1, v4, v5>，每条边的流为1，此原始流网络和残留网会有所变化，如下图4。</p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20140102/20140102_fig004.jpg" width="500" height="300" title="图4" alt="图4" ></p>
<p>图4在图3操作之后，路径<v0, v2, v3, v1, v4, v5>上有了大小为1的流，此时需要对残留图中相应的边做调整：</p>
<ul>
<li>​    c(0, 2) &gt; f(0, 2) &gt; 0，在残留图中有容量为1的边(0, 2)和容量为2的边(2, 0)；</li>
<li>​    f(2, 3) &gt; 0，在残留图中有容量为1的边(3, 2)；</li>
<li>​    c(3, 1) &gt; f(3, 1) &gt; 0，在残留图中有容量为1的边(3, 1)和容量为2的边(1, 3)；</li>
<li>​    f(1, 4) &gt; 0，在残留图中有容量为1的边(4, 1)；</li>
<li>​    c(4, 5) &gt; f(4, 5) &gt; 0，在残留图中有容量为1的边(4, 5)和容量为2的边(5, 4)；</li>
</ul>
<p>此时残留图中无法再找到顶点0到顶点5的路径，则迭代结束，我们认为图4中即为寻找到的最大流（该结论可以由最大流最小割定理证明）。</p>
<p><strong>最大流最小割定理：</strong>一个网中所有流中的最大值等于所有割中的最小容量。并且可以证明一下三个条件等价：</p>
<ul>
<li>f是流网络G的一个最大流；</li>
<li>残留网Gf不包含增广路径；</li>
<li>G的某个割(S, T)，满足f(S, T) = c(S, T).</li>
</ul>
<hr>
<p><strong>寻找增广路径方法的影响</strong></p>
<p>增广路径事实上是残留网中从源点s到汇点t的路径，可以利用图算法中的任意一种被算法来获取这条路径，例如BFS，DFS等。其中基于BFS的算法通常称为Edmonds-Karp算法，该算法是“最短”扩充路径，这里的“最短”由路径上的边的数量来度量，而不是流量或者容量。</p>
<p>这里所选的路径寻找方法会直接影响算法的运行时间，例如，对下图(a)采用DFS的方法搜索残留网中的增广路径。图(b)中是第一次搜索得到的增广路径为<s, v1, v2, t>，路径的流大小为1；图(c)和(d)中搜索得到的增广路径的流大小也是1。可以发现，在这个例子中，采用DFS算法将需要2000000次搜索才能得到最大流。</p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20140102/20140102_fig005.jpg" width="500" height="400" title="图5" alt="图5" ></p>
<p>如果换一种方法对残留网中的进行遍历将会很快求得流网络的最大流。如下图，第一次在顶点1搜索下一条边时，不是选择边(1, 2)而是选择容量更大的边(1, t)；第二次在顶点2处搜索下一条边时，选择边(2, t)。这样只要两次遍历即可求解最大流。可见，在残留网中搜索增广路径的算法直接影响Ford-Fulkerson方法实现的效率。</p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20140102/20140102_fig006.jpg" width="500" height="150" title="图6" alt="图6" ></p>
<p><strong>下面我采用BFS算法来寻找增广路径，具体的程序实现如下：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 6 <span class="comment">//顶点数 </span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/********************************************************\</span></span><br><span class="line"><span class="comment">函数功能：从残留网络中找到从源点s到汇点t的增广路径</span></span><br><span class="line"><span class="comment">输入：残留网络矩阵、记录前一顶点的矩阵</span></span><br><span class="line"><span class="comment">输出：0表示未找到路径，1表示找到了路径</span></span><br><span class="line"><span class="comment">\********************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span> dist1[N][N],<span class="keyword">int</span> vertex[N])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> <span class="built_in">queue</span>[<span class="number">20</span>]=&#123;<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>&#125;;<span class="comment">//初始化，-1作为标记</span></span><br><span class="line">	<span class="keyword">int</span> flag[N]=&#123;<span class="number">0</span>&#125;;<span class="comment">//标记顶点是否被访问过</span></span><br><span class="line">	<span class="keyword">int</span> front=<span class="number">0</span>;<span class="comment">//队列头指针</span></span><br><span class="line">	<span class="keyword">int</span> rear=<span class="number">0</span>;<span class="comment">//队列尾指针</span></span><br><span class="line">	<span class="keyword">int</span> temp=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="built_in">queue</span>[rear]=<span class="number">0</span>;<span class="comment">//将源点入队列</span></span><br><span class="line">	flag[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">	rear++;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">queue</span>[front]!=<span class="number">-1</span>)<span class="comment">//队列不为空</span></span><br><span class="line">	&#123;</span><br><span class="line">		temp=<span class="built_in">queue</span>[front];<span class="comment">//取队头元素</span></span><br><span class="line">	    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">			<span class="keyword">if</span>(dist1[temp][i]!=<span class="number">0</span>&amp;&amp;flag[i]==<span class="number">0</span>)<span class="comment">//广度搜索法</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">queue</span>[rear++]=i;<span class="comment">//入队</span></span><br><span class="line">				flag[i]=<span class="number">1</span>;</span><br><span class="line">				vertex[i]=temp;<span class="comment">//标记当前节点的上一个节点</span></span><br><span class="line">			&#125;</span><br><span class="line">		front++;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(front==N)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">queue</span>[rear<span class="number">-1</span>]!=<span class="number">5</span>)<span class="comment">//没有找到路径到汇点</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**************************************************************************\</span></span><br><span class="line"><span class="comment">函数功能：修改残余网络矩阵和原始流网络矩阵</span></span><br><span class="line"><span class="comment">输入：原始流网络矩阵、残留网络矩阵、记录前一顶点的矩阵、源点和汇点，最大流值</span></span><br><span class="line"><span class="comment">输出：0表示未找到路径，1表示找到了路径</span></span><br><span class="line"><span class="comment">\***************************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> dist[N][N],<span class="keyword">int</span> dist1[N][N],<span class="keyword">int</span> vertex[N],<span class="keyword">int</span> s,<span class="keyword">int</span> t,<span class="keyword">int</span> flow)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i,j;</span><br><span class="line">	<span class="keyword">int</span> min=<span class="number">10000</span>;<span class="comment">//记录找到的路径所能通过的最大流</span></span><br><span class="line"></span><br><span class="line">	i=vertex[t];</span><br><span class="line">	j=t;</span><br><span class="line">	<span class="keyword">while</span>(j!=s)<span class="comment">//寻找路径所含边的最大流量值中的最小值</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(dist1[i][j]&lt;min)</span><br><span class="line">			min=dist1[i][j];	</span><br><span class="line">		j=i;  </span><br><span class="line">		i=vertex[i];</span><br><span class="line">	&#125;</span><br><span class="line">	i=vertex[t];</span><br><span class="line">	j=t;</span><br><span class="line">	flow=flow+min;<span class="comment">//记录最大流量</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(j!=s)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(dist1[i][j]&gt;<span class="number">0</span>)<span class="comment">//更改残余图</span></span><br><span class="line">			dist1[j][i]=dist1[i][j];</span><br><span class="line">		dist1[i][j]=dist1[i][j]-min;</span><br><span class="line">		dist[i][j]=dist[i][j]+min-dist[j][i];<span class="comment">//更改原始流网路</span></span><br><span class="line">		<span class="keyword">if</span>(dist[i][j]&lt;<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			dist[j][i]=-dist[i][j];</span><br><span class="line">			dist[i][j]=<span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		j=i;</span><br><span class="line">		i=vertex[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"原始流网络矩阵：\n"</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;N;j++)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%d "</span>,dist[i][j]);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"残留网络矩阵：\n"</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;N;j++)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%d "</span>,dist1[i][j]);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FordFulkerson</span><span class="params">(<span class="keyword">int</span> dist[N][N],<span class="keyword">int</span> dist1[N][N])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> vertex[N]=&#123;<span class="number">0</span>&#125;;<span class="comment">//初始化</span></span><br><span class="line">	<span class="keyword">int</span> flow=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(search(dist1,vertex)==<span class="number">1</span>)<span class="comment">//当能找到增广路径时</span></span><br><span class="line">	&#123;    </span><br><span class="line">		flow=modify(dist,dist1,vertex,<span class="number">0</span>,<span class="number">5</span>,flow);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"最大流为%d \n"</span>,flow);</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> dist1[N][N]=&#123;&#123;<span class="number">0</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,<span class="comment">//初始的残留网络即为原始网络</span></span><br><span class="line">					&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">0</span>&#125;,</span><br><span class="line">					&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>&#125;,</span><br><span class="line">					&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">2</span>&#125;,</span><br><span class="line">					&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">3</span>&#125;,</span><br><span class="line">					&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line">	<span class="keyword">int</span> dist[N][N]=&#123;<span class="number">0</span>&#125;;<span class="comment">//初始的流网络为0</span></span><br><span class="line"></span><br><span class="line">	FordFulkerson(dist,dist1);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>显示结果如下：</strong></p>
<p>原始流网络矩阵：<br>0 2 0 0 0 0<br>0 0 0 2 0 0<br>0 0 0 0 0 0<br>0 0 0 0 0 2<br>0 0 0 0 0 0<br>0 0 0 0 0 0<br>残留网络矩阵：<br>0 0 3 0 0 0<br>2 0 0 1 1 0<br>0 0 0 1 1 0<br>0 3 0 0 0 0<br>0 0 0 0 0 3<br>0 0 0 2 0 0</p>
<p>原始流网络矩阵：<br>0 2 1 0 0 0<br>0 0 0 2 0 0<br>0 0 0 0 1 0<br>0 0 0 0 0 2<br>0 0 0 0 0 1<br>0 0 0 0 0 0<br>残留网络矩阵：<br>0 0 2 0 0 0<br>2 0 0 1 1 0<br>3 0 0 1 0 0<br>0 3 0 0 0 0<br>0 0 1 0 0 2<br>0 0 0 2 3 0</p>
<p>原始流网络矩阵：<br>0 2 2 0 0 0<br>0 0 0 1 1 0<br>0 0 0 1 1 0<br>0 0 0 0 0 2<br>0 0 0 0 0 2<br>0 0 0 0 0 0<br>残留网络矩阵：<br>0 0 1 0 0 0<br>2 0 0 3 0 0<br>2 0 0 0 0 0<br>0 2 1 0 0 0<br>0 1 1 0 0 1<br>0 0 0 2 2 0</p>
<p>最大流为4<br>请按任意键继续. . .</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>Algorithm Design</tag>
      </tags>
  </entry>
  <entry>
    <title>【算法导论】幻方算法</title>
    <url>/2013/12/30/%5B20131230%5D/</url>
    <content><![CDATA[<p>​    说起幻方，大家应该在小学时候就已经接触过了，最简单的就是九宫格，射雕英雄传中的那段至今还记得：<strong>戴九履一，左三右七，二四为肩，六八为足</strong>。下面我们就来看看这个有趣的问题。</p>
<a id="more"></a>
<p>​    幻方可以分为：<strong>奇数阶幻方、双偶阶幻方、单偶阶幻方</strong>。</p>
<p><strong>奇数阶幻方</strong></p>
<p>​    上面所说的九宫格就是典型的奇数阶幻方，奇数阶幻方值得是阶数为奇数的幻方。其最经典的填法是罗伯法。首先 把$1$（或最小的数）放在第一行正中；按以下规律排列剩下的$(n^2-1)$个数，<strong>具体步骤为：</strong></p>
<p>（1）每一个数放在前一个数的右上一格；</p>
<p>（2）如果这个数所要放的格已经超出了顶行那么就把它放在底行，仍然要放在右一列；</p>
<p>（3）如果这个数所要放的格已经超出了最右列那么就把它放在最左列，仍然要放在上一行；</p>
<p>（4）如果这个数所要放的格已经超出了顶行且超出了最右列，那么就把它放在底行且最左列；</p>
<p>（5）如果这个数所要放的格已经有数填入，那么就把它放在前一个数的下一行同一列的格内。</p>
<p><strong>上述步骤可以总结为七言绝句：</strong>       </p>
<blockquote>
<p> 先填上行正中央， 依次斜填切莫忘。 上格没有顶格填， 顶格没有底格放。—奇幻七绝</p>
</blockquote>
<p>下面有人通过作图可以很好的解释这几句话，现借鉴如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20131230/20131230_fig001.jpg" width="600" height="300" title="图1" alt="图1" ></p>
<p>从上面的图可以看出，该图与我们前面的九宫格口诀不相符，上下颠倒了。但是这都是对的，本质上没有区别。</p>
<p><strong>双偶数阶幻方</strong></p>
<p>所谓双偶阶幻方就是当$n$可以被$4$整除时的偶阶幻方，即$4K$阶幻方。其最经典的填法为海尔法，下面以$8$阶幻方为例，具体的填法为：</p>
<p>（1）先把数字按顺序填。然后，按$4\times 4$把它分割成$4$块（如图）<br><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20131230/20131230_fig002.jpg" width="300" height="300" title="图2" alt="图2" ></p>
<p>（2）每个小方阵对角线上的数字（如左上角小方阵部分），换成和它互补的数。</p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20131230/20131230_fig003.jpg" width="300" height="300" title="图3" alt="图3" ></p>
<p><strong>单偶数阶幻方</strong></p>
<p>所谓单偶阶幻方就是当$n$不可以被$4$整除时的偶阶幻方，即$4K+2$阶幻方。如$(n=6, 10,\cdots)$的幻方。其经典的填法为<strong>斯特拉兹法</strong>，以$10$阶幻方为例，具体的步骤如下：</p>
<p>1）把魔方阵分为$A,B,C,D$四个象限，这样每一个象限肯定是奇数阶。用<strong>罗伯法</strong>，依次在$A$象限，$D$象限，$B$象限，$C$象限按奇数阶幻方的填法填数。</p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20131230/20131230_fig004.jpg" width="300" height="300" title="图4" alt="图4" ></p>
<p>（2）在$A$象限的中间行、中间格开始，按自左向右的方向，标出$k$格。$A$象限的其它行则标出最左边的$k$格。将这些格，和$C$象限相对位置上的数互换位置。</p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20131230/20131230_fig005.jpg" width="600" height="300" title="图5" alt="图5" ></p>
<p>（3）在$B$象限所有行的中间格，自右向左，标出$k-1$格。(注：$6$阶幻方由于$k-1=0$，所以不用再作$B$、$D$象限的数据交换)，将这些格，和$D$象限相对位置上的数互换位置。</p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20131230/20131230_fig006.jpg" width="600" height="300" title="图6" alt="图6" ></p>
<p><strong>具体的程序实现如下：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//注意由于matrix大小(可以更改)给定，能最大生成10阶幻方</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> matrix[<span class="number">10</span>][<span class="number">10</span>],<span class="keyword">int</span> n)</span><span class="comment">//判断是否为幻方 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> temp=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>,k=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>( i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">		sum=sum+matrix[<span class="number">0</span>][i];<span class="comment">//得到一行或列的总和</span></span><br><span class="line">	<span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;n;j++)<span class="comment">//检查行</span></span><br><span class="line">	&#123;</span><br><span class="line">		temp=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(k=<span class="number">0</span>;k&lt;n;k++)</span><br><span class="line">			temp=temp+matrix[j][k];</span><br><span class="line">		<span class="keyword">if</span>(temp!=sum)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>( j=<span class="number">0</span>;j&lt;n;j++)<span class="comment">//检查列</span></span><br><span class="line">	&#123;</span><br><span class="line">		temp=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(k=<span class="number">0</span>;k&lt;n;k++)</span><br><span class="line">			temp=temp+matrix[k][j];</span><br><span class="line">		<span class="keyword">if</span>(temp!=sum)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	temp=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">		temp=temp+matrix[i][i];<span class="comment">//检查主对角线</span></span><br><span class="line">	<span class="keyword">if</span>(temp!=sum)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	temp=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">		temp=temp+matrix[i][n<span class="number">-1</span>-i];<span class="comment">//检测副对角线</span></span><br><span class="line">	<span class="keyword">if</span>(temp!=sum)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"该方阵为幻方！\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Odd</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> matrix[<span class="number">10</span>][<span class="number">10</span>])</span><span class="comment">//奇数阶幻方</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i=<span class="number">0</span>,j=n/<span class="number">2</span>;</span><br><span class="line">	<span class="keyword">int</span> number=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;n*n;k++)</span><br><span class="line">	&#123;</span><br><span class="line">		matrix[i][j]=number;</span><br><span class="line">			</span><br><span class="line">		i--;</span><br><span class="line">		j++;</span><br><span class="line">		number++;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(i&lt;<span class="number">0</span>&amp;&amp;j&lt;n)<span class="comment">//出上界</span></span><br><span class="line">		&#123;</span><br><span class="line">			i=n<span class="number">-1</span>;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(i&gt;=<span class="number">0</span>&amp;&amp;j&gt;=n)<span class="comment">//出右界</span></span><br><span class="line">		&#123;</span><br><span class="line">			j=<span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(i&lt;<span class="number">0</span>&amp;&amp;j&gt;=n)<span class="comment">//右、上出界</span></span><br><span class="line">		&#123;</span><br><span class="line">		</span><br><span class="line">			<span class="keyword">if</span>(matrix[n<span class="number">-1</span>][<span class="number">0</span>]!=<span class="number">0</span>)<span class="comment">//底格放</span></span><br><span class="line">			&#123;</span><br><span class="line">				i=i+<span class="number">2</span>;</span><br><span class="line">				j=j<span class="number">-1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">			i=n<span class="number">-1</span>;</span><br><span class="line">			j=<span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(matrix[i][j]!=<span class="number">0</span>)<span class="comment">//底格放</span></span><br><span class="line">		&#123;</span><br><span class="line">			i=i+<span class="number">2</span>;</span><br><span class="line">			j=j<span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DoubleEven</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> matrix[<span class="number">10</span>][<span class="number">10</span>])</span><span class="comment">//双偶数阶幻方</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> number=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> temp=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>,k=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">		<span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">			matrix[i][j]=number++;<span class="comment">//初始化</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i=i+<span class="number">4</span>)</span><br><span class="line">		<span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;n;j=j+<span class="number">4</span>)</span><br><span class="line">			<span class="keyword">for</span>(k=<span class="number">0</span>;k&lt;<span class="number">4</span>;k++)</span><br><span class="line">			&#123;</span><br><span class="line">				matrix[i+k][j+k]=n*n+<span class="number">1</span>-matrix[i+k][j+k];<span class="comment">//每个对角线的数换成互补的数</span></span><br><span class="line">				matrix[i+k][j+<span class="number">3</span>-k]=n*n+<span class="number">1</span>-matrix[i+k][j+<span class="number">3</span>-k];</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SingleEven</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> matrix[<span class="number">10</span>][<span class="number">10</span>])</span><span class="comment">//单偶数阶幻方</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> degree=n/<span class="number">2</span>;</span><br><span class="line">	<span class="keyword">int</span> flag=n/<span class="number">4</span>;</span><br><span class="line">	<span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>,k=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> temp=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> matrix1[<span class="number">10</span>][<span class="number">10</span>]=&#123;<span class="number">0</span>&#125;;<span class="comment">//将大矩阵化为A B C D四个小矩阵</span></span><br><span class="line">	<span class="keyword">int</span> matrix2[<span class="number">10</span>][<span class="number">10</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="keyword">int</span> matrix3[<span class="number">10</span>][<span class="number">10</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="keyword">int</span> matrix4[<span class="number">10</span>][<span class="number">10</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">	Odd(degree,matrix1);<span class="comment">//对每一个矩阵进行奇数幻方算法</span></span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;degree;i++)</span><br><span class="line">		<span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;degree;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			matrix2[i][j]=matrix1[i][j]+degree*degree;</span><br><span class="line">			matrix3[i][j]=matrix1[i][j]+degree*degree*<span class="number">2</span>;</span><br><span class="line">			matrix4[i][j]=matrix1[i][j]+degree*degree*<span class="number">3</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;degree;i++)<span class="comment">//对A C矩阵按照规则进行数据交换</span></span><br><span class="line">		<span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;flag;j++)</span><br><span class="line">			<span class="keyword">if</span>(i!=(degree/<span class="number">2</span>))</span><br><span class="line">			&#123;</span><br><span class="line">				temp=matrix1[i][j];</span><br><span class="line">				matrix1[i][j]=matrix4[i][j];</span><br><span class="line">				matrix4[i][j]=temp;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				temp=matrix1[i][j+degree/<span class="number">2</span>];</span><br><span class="line">				matrix1[i][j+degree/<span class="number">2</span>]=matrix4[i][j+degree/<span class="number">2</span>];</span><br><span class="line">				matrix4[i][j+degree/<span class="number">2</span>]=temp;</span><br><span class="line">			&#125;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;degree;i++)<span class="comment">//对B D矩阵按照规则进行数据交换</span></span><br><span class="line">		<span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;flag<span class="number">-1</span>;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			temp=matrix2[i][j+degree/<span class="number">2</span>];</span><br><span class="line">			matrix2[i][j+degree/<span class="number">2</span>]=matrix3[i][j+degree/<span class="number">2</span>];</span><br><span class="line">			matrix3[i][j+degree/<span class="number">2</span>]=temp;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="comment">//将新的四个矩阵赋给幻方矩阵matrix</span></span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;degree;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;degree;j++)</span><br><span class="line">				matrix[i][j]=matrix1[i][j];</span><br><span class="line">	</span><br><span class="line">			<span class="keyword">for</span>(k=<span class="number">0</span>;k&lt;degree;k++)</span><br><span class="line">				matrix[i][j+k]=matrix3[i][k];</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;degree;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;degree;j++)</span><br><span class="line">				matrix[i+degree][j]=matrix4[i][j];</span><br><span class="line"></span><br><span class="line">			<span class="keyword">for</span>(k=<span class="number">0</span>;k&lt;degree;k++)</span><br><span class="line">				matrix[i+degree][j+k]=matrix2[i][k];</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> matrix[<span class="number">10</span>][<span class="number">10</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="keyword">int</span> n;	<span class="built_in">printf</span>(<span class="string">"%d"</span>,<span class="number">6</span>%<span class="number">2</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"请输入幻方的阶数："</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(n%<span class="number">2</span>!=<span class="number">0</span>)</span><br><span class="line">		Odd(n,matrix);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(n%<span class="number">4</span>!=<span class="number">0</span>)</span><br><span class="line">		SingleEven(n,matrix);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		DoubleEven(n,matrix);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"%d "</span>,matrix[i][j]);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		check(matrix,n);<span class="comment">//检测是否为幻方</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>Algorithm Design</tag>
      </tags>
  </entry>
  <entry>
    <title>【算法导论】地图染色算法</title>
    <url>/2013/12/28/%5B20131228%5D/</url>
    <content><![CDATA[<p>​    地图染色问题可以根据四色定理来解决。所谓<strong>四色定理</strong>，就是指可以用不多于四种的颜色对地图着色，使相邻的行政区域不重色，因此我们可以用四色定理的结论，用回溯算法对一幅给定的地图染色。</p>
<p>​    <strong>算法的基本思想是</strong>：从第(1)号行政区域开始染色，每个区域逐次用颜色1#、2#、3#、4#进行试探，若当前所取的颜色与周围已染色的行政区域不重色，则用栈记下该区域的颜色序号，否则依次用下一颜色进行试探；若出现用1#到4#颜色均与相邻区域的颜色重色，则需退栈回溯，修改当前栈顶的颜色序号，再进行试探。直到所有行政区域都已分配合适的颜色。</p>
<a id="more"></a>
<p><strong>行政地图如下：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20131228/20131228_fig001.jpg" width="500" height="300" title="图1" alt="图1" ></p>
<p><strong>具体程序实现如下：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 7<span class="comment">//区域个数</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MapColor</span><span class="params">(<span class="keyword">int</span> dist[N][N],<span class="keyword">int</span> s[N])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> color,area,k;<span class="comment">//总共有4种颜色</span></span><br><span class="line">	s[<span class="number">0</span>]=<span class="number">1</span>;<span class="comment">//第一个区域先着色为颜色1</span></span><br><span class="line">	area=<span class="number">1</span>;<span class="comment">//从第二区域开始试探染色</span></span><br><span class="line">	color=<span class="number">1</span>;<span class="comment">//从第一种颜色开始试探</span></span><br><span class="line">	<span class="keyword">while</span>(area&lt;N)<span class="comment">//是否全部染色完毕</span></span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span>(color&lt;=<span class="number">4</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(area&gt;=N)</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			k=<span class="number">0</span>;</span><br><span class="line">			<span class="keyword">while</span>((k&lt;area)&amp;&amp;(s[k]*dist[area][k]!=color))<span class="comment">//判断是否重色</span></span><br><span class="line">				k++;</span><br><span class="line">			<span class="keyword">if</span>(k&lt;area)</span><br><span class="line">				color++;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				s[area]=color;</span><br><span class="line">				area++;</span><br><span class="line">				color=<span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(color&gt;<span class="number">4</span>)<span class="comment">//没有找到合适的颜色，需要进行回溯</span></span><br><span class="line">		&#123;</span><br><span class="line">			area=area<span class="number">-1</span>;</span><br><span class="line">			color=s[area]+<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> dist[N][N]=&#123;&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>&#125;,<span class="comment">//地图的邻接矩阵</span></span><br><span class="line">					&#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;,</span><br><span class="line">					&#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">					&#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>&#125;,</span><br><span class="line">					&#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;,</span><br><span class="line">					&#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">					&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line">	<span class="keyword">int</span> s[N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">	MapColor(dist,s);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"地图区域标号为1~7的染色情况为："</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d "</span>,s[i]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>结果显示如下：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20131228/20131228_fig002.jpg" width="600" height="400" title="图2" alt="图2" ></p>
<p><strong>其中栈S的变化情况如下：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20131228/20131228_fig003.jpg" width="500" height="400" title="图3" alt="图3" ></p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>Algorithm Design</tag>
      </tags>
  </entry>
  <entry>
    <title>【算法导论】有向图的可达矩阵</title>
    <url>/2013/12/27/%5B20131227%5D/</url>
    <content><![CDATA[<p>​    有时候，我们关注的不是从一个地点到另一个地点的费用，而是能否从一个顶点到达另一个顶点。因此我们可以假设所有边的权值为单位1，在下面的算法中，我们可以在$O(n^3)$的时间内计算出图中任意两点是否可达，我用可达矩阵来表示有向图中两者是否可达。如果可以从$i$到$j$，则定义$t<em>{ij}=1$,否则$t</em>{ij}=0$。因此我们可以得到下式：</p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20131227/20131227_fig001.jpg" width="600" height="200" title="图1" alt="图1" ></p>
<p><strong>我们以下面的有向图进行具体实现：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20131227/20131227_fig002.jpg" width="300" height="250" title="图2" alt="图2" ></p>
<p>下图给出了计算所得的每一个$T^{(k)}$矩阵：</p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20131227/20131227_fig003.jpg" width="600" height="250" title="图3" alt="图3" ></p>
<p><strong>具体程序实现如下：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 10000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 4 <span class="comment">//顶点个数</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TransitiveClosure</span><span class="params">(<span class="keyword">int</span> dist[N][N],<span class="keyword">int</span> t[N][N])</span><span class="comment">//寻找可达矩阵</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)<span class="comment">//进行遍历</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;N;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>((i==j)||(dist[i][j])==<span class="number">1</span>)<span class="comment">//发现可达</span></span><br><span class="line">				t[i][j]=<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				t[i][j]=<span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;N;k++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;N;j++)</span><br><span class="line">				t[i][j]=t[i][j]||(t[i][k]&amp;&amp;t[k][j]);<span class="comment">//由文中公式可得</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> dist[N][N]=&#123;&#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,<span class="comment">//邻接矩阵</span></span><br><span class="line">					&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;,</span><br><span class="line">					&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>&#125;,</span><br><span class="line">					&#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> t[N][N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">	TransitiveClosure( dist, t);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">	&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;N;j++)</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"%d "</span>,t[i][j]);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>在上面的程序中，我用了逻辑运算来计算可达矩阵，因为在某些计算机上，对单位的值，逻辑操作的执行速度快于对整数字长数据的算术运算操作，其空间要求也比整数要小。</strong></p>
<hr>
<p>​    学过图论的可能知道，一个邻接矩阵$A$（若边的权值都为单位$1$）表示两个顶点经过一步的可达情况, $A<em>{ij}$表示经过一步，$i$能到达$j$的次数。同理$A^{(2)}$表示两个顶点经过两部步的可达情况,$A</em>{ij}$表示经过两步，$i$能到达$j$的次数，一次类推……。还是以上面的图为例：</p>
<script type="math/tex; mode=display">
A=\begin{pmatrix}
1 & 0 & 0 & 0\\
0 & 1 & 1 & 1\\
0 & 1 & 1 & 0\\
1 & 0 & 1 & 1
\end{pmatrix}
\quad
A^{(2)}=\begin{pmatrix}
1 & 0 & 0 & 0\\
1 & 2 & 3 & 2\\
0 & 2 & 2 & 1\\
2 & 1 & 2 & 1
\end{pmatrix}</script><p>比如$A^{(2)}$中$A_{12}=2$，表示从顶点$2$到顶点$3$经过两步可以到达的次数为$3$。 <strong>注意:自己到达自己可以是任意步！</strong></p>
<p><strong>由相关知识可知，可达矩阵$B=A+A^{(2)}+A^{(3)}+\cdots+A^{(n)}$ ，$n$为顶点个数</strong>。具体的C​语言实现比上面的算法要复杂，<strong>下面用matlab实现</strong>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function P &#x3D; canget( A )</span><br><span class="line">%计算可达矩阵</span><br><span class="line">%B&#x3D;A+A^2+A^3+……+A^n   A为邻接矩阵</span><br><span class="line">n&#x3D;length(A);</span><br><span class="line">P&#x3D;A;</span><br><span class="line">for i&#x3D;2:n</span><br><span class="line">    P&#x3D;P+A^i;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">P&#x3D;(P~&#x3D;0);</span><br></pre></td></tr></table></figure>
<p>结算可以得到相同的结果。由于matlab擅长矩阵运算，因此程序计算十分简单。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>Algorithm Design</tag>
      </tags>
  </entry>
  <entry>
    <title>【算法导论】每对顶点之间的最短路径算法</title>
    <url>/2013/12/26/%5B20131226%5D/</url>
    <content><![CDATA[<p>​    对于一个顶点数为N的有向网路图，我们可以通过前面所提到的单源最短路径算法执行N次来获得每一对顶点间的最短路径。这种方法的时间复杂度为$O(N^3)$。如果网络中有负权值的边，则需要使用前面提到的单源最短路径算法之Bellman—Floyd算法。总之，总可以通过单源最短路径来求得每对顶点间的最短路径。这里我就不再用程序实现上述方法。<strong>下面介绍Floyd解决这一问题的另一种算法，它形式简单，利于理解，而且时间复杂度同样为</strong>$O(N^3)$。</p>
<a id="more"></a>
<p>​    Floyd算法是根据给定有向网络的邻接矩阵$dist[n][n]$来求顶点$v_i$到顶点$v_j$的最短路径。这一算法的<strong>基本思想是</strong>：假设$v_i$和$v_j$之间存在一条路径，但这并不一定是最短路径，试着在$v_i$和$v_j$之间增加一个中间顶点$v_k$。 若增加$v_k$后的路径$(v_i, v_k, v_j)$ 比$(v_i, v_j)$短，则以新的路径代替原路径，并且修改$dist[i][j]$的值为新路径的权值；若增加$v_k$后的路径比$(v_i, v_j)$更长，则维持$dist[i][j]$不变。然后在修改后的$dist$矩阵中，另选一个顶点作为中间顶点，重复以上的操作，直到除$v_i$和$v_j$顶点的其余顶点都做过中间顶点为止。<strong>下面以具体实例来说明问题：</strong></p>
<p>假设有向网路图如下所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20131226/20131226_fig001.jpg" width="300" height="300" title="图1" alt="图1" ></p>
<p>设原始的最短路径矩阵为$L^{(1)}$,经过一次循环后得到新的最短矩阵为$L^{(2)}$,依此类推，当得到$L^{(N-1)}$时，我们就得到了最短的路径矩阵。<strong>最短路径矩阵的变化情况如下：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20131226/20131226_fig002.jpg" width="500" height="300" title="图2" alt="图2" ></p>
<p><strong>具体程序实现如下：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 5 <span class="comment">//顶点个数</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 10000</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Floyd</span><span class="params">(<span class="keyword">int</span> dist[N][N],<span class="keyword">int</span> A[N][N],<span class="keyword">int</span> path[N][N])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;N;j++)</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;N;k++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">/*if(A[i][j]&gt;(A[i][k]+dist[k][j]))//方法一：计算每一次矩阵</span></span><br><span class="line"><span class="comment">				&#123;</span></span><br><span class="line"><span class="comment">					A[i][j]=(A[i][k]+dist[k][j]);</span></span><br><span class="line"><span class="comment">					path[i][j]=path[k][j];</span></span><br><span class="line"><span class="comment">				&#125;*/</span></span><br><span class="line">				<span class="keyword">if</span>(A[i][j]&gt;(A[i][k]+A[k][j]))<span class="comment">//方法二:计算2的幂次矩阵</span></span><br><span class="line">				&#123;</span><br><span class="line">					A[i][j]=(A[i][k]+A[k][j]);</span><br><span class="line">					path[i][j]=path[k][j];</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> dist[N][N]=&#123;&#123;<span class="number">0</span>,<span class="number">3</span>,<span class="number">8</span>,MAX,<span class="number">-4</span>&#125;,<span class="comment">//图的邻接矩阵</span></span><br><span class="line">	                &#123;MAX,<span class="number">0</span>,MAX,<span class="number">1</span>,<span class="number">7</span>&#125;,</span><br><span class="line">	                &#123;MAX,<span class="number">4</span>,<span class="number">0</span>,MAX,MAX&#125;,</span><br><span class="line">	                &#123;<span class="number">2</span>,MAX,<span class="number">-5</span>,<span class="number">0</span>,MAX&#125;,</span><br><span class="line">	                &#123;MAX,MAX,MAX,<span class="number">6</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line">	<span class="keyword">int</span> A[N][N];</span><br><span class="line">	<span class="keyword">int</span> path[N][N]=&#123;<span class="number">0</span>&#125;;<span class="comment">//给出两顶点间的路径</span></span><br><span class="line">	<span class="keyword">int</span> pre=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;N;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			A[i][j]=dist[i][j];</span><br><span class="line">			<span class="keyword">if</span>(dist[i][j]!=MAX)</span><br><span class="line">				path[i][j]=i+<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				path[i][j]=<span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;<span class="number">2</span>;k++)<span class="comment">//若用方法一，需循环N-3次，若用方法二，需要循环lg(N-1)次</span></span><br><span class="line">		Floyd(dist,A,path);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"每对顶点间的最短路径矩阵为：\n"</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;N;j++)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%d "</span>,A[i][j]);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\n每对顶点的具体最短路径为：\n"</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;N;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%d: %d "</span>,A[i][j],j+<span class="number">1</span>);</span><br><span class="line">		pre=path[i][j];</span><br><span class="line">		<span class="keyword">while</span>((pre!=<span class="number">0</span>)&amp;&amp;(pre!=i+<span class="number">1</span>))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"&lt;- %d "</span>,pre);</span><br><span class="line">			pre=path[i][pre<span class="number">-1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">" &lt;- %d\n"</span>,i+<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>结果显示如下：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20131226/20131226_fig003.jpg" width="600" height="500" title="图3" alt="图3" ></p>
<p><strong>程序不但显示了两点之间的最短路径长度，而且显示了具体的路径。在程序中，我用了两种方法求最短路径矩阵，其中第二种方法更加简单的，因为我们要求的最短路径矩阵为$L^{(N-1)}$。比如说当$N=5$时，我们需要最终得到$L^{(4)}$,我们可以只求$L^{(1)}$、$L^{(2)}$、$L^{(4)}$，而不需要求得每一个$L$。</strong></p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>Algorithm Design</tag>
      </tags>
  </entry>
  <entry>
    <title>【算法导论】单源最短路径之Dijkstra算法</title>
    <url>/2013/12/23/%5B20131223%5D/</url>
    <content><![CDATA[<p>​    <strong>Dijkstra算法解决了有向图上带正权值的单源最短路径问题，其运行时间要比Bellman-Ford算法低，但适用范围比Bellman-Ford算法窄。</strong></p>
<a id="more"></a>
<p>迪杰斯特拉提出的按路径长度递增次序来产生源点到各顶点的最短路径的<strong>算法思想是</strong>：对有$n$个顶点的有向连通网络$G=(V, E)$，首先从$V$中取出源点$u_0$放入最短路径顶点集合$U$中，这时的最短路径网络$S=({u0}, {\emptyset})$; 然后从$u\in U$和$v\in V-U$中找一条代价最小的边$(u^\star, v^\star)$加入到$S$中去，此时$S=({u_0, v^\star}, {(u_0, v^\star)})$。每往$U$中增加一个顶点，则要对$V-U$中的各顶点的权值进行一次修正。若加进$v^\star$作为中间顶点，使得从$u_0$到其他属于$V-U$的顶点$v_i$的路径不加$v^\star$时最短，则修改$u_0$到$v_i$的权值，即以$(u_0, v^\star)$的权值加上$(v^\star, v_i)$的权值来代替原$(u_0, v_i)$的权值，否则不修改$u_0$到$v_i$的权值。接着再从权值修正后的$V-U$中选择最短的边加入$S$中，如此反复，直到$U=V$为止。</p>
<p>上面的说明都很抽象，<strong>下面图解算法思想：</strong></p>
<p>   <strong>原始图为：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20131223/20131223_fig001.jpg" width="400" height="300" title="图1" alt="图1" ></p>
<p><strong>寻找最短路径的过程如下：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20131223/20131223_fig002.jpg" width="400" height="500" title="图2" alt="图2" ></p>
<p>​    对第一个图中的有向网络按以上算法思想处理，所求得的从源点$F$到其余顶点的最短路径的过程如上图所示。其中单圆圈表示$U$中的顶点，而双圆圈表示$V-U$中的顶点。连接$U$中两个顶点的有向边用实线表示，连接$U$和$V-U$中两个顶点的有向边用虚线表示。圆圈旁的数字为源点到该顶点当前的距离值。<br>​    初始时，$S$中只有一个源点$F$，它到$V-U$中各顶点的路径如上图(a)所示；选择图(a)中最小代价边$(F,B)$，同时由于路径$(F, A)$大于$(F, B, A)$和$(F, C)$大于$(F, B, C)$，进行相应调整可得到图(b)；选择图(b)中的最小代价边$(B, C)$，同时由于$(F, B, A)$大于$(F, B, C, A)$，进行相应调整可得到图(c)；选择图(c)中最小代价边$(C, A)$即可得到图(d)；选择图(d)中最小代价边$(F, D)$ 即可得到图(e); 最后选择$(F, E)$即可得到图( f )。</p>
<p><strong>具体的程序实现如下：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M 12<span class="comment">//边数</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 6<span class="comment">//顶点数</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 10000</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> dist[][N],<span class="keyword">int</span> D[N],<span class="keyword">int</span> p[N],<span class="keyword">int</span> s[N])</span> </span>;</span><br><span class="line"><span class="keyword">int</span> flag[N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> flag1=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> flag2=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> startvex;</span><br><span class="line">	<span class="keyword">int</span> endvex;</span><br><span class="line">	<span class="keyword">int</span> length;</span><br><span class="line">&#125;edge;<span class="comment">//边的结构体</span></span><br><span class="line">edge T[M];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> dist[N][N]=&#123;&#123;<span class="number">0</span>,<span class="number">6</span>,MAX,<span class="number">8</span>,MAX,MAX&#125;,<span class="comment">//图的邻接矩阵</span></span><br><span class="line">					&#123;<span class="number">18</span>,<span class="number">0</span>,<span class="number">7</span>,MAX,MAX,<span class="number">10</span>&#125;,</span><br><span class="line">					&#123;<span class="number">9</span>,MAX,<span class="number">0</span>,<span class="number">15</span>,MAX,MAX&#125;,</span><br><span class="line">					&#123;MAX,MAX,<span class="number">12</span>,<span class="number">0</span>,MAX,MAX&#125;,</span><br><span class="line">					&#123;MAX,MAX,<span class="number">4</span>,MAX,<span class="number">0</span>,MAX&#125;,</span><br><span class="line">					&#123;<span class="number">24</span>,<span class="number">5</span>,MAX,<span class="number">25</span>,MAX,<span class="number">0</span>&#125;&#125;;</span><br><span class="line">	<span class="keyword">int</span> D[N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="keyword">int</span> p[N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="keyword">int</span> s[N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line">    Dijkstra(<span class="number">5</span>,dist,D, p,s) ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> dist[][N],<span class="keyword">int</span> D[N],<span class="keyword">int</span> p[N],<span class="keyword">int</span> s[N])</span> </span></span><br><span class="line"><span class="function"> </span>&#123; 	<span class="keyword">int</span> i, j, k, v1, min, max=<span class="number">10000</span>, pre; 	<span class="comment">/* Max中的值用以表示dist矩阵中的值 */</span></span><br><span class="line">	v1=v; </span><br><span class="line">	<span class="keyword">for</span>( i=<span class="number">0</span>; i&lt;N; i++)              <span class="comment">/* 各数组进行初始化 */</span></span><br><span class="line">	&#123;	D[i]=dist[v1][i]; </span><br><span class="line">		<span class="keyword">if</span>( D[i] != MAX )  p[i]= v1+<span class="number">1</span>; </span><br><span class="line">		<span class="keyword">else</span> p[i]=<span class="number">0</span>; </span><br><span class="line">		s[i]=<span class="number">0</span>; </span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	s[v1]=<span class="number">1</span>;     		             <span class="comment">/* 将源点送U */</span></span><br><span class="line">	  <span class="keyword">for</span>( i=<span class="number">0</span>; i&lt;N<span class="number">-1</span>; i++) 	 <span class="comment">/* 求源点到其余顶点的最短距离 */</span></span><br><span class="line">	&#123;	min=<span class="number">10001</span>;    <span class="comment">/* min&gt;max, 以保证值为的顶点也能加入U */</span></span><br><span class="line">		<span class="keyword">for</span>( j=<span class="number">0</span>; j&lt;N<span class="number">-1</span>; j++)</span><br><span class="line">			  <span class="keyword">if</span> ( ( !s[j] )&amp;&amp;(D[j]&lt;min) )  		<span class="comment">/* 找出到源点具有最短距离的边 */</span></span><br><span class="line">		  		&#123;min=D[j]; </span><br><span class="line">						k=j; </span><br><span class="line">		 			&#125;</span><br><span class="line">				s[k]=<span class="number">1</span>;  <span class="comment">/* 将找到的顶点k送入U */</span>	</span><br><span class="line">	<span class="keyword">for</span>(j=<span class="number">0</span>; j&lt;N; j++)</span><br><span class="line">	 <span class="keyword">if</span> ( (!s[j])&amp;&amp;(D[j]&gt;D[k]+dist[k][j]) ) <span class="comment">/* 调整V－U中各顶点的距离值 */</span></span><br><span class="line">		&#123;D[j]=D[k]+dist[k][j]; </span><br><span class="line">		p[j]=k+<span class="number">1</span>;                  	<span class="comment">/* k是j的前趋 */</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;                           	<span class="comment">/*  所有顶点已扩充到U中 */</span></span><br><span class="line">			<span class="keyword">for</span>( i=<span class="number">0</span>; i&lt;N; i++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">" %d : %d "</span>, D[i], i);</span><br><span class="line">				pre=p[i]; </span><br><span class="line">			<span class="keyword">while</span> ((pre!=<span class="number">0</span>)&amp;&amp;(pre!=v+<span class="number">1</span>))</span><br><span class="line">			&#123;	<span class="built_in">printf</span> (<span class="string">"&lt;- %d "</span>, pre<span class="number">-1</span>); </span><br><span class="line">				pre=p[pre<span class="number">-1</span>]; </span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"&lt;-%d \n"</span>, v); </span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>结果显示如下：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20131223/20131223_fig003.jpg" width="400" height="300" title="图3" alt="图3" ></p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>Algorithm Design</tag>
      </tags>
  </entry>
  <entry>
    <title>【算法导论】单源最短路径之Bellman-Ford算法</title>
    <url>/2013/12/20/%5B20131220%5D/</url>
    <content><![CDATA[<p>​    <strong>单源最短路径</strong>指的是从一个顶点到其它顶点的具有最小权值的路径。我们之前提到的广度优先搜索算法就是一种无权图上执行的最短路径算法，即在所有的边都具有单位权值的图的一种算法。单源最短路径算法可以解决图中任意顶点间的最短路径。</p>
<a id="more"></a>
<p>​    <strong>对于单源最短路径问题，一般有两种经典解法</strong>：</p>
<ul>
<li>对于有权值为负的图，采用Bellman-Ford算法；</li>
<li>对于权值全为正的图，常采用Dijkstra算法。本文介绍Bellman-Ford算法，下一篇介绍Dijkstra算法。</li>
</ul>
<p>Bellman-Ford算法适用于权值可以为负、无权值为负的回路的图，这比Dijkstra算法的使用范围要广。其基本思想为：首先假设源点到所有点的距离为无穷大，然后从任一顶点$u$出发，遍历其它所有顶点$v_i$，计算从源点到其它顶点$v_i$的距离与从$v_i$到$u$的距离的和，如果比原来距离小，则更新，遍历完所有的顶点为止，即可求得源点到所有顶点的最短距离。<strong>下面用实例说明：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20131220/20131220_fig001.jpg" width="600" height="350" title="图1" alt="图1" ></p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20131220/20131220_fig002.jpg" width="600" height="150" title="图2" alt="图2" ></p>
<p>上图中，顶点内的值表示该顶点到s顶点的距离。<strong>在下面的具体程序实现中，我用0 1 2 3 4代表 s t x y z.</strong></p>
<p><strong>具体程序实现如下：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M 10<span class="comment">//边数</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 5<span class="comment">//顶点数</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 10000</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BellmanFord</span><span class="params">(<span class="keyword">int</span> dist[N][N],<span class="keyword">int</span> d[N],<span class="keyword">int</span> i)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> flag1=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> flag2=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> startvex;</span><br><span class="line">	<span class="keyword">int</span> endvex;</span><br><span class="line">	<span class="keyword">int</span> length;</span><br><span class="line">&#125;edge;</span><br><span class="line">edge T[M];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> dist[N][N]=&#123;&#123;<span class="number">0</span>,<span class="number">6</span>,MAX,<span class="number">7</span>,MAX&#125;,</span><br><span class="line">					&#123;MAX,<span class="number">0</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">-4</span>&#125;,</span><br><span class="line">					&#123;MAX,<span class="number">-2</span>,<span class="number">0</span>,MAX,MAX&#125;,</span><br><span class="line">					&#123;MAX,MAX,<span class="number">-3</span>,<span class="number">0</span>,<span class="number">9</span>&#125;,</span><br><span class="line">					&#123;<span class="number">2</span>,MAX,<span class="number">7</span>,MAX,<span class="number">0</span>&#125;&#125;;<span class="comment">//图的邻接矩阵</span></span><br><span class="line">	<span class="keyword">int</span> d[N];</span><br><span class="line">	<span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line">    num=BellmanFord(dist,d, <span class="number">0</span>);<span class="comment">//计算下标为0的顶点到其它顶点的距离，num用于统计边数</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)<span class="comment">//打印到各个顶点之间的距离</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d "</span>,d[i]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;num;j++)<span class="comment">//打印考虑过的边</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"start=%d,end=%d,lenth=%d\n"</span>,T[j].startvex,T[j].endvex,T[j].length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BellmanFord</span><span class="params">(<span class="keyword">int</span> dist[N][N],<span class="keyword">int</span> d[N],<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;N;j++)<span class="comment">//初始化</span></span><br><span class="line">		d[j]=MAX;</span><br><span class="line">	d[i]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;N<span class="number">-1</span>;k++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> ii=<span class="number">0</span>;ii&lt;N;ii++)</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> jj=<span class="number">0</span>;jj&lt;N;jj++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(dist[ii][jj]!=MAX)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">if</span>(d[jj]&gt;(d[ii]+dist[ii][jj]))<span class="comment">//不断更新距离</span></span><br><span class="line">					&#123;</span><br><span class="line">						d[jj]=d[ii]+dist[ii][jj];<span class="comment">//当原节点到jj节点的距离大于</span></span><br><span class="line">						                         <span class="comment">//原节点到ii节点的距离与从ii节点到jj节点的距离和时更新</span></span><br><span class="line">						T[num].startvex=ii;</span><br><span class="line">						T[num].endvex=jj;</span><br><span class="line">						T[num].length=dist[ii][jj];</span><br><span class="line">						num++;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> ii=<span class="number">0</span>;ii&lt;N;ii++)</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> jj=<span class="number">0</span>;jj&lt;N;jj++)<span class="comment">//有权值为负的回路的情况</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(d[jj]&gt;(d[ii]+dist[ii][jj]))</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">return</span> num;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果显示如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20131220/20131220_fig003.jpg" width="600" height="450" title="图3" alt="图3" ></p>
<p>注意：上述的结果与前面图解的一致，但是用到的边有7条比前面图解的阴影部分的边多3条，这是因为图解过程中省略了中间的一些步骤，直接得到最小权值时的情况。通过阴影部分的边，我们可以轻松的找到最短路径所经过的顶点，当然，当图比较复杂时，就该写程序来打印最短路径了。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>Algorithm Design</tag>
      </tags>
  </entry>
  <entry>
    <title>【算法导论】最小生成树之Prime法</title>
    <url>/2013/12/19/%5B20131219%5D/</url>
    <content><![CDATA[<p>​    关于最小生成树的概念，在前一篇文章中已经讲到，就不在赘述了。下面介绍Prime算法：</p>
<p>​    <strong>其基本思想为</strong>：从一个顶点出发，选择由该顶点出发的最小权值边，并将该边的另一个顶点包含进来，然后找出由这两个顶点出发的最小边，依此类推，直至包含所有的顶点。如果期间构成环，就舍弃该边，继续寻找最小边。</p>
<a id="more"></a>
<p><strong>下面以具体实例来说明算法的过程：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20131219/20131219_fig001.jpg" width="500" height="500" title="图1" alt="图1" ></p>
<p><strong>具体的程序实现如下：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 6 <span class="comment">//顶点数</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 10000</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> startvex,endvex;<span class="comment">//边的起点和终点2</span></span><br><span class="line">	<span class="keyword">int</span> length;<span class="comment">//边的权值</span></span><br><span class="line">&#125;edge;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> flag[N]=&#123;<span class="number">0</span>&#125;;<span class="comment">//标志顶点是否被选定</span></span><br><span class="line"><span class="keyword">int</span> flag1=<span class="number">0</span>;<span class="comment">//记录边的终点</span></span><br><span class="line"><span class="keyword">int</span> flag2=<span class="number">0</span>;<span class="comment">//记录边的起点</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Prime</span><span class="params">(<span class="keyword">int</span>  i,<span class="keyword">int</span> dist[N][N],edge T[N<span class="number">-1</span>])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> j,k,min;</span><br><span class="line">	<span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line">	flag[i]=<span class="number">1</span>;<span class="comment">//包含顶点置为1</span></span><br><span class="line">	<span class="keyword">while</span>(num&lt;<span class="number">5</span>)<span class="comment">//6个顶点则有5条边</span></span><br><span class="line">	&#123;</span><br><span class="line">		min=MAX;</span><br><span class="line">		<span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;N;j++)<span class="comment">//从已选边中找到最小权值的边</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(flag[j]==<span class="number">1</span>)</span><br><span class="line">				<span class="keyword">for</span>(k=<span class="number">0</span>;k&lt;N;k++)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">if</span>(dist[j][k]&lt;min)</span><br><span class="line">					&#123;</span><br><span class="line">						min=dist[j][k];</span><br><span class="line">						flag1=k;<span class="comment">//记录当前最小权值边的起点和终点</span></span><br><span class="line">						flag2=j;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(flag[flag1]!=<span class="number">1</span>)<span class="comment">//判断是否构成回路</span></span><br><span class="line">		&#123;</span><br><span class="line">			T[num].startvex=flag2;<span class="comment">//将找到的最小权值边记录</span></span><br><span class="line">			T[num].endvex=flag1;</span><br><span class="line">			T[num].length=dist[flag2][flag1];</span><br><span class="line">			num++;</span><br><span class="line">			flag[flag1]=<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		dist[flag2][flag1]=MAX;<span class="comment">//将已经选择的边的权值置为无穷大</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N<span class="number">-1</span>;i++)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"start=%d,end=%d,length=%d\n"</span>,T[i].startvex,T[i].endvex,T[i].length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> dist[N][N]=&#123;&#123;MAX,<span class="number">10</span>,MAX,MAX,<span class="number">19</span>,<span class="number">21</span>&#125;,</span><br><span class="line">					&#123;<span class="number">10</span>,MAX,<span class="number">5</span>,<span class="number">6</span>,MAX,<span class="number">11</span>&#125;,</span><br><span class="line">					&#123;MAX,<span class="number">5</span>,MAX,<span class="number">6</span>,MAX,MAX&#125;,</span><br><span class="line">					&#123;MAX,<span class="number">6</span>,<span class="number">6</span>,MAX,<span class="number">18</span>,<span class="number">14</span>&#125;,</span><br><span class="line">					&#123;<span class="number">19</span>,MAX,MAX,<span class="number">18</span>,MAX,<span class="number">33</span>&#125;,</span><br><span class="line">					&#123;<span class="number">21</span>,<span class="number">11</span>,MAX,<span class="number">14</span>,<span class="number">33</span>,MAX&#125;&#125;;</span><br><span class="line">	edge T[N<span class="number">-1</span>];</span><br><span class="line">	Prime(<span class="number">1</span>,dist,T);<span class="comment">//1代表从序号为一的顶点开始</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>运行结果如下：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20131219/20131219_fig002.jpg" width="600" height="400" title="图2" alt="图2" ></p>
<p><strong>注意最小生成树不是唯一的，但是总权值是一样的。</strong></p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>Algorithm Design</tag>
      </tags>
  </entry>
  <entry>
    <title>【算法导论】最小生成树之Kruskal法</title>
    <url>/2013/12/17/%5B20131217%5D/</url>
    <content><![CDATA[<p>​    在图论中，树是指无回路存在的连通图。一个连通图的生成树是指包含了所有顶点的树。如果把生成树的边的权值总和作为生成树的权，那么权值最小的生成树就称为最小生成树。因为最小生成树在实际中有很多应用，所以我们有必要了解怎样生成最小生成树。<strong>构造最小生成树的两种常用方法</strong>：Kruskal算法、Prim算法。本文介绍Kruskal算法，Prim算法在下篇文章中介绍。</p>
<a id="more"></a>
<p>   <strong>Kruskal算法</strong>是从另一条途径来求网络的的最小生成树。设$G=(V, E)$是一个有$n$个顶点的连通图，则令最小生成树的初值状态为只有$n$个顶点而无任何边的非连通图$T=(V, {\emptyset})$，此时图中每个顶点自成一个连通分量。按照权值递增的顺序依次选择$E$中的边，若该边依附于$T$中两个不同的连通分量，则将此边加入$TE$中，否则舍去此边而选择下一条代价最小的边，直到$T$中所有顶点都在同一连通分量上为止。这时的$T$，便是$G$的一棵最小生成树。 </p>
<p>​    物理老师曾说过，图像比文字的信息量大得多，这可以从一幅图像和一篇文章所占电脑的存储空间大小明显得出。因此我们可以同下面的图解过程了解Kruskal算法的思想：</p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20131217/20131217_fig001.jpg" width="600" height="400" title="图1" alt="图1" ></p>
<p>​    在该算法中，每次都要寻找最短边，如果用邻接矩阵实现的话，则需要对整个矩阵扫描一遍，时间复杂度较高，如果采用邻接表的话，由于每条边都被连接两次，使得寻找时间加倍。所以采用如下结构体：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M 8 <span class="comment">//边数</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 6  <span class="comment">//顶点数 </span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//图的存储结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> startvex,endvex;<span class="comment">//边的两个顶点</span></span><br><span class="line">	<span class="keyword">int</span> length;<span class="comment">//边长</span></span><br><span class="line">	<span class="keyword">int</span> sign;<span class="comment">//是否被选择,1表示被选择，0表示未被选择，2表示选择后形成环，被抛弃</span></span><br><span class="line">&#125;edge;</span><br><span class="line">	edge T[M];</span><br><span class="line">	<span class="keyword">int</span> flag1[N];<span class="comment">//标记顶点是否已被选中</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Kruskal</span><span class="params">(edge T[M],<span class="keyword">int</span> *flag1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i,j,k,l,min;</span><br><span class="line">	<span class="keyword">int</span> a[M]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;<span class="comment">//边的两个顶点及边的长度</span></span><br><span class="line">	<span class="keyword">int</span> b[M]=&#123;<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>&#125;;</span><br><span class="line">	<span class="keyword">int</span> c[M]=&#123;<span class="number">10</span>,<span class="number">19</span>,<span class="number">21</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">11</span>,<span class="number">6</span>,<span class="number">18</span>,<span class="number">14</span>,<span class="number">33</span>&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//int a[M]=&#123;0,0,0,1,1,2,3,4&#125;;//边的两个顶点及边的长度</span></span><br><span class="line">	<span class="comment">//int b[M]=&#123;1,3,5,2,4,3,4,5&#125;;</span></span><br><span class="line">	<span class="comment">//int c[M]=&#123;7,3,5,6,9,8,4,2&#125;;</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">		flag1[i]=i;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;M;i++)<span class="comment">//初始化</span></span><br><span class="line">	&#123;</span><br><span class="line">		T[i].startvex=a[i];</span><br><span class="line">		T[i].endvex=b[i];</span><br><span class="line">		T[i].length=c[i];</span><br><span class="line">		T[i].sign=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	j=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> flag=<span class="number">0</span>;<span class="comment">//记录最小边的序号</span></span><br><span class="line">	<span class="keyword">while</span>(j&lt;N<span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		flag=<span class="number">0</span>;</span><br><span class="line">		min=<span class="number">10000</span>;</span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;M;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(T[i].sign==<span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(T[i].length&lt;min)</span><br><span class="line">				&#123;</span><br><span class="line">					k=T[i].startvex;</span><br><span class="line">					l=T[i].endvex;</span><br><span class="line">					flag=i;</span><br><span class="line">					min=T[i].length;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		T[flag].sign=<span class="number">1</span>;<span class="comment">//标记被选中</span></span><br><span class="line">		<span class="comment">//printf("k=%d,l=%d:  ",k,l);</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//printf("\n");</span></span><br><span class="line">		<span class="keyword">if</span>(flag1[k]==flag1[l])<span class="comment">//当边的两个顶点都已经被选择，说明若选择该边就会形成环</span></span><br><span class="line">		&#123;</span><br><span class="line">			T[flag].sign=<span class="number">2</span>;<span class="comment">//表示抛弃该边</span></span><br><span class="line">			<span class="comment">//printf("ok ");</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			j++;</span><br><span class="line">			<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">				<span class="keyword">if</span>(flag1[i]==l)</span><br><span class="line">					flag1[i]=flag1[k];</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="comment">//for(int ii=0;ii&lt;M;ii++)</span></span><br><span class="line">	<span class="comment">//	printf(" %d ",T[ii].sign);</span></span><br><span class="line">	<span class="comment">//printf("\n\n");</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	Kruskal(T,flag1);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;M;i++)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d "</span>,T[i].sign);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序的结果与上面的图解的结果稍有不同，但是正确的，因为最小生成树有时候是不唯一的。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>Algorithm Design</tag>
      </tags>
  </entry>
  <entry>
    <title>【算法导论】有向图的深度优先搜索遍历</title>
    <url>/2013/12/15/%5B20131215%5D/</url>
    <content><![CDATA[<p>在前面的文章中，我已经讨论了无向图的遍历，现在发现在有向图中，可能会发生无法遍历到所有节点的情况。因此在经历一次深度优先搜索遍历后，如果还存在未被搜索到的节点，则需要再从新的节点开始进行深度优先搜索遍历，直到访问完所有节点。</p>
<a id="more"></a>
<p>以下面的有向图为例：</p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20131215/20131215_fig001.jpg" width="500" height="200" title="图1" alt="图1" ></p>
<p> 如果从$a$开始进行深度优先搜索遍历，则会得到 $ a b c d h g f $后结束，因此我们还要 从未访问到的节点$e$进行第二次深度优先搜索遍历得到$e$.在前面的深度优先搜索的基础上，有向图的深度优先搜索程序实现如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 8 <span class="comment">//顶点数</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">char</span> vexs[N];<span class="comment">//顶点数组</span></span><br><span class="line">	<span class="keyword">int</span> color[N];</span><br><span class="line">	<span class="keyword">int</span> arcs[N][N];<span class="comment">//邻接矩阵</span></span><br><span class="line"><span class="comment">//	struct node *p;</span></span><br><span class="line">&#125;graph;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS_direction</span><span class="params">(graph g,<span class="keyword">int</span> i,<span class="keyword">int</span> visited[N])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%c\n"</span>,g.vexs[i]);</span><br><span class="line">	visited[i]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;N;j++)</span><br><span class="line">		<span class="keyword">if</span>(g.arcs[i][j]==<span class="number">1</span>&amp;&amp;visited[j]==<span class="number">0</span>)</span><br><span class="line">			DFS_direction(g,j,visited);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	graph g;</span><br><span class="line">	<span class="keyword">int</span> v=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> visited[N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="keyword">int</span> visited1[N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="keyword">char</span> vertex[N]=&#123;<span class="string">'A'</span>,<span class="string">'B'</span>,<span class="string">'C'</span>,<span class="string">'D'</span>,<span class="string">'E'</span>,<span class="string">'F'</span>,<span class="string">'G'</span>,<span class="string">'H'</span>&#125;;</span><br><span class="line">	<span class="keyword">int</span> matrix[N][N]=&#123;&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">					  &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">					  &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;,</span><br><span class="line">					  &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>&#125;,</span><br><span class="line">					  &#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">					  &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;,</span><br><span class="line">					  &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>&#125;,</span><br><span class="line">					  &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>&#125;&#125;;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		g.vexs[i]=vertex[i];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;N;j++)</span><br><span class="line">			g.arcs[i][j]=matrix[i][j];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//printf("%d",g.arcs[7][5]);</span></span><br><span class="line">	<span class="keyword">int</span> d[N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="keyword">int</span> f[N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line">	<span class="comment">//printf("图按照邻接矩阵存储时的深度优先搜索遍历：\n");</span></span><br><span class="line">	<span class="keyword">while</span>(num!=N)<span class="comment">//当从某个节点无法一次搜索完所有节点时，从一个没有被访问过的节点开始</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;N;j++)</span><br><span class="line">			<span class="keyword">if</span>(visited[j]==<span class="number">0</span>)</span><br><span class="line">				DFS_direction(g,j,visited);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;N;k++)</span><br><span class="line">			num=num+visited[k];<span class="comment">//查看是否所有节点遍历到	</span></span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>Algorithm Design</tag>
      </tags>
  </entry>
  <entry>
    <title>【算法导论】邻接矩阵存储的拓扑排序</title>
    <url>/2013/12/11/%5B20131211%5D/</url>
    <content><![CDATA[<p>​    在很多应用中，很多事情都是按照一定的次序来进行的，比如说起床穿衣时，不可能先穿鞋再穿袜子，但是穿袜子和穿裤子可以不分先后次序。这种按照一定顺序进行的活动，可以使用顶点表示活动，顶点之间的有向边表示活动间的先后关系，这种有向无回路图说明了活动的先后次序。</p>
<a id="more"></a>
<p>​    当活动只能单个进行时，如果可以将图中的所有顶点排列成一个线性序列$v<em>{i1}, v</em>{i2}, \cdots, v_{in}$，并且这个序列同时满足关系：若从顶点$v_i$到顶点$v_j$存在一条路径，则在线性序列中$v_i$必在$v_j$之前，我们就称这个线性序列为拓扑序列。<strong>把对有向无回路图构造拓扑序列的操作称为拓扑排序。</strong></p>
<p><strong>其基本思想：</strong></p>
<p>​    <strong>拓扑排序的基本操作为：</strong></p>
<ul>
<li>从图中选择一个入度为0的顶点并且输出它；</li>
<li>从图中删除此顶点及所有由它发出的边；</li>
<li>重复上述过程，直到图中没有入度为0的边。</li>
</ul>
<p><strong>以上的操作会产生两种结果：</strong>一种是图中的全部顶点都被输出，整个拓扑排序完成；另一种是图中顶点未被全部输出，剩余的顶点的入度均不为0，则说明网中存在有向环。</p>
<p><strong>上述表述比较抽象，下面我用图解的方式来介绍其思想：</strong></p>
<p>假设有向无回路图如下所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20131211/20131211_fig001.jpg" width="250" height="200" title="图1" alt="图1" ></p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20131211/20131211_fig002.jpg" width="250" height="200" title="图2" alt="图2" ></p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20131211/20131211_fig003.jpg" width="250" height="200" title="图3" alt="图3" ></p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20131211/20131211_fig004.jpg" width="150" height="150" title="图4" alt="图4" ></p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20131211/20131211_fig005.jpg" width="150" height="150" title="图5" alt="图5" ></p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20131211/20131211_fig006.jpg" width="50" height="100" title="图6" alt="图6" ></p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20131211/20131211_fig007.jpg" width="50" height="50" title="图7" alt="图7" ></p>
<p><strong>因此得到的拓扑排序序列为： A B D C E F G.</strong></p>
<p><strong>具体的程序实现如下：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 7<span class="comment">//顶点个数</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">char</span> vexs[N];<span class="comment">//顶点数组</span></span><br><span class="line">	<span class="keyword">int</span> arcs[N][N];<span class="comment">//邻接矩阵</span></span><br><span class="line">&#125;graph;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TopoSort_matrix</span><span class="params">(graph g)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> row[N]=&#123;<span class="number">0</span>&#125;;<span class="comment">//按照列来设置标志，为1表示已经输出（不再考虑），为0表示未输出。</span></span><br><span class="line">	<span class="keyword">int</span> v=<span class="number">1</span>;<span class="comment">//标志符，1表示已经输出（不再考虑），为0表示未输出，赋给row数组</span></span><br><span class="line">	<span class="keyword">int</span> i,j,k,t,m;</span><br><span class="line">	<span class="keyword">for</span>(k=<span class="number">0</span>;k&lt;N;k++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;N;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(row[j]==<span class="number">0</span>)<span class="comment">//活动j还未输出</span></span><br><span class="line">			&#123;</span><br><span class="line">				t=<span class="number">1</span>;<span class="comment">//标识符</span></span><br><span class="line">				<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">					<span class="keyword">if</span>(g.arcs[i][j]==<span class="number">1</span>)<span class="comment">//当前活动有入度（活动i必须在活动j之前）</span></span><br><span class="line">					&#123;</span><br><span class="line">						t=<span class="number">0</span>;</span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				<span class="keyword">if</span>(t==<span class="number">1</span>)<span class="comment">//活动j没有入度</span></span><br><span class="line">				&#123;</span><br><span class="line">					m=j;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(j!=N)</span><br><span class="line">		&#123;</span><br><span class="line">			row[m]=v;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%c"</span>,g.vexs[m]);</span><br><span class="line">			<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">				g.arcs[m][i]=<span class="number">0</span>;<span class="comment">//将已经输出的活动所到达的下个活动的入度置为0</span></span><br><span class="line">			v++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> </span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(v<span class="number">-1</span>&lt;N)<span class="comment">//当row中不是所有的元素都被赋予新值v时，说明有环存在</span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"\n该有向图有环存在！"</span>);</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	graph g;</span><br><span class="line">	<span class="keyword">int</span> matrix[N][N]=&#123;&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">					  &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>&#125;,</span><br><span class="line">			    	  &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>&#125;,</span><br><span class="line">					  &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">					  &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>&#125;,</span><br><span class="line">					  &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">					  &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line">	<span class="keyword">char</span> vertex[N]=&#123;<span class="string">'A'</span>,<span class="string">'B'</span>,<span class="string">'C'</span>,<span class="string">'D'</span>,<span class="string">'E'</span>,<span class="string">'F'</span>,<span class="string">'G'</span>&#125;;<span class="comment">//初始化</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			g.vexs[i]=vertex[i];</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;N;j++)</span><br><span class="line">				g.arcs[i][j]=matrix[i][j];</span><br><span class="line">		&#125;</span><br><span class="line">	TopoSort_matrix(g);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>Algorithm Design</tag>
      </tags>
  </entry>
  <entry>
    <title>【算法导论】图的深度优先搜索遍历(DFS)</title>
    <url>/2013/12/10/%5B20131210%5D/</url>
    <content><![CDATA[<p>​    关于图的存储在上一篇文章中已经讲述，在这里不在赘述。<strong>下面我们介绍图的深度优先搜索遍历（DFS）。</strong></p>
<p>​    深度优先搜索遍历实在访问了顶点$v_i$后，访问$v_i$的一个邻接点$v_j$；访问$v_j$之后，又访问$v_j$的一个邻接点，依次类推，尽可能向纵深方向搜索，所以称为深度优先搜索遍历。显然这种搜索方法具有递归的性质。图的BFS和树的搜索遍历很类似，只是其存储方式不同。</p>
<a id="more"></a>
<p>​    <strong>其基本思想为</strong>：从图中某一顶点$v_i$出发，访问此顶点，并进行标记，然后依次搜索$v_i$的每个邻接点$v_j$；若$v_j$未被访问过，则对$v_j$进行访问和标记，然后依次搜索$v_j$的每个邻接点; 若$v_j$的邻接点未被访问过，则访问$v_j$的邻接点，并进行标记，直到图中和$v_i$有路径相通的顶点都被访问。若图中尚有顶点未被访问过（非连通的情况下），则另选图中的一个未被访问的顶点作为出发点，重复上述过程，直到图中所有顶点都被访问为止。</p>
<p>在下面的程序中，假设图如下所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20131210/20131210_fig001.jpg" width="300" height="250" title="图1" alt="图1" ></p>
<p><strong>A B C D E对应的序号分别为0 1 2 3 4. 上图的轨迹为一种深度优先搜索遍历。</strong></p>
<p><strong>具体的程序实现如下：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">char</span> vexs[N];<span class="comment">//顶点数组</span></span><br><span class="line">	<span class="keyword">int</span> arcs[N][N];<span class="comment">//邻接矩阵</span></span><br><span class="line">&#125;graph;</span><br><span class="line"></span><br><span class="line"><span class="comment">//图的两种存储方法的结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> adjvex;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;edgenode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">char</span> vertex;</span><br><span class="line">	edgenode *link;</span><br><span class="line">&#125;vexnode;</span><br><span class="line"></span><br><span class="line"><span class="comment">//队列的结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;linklist;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	linklist *front,*rear;</span><br><span class="line">&#125;linkqueue;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS_matrix</span><span class="params">(graph g,<span class="keyword">int</span> i,<span class="keyword">int</span> visited[N])</span></span>;<span class="comment">//图按照邻接矩阵存储时的深度优先搜索遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS_AdjTable</span><span class="params">(vexnode ga[N],<span class="keyword">int</span> i,<span class="keyword">int</span> visited[N])</span></span>;<span class="comment">//图按照邻接矩表存储时的深度优先搜索遍历</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SetNull</span><span class="params">(linkqueue *q)</span><span class="comment">//置空</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	q-&gt;front=(linklist *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(linklist));</span><br><span class="line">	q-&gt;front-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">	q-&gt;rear=q-&gt;front;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Empty</span><span class="params">(linkqueue *q)</span><span class="comment">//判空</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(q-&gt;front==q-&gt;rear)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Front</span><span class="params">(linkqueue *q)</span><span class="comment">//取队头元素</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(Empty(q))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"queue is empty!"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> q-&gt;front-&gt;next-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ENqueue</span><span class="params">(linkqueue *q,<span class="keyword">int</span> x)</span><span class="comment">//入队</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	linklist * newnode=(linklist *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(linklist));</span><br><span class="line">    q-&gt;rear-&gt;next=newnode;</span><br><span class="line">	q-&gt;rear=newnode;</span><br><span class="line">	q-&gt;rear-&gt;data=x;</span><br><span class="line">	q-&gt;rear-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DEqueue</span><span class="params">(linkqueue *q)</span><span class="comment">//出队</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> temp;</span><br><span class="line">	linklist *s;</span><br><span class="line">	<span class="keyword">if</span>(Empty(q))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"queue is empty!"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		s=q-&gt;front-&gt;next;</span><br><span class="line">		<span class="keyword">if</span>(s-&gt;next==<span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			q-&gt;front-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">			q-&gt;rear=q-&gt;front;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			q-&gt;front-&gt;next=s-&gt;next;</span><br><span class="line">		temp=s-&gt;data;</span><br><span class="line">		<span class="keyword">return</span> temp;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateAdjTable</span><span class="params">(vexnode ga[N],<span class="keyword">int</span> e)</span><span class="comment">//创建邻接表</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i,j,k;</span><br><span class="line">	edgenode *s;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\n输入顶点的内容："</span>);</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//scanf("\n%c",ga[i].vertex);</span></span><br><span class="line">		</span><br><span class="line">		ga[i].vertex=getchar();</span><br><span class="line">		</span><br><span class="line">		ga[i].link=<span class="literal">NULL</span>;<span class="comment">//初始化</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">	<span class="keyword">for</span>(k=<span class="number">0</span>;k&lt;e;k++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"输入边的两个顶点的序号:"</span>);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;i,&amp;j);<span class="comment">//读入边的两个顶点的序号</span></span><br><span class="line">		s=(edgenode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(edgenode));</span><br><span class="line">		s-&gt;adjvex=j;</span><br><span class="line">		s-&gt;next=ga[i].link;</span><br><span class="line">		ga[i].link=s;</span><br><span class="line"></span><br><span class="line">		s=(edgenode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(edgenode));</span><br><span class="line">		s-&gt;adjvex=i;</span><br><span class="line">		s-&gt;next=ga[j].link;</span><br><span class="line">		ga[j].link=s;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	graph g;</span><br><span class="line">	<span class="keyword">int</span> visited[<span class="number">5</span>]=&#123;<span class="number">0</span>&#125;;<span class="comment">//初始化</span></span><br><span class="line">	<span class="keyword">int</span> visited1[<span class="number">5</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">	g.vexs[<span class="number">0</span>]=<span class="string">'A'</span>;</span><br><span class="line">	g.vexs[<span class="number">1</span>]=<span class="string">'B'</span>;</span><br><span class="line">	g.vexs[<span class="number">2</span>]=<span class="string">'C'</span>;</span><br><span class="line">	g.vexs[<span class="number">3</span>]=<span class="string">'D'</span>;</span><br><span class="line">	g.vexs[<span class="number">4</span>]=<span class="string">'E'</span>;</span><br><span class="line">	<span class="keyword">int</span> a[<span class="number">5</span>][<span class="number">5</span>]=&#123;&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>&#125;,&#123; <span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>&#125;,&#123; <span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,&#123; <span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,&#123; <span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">5</span>;j++)</span><br><span class="line">			g.arcs[i][j]=a[i][j];</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"图按照邻接矩阵存储时的深度优先搜索遍历：\n"</span>);</span><br><span class="line">	DFS_matrix(g,<span class="number">0</span>,visited);</span><br><span class="line">	vexnode ga[N];</span><br><span class="line">	CreateAdjTable(ga,<span class="number">5</span>);<span class="comment">//5为边的条数</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"图按照邻接表存储时的深度优先搜索遍历：\n"</span>);</span><br><span class="line">    DFS_AdjTable(ga,<span class="number">0</span>,visited1);<span class="comment">//0为开始的顶点的序号</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS_matrix</span><span class="params">(graph g,<span class="keyword">int</span> i,<span class="keyword">int</span> visited[N])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%c\n"</span>,g.vexs[i]);</span><br><span class="line">	visited[i]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;N;j++)</span><br><span class="line">		<span class="keyword">if</span>(g.arcs[i][j]==<span class="number">1</span>&amp;&amp;visited[j]==<span class="number">0</span>)<span class="comment">//是否有未被访问的邻接点</span></span><br><span class="line">			DFS_matrix(g,j,visited);<span class="comment">//递归</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS_AdjTable</span><span class="params">(vexnode ga[N],<span class="keyword">int</span> i,<span class="keyword">int</span> visited[N])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	edgenode *p;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%c\n"</span>,ga[i].vertex);</span><br><span class="line">	visited[i]=<span class="number">1</span>;</span><br><span class="line">	p=ga[i].link;</span><br><span class="line">	<span class="keyword">while</span>(p!=<span class="literal">NULL</span>)<span class="comment">//p是否为空</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(visited[p-&gt;adjvex]==<span class="number">0</span>)</span><br><span class="line">			DFS_AdjTable(ga,p-&gt;adjvex,visited);</span><br><span class="line">		p=p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其结果如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20131210/20131210_fig002.jpg" width="500" height="350" title="图2" alt="图2" ></p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>Algorithm Design</tag>
      </tags>
  </entry>
  <entry>
    <title>【算法导论】图的广度优先搜索遍历（BFS）</title>
    <url>/2013/12/09/%5B20131209%5D/</url>
    <content><![CDATA[<p>​    图的存储方法：<strong>邻接矩阵、邻接表</strong></p>
<a id="more"></a>
<p>​    例如：有一个图如下所示(该图也作为程序的实例)：</p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20131209/20131209_fig001.jpg" width="300" height="250" title="图1" alt="图1" ></p>
<p>则上图<strong>用邻接矩阵可以表示</strong>为：</p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20131209/20131209_fig002.jpg" width="300" height="200" title="图2" alt="图2" ></p>
<p>用<strong>邻接表可以表示</strong>如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20131209/20131209_fig003.jpg" width="400" height="300" title="图3" alt="图3" ></p>
<p>邻接矩阵可以很容易的用二维数组表示，<strong>下面主要看看怎样构成邻接表</strong>：</p>
<p>​    邻接表存储方法是一种顺序存储与链式存储相结合的存储方法。<strong>在这种方法中，只考虑非零元素，所以在图中的顶点很多而边很少时，可以节省存储空间</strong>。<br>​    <strong>邻接表存储结构由两部分组成</strong>：对于每个顶点$v_i$, 使用一个具有两个域的结构体数组来存储，这个数组称为顶点表。其中一个域称为顶点域(vertex)，用来存放顶点本身的数据信息；而另一个域称为指针域(link)，用来存放依附于该顶点的边所组成的单链表的表头结点的存储位置。邻接于$v_i$的顶点$v_j$链接成的单链表称为$v_i$的邻接链表。邻接链表中的每个结点由两个域构成：一是邻接点域(adjvex)，用来存放与$v_i$相邻接的顶点$v_j$的序号$j$ (可以是顶点$v_j$在顶点表中所占数组单元的下标)； 其二是链域(next)，用来将邻接链表中的结点链接在一起。具体的程序实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateAdjTable</span><span class="params">(vexnode ga[N],<span class="keyword">int</span> e)</span><span class="comment">//创建邻接表</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i,j,k;</span><br><span class="line">	edgenode *s;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\n输入顶点的内容："</span>);</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		ga[i].vertex=getchar();<span class="comment">//读入顶点的内容</span></span><br><span class="line">		</span><br><span class="line">		ga[i].link=<span class="literal">NULL</span>;<span class="comment">//初始化</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">	<span class="keyword">for</span>(k=<span class="number">0</span>;k&lt;e;k++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"输入边的两个顶点的序号:"</span>);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;i,&amp;j);<span class="comment">//读入边的两个顶点的序号</span></span><br><span class="line">		s=(edgenode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(edgenode));</span><br><span class="line">		s-&gt;adjvex=j;</span><br><span class="line">		s-&gt;next=ga[i].link;</span><br><span class="line">		ga[i].link=s;</span><br><span class="line"></span><br><span class="line">		s=(edgenode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(edgenode));</span><br><span class="line">		s-&gt;adjvex=i;</span><br><span class="line">		s-&gt;next=ga[j].link;</span><br><span class="line">		ga[j].link=s;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="广度优先搜索遍历（BFS）"><a href="#广度优先搜索遍历（BFS）" class="headerlink" title="广度优先搜索遍历（BFS）:"></a>广度优先搜索遍历（BFS）:</h3><p>​    图的广度优先搜索遍历类似于树的按层次遍历。在假设初始状态是图中所有顶点都未被访问的条件下，这种方法从图中某一顶点$v_i$出发，先访问$v_i$，然后访问$v_i$的邻接点$v_j$。在所有的$v_j$都被访问之后，再访问$v_j$的邻接点$v_k$，依次类推，直到图中所有和初始出发点$v_i$有路径相通的顶点都被访问为止。若图是非连通的，则选择一个未曾被访问的顶点作为起始点，重复以上过程，直到图中所有顶点都被访问为止。<br>​    在这种方法的遍历过程中，先被访问的顶点，其邻接点也先被访问，具有先进先出的特性，所以可以使用一个队列来保存已访问过的顶点，以确定对访问过的顶点的邻接点的访问次序。为了避免重复访问一个顶点，也使用了一个辅助数组visited[n]来标记顶点的访问情况。下面分别给出以邻接矩阵和邻接表为存储结构时的广度优先搜索遍历算法BFS_matrix和BFS_AdjTable:</p>
<p><strong>具体程序实现如下：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//邻接矩阵存储法</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">char</span> vexs[N];<span class="comment">//顶点数组</span></span><br><span class="line">	<span class="keyword">int</span> arcs[N][N];</span><br><span class="line">&#125;graph;</span><br><span class="line"></span><br><span class="line"><span class="comment">//邻接表存储法</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> adjvex;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line"></span><br><span class="line">&#125;edgenode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">char</span> vertex;</span><br><span class="line">	edgenode *link;</span><br><span class="line">&#125;vexnode;</span><br><span class="line"></span><br><span class="line"><span class="comment">//队列操作</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;linklist;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	linklist *front,*rear;</span><br><span class="line">&#125;linkqueue;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SetNull</span><span class="params">(linkqueue *q)</span><span class="comment">//队列置空</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	q-&gt;front=(linklist *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(linklist));</span><br><span class="line">	q-&gt;front-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">	q-&gt;rear=q-&gt;front;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Empty</span><span class="params">(linkqueue *q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(q-&gt;front==q-&gt;rear)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Front</span><span class="params">(linkqueue *q)</span><span class="comment">//取队头元素</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(Empty(q))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"queue is empty!"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> q-&gt;front-&gt;next-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ENqueue</span><span class="params">(linkqueue *q,<span class="keyword">int</span> x)</span><span class="comment">//入队</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	linklist * newnode=(linklist *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(linklist));</span><br><span class="line">    q-&gt;rear-&gt;next=newnode;</span><br><span class="line">	q-&gt;rear=newnode;</span><br><span class="line">	q-&gt;rear-&gt;data=x;</span><br><span class="line">	q-&gt;rear-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DEqueue</span><span class="params">(linkqueue *q)</span><span class="comment">//出队</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> temp;</span><br><span class="line">	linklist *s;</span><br><span class="line">	<span class="keyword">if</span>(Empty(q))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"queue is empty!"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		s=q-&gt;front-&gt;next;</span><br><span class="line">		<span class="keyword">if</span>(s-&gt;next==<span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			q-&gt;front-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">			q-&gt;rear=q-&gt;front;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			q-&gt;front-&gt;next=s-&gt;next;</span><br><span class="line">		temp=s-&gt;data;</span><br><span class="line">		<span class="keyword">return</span> temp;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS_matrix</span><span class="params">(graph g,<span class="keyword">int</span> k,<span class="keyword">int</span> visited[N])</span><span class="comment">//图按照邻接矩阵存储时的广度优先遍历</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">	linkqueue q;</span><br><span class="line">	SetNull(&amp;q);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%c\n"</span>,g.vexs[k]);</span><br><span class="line">	visited[k]=<span class="number">1</span>;</span><br><span class="line">	ENqueue(&amp;q,k);</span><br><span class="line">	<span class="keyword">while</span>(!Empty(&amp;q))</span><br><span class="line">	&#123;</span><br><span class="line">		i=DEqueue(&amp;q);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;N;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(g.arcs[i][j]==<span class="number">1</span>&amp;&amp;visited[j]!=<span class="number">1</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"%c\n"</span>,g.vexs[j]);</span><br><span class="line">				visited[j]=<span class="number">1</span>;</span><br><span class="line">				ENqueue(&amp;q,j);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateAdjTable</span><span class="params">(vexnode ga[N],<span class="keyword">int</span> e)</span><span class="comment">//创建邻接表</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i,j,k;</span><br><span class="line">	edgenode *s;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\n输入顶点的内容："</span>);</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		ga[i].vertex=getchar();<span class="comment">//读入顶点的内容</span></span><br><span class="line">		</span><br><span class="line">		ga[i].link=<span class="literal">NULL</span>;<span class="comment">//初始化</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">	<span class="keyword">for</span>(k=<span class="number">0</span>;k&lt;e;k++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"输入边的两个顶点的序号:"</span>);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;i,&amp;j);<span class="comment">//读入边的两个顶点的序号</span></span><br><span class="line">		s=(edgenode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(edgenode));</span><br><span class="line">		s-&gt;adjvex=j;</span><br><span class="line">		s-&gt;next=ga[i].link;</span><br><span class="line">		ga[i].link=s;</span><br><span class="line"></span><br><span class="line">		s=(edgenode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(edgenode));</span><br><span class="line">		s-&gt;adjvex=i;</span><br><span class="line">		s-&gt;next=ga[j].link;</span><br><span class="line">		ga[j].link=s;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS_AdjTable</span><span class="params">(vexnode ga[],<span class="keyword">int</span> k,<span class="keyword">int</span> visited[N])</span><span class="comment">//图按照邻接表存储时的广度优先遍历</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">	edgenode *p;</span><br><span class="line">	linkqueue q;</span><br><span class="line">	SetNull(&amp;q);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%c\n"</span>,ga[k].vertex);</span><br><span class="line">	visited[k]=<span class="number">1</span>;<span class="comment">//标记是否被访问过</span></span><br><span class="line">	ENqueue(&amp;q,k);<span class="comment">//入队</span></span><br><span class="line">	<span class="keyword">while</span>(!Empty(&amp;q))</span><br><span class="line">	&#123;</span><br><span class="line">		i=DEqueue(&amp;q);</span><br><span class="line">		p=ga[i].link;</span><br><span class="line">		<span class="keyword">while</span>(p!=<span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(visited[p-&gt;adjvex]!=<span class="number">1</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"%c\n"</span>,ga[p-&gt;adjvex].vertex);</span><br><span class="line">				visited[p-&gt;adjvex]=<span class="number">1</span>;</span><br><span class="line">				ENqueue(&amp;q,p-&gt;adjvex);</span><br><span class="line">			&#125;</span><br><span class="line">			p=p-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	graph g;</span><br><span class="line">	vexnode ga[N];</span><br><span class="line">	<span class="keyword">int</span> visited[<span class="number">5</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="keyword">int</span> visited1[<span class="number">5</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">	g.vexs[<span class="number">0</span>]=<span class="string">'A'</span>;</span><br><span class="line">	g.vexs[<span class="number">1</span>]=<span class="string">'B'</span>;</span><br><span class="line">	g.vexs[<span class="number">2</span>]=<span class="string">'C'</span>;</span><br><span class="line">	g.vexs[<span class="number">3</span>]=<span class="string">'D'</span>;</span><br><span class="line">	g.vexs[<span class="number">4</span>]=<span class="string">'E'</span>;</span><br><span class="line">	<span class="keyword">int</span> a[<span class="number">5</span>][<span class="number">5</span>]=&#123;&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>&#125;,&#123; <span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>&#125;,&#123; <span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,&#123; <span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,&#123; <span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">5</span>;j++)</span><br><span class="line">			g.arcs[i][j]=a[i][j];</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"图按照邻接矩阵存储时的广度优先遍历：\n"</span>);</span><br><span class="line">	BFS_matrix(g,<span class="number">0</span>,visited);</span><br><span class="line">	CreateAdjTable(ga,<span class="number">5</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"图按照邻接表存储时的广度优先遍历：\n"</span>);</span><br><span class="line">	BFS_AdjTable(ga,<span class="number">0</span>,visited1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>其结果如下图：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20131209/20131209_fig004.jpg" width="500" height="350" title="图4" alt="图4" ></p>
<p><strong>从上面可以看出，两种方式的结果不同，但都是正确的，因为这与邻接点访问的顺序有关。</strong></p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>Algorithm Design</tag>
      </tags>
  </entry>
  <entry>
    <title>【算法导论】链表队列</title>
    <url>/2013/12/06/%5B20131206%5D/</url>
    <content><![CDATA[<p>​    链表队列很简单，之前看到过，没有用程序实现。其原理就是遵循FIFO原则,只能从队首取元素，从队尾插入元素，就和排队模型一样。因此只需要队首指针和队尾指针就可以方便的进行队列操作。因为在最近看的图论算法中，经常用到队列，在这里就先用程序实现链表队列。</p>
<a id="more"></a>
<p>​    和单链表一样，为了运算方便，我们也在队头节点前附加一个头结点，且头指针指向头结点。其链表队列的示意图如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20131206/20131206_fig001.jpg" width="600" height="250" title="图1" alt="图1" ></p>
<p><strong>下面是具体的程序实现：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span>//定义节点的结构体</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;linklist;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>//定义链表</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	linklist *front,*rear;<span class="comment">//定义指向节点的头尾指针</span></span><br><span class="line">&#125;linkqueue;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SetNull</span><span class="params">(linkqueue *q)</span><span class="comment">//置空队列（含空的头节点，便于处理）</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	q-&gt;front=(linklist *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(linklist));</span><br><span class="line">	q-&gt;front-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">	q-&gt;rear=q-&gt;front;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Empty</span><span class="params">(linkqueue *q)</span><span class="comment">//判断队列是否为空</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(q-&gt;front==q-&gt;rear)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Front</span><span class="params">(linkqueue *q)</span><span class="comment">//取出队列的头元素</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(Empty(q))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"queue is empty!"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> q-&gt;front-&gt;next-&gt;data;<span class="comment">//注意有头指针，该指针的下个元素才是第一个元素</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ENqueue</span><span class="params">(linkqueue *q,<span class="keyword">int</span> x)</span><span class="comment">//进队列</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	linklist * newnode=(linklist *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(linklist));</span><br><span class="line">    q-&gt;rear-&gt;next=newnode;</span><br><span class="line">	q-&gt;rear=newnode;</span><br><span class="line">	q-&gt;rear-&gt;data=x;</span><br><span class="line">	q-&gt;rear-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DEqueue</span><span class="params">(linkqueue *q)</span><span class="comment">//出队列</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> temp;</span><br><span class="line">	linklist *s;</span><br><span class="line">	<span class="keyword">if</span>(Empty(q))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"queue is empty!"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		s=q-&gt;front-&gt;next;</span><br><span class="line">		<span class="keyword">if</span>(s-&gt;next==<span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			q-&gt;front-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">			q-&gt;rear=q-&gt;front;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			q-&gt;front-&gt;next=s-&gt;next;</span><br><span class="line">		temp=s-&gt;data;</span><br><span class="line">		<span class="keyword">return</span> temp;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	linkqueue q;<span class="comment">//这里是产生队列q,而不是产生指向队列的指正，是为了方便初始化。</span></span><br><span class="line">	            <span class="comment">//如果为指针的话，必须初始化，则头尾指针无法初始化。</span></span><br><span class="line">	</span><br><span class="line">	SetNull(&amp;q);<span class="comment">//相当于初始化</span></span><br><span class="line">	ENqueue(&amp;q,<span class="number">2</span>);<span class="comment">//将关键字2入队</span></span><br><span class="line">	ENqueue(&amp;q,<span class="number">3</span>);<span class="comment">//将关键字3入队</span></span><br><span class="line">	ENqueue(&amp;q,<span class="number">4</span>);<span class="comment">//将关键字4入队</span></span><br><span class="line">	DEqueue(&amp;q);<span class="comment">//将关键字2出队</span></span><br><span class="line">	DEqueue(&amp;q);<span class="comment">//将关键字3出队</span></span><br><span class="line">	<span class="keyword">int</span> a=<span class="number">0</span>;</span><br><span class="line">    a=Front(&amp;q);<span class="comment">//取队头元素</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>Algorithm Design</tag>
      </tags>
  </entry>
  <entry>
    <title>【算法导论】B树</title>
    <url>/2013/12/04/%5B20131204%5D/</url>
    <content><![CDATA[<p>   <strong>一棵B树T是具有如下性质的有根树（设根为root）</strong>:</p>
<ul>
<li><p>每个节点x有一下域：</p>
<ul>
<li>num,当前存储在节点x的关键字个数,关键字以非降序存放，因此$key[i]\le key[i+1]\le\cdots \le key[n]$; </li>
<li>isleaf,是一个bool值，如果x为叶子节点，则isleaf=true；</li>
<li>每个节点包括$num+1$个指向其子女的指针$p[0], p[1], \cdots ,p[num]$。如果$x$为叶子，则$p=NULL$；</li>
<li>每个节点包括$num$个关键字$key[0], key[1], \cdots, key[num-1]$。各关键字$key[i]$对存储在各子树中的关键字范围加以分隔：  $k1\le key[1]\le k2\le key[2]\le\cdots$</li>
</ul>
</li>
<li><p>每个叶节点具有相同的深度；</p>
</li>
<li><p>每一个节点包含的关键字有上下界。这些界可以用一个称为B树的最小度数的固定整数$M\ge2$来表示。每个非根节点的个数$n$必须满足$M-1\le n\le 2M-1$。根节点至少包括   一个关键字。如果一个节点是满的，则它恰好有$2M-1$个关键字。</p>
<a id="more"></a>
</li>
</ul>
<p>​    <strong>一棵B树可以表示如下：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20131204/20131204_fig001.jpg" width="500" height="250" title="图1" alt="图1" ></p>
<p>​    <strong>B树与红黑树的相似之处</strong>在于，每棵有$n$个节点的B树高度为$O(\log n)$，但可能要比一棵红黑树的高度小很多，因为它的分支比较多！因为在磁盘存储中，需要经常读取数据，所以选择一个大的分支因子，可以大大地降低树的高度，以及磁盘存取次数。这样说可能比较抽象，下面举例说明：下图为一棵分支因子为$1001$、高度为$2$的B树，可以看出它可以存储超过$10$亿个关键字；但是，因为根节点可以持久的保留在主存中，因此需找某个关键字至多只需要两次磁盘存取。如果用二叉树存储的话，树的深度将会很大，那么寻找位于叶子节点处的关键字将需要很多次磁盘读取！假设有$n$个节点，那么二叉树的高度为$h\le\log(n+1)$,而B树为$h\le\log((n+1)/2)/\log(M)$,其中$M$为最小度数。</p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20131204/20131204_fig002.jpg" width="600" height="200" title="图2" alt="图2" ></p>
<hr>
<h2 id="B树的各种操作"><a href="#B树的各种操作" class="headerlink" title="B树的各种操作"></a>B树的各种操作</h2><h4 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h4><p>  查找b树和查找二叉树类似，就是在分支处进行判断选择正确的子树，然后递归调用。查找过程的时间复杂读为$M\log n/\log M$具体程序实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**********************************************************\</span></span><br><span class="line"><span class="comment">函数功能：查找关键字所在的节点</span></span><br><span class="line"><span class="comment">输入：    树的根，关键字</span></span><br><span class="line"><span class="comment">输出：    关键字所在的节点</span></span><br><span class="line"><span class="comment">\**********************************************************/</span></span><br><span class="line"><span class="function">BtreeNode *<span class="title">BtreeSearch</span><span class="params">(BtreeNode *TestNode,<span class="keyword">int</span> keyword)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(i&lt;TestNode-&gt;num&amp;&amp;keyword&gt;TestNode-&gt;key[i])</span><br><span class="line">		i=i+<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(i&lt;=TestNode-&gt;num&amp;&amp;keyword==TestNode-&gt;key[i])</span><br><span class="line">		<span class="keyword">return</span> TestNode;</span><br><span class="line">	<span class="keyword">if</span>(TestNode-&gt;isleaf)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Not founded!\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> BtreeSearch(TestNode-&gt;p[i],keyword);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="创建空的B树"><a href="#创建空的B树" class="headerlink" title="创建空的B树"></a>创建空的B树</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**********************************************************\</span></span><br><span class="line"><span class="comment">函数功能：创建节点</span></span><br><span class="line"><span class="comment">输入：无</span></span><br><span class="line"><span class="comment">输出：新节点</span></span><br><span class="line"><span class="comment">\**********************************************************/</span></span><br><span class="line"><span class="function">BtreeNode * <span class="title">BtreeCreate</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	BtreeNode *node=(BtreeNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BtreeNode));</span><br><span class="line">	<span class="keyword">if</span>(<span class="literal">NULL</span>==node)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	node-&gt;isleaf=<span class="literal">true</span>;</span><br><span class="line">	node-&gt;num=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>*M;i++)</span><br><span class="line">		node-&gt;p[i]=<span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>*M<span class="number">-1</span>;i++)</span><br><span class="line">		node-&gt;key[i]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h4><p>​    <strong>B树的插入比二叉树的插入要复杂的多</strong>，因为二叉树的插入是插入新的节点，而B树的插入是将关键字插入到已存在的节点，而节点可能已经是满节点（前面提到过），就会破坏B树的性质。因此不能将关键字插入到满节点上。根据B树的规则，每个节点的关键字个数在$[M-1, 2M-1]$之间，故当keyword(要插入的关键字)要加入到某个叶子时，如果该叶子节点已经有$2M-1$个关键字，则再加入keyword就违反了B树的定义，这时就需要对该叶子节点进行分裂，将叶子以中间节点为界，分成两个包含$M-1$个关键字的子节点，同时把中间节点提升到该叶子的父节点中，如果这样使得父节点的关键字个数超过$2M-1$，则要继续向上分裂，直到根节点，根节点的分裂会使得树加高一层。</p>
<p>​    <strong>为了解决上面问题，我们需要不断地回溯，这显然比较复杂，我们可以未雨绸缪</strong>：我们不是等到发现是否真的需要分裂一个满节点时才做插入操作。相反地，当沿着树向下查找要插入关键字所处位置时，就分裂沿途遇到的每个满节点。这样做后，每当要分裂一个满节点时，就能保证其双亲不是满节点。</p>
<p>分裂满节点的过程图解如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20131204/20131204_fig003.jpg" width="600" height="200" title="图3" alt="图3" ></p>
<p>​    <strong>我们还要考虑特殊情况</strong>：当分裂一个满的根时，需要先让根成为一个新的空根节点的孩子，这样才能被上面的分解过程分解。树的高度增加$1$，分裂是树增高的唯一途径！其操作如下图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20131204/20131204_fig004.jpg" width="600" height="200" title="图4" alt="图4" ></p>
<p><strong>综上所述，插入过程的具体实现如下：</strong></p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        插入源代码：
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//////////////////////////////插入部分///////////////////////////////////////////</span></span><br><span class="line"><span class="comment">/**********************************************************\</span></span><br><span class="line"><span class="comment">函数功能：节点分裂，防止违反B树的性质</span></span><br><span class="line"><span class="comment">输入： 父节点father ,子节点child，k表示子节点为父节点的哪个孩子</span></span><br><span class="line"><span class="comment">输出：无</span></span><br><span class="line"><span class="comment">\**********************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BtreeSplitChild</span><span class="params">(BtreeNode *father,BtreeNode *child,<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BtreeNode *newchild=(BtreeNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BtreeNode));</span><br><span class="line">    newchild-&gt;isleaf=child-&gt;isleaf;<span class="comment">//newchild为child的右节点，即child分裂为child和newchild</span></span><br><span class="line">    newchild-&gt;num=M<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;M<span class="number">-1</span>;i++)</span><br><span class="line">        newchild-&gt;key[i]=child-&gt;key[i+M];</span><br><span class="line">    <span class="keyword">if</span>(!child-&gt;isleaf)<span class="comment">//当child不是叶子时，还要把指针赋给newchild</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;M;j++)</span><br><span class="line">            newchild-&gt;p[j]=child-&gt;p[j+M];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    child-&gt;num=M<span class="number">-1</span>;<span class="comment">//child的个数由2M-1变为M-1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=father-&gt;num<span class="number">-1</span>;i&gt;=k+<span class="number">1</span>;i--)<span class="comment">//改变父节点的内容</span></span><br><span class="line">        father-&gt;p[i+<span class="number">1</span>]=father-&gt;p[i];</span><br><span class="line">    father-&gt;p[k+<span class="number">1</span>]=newchild;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=father-&gt;num<span class="number">-1</span>;j&gt;=k;j--)</span><br><span class="line">        father-&gt;key[j+<span class="number">1</span>]=father-&gt;key[j];</span><br><span class="line">    father-&gt;key[k]=child-&gt;key[M<span class="number">-1</span>];<span class="comment">//将child的中间节点提升到父节点</span></span><br><span class="line">    father-&gt;num=father-&gt;num+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**********************************************************\</span></span><br><span class="line"><span class="comment">函数功能：x节点不是满的情况下，插入keyword</span></span><br><span class="line"><span class="comment">输入：B树的根，要插入的关键字</span></span><br><span class="line"><span class="comment">输出：无</span></span><br><span class="line"><span class="comment">\**********************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BtreeInsertNotFull</span><span class="params">(BtreeNode *x,<span class="keyword">int</span> keyword)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=x-&gt;num;</span><br><span class="line">    <span class="keyword">if</span>(x-&gt;isleaf)<span class="comment">//当x为叶子时，keyword插入到该节点中</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(i&gt;=<span class="number">1</span>&amp;&amp;keyword&lt;x-&gt;key[i<span class="number">-1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            x-&gt;key[i]=x-&gt;key[i<span class="number">-1</span>];</span><br><span class="line">            i=i<span class="number">-1</span>;</span><br><span class="line">        &#125;    </span><br><span class="line">        x-&gt;key[i]=keyword;</span><br><span class="line">        x-&gt;num=x-&gt;num+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span><span class="comment">//当x不是叶子时，找到keyword要插入的节点并插入</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(i&gt;=<span class="number">1</span>&amp;&amp;keyword&lt;x-&gt;key[i<span class="number">-1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            i=i<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span>(x-&gt;p[i]-&gt;num==<span class="number">2</span>*M<span class="number">-1</span>)<span class="comment">//当节点为满节点时，需要分裂</span></span><br><span class="line">        &#123;</span><br><span class="line">            BtreeSplitChild(x,x-&gt;p[i],i);</span><br><span class="line">            <span class="keyword">if</span>(keyword&gt;x-&gt;key[i])</span><br><span class="line">                i=i+<span class="number">1</span>;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        BtreeInsertNotFull(x-&gt;p[i],keyword);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**********************************************************\</span></span><br><span class="line"><span class="comment">函数功能：插入关键值</span></span><br><span class="line"><span class="comment">输入：B树的根，关键字</span></span><br><span class="line"><span class="comment">输出：B树的根</span></span><br><span class="line"><span class="comment">\**********************************************************/</span></span><br><span class="line"><span class="function">BtreeNode * <span class="title">BtreeInsert</span><span class="params">(BtreeNode *TestNode,<span class="keyword">int</span> keyword)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(TestNode-&gt;num==<span class="number">2</span>*M<span class="number">-1</span>)<span class="comment">//当根节点为满时，唯一增加高度的情况</span></span><br><span class="line">    &#123;</span><br><span class="line">        BtreeNode *newroot=(BtreeNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BtreeNode));</span><br><span class="line">        newroot-&gt;isleaf=<span class="literal">false</span>;<span class="comment">//产生新的根</span></span><br><span class="line">        newroot-&gt;num=<span class="number">0</span>;</span><br><span class="line">        newroot-&gt;p[<span class="number">0</span>]=TestNode;</span><br><span class="line">        BtreeSplitChild(newroot,TestNode,<span class="number">0</span>);</span><br><span class="line">        BtreeInsertNotFull(newroot,keyword);</span><br><span class="line">        <span class="keyword">return</span> newroot;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        BtreeInsertNotFull(TestNode,keyword);</span><br><span class="line">        <span class="keyword">return</span> TestNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </div>
</div>
<h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><p>​        B树的删除比插入操作更加复杂，插入操作只需考虑三种情况，而删除操作需要考虑的情况很多，情况如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20131204/20131204_fig005.jpg" width="600" height="400" title="图5" alt="图5" ></p>
<p>​    和插入操作类似，根据B树的规则，每个节点的关键字个数在$[M-1, 2M-1]$之间，故当keyword(要插入的关键字)要从某个叶子删除时，<strong>如果该叶子节点只有$M-1$个关键字，则再删除keyword就违反了B树的定义</strong>，这时就需要对该叶子节点进行合并。上图中各种情况中的t就是我所说的$M$即最小度数。<strong>具体程序实现如下：</strong></p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        删除操作源代码:
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">///////////////////////////删除部分//////////////////////////////////////////</span></span><br><span class="line"><span class="comment">/**********************************************************\</span></span><br><span class="line"><span class="comment">函数功能：合并左右子节点</span></span><br><span class="line"><span class="comment">输入：根，左右子节点，左节点是父节点的第pos个节点</span></span><br><span class="line"><span class="comment">输出：无</span></span><br><span class="line"><span class="comment">\**********************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BtreeMergeChild</span><span class="params">(BtreeNode *root, <span class="keyword">int</span> pos, BtreeNode *y, BtreeNode *z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 将z中节点拷贝到y的后半部分</span></span><br><span class="line">    y-&gt;num = <span class="number">2</span> * M - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = M; i &lt; <span class="number">2</span> * M - <span class="number">1</span>; i++) </span><br><span class="line">    &#123;</span><br><span class="line">        y-&gt;key[i] = z-&gt;key[i-M];</span><br><span class="line">    &#125;</span><br><span class="line">    y-&gt;key[M<span class="number">-1</span>] = root-&gt;key[pos]; <span class="comment">// 将root-&gt;key[pos]下降为y的中间节点</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">false</span> == z-&gt;isleaf)<span class="comment">// 如果z是内节点即非叶子，需要拷贝指向子节点的指针p</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = M; i &lt; <span class="number">2</span> * M; i++) </span><br><span class="line">        &#123;</span><br><span class="line">            y-&gt;p[i] = z-&gt;p[i-M];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">      </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = pos + <span class="number">1</span>; j &lt; root-&gt;num; j++) <span class="comment">// root-&gt;key[pos]下降到y中，更新root中key和p</span></span><br><span class="line">    &#123;</span><br><span class="line">        root-&gt;key[j<span class="number">-1</span>] = root-&gt;key[j];</span><br><span class="line">        root-&gt;p[j] = root-&gt;p[j+<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    root-&gt;num -= <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">free</span>(z);</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">/**********************************************************\</span></span><br><span class="line"><span class="comment">函数功能：删除关键字keyword</span></span><br><span class="line"><span class="comment">输入：树的根，关键字</span></span><br><span class="line"><span class="comment">输出：树的根</span></span><br><span class="line"><span class="comment">\**********************************************************/</span></span><br><span class="line"><span class="function">BtreeNode *<span class="title">BtreeDelete</span><span class="params">(BtreeNode *root, <span class="keyword">int</span> keyword)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 唯一能降低树高的情形</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="number">1</span> == root-&gt;num) <span class="comment">// 当根只有一个关键字，两个子女</span></span><br><span class="line">    &#123;</span><br><span class="line">        BtreeNode *y = root-&gt;p[<span class="number">0</span>];</span><br><span class="line">        BtreeNode *z = root-&gt;p[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">NULL</span> != y &amp;&amp; <span class="literal">NULL</span> != z &amp;&amp;M - <span class="number">1</span> == y-&gt;num &amp;&amp; M - <span class="number">1</span> == z-&gt;num)<span class="comment">//两个子女的关键字个数都为M-1时，合并根与两个子女</span></span><br><span class="line">        &#123;</span><br><span class="line">            BtreeMergeChild(root, <span class="number">0</span>, y, z);</span><br><span class="line">            <span class="built_in">free</span>(root);<span class="comment">//注意释放空间</span></span><br><span class="line">            BtreeDeleteNotFull(y, keyword);</span><br><span class="line">            <span class="keyword">return</span> y;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            BtreeDeleteNotFull(root, keyword);</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        BtreeDeleteNotFull(root, keyword);    </span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**********************************************************\</span></span><br><span class="line"><span class="comment">函数功能： root至少有个M个关键字时删除关键字</span></span><br><span class="line"><span class="comment">输入：   树的根，关键字</span></span><br><span class="line"><span class="comment">输出：   无</span></span><br><span class="line"><span class="comment">\**********************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BtreeDeleteNotFull</span><span class="params">(BtreeNode *root, <span class="keyword">int</span> keyword)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">true</span> == root-&gt;isleaf) <span class="comment">// 如果在叶子节点，直接删除,情况1</span></span><br><span class="line">    &#123; </span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; root-&gt;num &amp;&amp; keyword &gt; root-&gt;key[i]) i++;</span><br><span class="line">        <span class="keyword">if</span>(keyword == root-&gt;key[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; <span class="number">2</span> * M - <span class="number">1</span>; j++) </span><br><span class="line">            &#123;</span><br><span class="line">                root-&gt;key[j<span class="number">-1</span>] = root-&gt;key[j];</span><br><span class="line">            &#125;</span><br><span class="line">            root-&gt;num -= <span class="number">1</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"keyword not found\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;  <span class="comment">// 在分支中</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        BtreeNode *y = <span class="literal">NULL</span>, *z = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; root-&gt;num &amp;&amp; keyword &gt; root-&gt;key[i]) i++; </span><br><span class="line">        <span class="keyword">if</span>(i &lt; root-&gt;num &amp;&amp; keyword == root-&gt;key[i]) </span><br><span class="line">        &#123; <span class="comment">// 如果在分支节点找到keyword</span></span><br><span class="line">            y = root-&gt;p[i];</span><br><span class="line">            z = root-&gt;p[i+<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(y-&gt;num &gt; M - <span class="number">1</span>) </span><br><span class="line">            &#123;  </span><br><span class="line">              <span class="comment">// 如果左分支关键字多于M-1，则找到左分支的最右节点pre，替换keyword</span></span><br><span class="line">                <span class="comment">// 并在左分支中递归删除prev,情况2a</span></span><br><span class="line">                <span class="keyword">int</span> pre = BtreeSearchPrevious(y);</span><br><span class="line">                root-&gt;key[i] = pre;</span><br><span class="line">                BtreeDeleteNotFull(y, pre);<span class="comment">//递归处理</span></span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(z-&gt;num &gt; M - <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 如果右分支关键字多于M-1，则找到右分支的最左节点next，替换keyword</span></span><br><span class="line">                <span class="comment">// 并在右分支中递归删除next,情况2b</span></span><br><span class="line">                <span class="keyword">int</span> next = BtreeSearchNext(z);</span><br><span class="line">                root-&gt;key[i] = next;</span><br><span class="line">                BtreeDeleteNotFull(z, next);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="comment">// 两个分支节点数都为M-1，则合并至y，并在y中递归删除keyword,情况2c</span></span><br><span class="line">            &#123;</span><br><span class="line">                </span><br><span class="line">                BtreeMergeChild(root, i, y, z);</span><br><span class="line">                BtreeDelete(y, keyword);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span><span class="comment">// 分支中没有，在分支的子节点中的情况</span></span><br><span class="line">        &#123;   </span><br><span class="line">            y = root-&gt;p[i];</span><br><span class="line">            <span class="keyword">if</span>(i &lt; root-&gt;num) </span><br><span class="line">            &#123;</span><br><span class="line">                z = root-&gt;p[i+<span class="number">1</span>];<span class="comment">//y的右兄弟</span></span><br><span class="line">            &#125;</span><br><span class="line">            BtreeNode *p = <span class="literal">NULL</span>;<span class="comment">//初始化</span></span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                p = root-&gt;p[i<span class="number">-1</span>];<span class="comment">//y的左兄弟</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(y-&gt;num == M - <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; p-&gt;num &gt; M - <span class="number">1</span>) </span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 左兄弟节点关键字个数大于M-1,情况3a</span></span><br><span class="line">                    BtreeChangeToRchild(root, i<span class="number">-1</span>, p, y); </span><br><span class="line">                &#125; </span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(i &lt; root-&gt;num &amp;&amp; z-&gt;num &gt; M - <span class="number">1</span>) </span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 右兄弟节点关键字个数大于M-1,情况3a</span></span><br><span class="line">                    BtreeChangeToLchild(root, i, y, z); </span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(i &gt; <span class="number">0</span>) </span><br><span class="line">                &#123;   </span><br><span class="line">                    BtreeMergeChild(root, i<span class="number">-1</span>, p, y);  <span class="comment">//左右兄弟节点都不大于M-1，情况3b</span></span><br><span class="line">                    y = p;</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="keyword">else</span> <span class="comment">//没有左兄弟的情况</span></span><br><span class="line">                &#123;</span><br><span class="line">                    BtreeMergeChild(root, i, y, z); </span><br><span class="line">                &#125;</span><br><span class="line">                BtreeDeleteNotFull(y, keyword);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            &#123;</span><br><span class="line">                BtreeDeleteNotFull(y, keyword);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**********************************************************\</span></span><br><span class="line"><span class="comment">函数功能：寻找以root为根的最大关键字</span></span><br><span class="line"><span class="comment">输入：    树的根</span></span><br><span class="line"><span class="comment">输出：    最大关键字</span></span><br><span class="line"><span class="comment">\**********************************************************/</span> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BtreeSearchPrevious</span><span class="params">(BtreeNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BtreeNode *y = root;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">false</span> == y-&gt;isleaf)</span><br><span class="line">    &#123;</span><br><span class="line">        y = y-&gt;p[y-&gt;num];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> y-&gt;key[y-&gt;num<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**********************************************************\</span></span><br><span class="line"><span class="comment">函数功能：寻找以root为根的最小关键字</span></span><br><span class="line"><span class="comment">输入：树的根</span></span><br><span class="line"><span class="comment">输出：最小关键字</span></span><br><span class="line"><span class="comment">\**********************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BtreeSearchNext</span><span class="params">(BtreeNode *root)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BtreeNode *z = root;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">false</span> == z-&gt;isleaf)</span><br><span class="line">    &#123;</span><br><span class="line">        z = z-&gt;p[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> z-&gt;key[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**********************************************************\</span></span><br><span class="line"><span class="comment">函数功能：z向y借节点，将root-&gt;key[pos]下降至z，将y的最大关键字上升至root的pos处</span></span><br><span class="line"><span class="comment">输入：根，左右子节点，左节点是父节点的第pos个节点</span></span><br><span class="line"><span class="comment">输出：无</span></span><br><span class="line"><span class="comment">\**********************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BtreeChangeToRchild</span><span class="params">(BtreeNode *root, <span class="keyword">int</span> pos, BtreeNode *y, BtreeNode *z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    z-&gt;num += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = z-&gt;num <span class="number">-1</span>; i &gt; <span class="number">0</span>; i--) </span><br><span class="line">    &#123;</span><br><span class="line">        z-&gt;key[i] = z-&gt;key[i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    z-&gt;key[<span class="number">0</span>]= root-&gt;key[pos];</span><br><span class="line">    root-&gt;key[pos] = y-&gt;key[y-&gt;num<span class="number">-1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">false</span> == z-&gt;isleaf)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = z-&gt;num; i &gt; <span class="number">0</span>; i--) </span><br><span class="line">        &#123;</span><br><span class="line">            z-&gt;p[i] = z-&gt;p[i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        z-&gt;p[<span class="number">0</span>] = y-&gt;p[y-&gt;num];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    y-&gt;num -= <span class="number">1</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"><span class="comment">/**********************************************************\</span></span><br><span class="line"><span class="comment">函数功能：y向借节点，将root-&gt;key[pos]下降至y，将z的最小关键字上升至root的pos处</span></span><br><span class="line"><span class="comment">输入：根，左右子节点，左节点是父节点的第pos个节点</span></span><br><span class="line"><span class="comment">输出：无</span></span><br><span class="line"><span class="comment">\**********************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BtreeChangeToLchild</span><span class="params">(BtreeNode *root, <span class="keyword">int</span> pos, BtreeNode *y, BtreeNode *z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    y-&gt;num += <span class="number">1</span>;</span><br><span class="line">    y-&gt;key[y-&gt;num<span class="number">-1</span>] = root-&gt;key[pos];</span><br><span class="line">    root-&gt;key[pos] = z-&gt;key[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; z-&gt;num; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        z-&gt;key[j<span class="number">-1</span>] = z-&gt;key[j];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">false</span> == z-&gt;isleaf) </span><br><span class="line">    &#123;</span><br><span class="line">        y-&gt;p[y-&gt;num] = z-&gt;p[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= z-&gt;num; j++) </span><br><span class="line">        &#123;</span><br><span class="line">            z-&gt;p[j<span class="number">-1</span>] = z-&gt;p[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    z-&gt;num -= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </div>
</div>
<hr>
<p><strong>下面用具体实例来形象地说明B树的操作：</strong></p>
<p>假设初始的B树如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20131204/20131204_fig006.jpg" width="600" height="120" title="图6" alt="图6" ></p>
<p>经过一系列的插入操作后：</p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20131204/20131204_fig007.jpg" width="600" height="500" title="图7" alt="图7" ></p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20131204/20131204_fig008.jpg" width="600" height="200" title="图8" alt="图8" ></p>
<p><strong>在程序中为表示方便，将关键字由字母换成了数字，A、B、C……Y、Z对应于1、2、3……25、26.</strong></p>
<p>经过上面的插入操作后，紧接在进行一系列删除操作：</p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20131204/20131204_fig009.jpg" width="500" height="400" title="图9" alt="图9" ></p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20131204/20131204_fig010.jpg" width="500" height="350" title="图10" alt="图10" ></p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20131204/20131204_fig011.jpg" width="600" height="200" title="图11" alt="图11" ></p>
<p><strong>具体的完整实例程序实现如下：</strong></p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        完整实例源代码:
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//节点结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BtreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BtreeNode</span> *<span class="title">p</span>[2*<span class="title">M</span>];</span></span><br><span class="line">    <span class="keyword">int</span> key[<span class="number">2</span>*M<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">bool</span> isleaf; </span><br><span class="line">&#125;BtreeNode;</span><br><span class="line"></span><br><span class="line"><span class="function">BtreeNode * <span class="title">BtreeCreate</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BtreeSplitChild</span><span class="params">(BtreeNode *father,BtreeNode *child,<span class="keyword">int</span> k)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BtreeInsertNotFull</span><span class="params">(BtreeNode *x,<span class="keyword">int</span> keyword)</span></span>;</span><br><span class="line"><span class="function">BtreeNode * <span class="title">BtreeInsert</span><span class="params">(BtreeNode *TestNode,<span class="keyword">int</span> keyword)</span></span>;</span><br><span class="line"><span class="function">BtreeNode *<span class="title">BtreeSearch</span><span class="params">(BtreeNode *TestNode,<span class="keyword">int</span> keyword)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//////</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BtreeMergeChild</span><span class="params">(BtreeNode *root, <span class="keyword">int</span> pos, BtreeNode *y, BtreeNode *z)</span></span>;</span><br><span class="line"><span class="function">BtreeNode *<span class="title">BtreeDelete</span><span class="params">(BtreeNode *root, <span class="keyword">int</span> keyword)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BtreeDeleteNotFull</span><span class="params">(BtreeNode *root, <span class="keyword">int</span> keyword)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BtreeSearchPrevious</span><span class="params">(BtreeNode *root)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BtreeSearchNext</span><span class="params">(BtreeNode *root)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BtreeChangeToRchild</span><span class="params">(BtreeNode *root, <span class="keyword">int</span> pos, BtreeNode *y, BtreeNode *z)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BtreeChangeToLchild</span><span class="params">(BtreeNode *root, <span class="keyword">int</span> pos, BtreeNode *y, BtreeNode *z)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**********************************************************\</span></span><br><span class="line"><span class="comment">函数功能：创建节点</span></span><br><span class="line"><span class="comment">输入：无</span></span><br><span class="line"><span class="comment">输出：新节点</span></span><br><span class="line"><span class="comment">\**********************************************************/</span></span><br><span class="line"><span class="function">BtreeNode * <span class="title">BtreeCreate</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BtreeNode *node=(BtreeNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BtreeNode));</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span>==node)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    node-&gt;isleaf=<span class="literal">true</span>;</span><br><span class="line">    node-&gt;num=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>*M;i++)</span><br><span class="line">        node-&gt;p[i]=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>*M<span class="number">-1</span>;i++)</span><br><span class="line">        node-&gt;key[i]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//////////////////////////////插入部分///////////////////////////////////////////</span></span><br><span class="line"><span class="comment">/**********************************************************\</span></span><br><span class="line"><span class="comment">函数功能：节点分裂，防止违反B树的性质</span></span><br><span class="line"><span class="comment">输入： 父节点father ,子节点child，k表示子节点为父节点的哪个孩子</span></span><br><span class="line"><span class="comment">输出：无</span></span><br><span class="line"><span class="comment">\**********************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BtreeSplitChild</span><span class="params">(BtreeNode *father,BtreeNode *child,<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BtreeNode *newchild=(BtreeNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BtreeNode));</span><br><span class="line">    newchild-&gt;isleaf=child-&gt;isleaf;<span class="comment">//newchild为child的右节点，即child分裂为child和newchild</span></span><br><span class="line">    newchild-&gt;num=M<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;M<span class="number">-1</span>;i++)</span><br><span class="line">        newchild-&gt;key[i]=child-&gt;key[i+M];</span><br><span class="line">    <span class="keyword">if</span>(!child-&gt;isleaf)<span class="comment">//当child不是叶子时，还要把指针赋给newchild</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;M;j++)</span><br><span class="line">            newchild-&gt;p[j]=child-&gt;p[j+M];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    child-&gt;num=M<span class="number">-1</span>;<span class="comment">//child的个数由2M-1变为M-1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=father-&gt;num;i&gt;=k+<span class="number">1</span>;i--)<span class="comment">//改变父节点的内容</span></span><br><span class="line">    &#123;</span><br><span class="line">        father-&gt;p[i+<span class="number">1</span>]=father-&gt;p[i];</span><br><span class="line">    &#125;</span><br><span class="line">    father-&gt;p[k+<span class="number">1</span>]=newchild;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=father-&gt;num<span class="number">-1</span>;j&gt;=k;j--)</span><br><span class="line">        father-&gt;key[j+<span class="number">1</span>]=father-&gt;key[j];</span><br><span class="line">    father-&gt;key[k]=child-&gt;key[M<span class="number">-1</span>];<span class="comment">//将child的中间节点提升到父节点</span></span><br><span class="line">    father-&gt;num=father-&gt;num+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**********************************************************\</span></span><br><span class="line"><span class="comment">函数功能：x节点不是满的情况下，插入keyword</span></span><br><span class="line"><span class="comment">输入：B树的根，要插入的关键字</span></span><br><span class="line"><span class="comment">输出：无</span></span><br><span class="line"><span class="comment">\**********************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BtreeInsertNotFull</span><span class="params">(BtreeNode *x,<span class="keyword">int</span> keyword)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=x-&gt;num;</span><br><span class="line">    <span class="keyword">if</span>(x-&gt;isleaf)<span class="comment">//当x为叶子时，keyword插入到该节点中</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(i&gt;=<span class="number">1</span>&amp;&amp;keyword&lt;x-&gt;key[i<span class="number">-1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            x-&gt;key[i]=x-&gt;key[i<span class="number">-1</span>];</span><br><span class="line">            i=i<span class="number">-1</span>;</span><br><span class="line">        &#125;    </span><br><span class="line">        x-&gt;key[i]=keyword;</span><br><span class="line">        x-&gt;num=x-&gt;num+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span><span class="comment">//当x不是叶子时，找到keyword要插入的节点并插入</span></span><br><span class="line">    &#123;</span><br><span class="line">        i=x-&gt;num;</span><br><span class="line">        <span class="keyword">while</span>(i&gt;=<span class="number">1</span>&amp;&amp;keyword&lt;x-&gt;key[i<span class="number">-1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            i=i<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span>(x-&gt;p[i]-&gt;num==<span class="number">2</span>*M<span class="number">-1</span>)<span class="comment">//当节点为满节点时，需要分裂</span></span><br><span class="line">        &#123;</span><br><span class="line">            BtreeSplitChild(x,x-&gt;p[i],i);</span><br><span class="line">            <span class="keyword">if</span>(keyword&gt;x-&gt;key[i])</span><br><span class="line">                i=i+<span class="number">1</span>;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        BtreeInsertNotFull(x-&gt;p[i],keyword);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**********************************************************\</span></span><br><span class="line"><span class="comment">函数功能：插入关键值</span></span><br><span class="line"><span class="comment">输入：B树的根，关键字</span></span><br><span class="line"><span class="comment">输出：B树的根</span></span><br><span class="line"><span class="comment">\**********************************************************/</span></span><br><span class="line"><span class="function">BtreeNode * <span class="title">BtreeInsert</span><span class="params">(BtreeNode *TestNode,<span class="keyword">int</span> keyword)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(TestNode-&gt;num==<span class="number">2</span>*M<span class="number">-1</span>)<span class="comment">//当根节点为满时，唯一增加高度的情况</span></span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">        BtreeNode *newroot=(BtreeNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BtreeNode));</span><br><span class="line">        newroot-&gt;isleaf=<span class="literal">false</span>;<span class="comment">//产生新的根</span></span><br><span class="line">        newroot-&gt;num=<span class="number">0</span>;</span><br><span class="line">        newroot-&gt;p[<span class="number">0</span>]=TestNode;</span><br><span class="line">        BtreeSplitChild(newroot,TestNode,<span class="number">0</span>);</span><br><span class="line">        BtreeInsertNotFull(newroot,keyword);</span><br><span class="line">        <span class="keyword">return</span> newroot;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">        BtreeInsertNotFull(TestNode,keyword);</span><br><span class="line">        <span class="keyword">return</span> TestNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**********************************************************\</span></span><br><span class="line"><span class="comment">函数功能：查找关键字所在的节点</span></span><br><span class="line"><span class="comment">输入：    树的根，关键字</span></span><br><span class="line"><span class="comment">输出：    关键字所在的节点</span></span><br><span class="line"><span class="comment">\**********************************************************/</span></span><br><span class="line"><span class="function">BtreeNode *<span class="title">BtreeSearch</span><span class="params">(BtreeNode *TestNode,<span class="keyword">int</span> keyword)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;TestNode-&gt;num&amp;&amp;keyword&gt;TestNode-&gt;key[i])</span><br><span class="line">        i=i+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;=TestNode-&gt;num&amp;&amp;keyword==TestNode-&gt;key[i])</span><br><span class="line">        <span class="keyword">return</span> TestNode;</span><br><span class="line">    <span class="keyword">if</span>(TestNode-&gt;isleaf)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Not founded!\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> BtreeSearch(TestNode-&gt;p[i],keyword);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">///////////////////////////删除部分//////////////////////////////////////////</span></span><br><span class="line"><span class="comment">/**********************************************************\</span></span><br><span class="line"><span class="comment">函数功能：合并左右子节点</span></span><br><span class="line"><span class="comment">输入：根，左右子节点，左节点是父节点的第pos个节点</span></span><br><span class="line"><span class="comment">输出：无</span></span><br><span class="line"><span class="comment">\**********************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BtreeMergeChild</span><span class="params">(BtreeNode *root, <span class="keyword">int</span> pos, BtreeNode *y, BtreeNode *z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 将z中节点拷贝到y的后半部分</span></span><br><span class="line">    y-&gt;num = <span class="number">2</span> * M - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = M; i &lt; <span class="number">2</span> * M - <span class="number">1</span>; i++) </span><br><span class="line">    &#123;</span><br><span class="line">        y-&gt;key[i] = z-&gt;key[i-M];</span><br><span class="line">    &#125;</span><br><span class="line">    y-&gt;key[M<span class="number">-1</span>] = root-&gt;key[pos]; <span class="comment">// 将root-&gt;key[pos]下降为y的中间节点</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">false</span> == z-&gt;isleaf)<span class="comment">// 如果z是内节点即非叶子，需要拷贝指向子节点的指针p</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = M; i &lt; <span class="number">2</span> * M; i++) </span><br><span class="line">        &#123;</span><br><span class="line">            y-&gt;p[i] = z-&gt;p[i-M];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">      </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = pos + <span class="number">1</span>; j &lt; root-&gt;num; j++) <span class="comment">// root-&gt;key[pos]下降到y中，更新root中key和p</span></span><br><span class="line">    &#123;</span><br><span class="line">        root-&gt;key[j<span class="number">-1</span>] = root-&gt;key[j];</span><br><span class="line">        root-&gt;p[j] = root-&gt;p[j+<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    root-&gt;num -= <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">free</span>(z);</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">/**********************************************************\</span></span><br><span class="line"><span class="comment">函数功能：删除关键字keyword</span></span><br><span class="line"><span class="comment">输入：树的根，关键字</span></span><br><span class="line"><span class="comment">输出：树的根</span></span><br><span class="line"><span class="comment">\**********************************************************/</span></span><br><span class="line"><span class="function">BtreeNode *<span class="title">BtreeDelete</span><span class="params">(BtreeNode *root, <span class="keyword">int</span> keyword)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 唯一能降低树高的情形</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="number">1</span> == root-&gt;num) <span class="comment">// 当根只有一个关键字，两个子女</span></span><br><span class="line">    &#123;</span><br><span class="line">        BtreeNode *y = root-&gt;p[<span class="number">0</span>];</span><br><span class="line">        BtreeNode *z = root-&gt;p[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">NULL</span> != y &amp;&amp; <span class="literal">NULL</span> != z &amp;&amp;M - <span class="number">1</span> == y-&gt;num &amp;&amp; M - <span class="number">1</span> == z-&gt;num)<span class="comment">//两个子女的关键字个数都为M-1时，合并根与两个子女</span></span><br><span class="line">        &#123;</span><br><span class="line">            BtreeMergeChild(root, <span class="number">0</span>, y, z);</span><br><span class="line">            <span class="built_in">free</span>(root);<span class="comment">//注意释放空间</span></span><br><span class="line">            BtreeDeleteNotFull(y, keyword);</span><br><span class="line">            <span class="keyword">return</span> y;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            BtreeDeleteNotFull(root, keyword);</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        BtreeDeleteNotFull(root, keyword);    </span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**********************************************************\</span></span><br><span class="line"><span class="comment">函数功能： root至少有个M个关键字时删除关键字</span></span><br><span class="line"><span class="comment">输入：   树的根，关键字</span></span><br><span class="line"><span class="comment">输出：   无</span></span><br><span class="line"><span class="comment">\**********************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BtreeDeleteNotFull</span><span class="params">(BtreeNode *root, <span class="keyword">int</span> keyword)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">true</span> == root-&gt;isleaf) <span class="comment">// 如果在叶子节点，直接删除,情况1</span></span><br><span class="line">    &#123; </span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; root-&gt;num &amp;&amp; keyword &gt; root-&gt;key[i]) i++;</span><br><span class="line">        <span class="keyword">if</span>(keyword == root-&gt;key[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; <span class="number">2</span> * M - <span class="number">1</span>; j++) </span><br><span class="line">            &#123;</span><br><span class="line">                root-&gt;key[j<span class="number">-1</span>] = root-&gt;key[j];</span><br><span class="line">            &#125;</span><br><span class="line">            root-&gt;num -= <span class="number">1</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"keyword not found\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;  <span class="comment">// 在分支中</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        BtreeNode *y = <span class="literal">NULL</span>, *z = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; root-&gt;num &amp;&amp; keyword &gt; root-&gt;key[i]) i++; </span><br><span class="line">        <span class="keyword">if</span>(i &lt; root-&gt;num &amp;&amp; keyword == root-&gt;key[i]) </span><br><span class="line">        &#123; <span class="comment">// 如果在分支节点找到keyword</span></span><br><span class="line">            y = root-&gt;p[i];</span><br><span class="line">            z = root-&gt;p[i+<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(y-&gt;num &gt; M - <span class="number">1</span>) </span><br><span class="line">            &#123;  </span><br><span class="line">              <span class="comment">// 如果左分支关键字多于M-1，则找到左分支的最右节点pre，替换keyword</span></span><br><span class="line">                <span class="comment">// 并在左分支中递归删除prev,情况2a</span></span><br><span class="line">                <span class="keyword">int</span> pre = BtreeSearchPrevious(y);</span><br><span class="line">                root-&gt;key[i] = pre;</span><br><span class="line">                BtreeDeleteNotFull(y, pre);<span class="comment">//递归处理</span></span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(z-&gt;num &gt; M - <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 如果右分支关键字多于M-1，则找到右分支的最左节点next，替换keyword</span></span><br><span class="line">                <span class="comment">// 并在右分支中递归删除next,情况2b</span></span><br><span class="line">                <span class="keyword">int</span> next = BtreeSearchNext(z);</span><br><span class="line">                root-&gt;key[i] = next;</span><br><span class="line">                BtreeDeleteNotFull(z, next);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="comment">// 两个分支节点数都为M-1，则合并至y，并在y中递归删除keyword,情况2c</span></span><br><span class="line">            &#123;</span><br><span class="line">                </span><br><span class="line">                BtreeMergeChild(root, i, y, z);</span><br><span class="line">                BtreeDelete(y, keyword);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span><span class="comment">// 分支中没有，在分支的子节点中的情况</span></span><br><span class="line">        &#123;   </span><br><span class="line">            y = root-&gt;p[i];</span><br><span class="line">            <span class="keyword">if</span>(i &lt; root-&gt;num) </span><br><span class="line">            &#123;</span><br><span class="line">                z = root-&gt;p[i+<span class="number">1</span>];<span class="comment">//y的右兄弟</span></span><br><span class="line">            &#125;</span><br><span class="line">            BtreeNode *p = <span class="literal">NULL</span>;<span class="comment">//初始化</span></span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                p = root-&gt;p[i<span class="number">-1</span>];<span class="comment">//y的左兄弟</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(y-&gt;num == M - <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; p-&gt;num &gt; M - <span class="number">1</span>) </span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 左兄弟节点关键字个数大于M-1,情况3a</span></span><br><span class="line">                    BtreeChangeToRchild(root, i<span class="number">-1</span>, p, y); </span><br><span class="line">                &#125; </span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(i &lt; root-&gt;num &amp;&amp; z-&gt;num &gt; M - <span class="number">1</span>) </span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 右兄弟节点关键字个数大于M-1,情况3a</span></span><br><span class="line">                    BtreeChangeToLchild(root, i, y, z); </span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(i &gt; <span class="number">0</span>) </span><br><span class="line">                &#123;   </span><br><span class="line">                    BtreeMergeChild(root, i<span class="number">-1</span>, p, y);  <span class="comment">//左右兄弟节点都不大于M-1，情况3b</span></span><br><span class="line">                    y = p;</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="keyword">else</span> <span class="comment">//没有左兄弟的情况</span></span><br><span class="line">                &#123;</span><br><span class="line">                    BtreeMergeChild(root, i, y, z); </span><br><span class="line">                &#125;</span><br><span class="line">                BtreeDeleteNotFull(y, keyword);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            &#123;</span><br><span class="line">                BtreeDeleteNotFull(y, keyword);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**********************************************************\</span></span><br><span class="line"><span class="comment">函数功能：寻找以root为根的最大关键字</span></span><br><span class="line"><span class="comment">输入：    树的根</span></span><br><span class="line"><span class="comment">输出：    最大关键字</span></span><br><span class="line"><span class="comment">\**********************************************************/</span> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BtreeSearchPrevious</span><span class="params">(BtreeNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BtreeNode *y = root;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">false</span> == y-&gt;isleaf)</span><br><span class="line">    &#123;</span><br><span class="line">        y = y-&gt;p[y-&gt;num];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> y-&gt;key[y-&gt;num<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**********************************************************\</span></span><br><span class="line"><span class="comment">函数功能：寻找以root为根的最小关键字</span></span><br><span class="line"><span class="comment">输入：树的根</span></span><br><span class="line"><span class="comment">输出：最小关键字</span></span><br><span class="line"><span class="comment">\**********************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BtreeSearchNext</span><span class="params">(BtreeNode *root)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BtreeNode *z = root;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">false</span> == z-&gt;isleaf)</span><br><span class="line">    &#123;</span><br><span class="line">        z = z-&gt;p[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> z-&gt;key[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**********************************************************\</span></span><br><span class="line"><span class="comment">函数功能：z向y借节点，将root-&gt;key[pos]下降至z，将y的最大关键字上升至root的pos处</span></span><br><span class="line"><span class="comment">输入：根，左右子节点，左节点是父节点的第pos个节点</span></span><br><span class="line"><span class="comment">输出：无</span></span><br><span class="line"><span class="comment">\**********************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BtreeChangeToRchild</span><span class="params">(BtreeNode *root, <span class="keyword">int</span> pos, BtreeNode *y, BtreeNode *z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    z-&gt;num += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = z-&gt;num <span class="number">-1</span>; i &gt; <span class="number">0</span>; i--) </span><br><span class="line">    &#123;</span><br><span class="line">        z-&gt;key[i] = z-&gt;key[i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    z-&gt;key[<span class="number">0</span>]= root-&gt;key[pos];</span><br><span class="line">    root-&gt;key[pos] = y-&gt;key[y-&gt;num<span class="number">-1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">false</span> == z-&gt;isleaf)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = z-&gt;num; i &gt; <span class="number">0</span>; i--) </span><br><span class="line">        &#123;</span><br><span class="line">            z-&gt;p[i] = z-&gt;p[i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        z-&gt;p[<span class="number">0</span>] = y-&gt;p[y-&gt;num];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    y-&gt;num -= <span class="number">1</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"><span class="comment">/**********************************************************\</span></span><br><span class="line"><span class="comment">函数功能：y向借节点，将root-&gt;key[pos]下降至y，将z的最小关键字上升至root的pos处</span></span><br><span class="line"><span class="comment">输入：根，左右子节点，左节点是父节点的第pos个节点</span></span><br><span class="line"><span class="comment">输出：无</span></span><br><span class="line"><span class="comment">\**********************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BtreeChangeToLchild</span><span class="params">(BtreeNode *root, <span class="keyword">int</span> pos, BtreeNode *y, BtreeNode *z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    y-&gt;num += <span class="number">1</span>;</span><br><span class="line">    y-&gt;key[y-&gt;num<span class="number">-1</span>] = root-&gt;key[pos];</span><br><span class="line">    root-&gt;key[pos] = z-&gt;key[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; z-&gt;num; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        z-&gt;key[j<span class="number">-1</span>] = z-&gt;key[j];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">false</span> == z-&gt;isleaf) </span><br><span class="line">    &#123;</span><br><span class="line">        y-&gt;p[y-&gt;num] = z-&gt;p[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= z-&gt;num; j++) </span><br><span class="line">        &#123;</span><br><span class="line">            z-&gt;p[j<span class="number">-1</span>] = z-&gt;p[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    z-&gt;num -= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//按层次遍历B树</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">(BtreeNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    <span class="keyword">int</span> front,rear;</span><br><span class="line">    <span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> num1=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> flag=<span class="number">0</span>;</span><br><span class="line">    BtreeNode *<span class="built_in">queue</span>[<span class="number">100</span>];</span><br><span class="line">    BtreeNode *s;</span><br><span class="line">    <span class="keyword">if</span>(root!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        rear=<span class="number">1</span>;</span><br><span class="line">        front=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">queue</span>[rear]=root;</span><br><span class="line">        <span class="keyword">while</span>(front&lt;rear)</span><br><span class="line">        &#123;</span><br><span class="line">            front++;</span><br><span class="line">        </span><br><span class="line">            s=<span class="built_in">queue</span>[front];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(!s-&gt;isleaf)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=s-&gt;num;j++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(s-&gt;p[j]!=<span class="literal">NULL</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        rear++;</span><br><span class="line">                        <span class="built_in">queue</span>[rear]=s-&gt;p[j];</span><br><span class="line">                        </span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=rear;k++)<span class="comment">//使输出简单易看</span></span><br><span class="line">            &#123;    </span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="built_in">queue</span>[k]-&gt;num;i++)</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"%d "</span>,<span class="built_in">queue</span>[k]-&gt;key[i]);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"| "</span>);            </span><br><span class="line">                <span class="keyword">if</span>(k&gt;num)</span><br><span class="line">                &#123;</span><br><span class="line">                    </span><br><span class="line">                    <span class="keyword">while</span>(flag&lt;k)</span><br><span class="line">                    &#123;</span><br><span class="line">                    num=num+<span class="built_in">queue</span>[flag+<span class="number">1</span>]-&gt;num+<span class="number">1</span>;</span><br><span class="line">                    flag++;</span><br><span class="line">                    &#125;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">                flag=k;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/**************************初始化**************************/</span></span><br><span class="line">    BtreeNode *TestNode=BtreeCreate();</span><br><span class="line">    BtreeNode *Node1=BtreeCreate();</span><br><span class="line">    BtreeNode *Node2=BtreeCreate();</span><br><span class="line">    BtreeNode *Node3=BtreeCreate();</span><br><span class="line">    BtreeNode *Node4=BtreeCreate();</span><br><span class="line">    BtreeNode *Node5=BtreeCreate();</span><br><span class="line">    BtreeNode *root=BtreeCreate();</span><br><span class="line"></span><br><span class="line">    BtreeNode *SearchNode=BtreeCreate();</span><br><span class="line">    TestNode-&gt;isleaf=<span class="literal">false</span>;</span><br><span class="line">    TestNode-&gt;num=<span class="number">4</span>;</span><br><span class="line">    TestNode-&gt;key[<span class="number">0</span>]=<span class="number">7</span>;</span><br><span class="line">    TestNode-&gt;key[<span class="number">1</span>]=<span class="number">13</span>;</span><br><span class="line">    TestNode-&gt;key[<span class="number">2</span>]=<span class="number">16</span>;</span><br><span class="line">    TestNode-&gt;key[<span class="number">3</span>]=<span class="number">24</span>;</span><br><span class="line">    TestNode-&gt;p[<span class="number">0</span>]=Node1;</span><br><span class="line">    TestNode-&gt;p[<span class="number">1</span>]=Node2;</span><br><span class="line">    TestNode-&gt;p[<span class="number">2</span>]=Node3;</span><br><span class="line">    TestNode-&gt;p[<span class="number">3</span>]=Node4;</span><br><span class="line">    TestNode-&gt;p[<span class="number">4</span>]=Node5;</span><br><span class="line"></span><br><span class="line">    Node1-&gt;isleaf=<span class="literal">true</span>;</span><br><span class="line">    Node1-&gt;num=<span class="number">4</span>;</span><br><span class="line">    Node1-&gt;key[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    Node1-&gt;key[<span class="number">1</span>]=<span class="number">3</span>;</span><br><span class="line">    Node1-&gt;key[<span class="number">2</span>]=<span class="number">4</span>;</span><br><span class="line">    Node1-&gt;key[<span class="number">3</span>]=<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    Node2-&gt;isleaf=<span class="literal">true</span>;</span><br><span class="line">    Node2-&gt;num=<span class="number">2</span>;</span><br><span class="line">    Node2-&gt;key[<span class="number">0</span>]=<span class="number">10</span>;</span><br><span class="line">    Node2-&gt;key[<span class="number">1</span>]=<span class="number">11</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Node3-&gt;isleaf=<span class="literal">true</span>;</span><br><span class="line">    Node3-&gt;num=<span class="number">2</span>;</span><br><span class="line">    Node3-&gt;key[<span class="number">0</span>]=<span class="number">14</span>;</span><br><span class="line">    Node3-&gt;key[<span class="number">1</span>]=<span class="number">15</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Node4-&gt;isleaf=<span class="literal">true</span>;</span><br><span class="line">    Node4-&gt;num=<span class="number">5</span>;</span><br><span class="line">    Node4-&gt;key[<span class="number">0</span>]=<span class="number">18</span>;</span><br><span class="line">    Node4-&gt;key[<span class="number">1</span>]=<span class="number">19</span>;</span><br><span class="line">    Node4-&gt;key[<span class="number">2</span>]=<span class="number">20</span>;</span><br><span class="line">    Node4-&gt;key[<span class="number">3</span>]=<span class="number">21</span>;</span><br><span class="line">    Node4-&gt;key[<span class="number">4</span>]=<span class="number">22</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Node5-&gt;isleaf=<span class="literal">true</span>;</span><br><span class="line">    Node5-&gt;num=<span class="number">2</span>;</span><br><span class="line">    Node5-&gt;key[<span class="number">0</span>]=<span class="number">25</span>;</span><br><span class="line">    Node5-&gt;key[<span class="number">1</span>]=<span class="number">26</span>;</span><br><span class="line">    root=TestNode;</span><br><span class="line"><span class="comment">/*******************************初始化结束***********************/</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"原始B树：\n"</span>);</span><br><span class="line">    Print(root);</span><br><span class="line">    root=BtreeInsert(root,<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n插入关键字为2后的B树：\n"</span>);</span><br><span class="line">    Print(root);</span><br><span class="line">    root=BtreeInsert(root,<span class="number">17</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n插入关键字为17后的B树：\n"</span>);</span><br><span class="line">    Print(root);</span><br><span class="line">    root=BtreeInsert(root,<span class="number">12</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n插入关键字为12后的B树：\n"</span>);</span><br><span class="line">    Print(root);</span><br><span class="line">    root=BtreeInsert(root,<span class="number">6</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n插入关键字为6后的B树：\n"</span>);</span><br><span class="line">    Print(root);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n\n"</span>);</span><br><span class="line">    <span class="comment">//删除操作</span></span><br><span class="line">    root=BtreeDelete(root,<span class="number">6</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n删除关键字为6后的B树：\n"</span>);</span><br><span class="line">    Print(root);</span><br><span class="line"></span><br><span class="line">    root=BtreeDelete(root,<span class="number">13</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n删除关键字为13后的B树：\n"</span>);</span><br><span class="line">    Print(root);</span><br><span class="line"></span><br><span class="line">    root=BtreeDelete(root,<span class="number">7</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n删除关键字为7后的B树：\n"</span>);</span><br><span class="line">    Print(root);</span><br><span class="line"></span><br><span class="line">    root=BtreeDelete(root,<span class="number">4</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n删除关键字为4后的B树：\n"</span>);</span><br><span class="line">    Print(root);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    root=BtreeDelete(root,<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n删除关键字为2后的B树：\n"</span>);</span><br><span class="line">    Print(root);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </div>
</div>
<p> 用于分开不同节点的关键字，下图显示是按树的层次遍历的，可以看出结果与上面插入和删除的图解过程完全相同！）：</p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20131204/20131204_fig012.jpg" width="450" height="400" title="图12" alt="图12" ></p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>Algorithm Design</tag>
      </tags>
  </entry>
  <entry>
    <title>【算法导论】贪心算法之背包问题</title>
    <url>/2013/12/01/%5B20131201%5D/</url>
    <content><![CDATA[<p>​    在讨论贪心算法时，我们先了解贪心算法与动态规划之间的区别与联系，后面我们将发现可以用0、1背包问题和部分背包问题来比较贪心算法和动态规划的关系。</p>
<a id="more"></a>
<p>​    我们知道，对于一个最优解问题，贪心算法不一定能够产生一个最优解。因为，如果<strong>想要采用贪心算法得到最优解需要满足两个条件：贪心选择性质、最优子结构</strong>。</p>
<ul>
<li><strong>贪心选择性质</strong>：一个全局最优解可以通过局部最优解来得到。that is to say, 当考虑如何做选择时，我们只考虑对当前问题最佳的选择而不考虑子问题的结果。</li>
<li><strong>最优子结构</strong>：全局最优解包含子问题的最优解。</li>
<li><strong>贪心算法和动态规划的区别</strong>：在动态规划中，每一步都要做出选择，但是这些选择都依赖于子问题的解。因此，解动态规划问题一般是自底向上，由子问题到问题。在贪心算法中，我们总是做出当前的最好选择，而这些选择都不是依赖子问题，选择后再解决选择之后出现的子问题。因此，解贪心算法问题一般是自顶向下，一个一个地做出贪心选择。</li>
</ul>
<p>​    从上面的描述可知，动态规划中解决问题，需要先解决子问题，因此可能用到递归（当然可以将递归化为非递归），计算复杂度要比贪心算法高。从上面的理论解释可能比较抽象，我们可以用具体的实例来说明问题。<strong>我们用经典的0、1背包问题和部分背包问题来看看动态规划和贪心算法的区别。</strong>两个问题的描述如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20131201/20131201_fig001.jpg" width="600" height="350" title="图1" alt="图1" ></p>
<p>用贪心选择算法来解决部分背包问题正如上面所说的思想，十分简单，在这里就不给予程序实现。我们主要讨论0、1背包问题的最优解。</p>
<p>​    <strong>下面我们例子来说明为什么贪心选择算法不能解0、1背包问题</strong>：假设背包容量为$116$，序号为$1-3$的物品的重量和价格分别为：$w[3]={100, 14, 10}, p[3]={20, 18, 15}$。其平均价值为${0.2, 18/14, 1.5}$，按照贪心算法的话，选择物品顺序为：$3, 2, 1$，最终的选择为$3, 2$，其价值为$33$，但是实际的最优方案为：选择$1, 2$，其价值为$38$。</p>
<p>从这个例子中可以看出，在0、1背包问题中，我们在选择是否要加入一个物品时，必须将把该物品加进去的子问题和不加进去的子问题进行比较（<strong>选择依赖子问题</strong>），这种方式的问题导致了许多重叠子问题，这是动态规划的一个特点。</p>
<p>​    下面我们用动态规划来解0、1背包问题：假设$f[i][j]$表示剩余物品为$i, i+1, \cdots , n$，容量为$j$时的最大价值，例如以上面的例子来说明，$f[0][10]$，表示物品为$1, 2, 3$，容量为$116$时的最大价值，$f[1][116]$，表示物品为$2, 3$，容量为$116$时的最大价值。我们目的是求$f[0][116]$，利用动态规划的思想，假设我们选择$1$号物品，则最大价值为$p[0]+f[1][116-100]$，如果不选$1$号，则最大价值为$f[1][116]$，因此选不选$1$号则需要比较两者的最大值。比较两者的最大值需要求$f[1][116]$和$f[1][116-100]$，这是重叠子问题。最终的表达式为：$f[i][j]=f[i+1][j]&gt;f[i+1][j-w[i]]+p[i]$。这个表达式可以递归求解，当然也可以迭代求解。</p>
<p><strong>具体程序实现如下：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Bag_0or1</span><span class="params">(<span class="keyword">int</span> *w,<span class="keyword">int</span> *p,<span class="keyword">int</span> *flag,<span class="keyword">int</span> n,<span class="keyword">int</span> i,<span class="keyword">int</span> y)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Bag_0or1_iteration</span><span class="params">(<span class="keyword">int</span> *w,<span class="keyword">int</span> *p,<span class="keyword">int</span> c,<span class="keyword">int</span> n,<span class="keyword">int</span> f[][<span class="number">116</span>])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> *w,<span class="keyword">int</span> *flag,<span class="keyword">int</span> n,<span class="keyword">int</span> c,<span class="keyword">int</span> f[][<span class="number">116</span>])</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> w[]=&#123;<span class="number">100</span>,<span class="number">14</span>,<span class="number">10</span>&#125;;<span class="comment">//被注释的部分是另外一个实例</span></span><br><span class="line">	<span class="keyword">int</span> p[]=&#123;<span class="number">20</span>,<span class="number">18</span>,<span class="number">15</span>&#125;;</span><br><span class="line">	<span class="keyword">int</span> c=<span class="number">116</span>;</span><br><span class="line">	<span class="keyword">int</span> n=<span class="number">2</span>;</span><br><span class="line">	<span class="comment">//int w[]=&#123;2,2,6,5,4&#125;;</span></span><br><span class="line">	<span class="comment">//int p[]=&#123;6,3,5,4,6&#125;;</span></span><br><span class="line">	<span class="comment">//int c=10;</span></span><br><span class="line">	<span class="comment">//int n=4;//n为物品个数减一，是因为数组从0开始。</span></span><br><span class="line">	<span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> f[<span class="number">5</span>][<span class="number">116</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="keyword">int</span> flag[<span class="number">5</span>]=&#123;<span class="number">0</span>&#125;;<span class="comment">//flag为1表示选择该物品</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"最大价值为：%d\n"</span>,Bag_0or1(w,p,flag,n,i,c));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"选择的物品为（1表示选择，0表示未选择）："</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d%d%d\n"</span>,flag[<span class="number">0</span>],flag[<span class="number">1</span>],flag[<span class="number">2</span>]);</span><br><span class="line">	 <span class="comment">//Bag_0or1_iteration(w,p,c-1,n,f);</span></span><br><span class="line">	 <span class="comment">//printf("最大价值为：%d\n",f[0][c-1]);</span></span><br><span class="line">	 <span class="comment">//printf("选择的物品为（1表示选择，0表示未选择）：");</span></span><br><span class="line">	 <span class="comment">//print(w,flag,n,c-1,f);</span></span><br><span class="line">	 <span class="comment">//printf("\n");</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/***************************************************\</span></span><br><span class="line"><span class="comment">函数功能：递归法解0/1背包问题</span></span><br><span class="line"><span class="comment">输入：    物品重量w、物品价格p,物品个数n、i,y表示剩余容量为y,剩余物品为i,i+1,……n</span></span><br><span class="line"><span class="comment">输出：    背包所能容下的最大价值</span></span><br><span class="line"><span class="comment">\***************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Bag_0or1</span><span class="params">(<span class="keyword">int</span> *w,<span class="keyword">int</span> *p,<span class="keyword">int</span> *flag,<span class="keyword">int</span> n,<span class="keyword">int</span> i,<span class="keyword">int</span> y)</span><span class="comment">//递归法</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(i==n)<span class="comment">//物品仅剩余最后一件</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(y&lt;w[n])</span><br><span class="line">			&#123;</span><br><span class="line">				flag[n]=<span class="number">0</span>;</span><br><span class="line">				<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				flag[n]=<span class="number">1</span>;</span><br><span class="line">				<span class="keyword">return</span> p[n];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(y&lt;w[i])<span class="comment">//当物品i加入后大于容量的情况</span></span><br><span class="line">		&#123;</span><br><span class="line">			flag[i]=<span class="number">0</span>;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"ok"</span>);</span><br><span class="line">			<span class="keyword">return</span> Bag_0or1(w,p,flag,n,i+<span class="number">1</span>,y);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(Bag_0or1(w,p,flag,n,i+<span class="number">1</span>,y)&gt;(Bag_0or1(w,p,flag,n,i+<span class="number">1</span>,y-w[i])+p[i]))</span><br><span class="line">		<span class="comment">//当物品i加入后还有剩余容量的情况</span></span><br><span class="line">		&#123;</span><br><span class="line">			flag[i]=<span class="number">0</span>;</span><br><span class="line">			<span class="keyword">return</span> Bag_0or1(w,p,flag,n,i+<span class="number">1</span>,y);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			flag[i]=<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">return</span> Bag_0or1(w,p,flag,n,i+<span class="number">1</span>,y-w[i])+p[i];</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/***************************************************\</span></span><br><span class="line"><span class="comment">函数功能：迭代法解0/1背包问题</span></span><br><span class="line"><span class="comment">输入：    物品重量w、物品价格p,物品个数n、i,y表示剩余容量为y,剩余物品为i,i+1,……n，</span></span><br><span class="line"><span class="comment">          f[i][j]表示剩余物品为i,i+1,……n,容量为j时的最大价值</span></span><br><span class="line"><span class="comment">输出：    无</span></span><br><span class="line"><span class="comment">\***************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Bag_0or1_iteration</span><span class="params">(<span class="keyword">int</span> *w,<span class="keyword">int</span> *p,<span class="keyword">int</span> c,<span class="keyword">int</span> n,<span class="keyword">int</span> f[][<span class="number">116</span>])</span><span class="comment">//迭代法</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> y=<span class="number">0</span>;y&lt;=c;y++)<span class="comment">//初始化</span></span><br><span class="line">		f[n][y]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> y=w[n];y&lt;=c;y++)<span class="comment">//这里有很多y值根本用不到，但是由于不能知道y的取值，所以要考虑所有y的取值</span></span><br><span class="line">		f[n][y]=p[n];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;<span class="number">0</span>;i--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> y=<span class="number">0</span>;y&lt;=c;y++)</span><br><span class="line">			f[i][y]=f[i+<span class="number">1</span>][y];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> y=w[i];y&lt;=c;y++)<span class="comment">//选择当前物品i是否装入</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(f[i+<span class="number">1</span>][y]&gt;(f[i+<span class="number">1</span>][y-w[i]]+p[i]))</span><br><span class="line">				f[i][y]=f[i+<span class="number">1</span>][y];<span class="comment">//不装入</span></span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				f[i][y]=f[i+<span class="number">1</span>][y-w[i]]+p[i];<span class="comment">//装入</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	f[<span class="number">0</span>][c]=f[<span class="number">1</span>][c];</span><br><span class="line">	<span class="keyword">if</span>(c&gt;=w[<span class="number">0</span>])<span class="comment">//考虑是否将第一个物品装入</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(f[<span class="number">0</span>][c]&gt;(f[<span class="number">1</span>][c-w[<span class="number">0</span>]]+p[<span class="number">0</span>]))</span><br><span class="line">			f[<span class="number">0</span>][c]=f[<span class="number">0</span>][c];</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			f[<span class="number">0</span>][c]=f[<span class="number">1</span>][c-w[<span class="number">0</span>]]+p[<span class="number">0</span>];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/***************************************************\</span></span><br><span class="line"><span class="comment">函数功能：打印被选择的物品</span></span><br><span class="line"><span class="comment">输入：    物品重量w、是否被选择的标志flag,物品个数n、c为背包容量</span></span><br><span class="line"><span class="comment">          f[i][j]表示剩余物品为i,i+1,……n,容量为j时的最大价值</span></span><br><span class="line"><span class="comment">输出：    无</span></span><br><span class="line"><span class="comment">\***************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> *w,<span class="keyword">int</span> *flag,<span class="keyword">int</span> n,<span class="keyword">int</span> c,<span class="keyword">int</span> f[][<span class="number">116</span>])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(f[i][c]==f[i+<span class="number">1</span>][c])<span class="comment">//不装入序号为i的物品的情况</span></span><br><span class="line">			flag[i]=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			flag[i]=<span class="number">1</span>;</span><br><span class="line">			c=c-w[i];</span><br><span class="line">		&#125;</span><br><span class="line">		flag[n]=(f[n][c])?<span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=n;j++)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d"</span>,flag[j]);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>Algorithm Design</tag>
      </tags>
  </entry>
  <entry>
    <title>【算法导论】贪心算法之活动安排问题</title>
    <url>/2013/11/27/%5B20131127%5D/</url>
    <content><![CDATA[<p>​     对于许多最优化问题来说，采用动态规划来求解最优解有点大材小用了，只需要采用更简单有效的贪心算法就行了。<strong>贪心算法就是所做的每一步选择都是当前最佳的，通过局部最佳来寻求全局最佳解</strong>。就像砝码称重一样，总是优先选择大的砝码。</p>
<a id="more"></a>
<p>​     <strong>贪心算法对大多数优化问题来说能产生最优解，但也不一定总是这样的</strong>。能用贪心算法解的典型问题包括活动选择问题、最小生成树、最短路径问题等等。下面我们来讨论活动活动选择问题：</p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20131127/20131127_fig001.jpg" width="600" height="350" title="图1" alt="图1" ></p>
<p>​     对于上面问题，<strong>贪心算法的思想就是：贪心选择使得剩下的、未调度的时间最大化</strong>。在本例中，先选择$i=1$,然后从$x_i\ge x_1$的集合中选择$f_i$最小的，此时$i=4$,然后从$x\ge x_4$的集合中选择$f_i$最小的，此时$i=8$,然后从$x\ge x_8$的集合中选择$f_i$最小的，此时$i=11$.因此就可以得到问题的一个最优解。</p>
<p><strong>具体程序实现如下：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> N 11</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GreadyActivitySelector</span><span class="params">(<span class="keyword">int</span> *s,<span class="keyword">int</span> *f,<span class="keyword">int</span> *A,<span class="keyword">int</span> n)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RecursiveActivitySelector</span><span class="params">(<span class="keyword">int</span> *s,<span class="keyword">int</span> *f,<span class="keyword">int</span> *A,<span class="keyword">int</span> i,<span class="keyword">int</span> n,<span class="keyword">int</span> k)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> s[N]=&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">8</span>,<span class="number">2</span>,<span class="number">12</span>&#125;;<span class="comment">//开始时间</span></span><br><span class="line">	<span class="keyword">int</span> f[N]=&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>,<span class="number">13</span>,<span class="number">14</span>&#125;;<span class="comment">//结束时间</span></span><br><span class="line">	<span class="keyword">int</span> A[N]=&#123;<span class="number">0</span>&#125;;<span class="comment">//初始化</span></span><br><span class="line">	<span class="keyword">int</span> n=N;</span><br><span class="line">	GreadyActivitySelector(s,f,A,n);<span class="comment">//迭代版本</span></span><br><span class="line"><span class="comment">//	RecursiveActivitySelector(s,f,A,0,n,0);//递归版本</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d "</span>,A[i]);<span class="comment">//被选择的活动 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/****************************************************\</span></span><br><span class="line"><span class="comment">函数功能：选择最佳的活动安排</span></span><br><span class="line"><span class="comment">输入：    各个活动的起始时间和结束时间、待存储被选择活动的数组A、活动个数</span></span><br><span class="line"><span class="comment">输出：    无</span></span><br><span class="line"><span class="comment">\****************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GreadyActivitySelector</span><span class="params">(<span class="keyword">int</span> *s,<span class="keyword">int</span> *f,<span class="keyword">int</span> *A,<span class="keyword">int</span> n)</span><span class="comment">//迭代版本</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	A[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span>	i=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> j=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> m=<span class="number">1</span>;m&lt;n;m++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(s[m]&gt;=f[i])<span class="comment">//开始时间大于上个活动的结束时间</span></span><br><span class="line">		&#123;</span><br><span class="line">			i=m;</span><br><span class="line">			A[j]=m+<span class="number">1</span>;<span class="comment">//注意下标与第几位差一</span></span><br><span class="line">			j++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/****************************************************\</span></span><br><span class="line"><span class="comment">函数功能：选择最佳的活动安排</span></span><br><span class="line"><span class="comment">输入：    各个活动的起始时间和结束时间、待存储被选择活动的数组A、i,n表示子问题的活动，活动个数</span></span><br><span class="line"><span class="comment">输出：    无</span></span><br><span class="line"><span class="comment">\****************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RecursiveActivitySelector</span><span class="params">(<span class="keyword">int</span> *s,<span class="keyword">int</span> *f,<span class="keyword">int</span> *A,<span class="keyword">int</span> i,<span class="keyword">int</span> n,<span class="keyword">int</span> k)</span><span class="comment">//递归版本</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> j=k;</span><br><span class="line">	<span class="keyword">int</span> m=i;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>((m&lt;n)&amp;&amp;(s[m]&lt;f[i])&amp;&amp;(m!=<span class="number">0</span>))<span class="comment">//找到结束时间大于上个活动开始时间的活动</span></span><br><span class="line">		m=m+<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(m&lt;n)</span><br><span class="line">	&#123;</span><br><span class="line">		A[j]=m+<span class="number">1</span>;<span class="comment">//将被选择的活动存储起来</span></span><br><span class="line">		</span><br><span class="line">		j++;</span><br><span class="line">		RecursiveActivitySelector(s,f,A,m+<span class="number">1</span>,n,j);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>Algorithm Design</tag>
      </tags>
  </entry>
  <entry>
    <title>【算法导论】动态规划之最优二叉查找树</title>
    <url>/2013/11/26/%5B20131126%5D/</url>
    <content><![CDATA[<p>​    如果我们想写一个单词查询的软件的话，我们的目的就是让查询的总时间最短，我们首先想到用之前的二叉查找树。我们可以用红黑树或者其它的平衡二叉树来保证每个单词的搜索时间。但是每个单词出现的频率一般不同，因此我们希望把频率较大的单词放在离根比较近的地方，频率较小的放在离叶子较近的地方。而且，我们所要查询的单词词库中没有，这也值得考虑。</p>
<a id="more"></a>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20131126/20131126_fig001.jpg" width="700" height="120" title="图1" alt="图1" ></p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20131126/20131126_fig002.jpg" width="600" height="380" title="图2" alt="图2" ></p>
<p>​    由上文可知，$k_i$表示单词，$d_i$表示不能查到的情况。由上面的例子可知，一棵最优二叉树不一定是高度最小的树。我们也不一定总把频率最大的放在根部。</p>
<p>​    和矩阵链乘法一样，穷举所有的可能行肯定不是一个好的算法。由于具有动态规划的特征，毫无疑问，我们将使用动态规划法。</p>
<p>​    对于原序列，我们假设第k个元素(采用遍历的方法)作为根时可以得到最优解，由于是二叉查询树，则前$k-1$个元素在左子树，剩余元素在右子树。接下来，我们要分别在左、右子树中找到最优二叉树，于是我们可以用相同的方法：假设左、右子树中第$m, n$个为根时，可以得到最优解，依此类推，就可以求得整体最优解。上面的解法中，可能存在左或者右子树为空的情况：</p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20131126/20131126_fig003.jpg" width="700" height="220" title="图3" alt="图3" ></p>
<p>通过推导，可以递推公式：</p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20131126/20131126_fig004.jpg" width="600" height="60" title="图4" alt="图4" ></p>
<p>其中$e$表示搜索的代价，$q[i]$为$d[i]$的出现频率，$w$为子树总的概率。</p>
<p><strong>具体程序实现如下：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 7</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Optimal_Bst</span><span class="params">(<span class="keyword">float</span> *p,<span class="keyword">float</span> *q,<span class="keyword">int</span> n,<span class="keyword">float</span> e[][N],<span class="keyword">int</span> root[][N])</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">float</span> p[]=&#123;<span class="number">0</span>,<span class="number">0.15</span>,<span class="number">0.1</span>,<span class="number">0.05</span>,<span class="number">0.1</span>,<span class="number">0.2</span>&#125;;<span class="comment">//关键字出现的概率</span></span><br><span class="line">	<span class="keyword">float</span> q[]=&#123;<span class="number">0.05</span>,<span class="number">0.1</span>,<span class="number">0.05</span>,<span class="number">0.05</span>,<span class="number">0.05</span>,<span class="number">0.1</span>&#125;;<span class="comment">//搜索不到关键字的几种情况的概率</span></span><br><span class="line">	<span class="keyword">int</span> n=<span class="number">6</span>;<span class="comment">//关键字个数</span></span><br><span class="line">	<span class="keyword">float</span> e[N][N]=&#123;<span class="number">0</span>&#125;;<span class="comment">//存储搜索的代价</span></span><br><span class="line">	<span class="keyword">int</span> root[N][N]=&#123;<span class="number">0</span>&#125;;<span class="comment">//子树的根，便于重构最优二叉树</span></span><br><span class="line">	Optimal_Bst(p,q,n,e,root);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;<span class="number">6</span>;i++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">5</span>;j&gt;=i;j--)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"从第%d个元素到第%d个元素的最优二叉查找树的顶点为：%d\n"</span>,i,j,root[i][j]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Optimal_Bst</span><span class="params">(<span class="keyword">float</span> *p,<span class="keyword">float</span> *q,<span class="keyword">int</span> n,<span class="keyword">float</span> e[][N],<span class="keyword">int</span> root[][N])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">float</span> w[N][N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="keyword">float</span> t=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="comment">//左右子树为空的情况</span></span><br><span class="line">	&#123;</span><br><span class="line">		e[i][i<span class="number">-1</span>]=q[i<span class="number">-1</span>];</span><br><span class="line">		w[i][i<span class="number">-1</span>]=q[i<span class="number">-1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> l=<span class="number">1</span>;l&lt;=n;l++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n-l+<span class="number">1</span>;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">			j=i+l<span class="number">-1</span>;</span><br><span class="line">			e[i][j]=<span class="number">10000</span>;<span class="comment">//初始化为很大的值，可以随意设置</span></span><br><span class="line">			w[i][j]=w[i][j<span class="number">-1</span>]+p[j]+q[j];<span class="comment">//</span></span><br><span class="line">			</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> r=i;r&lt;=j;r++)<span class="comment">//r代表以下标r为根，r在所有的子树节点中遍历</span></span><br><span class="line">			&#123;</span><br><span class="line">				t=e[i][r<span class="number">-1</span>]+e[r+<span class="number">1</span>][j]+w[i][j];</span><br><span class="line">				<span class="keyword">if</span>(t&lt;e[i][j])</span><br><span class="line">				&#123;</span><br><span class="line">					e[i][j]=t;</span><br><span class="line">					root[i][j]=r;<span class="comment">//得到最优二叉树时的根</span></span><br><span class="line">					</span><br><span class="line">				&#125;</span><br><span class="line">					</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>上述程序运行后，数组e,w,root的结果如下：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20131126/20131126_fig005.jpg" width="600" height="320" title="图5" alt="图5" ></p>
<p><strong>上述程序的运行时间为$O(n^3)$</strong>，这和前面的矩阵链乘法是一样的。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>Algorithm Design</tag>
      </tags>
  </entry>
  <entry>
    <title>【算法导论】动态规划之最长公共子序列</title>
    <url>/2013/11/25/%5B20131125%5D/</url>
    <content><![CDATA[<p>​    <strong>子序列</strong>：一个给定序列的子序列就是该给定序列去掉零个或者多个元素后的序列。例如：$Z={B, C, D, B}$是$X={A, B, C, B, D, A, B}$的一个子序列。注意顺序不能改变。</p>
<p>​    <strong>公共子序列</strong>：既是序列$X$的子序列，又是序列$Y$的子序列。例如：$X={A, B, C, B, D, A, B}$，$Y={B, D, C, A, B, A}$,则序列 ${B, C, A}$ 是$X$和$Y$的一个公共子序列，长度为$4$；序列${B, C, B, A}$ 是$X$和$Y$的一个最长公共子序列（LCS​），长度为$4$.</p>
<a id="more"></a>
<p>​    当然，我们可以查用穷举法来解决问题，但是，对于一个长度为$n$的序列，其子序列为$2^n$，因此时间复杂度为指数形式，当$n$很大时，显然不合实际。由观察和推导可知，最长公共子序列具有最优子结构性质和重叠子问题性质。因此我们可以通过动态规划算法来找到最长公共子序列,其时间复杂度为$O(mn+m+n)$。（$m,n$ 分别为两个序列的元素个数）</p>
<p>​    在下面的程序实现中，我假设两个序列为上面提到的$X={A,B,C,B,D,A,B}, Y={B, D, C, A, B, A}$，数组$b$对应于在计算$c[i][j]$时所选择的最优子问题的解，数组$c[i][j]$为$X_i$和$Y_j$的一个LCS​的长度，$X_i$为序列的前$i$个元素组成的序列，$Y_j$为序列的前$j$个元素组成的序列.</p>
<p><strong>具体程序如下：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Lcs_Length</span><span class="params">(<span class="keyword">char</span> *X,<span class="keyword">char</span> *Y,<span class="keyword">int</span> n1,<span class="keyword">int</span> n2,<span class="keyword">int</span> b[][<span class="number">7</span>],<span class="keyword">int</span> c[][<span class="number">7</span>])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print_Lcs</span><span class="params">(<span class="keyword">char</span> *X,<span class="keyword">int</span> b[][<span class="number">7</span>],<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> X[]=&#123;<span class="string">'A'</span>,<span class="string">'B'</span>,<span class="string">'C'</span>,<span class="string">'B'</span>,<span class="string">'D'</span>,<span class="string">'A'</span>,<span class="string">'B'</span>&#125;;</span><br><span class="line">	<span class="keyword">char</span> Y[]=&#123;<span class="string">'B'</span>,<span class="string">'D'</span>,<span class="string">'C'</span>,<span class="string">'A'</span>,<span class="string">'B'</span>,<span class="string">'A'</span>&#125;;</span><br><span class="line">	<span class="keyword">int</span> n1=<span class="keyword">sizeof</span>(X)/<span class="keyword">sizeof</span>(<span class="keyword">char</span>);</span><br><span class="line">	<span class="keyword">int</span> n2=<span class="keyword">sizeof</span>(Y)/<span class="keyword">sizeof</span>(<span class="keyword">char</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> b[<span class="number">8</span>][<span class="number">7</span>]=&#123;<span class="number">0</span>&#125;;<span class="comment">//b[i][j]对应于在计算c[i][j]时所选择的最优子问题的解</span></span><br><span class="line">	<span class="keyword">int</span> c[<span class="number">8</span>][<span class="number">7</span>]=&#123;<span class="number">0</span>&#125;;<span class="comment">//c[i][j]为Xi和Yi的一个LCS的长度</span></span><br><span class="line">	</span><br><span class="line">	Lcs_Length(X,Y,n1,n2,b,c);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"最长公共子序列为："</span>);</span><br><span class="line">    Print_Lcs(X,b,n1,n2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*******************************************************************\</span></span><br><span class="line"><span class="comment">函数功能：计算最长公共子序列的长度，并将结果存储在数组c中</span></span><br><span class="line"><span class="comment">输入：    两个序列X、Y 待存储的数组b,c</span></span><br><span class="line"><span class="comment">输出：    无</span></span><br><span class="line"><span class="comment">\*******************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Lcs_Length</span><span class="params">(<span class="keyword">char</span> *X,<span class="keyword">char</span> *Y,<span class="keyword">int</span> n1,<span class="keyword">int</span> n2,<span class="keyword">int</span> b[][<span class="number">7</span>],<span class="keyword">int</span> c[][<span class="number">7</span>])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n1;i++)</span><br><span class="line">		c[i][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n2;i++)</span><br><span class="line">		c[<span class="number">0</span>][i]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n1;i++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n2;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(X[i<span class="number">-1</span>]==Y[j<span class="number">-1</span>])</span><br><span class="line">			&#123;</span><br><span class="line">				c[i][j]=c[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">				b[i][j]=<span class="number">1</span>;<span class="comment">//b用于做标记，便于打印</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(c[i<span class="number">-1</span>][j]&gt;=c[i][j<span class="number">-1</span>])</span><br><span class="line">			&#123;</span><br><span class="line">				c[i][j]=c[i<span class="number">-1</span>][j];</span><br><span class="line">				b[i][j]=<span class="number">2</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				c[i][j]=c[i][j<span class="number">-1</span>];</span><br><span class="line">				b[i][j]=<span class="number">3</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*******************************************************************\</span></span><br><span class="line"><span class="comment">函数功能：打印最长公共子序列</span></span><br><span class="line"><span class="comment">输入：    原始序列X、已存储的数组b，i j表示是求X的前i个元素和Y的前j个元素的LCS</span></span><br><span class="line"><span class="comment">输出：    无</span></span><br><span class="line"><span class="comment">\*******************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print_Lcs</span><span class="params">(<span class="keyword">char</span> *X,<span class="keyword">int</span> b[][<span class="number">7</span>],<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(i==<span class="number">0</span>||j==<span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span>(b[i][j]==<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		Print_Lcs(X,b,i<span class="number">-1</span>,j<span class="number">-1</span>);<span class="comment">//递归打印</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%c "</span>,X[i<span class="number">-1</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(b[i][j]==<span class="number">2</span>)</span><br><span class="line">        Print_Lcs(X,b,i<span class="number">-1</span>,j);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		Print_Lcs(X,b,i,j<span class="number">-1</span>);</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面程序得到的结果数组$c$和$b$如下图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20131125/20131125_fig001.jpg" width="700" height="350" title="图1" alt="图1" ></p>
<p>上表中的数字代表长度，例如$c[7][6]=4$代表序列$X$的前$7$个元素组成的序列和序列$Y$前$6$个元素组成的序列的最长公共子序列的长度为$4$.</p>
<p>在程序中为了方便起见，$b$数组用数字$1, 2, 3$分别代表$↖，↑，←$。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>Algorithm Design</tag>
      </tags>
  </entry>
  <entry>
    <title>【算法导论】动态规划之矩阵链乘法</title>
    <url>/2013/11/24/%5B20131124%5D/</url>
    <content><![CDATA[<p>​    所谓矩阵链乘法是指当一些矩阵相乘时，如何加括号来改变乘法顺序从而来降低乘法次数。例如有三个矩阵连乘：$A_1\cdot A_2\cdot A_3$，其维数分别为：$10\times 100$，$100\times 5$，$5\times 50$. 如果按照$((A_1\cdot A_2)\cdot A_3)$来计算的话，求$(A_1\cdot A_2)$要$10\cdot 100\cdot 5=5000$次乘法，再乘以$A_3$需要$10\cdot 5\cdot 50=2500$次乘法，因此总共需要$7500$次乘法。如果按照$(A_1\cdot (A_2\cdot A_3))$来计算的话，求$(A_2\cdot A_3)$要$100\cdot 5\cdot 50=25000$次乘法，再乘以$A_1$需要$10\cdot 100\cdot 50=50000$次乘法，因此总共需要$75000$次乘法。可见，按不同的顺序计算，代价相差很大。</p>
<a id="more"></a>
<p>​    <strong>矩阵链乘法问题可以表述如下</strong>：给定$n$个矩阵构成的一个链$(A_1\cdot A_2\cdot A_3\cdot\ldots\cdot A_n)$，其中$i=1,2,……n$，矩阵$A_i$的维数为$p(i-1)\cdot p(i)$，对于乘积$A_1\cdot A_2\cdot A_3\cdot\ldots\cdot A_n$以一种最小化标量乘法次数的方式进行加括号。</p>
<p>​    解决这个问题，我们可以用穷举法，但是$n$很大时，这不是个好方法，其时间复杂度为指数形式。拿上面的例子来说，加括号后把矩阵链分成了两部分，计算代价为两者代价的和。因此假设这种方法的代价最少，则两个部分的代价也是最小的，如果不是最小的，那么这种方法就不是最优的，因此矩阵链乘法具有最优子结构。因此我们可以利用子问题的最优解来构造原问题的一个最优解。所以，可以把问题分割为两个子问题$(A<em>1\cdot A_2\cdot A_3\cdot\ldots\cdot A_k$和$A</em>{k+1}\cdot A<em>{k+2}\cdot A</em>{k+3}\cdot\ldots\cdot A_n)$,需找子问题的最优解，然后合并这些问题的最优解。从下面的程序可以看出，其时间复杂度为$O(n^3)$.</p>
<p><strong>上面算法的实现程序如下：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_parens</span><span class="params">(<span class="keyword">int</span> s[<span class="number">6</span>][<span class="number">6</span>],<span class="keyword">int</span> i ,<span class="keyword">int</span> j)</span></span>;<span class="comment">//打印加括号的位置</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">matrix_order</span><span class="params">(<span class="keyword">int</span> *p,<span class="keyword">int</span> n,<span class="keyword">int</span> m[<span class="number">6</span>][<span class="number">6</span>],<span class="keyword">int</span> s[<span class="number">6</span>][<span class="number">6</span>])</span></span>;<span class="comment">//计算最佳的加括号的方式</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> p[<span class="number">7</span>]=&#123;<span class="number">30</span>,<span class="number">35</span>,<span class="number">15</span>,<span class="number">5</span>,<span class="number">10</span>,<span class="number">20</span>,<span class="number">25</span>&#125;;<span class="comment">//记录6个矩阵的行和列，注意相邻矩阵的行和列是相同的</span></span><br><span class="line">	<span class="keyword">int</span> m[<span class="number">6</span>][<span class="number">6</span>]=&#123;<span class="number">0</span>&#125;;<span class="comment">//存储第i个矩阵到第j个矩阵的计算代价（以乘法次数来表示）</span></span><br><span class="line">	<span class="keyword">int</span> s[<span class="number">6</span>][<span class="number">6</span>]=&#123;<span class="number">0</span>&#125;;<span class="comment">//存储第i个矩阵到第j个矩阵的最小代价时的分为两部分的位置</span></span><br><span class="line">	<span class="keyword">int</span> n=<span class="number">6</span>;<span class="comment">//矩阵个数</span></span><br><span class="line">	matrix_order(p,n,m,s);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"最终加括号的形式为： "</span>);</span><br><span class="line">	print_parens(s,<span class="number">0</span> ,<span class="number">5</span>);<span class="comment">//计算从第1个矩阵到第6个矩阵的最优加括号的方法</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/****************************************************\</span></span><br><span class="line"><span class="comment">函数功能：计算最佳的加括号的方式，得到m和s矩阵</span></span><br><span class="line"><span class="comment">输入：    矩阵的行和列p,初始化的m和s矩阵</span></span><br><span class="line"><span class="comment">输出：    无</span></span><br><span class="line"><span class="comment">\****************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">matrix_order</span><span class="params">(<span class="keyword">int</span> *p,<span class="keyword">int</span> n,<span class="keyword">int</span> m[<span class="number">6</span>][<span class="number">6</span>],<span class="keyword">int</span> s[<span class="number">6</span>][<span class="number">6</span>])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> q=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">		m[i][i]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> l=<span class="number">2</span>;l&lt;=n;l++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n-l+<span class="number">1</span>;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			j=i+l<span class="number">-1</span>;</span><br><span class="line">			m[i][j]=<span class="number">1000000</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> k=i;k&lt;j;k++)<span class="comment">//在i,j中遍历每一个分割的位置</span></span><br><span class="line">			&#123;</span><br><span class="line">				q=m[i][k]+m[k+<span class="number">1</span>][j]+p[i]*p[k+<span class="number">1</span>]*p[j+<span class="number">1</span>];<span class="comment">//计算代价</span></span><br><span class="line">				<span class="keyword">if</span>(q&lt;m[i][j])</span><br><span class="line">				&#123;</span><br><span class="line">					m[i][j]=q;</span><br><span class="line">					s[i][j]=k;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/****************************************************\</span></span><br><span class="line"><span class="comment">函数功能：打印加括号的位置</span></span><br><span class="line"><span class="comment">输入：    s矩阵，想要计算的矩阵链的起始和结尾位置</span></span><br><span class="line"><span class="comment">输出：    无</span></span><br><span class="line"><span class="comment">\****************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_parens</span><span class="params">(<span class="keyword">int</span> s[<span class="number">6</span>][<span class="number">6</span>],<span class="keyword">int</span> i ,<span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(i==j)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"A%d"</span>,i);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"("</span>);</span><br><span class="line">		print_parens(s,i,s[i][j]);</span><br><span class="line">		print_parens(s,s[i][j]+<span class="number">1</span>,j);<span class="comment">//递归调用</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">")"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面程序的实现中，矩阵链的参数如下表：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>matrix</th>
<th>dimension</th>
</tr>
</thead>
<tbody>
<tr>
<td>$A_1$</td>
<td>30 × 35</td>
</tr>
<tr>
<td>$A_2$</td>
<td>35 × 15</td>
</tr>
<tr>
<td>$A_3$</td>
<td>15 × 5</td>
</tr>
<tr>
<td>$A_4$</td>
<td>5 × 10</td>
</tr>
<tr>
<td>$A_5$</td>
<td>10 × 20</td>
</tr>
<tr>
<td>$A_6$</td>
<td>20 × 25</td>
</tr>
</tbody>
</table>
</div>
<p>表示第$i$个矩阵到第$j$个矩阵的计算代价矩阵$m[i][j]$和表示第$i$个矩阵到第$j$个矩阵的最小代价时的分为两部分的位置矩阵$s[i][j]$的结果如下图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20131124/20131124_fig001.jpg" width="600" height="250" title="图1" alt="图1" ></p>
<p>从上面左图的$m$矩阵可以看出任意第$i$个到第$j$个矩阵连乘的乘法次数。最终的加括号形式为：$(A_1(A_2A_3))((A_4A_5)A_6)$</p>
<p>用动态规划算法解矩阵链乘法问题需要时间为$O(n^3)$，空间为$O(n^2)$，这比采用穷举法的指数时间相比要有效的多。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>Algorithm Design</tag>
      </tags>
  </entry>
  <entry>
    <title>【算法导论】动态规划算法之装配线调度</title>
    <url>/2013/11/23/%5B20131123%5D/</url>
    <content><![CDATA[<p>​    和分治算法一样，动态规划是通过组合子问题的解而解决整个问题的。但是与分治算法不同的是，动态规划算法适用于子问题不是独立的情况，也就是各子问题包含公共的子子问题。动态规划通常用于最优化问题的求解。看一个问题是否适合采用动态规划算法，主要有两个标志<strong>：最优子结构</strong>和<strong>重叠子问题。</strong></p>
<a id="more"></a>
<p><strong>最优子结构：问题的一个最优解包含了子问题的最优解。</strong></p>
<p><strong>重叠子问题：当一个递归算法不断地调用同一问题时，我们说该最优子问题包含重叠子问题。</strong></p>
<p><strong>动态规划算法的设计步骤如下：</strong></p>
<ol>
<li>描述最优解的结构。</li>
<li>递归定义最优解的值。</li>
<li>按自底向上的方式计算最优解的值。</li>
<li>由计算出的结果构造一个最优解。</li>
</ol>
<hr>
<p>下面利用动态规划算法求解一些最优化问题，本文解决装配线调度问题，问题如下：</p>
<p>假设有2条生产线，每条生产线有6个装配点。两条生产线对应点的功能相同，但是时间有所差别。产品需要经过这6个点才能完成生产。在同一条生产线上，产品从一个装配点转到下一个装配点的时间可以忽略，但是从一条生产线到另一条生产线则需要时间消耗。我们的问题是如何找到最短时间的路径。</p>
<p><strong>上面问题的一般模型如下图：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20131123/20131123_fig001.jpg" width="600" height="350" title="图1" alt="图1" ></p>
<p><strong>我们将上述一般模型实例化，可以转换为下图：</strong></p>
<p>​    <img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20131123/20131123_fig002.jpg" width="600" height="350" title="图2" alt="图2" ></p>
<p>在上图中，$f_1[i]$为到达第一条生产线中第$i$个装配站的时间（包括在第$i$站的时间）；$f_2[i]$为到达第二条生产线中第$i$个装配站的时间（包括在第i站的时间）；$l_1[i]$为到达第一条生产线中第$i$个装配站的上一站是哪条生产线；$l_2[i]$为到达第一条生产线中第$i$个装配站的上一站是哪条生产线。$f^\star$为最终的最短时间，$l^\star$为产品最终在哪条生产线上完成生产。</p>
<p><strong>算法思想如下：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20131123/20131123_fig003.jpg" width="600" height="150" title="图3" alt="图3" ></p>
<p>​    正如上面所说，我们先分别计算到两个装配线的站点1的最短路径，然后计算到站点2的最短路径，直到最终的最短路径。因为到一个站点的最短路径可以由前一个站点的最短路径加上前一个站点到本站点的最短路径。换句话说，到站点6的最短路径最优解包含到站点5的最优解，到站点5的最短路径最优解包含到站点4的最优解，……依此类推，最终可以变为到站点1的最优解。</p>
<p><strong>算法实现如下：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_route</span><span class="params">(<span class="keyword">int</span> *l1,<span class="keyword">int</span> *l2,<span class="keyword">int</span> lfinal,<span class="keyword">int</span> n)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Fastest_way</span><span class="params">(<span class="keyword">int</span> *a1,<span class="keyword">int</span> n1,<span class="keyword">int</span> *a2,<span class="keyword">int</span> n2,<span class="keyword">int</span> *t12,<span class="keyword">int</span> n3,<span class="keyword">int</span> *t21,<span class="keyword">int</span> n4,<span class="keyword">int</span> e1,<span class="keyword">int</span> e2,<span class="keyword">int</span> x1,<span class="keyword">int</span> x2,<span class="keyword">int</span> *l1,<span class="keyword">int</span> *l2,<span class="keyword">int</span> lfinal )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> a1[]=&#123;<span class="number">7</span>,<span class="number">9</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">4</span>&#125;;<span class="comment">//初始化各节点的时间消耗  </span></span><br><span class="line">	<span class="keyword">int</span> a2[]=&#123;<span class="number">8</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">7</span>&#125;;</span><br><span class="line">	<span class="keyword">int</span> t12[]=&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">	<span class="keyword">int</span> t21[]=&#123;<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>&#125;;</span><br><span class="line">	<span class="keyword">int</span> e1=<span class="number">2</span>;</span><br><span class="line">	<span class="keyword">int</span> e2=<span class="number">4</span>;</span><br><span class="line">	<span class="keyword">int</span> x1=<span class="number">3</span>;</span><br><span class="line">	<span class="keyword">int</span> x2=<span class="number">2</span>;</span><br><span class="line">	<span class="keyword">int</span> n1=<span class="keyword">sizeof</span>(a1)/<span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line">	<span class="keyword">int</span> n2=<span class="keyword">sizeof</span>(a2)/<span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line">	<span class="keyword">int</span> n3=<span class="keyword">sizeof</span>(t12)/<span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line">	<span class="keyword">int</span> n4=<span class="keyword">sizeof</span>(t21)/<span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line">	<span class="comment">//printf("%d%d%d%d\n",n1,n2,n3,n4);</span></span><br><span class="line">	<span class="keyword">int</span> l1[<span class="number">6</span>]=&#123;<span class="number">0</span>&#125;;<span class="comment">//第一个元素没有使用，每个元素的值代表前一次所在的生产线</span></span><br><span class="line">	<span class="keyword">int</span> l2[<span class="number">6</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="keyword">int</span> lfinal=<span class="number">0</span>;<span class="comment">//表示产品最终在哪个条线完成装配</span></span><br><span class="line">	lfinal=Fastest_way(a1,n1,a2,n2,t12,n3,t21,n4,e1,e2,x1,x2,l1,l2,lfinal );</span><br><span class="line">	print_route(l1,l2,lfinal,n1);	</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/******************************************************\</span></span><br><span class="line"><span class="comment">函数功能：寻找最短时间路径</span></span><br><span class="line"><span class="comment">输入：各个节点的时间消耗</span></span><br><span class="line"><span class="comment">输出：最终完成装配所在的生产线</span></span><br><span class="line"><span class="comment">\******************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Fastest_way</span><span class="params">(<span class="keyword">int</span> *a1,<span class="keyword">int</span> n1,<span class="keyword">int</span> *a2,<span class="keyword">int</span> n2,<span class="keyword">int</span> *t12,<span class="keyword">int</span> n3,<span class="keyword">int</span> *t21,<span class="keyword">int</span> n4,<span class="keyword">int</span> e1,<span class="keyword">int</span> e2,<span class="keyword">int</span> x1,<span class="keyword">int</span> x2,<span class="keyword">int</span> *l1,<span class="keyword">int</span> *l2,<span class="keyword">int</span> lfinal )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> f1[<span class="number">6</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="keyword">int</span> f2[<span class="number">6</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="keyword">int</span> final=<span class="number">0</span>;<span class="comment">//为总的最短时间消耗</span></span><br><span class="line">	f1[<span class="number">0</span>]=e1+a1[<span class="number">0</span>];</span><br><span class="line">	f2[<span class="number">0</span>]=e2+a2[<span class="number">0</span>];</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n1;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>((f1[i<span class="number">-1</span>]+a1[i])&lt;=(f2[i<span class="number">-1</span>]+a1[i]+t21[i<span class="number">-1</span>]))</span><br><span class="line">		&#123;</span><br><span class="line">			f1[i]=f1[i<span class="number">-1</span>]+a1[i];</span><br><span class="line">			l1[i]=<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			f1[i]=f2[i<span class="number">-1</span>]+a1[i]+t21[i<span class="number">-1</span>];</span><br><span class="line">			l1[i]=<span class="number">2</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>((f2[i<span class="number">-1</span>]+a2[i])&lt;=(f1[i<span class="number">-1</span>]+a2[i]+t12[i<span class="number">-1</span>]))</span><br><span class="line">		&#123;</span><br><span class="line">			f2[i]=f2[i<span class="number">-1</span>]+a2[i];</span><br><span class="line">			l2[i]=<span class="number">2</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			f2[i]=f1[i<span class="number">-1</span>]+a2[i]+t12[i<span class="number">-1</span>];</span><br><span class="line">			l2[i]=<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>((f1[n1<span class="number">-1</span>]+x1)&lt;(f2[n1<span class="number">-1</span>]+x2))</span><br><span class="line">	&#123;</span><br><span class="line">		final=f1[n1<span class="number">-1</span>]+x1;</span><br><span class="line">		lfinal=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		final=f2[n1<span class="number">-1</span>]+x2;</span><br><span class="line">		lfinal=<span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//for(int i=0;i&lt;6;i++)</span></span><br><span class="line">	<span class="comment">//	printf("%d ",f1[i]);</span></span><br><span class="line">	<span class="comment">//printf("\n");</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//for(int i=0;i&lt;6;i++)</span></span><br><span class="line">	<span class="comment">//	printf("%d ",f2[i]);</span></span><br><span class="line">	<span class="comment">//printf("\n");</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//for(int i=1;i&lt;6;i++)</span></span><br><span class="line">	<span class="comment">//	printf("%d ",l1[i]);</span></span><br><span class="line">	<span class="comment">//printf("\n");</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//for(int i=1;i&lt;6;i++)</span></span><br><span class="line">	<span class="comment">//	printf("%d ",l2[i]);</span></span><br><span class="line">	<span class="comment">//printf("\n");</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> lfinal;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**************************************************\</span></span><br><span class="line"><span class="comment">函数功能：逆向打印装配所经过的线路节点</span></span><br><span class="line"><span class="comment">输入：    记录经过的节点的数组了l1和l2、最终完成装配所在的生产线</span></span><br><span class="line"><span class="comment">输出：    打印装配所经过的路程</span></span><br><span class="line"><span class="comment">\**************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_route</span><span class="params">(<span class="keyword">int</span> *l1,<span class="keyword">int</span> *l2,<span class="keyword">int</span> lfinal,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> flag=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"line: %d ,station: %d\n"</span>,lfinal,n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;<span class="number">0</span>;i--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(i==n<span class="number">-1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(lfinal==<span class="number">1</span>)</span><br><span class="line">			&#123;</span><br><span class="line">			  <span class="built_in">printf</span>(<span class="string">"line: %d ,station: %d\n"</span>,l1[i],i);</span><br><span class="line">			  <span class="keyword">if</span>(l1[i]==<span class="number">1</span>)</span><br><span class="line">			      flag=<span class="number">1</span>;</span><br><span class="line">			  <span class="keyword">else</span></span><br><span class="line">				  flag=<span class="number">2</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">			  <span class="built_in">printf</span>(<span class="string">"line: %d ,station: %d\n"</span>,l2[i],i);</span><br><span class="line">			  <span class="keyword">if</span>(l2[i]==<span class="number">1</span>)</span><br><span class="line">				  flag=<span class="number">1</span>;</span><br><span class="line">			  <span class="keyword">else</span></span><br><span class="line">			      flag=<span class="number">2</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(flag==<span class="number">1</span>)</span><br><span class="line">	        &#123;</span><br><span class="line">			  <span class="built_in">printf</span>(<span class="string">"line: %d ,station: %d\n"</span>,l1[i],i);</span><br><span class="line">			   <span class="keyword">if</span>(l1[i]==<span class="number">1</span>)</span><br><span class="line">			      flag=<span class="number">1</span>;</span><br><span class="line">			  <span class="keyword">else</span></span><br><span class="line">				  flag=<span class="number">2</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">			  <span class="built_in">printf</span>(<span class="string">"line: %d ,station: %d\n"</span>,l2[i],i);</span><br><span class="line">			   <span class="keyword">if</span>(l2[i]==<span class="number">1</span>)</span><br><span class="line">				  flag=<span class="number">1</span>;</span><br><span class="line">			  <span class="keyword">else</span></span><br><span class="line">			      flag=<span class="number">2</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>Algorithm Design</tag>
      </tags>
  </entry>
  <entry>
    <title>【杂文散记】Verilog之加法器</title>
    <url>/2013/09/07/%5B20130907%5D/</url>
    <content><![CDATA[<p>  在fpga工程应用设计中，随处可见加法器，乘法器等等。现在将一些常用模块和心得体会先记录下来，以便日后使用。</p>
<a id="more"></a>
<ul>
<li><p><strong>一位半加器</strong>：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> halfadder(cout,sum,a,b);</span><br><span class="line"></span><br><span class="line">         outputcout,sum; <span class="comment">//不申明，默认是wire变量</span></span><br><span class="line"></span><br><span class="line">         <span class="keyword">input</span>  a,b;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">assign</span>&#123;cout,sum&#125;=a+b;<span class="comment">//cout为进位，sum为和</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p><strong>一位全加器</strong>：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> fulladder(a,b,cin,cout,sum);</span><br><span class="line"></span><br><span class="line">         inputa,b,cin;</span><br><span class="line"></span><br><span class="line">         outputcout,sum;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">assign</span>&#123;cout,sum&#125;=a+b+cin;</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p><strong>利用两个半加器实现全加器</strong>：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> halfadder(a,b,sum,cout);</span><br><span class="line"></span><br><span class="line">         outputcout,sum; <span class="comment">//不申明，默认是wire变量</span></span><br><span class="line"></span><br><span class="line">         <span class="keyword">input</span>  a,b;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">assign</span>&#123;cout,sum&#125;=a+b;</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> fulladder(x,y,c_in,sum,c_out);</span><br><span class="line"></span><br><span class="line">         inputx;</span><br><span class="line"></span><br><span class="line">         inputy;</span><br><span class="line"></span><br><span class="line">         inputc_in;</span><br><span class="line"></span><br><span class="line">         outputsum;</span><br><span class="line"></span><br><span class="line">         outputc_out;</span><br><span class="line"></span><br><span class="line">         wirea_sum;</span><br><span class="line"></span><br><span class="line">         wirea_out;</span><br><span class="line"></span><br><span class="line">         wireb_out;    </span><br><span class="line"></span><br><span class="line">         assignc_out=a_out|b_out;</span><br><span class="line"></span><br><span class="line">         halfadderhalf(x,y,a_sum,a_out);</span><br><span class="line"></span><br><span class="line">         halfadderhalf1(c_in,a_sum,sum,b_out);</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>测试文件的编写技巧</strong></p>
<p>就拿上面的半加器来说，我们需要添加的就是输入信号a,b.可以采用下列方法：</p>
<ul>
<li><p>第一种：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#100 a&#x3D;0;</span><br><span class="line"></span><br><span class="line">#100 b&#x3D;0;</span><br><span class="line"></span><br><span class="line">#100 a&#x3D;1;</span><br><span class="line"></span><br><span class="line">#100 b&#x3D;1;</span><br></pre></td></tr></table></figure>
<p>这种编辑方式虽然十分方便，可是对于很多情况的测试编写困难。</p>
</li>
<li><p>第二种：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">Integer I;</span><br><span class="line"></span><br><span class="line">For(i=<span class="number">0</span>;i&lt;=<span class="number">15</span>;i=i+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">a=I;<span class="comment">//注意这里a是一位，因此输出为0101010101010101</span></span><br><span class="line"></span><br><span class="line">第三种：</span><br><span class="line"></span><br><span class="line">Repeat(<span class="number">16</span>)</span><br><span class="line"></span><br><span class="line"> a =&#123;<span class="built_in">$random</span>&#125;%<span class="number">2</span>;<span class="comment">//这里产生随机的0 1比特流。</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>Algorithm Design</tag>
      </tags>
  </entry>
  <entry>
    <title>【妄言之言】随笔一</title>
    <url>/2013/08/15/%5B20130815%5D/</url>
    <content><![CDATA[<p>在暑假的上一阶段，我终于完成了算法导论中有关排序算法和树结构的学习及具体的程序实践。回头想想，收获不小，由于我是学通信的，以后可能很少用得到，但是我觉得我学习到的不是算法本身，而是算法的思想。它可能在我日后的科研过程中有着深刻的影响。现在这段时间忙着opnet软件的学习，算法导论中图论的学习可能要暂时搁置了。图论想必在我们通信上应该用的比较多吧，比如什么最短路径问题，最大流问题，最小费用问题等等。因此学习图论是很有必要的。</p>
<a id="more"></a>
<p>到目前为止，我只是将最近的文章上传到了这里，而文章类别也只有关于算法导论的c语言实现，我将逐步的将我以前发表在QQ空间的文章转移到这里来，毕竟这里才是讨论学术的主要阵地，而QQ空间只是娱乐的地方。</p>
<hr>
<p>时隔这么多年，早已不玩QQ了，CSDN也没准备更新了，现在逐步转移到个人博客了—2020.08.05</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>Algorithm Design</tag>
      </tags>
  </entry>
  <entry>
    <title>【算法导论】红黑树</title>
    <url>/2013/08/09/%5B20130809b%5D/</url>
    <content><![CDATA[<p>​     在了解红黑树之前，我们必须先了解二叉搜索树（又称二叉排序树，我在上一篇文章中有介绍），因为红黑树是一种特殊的二叉排序树：在每个节点上增加一个存储位来表示节点的颜色，因此红黑树共有五个域：color,key,lchild,rchild,p。</p>
<a id="more"></a>
<p>​     红黑树的提出：一个高度为h的二叉排序树可以实现任何一种基本的动态集合操作:插入、删除、查找等操作，但是当树才高度比较高时，二叉树就会退化成链表。而红黑树能确保在最坏的情况下，基本的动态集合操作的时间为$O(logn)$.</p>
<p>红黑树的性质决定了红黑树的性能，<strong>红黑树共有五大性质</strong>：</p>
<p>1、  每个节点不是红的，就是黑的。</p>
<p>2、  根节点是黑的。</p>
<p>3、  每个叶节点都是黑的。</p>
<p>4、  若一个节点是红的，则他的子节点都是黑的。</p>
<p>5、  对于每个节点，从该节点出发到其子孙叶节点的所有路径上包含相同数目的黑节点。</p>
<p>图片的信息比笔述更加清新明了，<strong>下图1-3就是一棵红黑树的几种形式</strong>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20130809b/20130809b_fig001.jpg" width="600" height="300" title="图1" alt="图1" ></p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20130809b/20130809b_fig002.jpg" width="600" height="300" title="图2" alt="图3" ></p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20130809b/20130809b_fig003.jpg" width="600" height="200" title="图3" alt="图3" ></p>
<p>上图中，为了便于处理边界问题，我们采用一个哨兵来代表NIL。哨兵NIL是一个与普通节点有相同域的对象。它的color域为BLACK，其它域可随意设置。我在程序中将p、lchild、rchild设置为NULL，将key设置为-1.将所有指向NIL的指针都指向哨兵NIL。</p>
<p><strong>下面先说明两个概念:</strong>内节点和外节点</p>
<p><strong>内节点</strong>：把带关键字的节点称为内节点。</p>
<p><strong>外节点</strong>：把没有子节点或父节点的节点称为外节点，我们把外节点都看成是哨兵NIL。</p>
<p>由于我们关注的是关键字key,因此我们主要关心内节点，所以在画红黑树的时候，常常忽略叶子，如上图3所示。</p>
<p>在介绍红黑树的插入和删除前，我们先必须介绍旋转这个概念。因为它在红黑树的插入、删除中，要用到很多。</p>
<p><strong>旋转：</strong>分为左旋、右旋，它能够<strong>保持二叉排序树性质</strong>的<strong>局部</strong>操作。至于为什么能够保持性质，我也没有深入研究。前人不知道怎么发现这个操作。</p>
<p>我始终认为图像更能直观的表达更准确丰富的含义，我相信大家通过下图即可以明白左旋和右旋了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20130809b/20130809b_fig004.jpg" width="400" height="150" title="图4" alt="图4" ></p>
<p>如果对上图4还是不太明了，也没关系，具体举例能使你有更深刻的认识，下图5是在x上左旋的过程：</p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20130809b/20130809b_fig005.jpg" width="500" height="400" title="图5" alt="图5" ></p>
<p><strong>下面附上左旋和右旋的代码：</strong><br><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        左旋和右旋的源代码：
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*************************************************\</span></span><br><span class="line"><span class="comment">函数功能：左旋</span></span><br><span class="line"><span class="comment">输入：    根节点、要左旋的节点、哨兵</span></span><br><span class="line"><span class="comment">输出：    根节点</span></span><br><span class="line"><span class="comment">\*************************************************/</span></span><br><span class="line"><span class="function">RBTree* <span class="title">Left_Rotate</span><span class="params">(RBTree* root,RBTree* x,RBTree* NIL)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    RBTree* y=<span class="literal">NULL</span>;</span><br><span class="line">    y=x-&gt;rchild;</span><br><span class="line">    x-&gt;rchild=y-&gt;lchild;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(y-&gt;lchild!=NIL)</span><br><span class="line">        y-&gt;lchild-&gt;p=x;</span><br><span class="line">    y-&gt;p=x-&gt;p;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(y-&gt;p==NIL)</span><br><span class="line">       root=y;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(x==x-&gt;p-&gt;lchild)</span><br><span class="line">        x-&gt;p-&gt;lchild=y;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        x-&gt;p-&gt;rchild=y;</span><br><span class="line">    y-&gt;lchild=x;</span><br><span class="line">    x-&gt;p=y;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*************************************************\</span></span><br><span class="line"><span class="comment">函数功能：在节点z上右旋</span></span><br><span class="line"><span class="comment">输入：    根节点、要右旋的节点、哨兵</span></span><br><span class="line"><span class="comment">输出：    根节点</span></span><br><span class="line"><span class="comment">\*************************************************/</span></span><br><span class="line"><span class="function">RBTree* <span class="title">Right_Rotate</span><span class="params">(RBTree* root,RBTree* x,RBTree* NIL)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    RBTree* y=<span class="literal">NULL</span>;</span><br><span class="line">    y=x-&gt;lchild;</span><br><span class="line">    x-&gt;lchild=y-&gt;rchild;</span><br><span class="line">    <span class="keyword">if</span>(y-&gt;rchild!=NIL)</span><br><span class="line">        y-&gt;rchild-&gt;p=x;</span><br><span class="line">    y-&gt;p=x-&gt;p;</span><br><span class="line">    <span class="keyword">if</span>(y-&gt;p==NIL)</span><br><span class="line">       root=y;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(x==x-&gt;p-&gt;lchild)</span><br><span class="line">        x-&gt;p-&gt;lchild=y;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        x-&gt;p-&gt;rchild=y;</span><br><span class="line">    y-&gt;rchild=x;</span><br><span class="line">    x-&gt;p=y;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div></p>
<hr>
<h2 id="插入操作：插入函数和插入修正函数"><a href="#插入操作：插入函数和插入修正函数" class="headerlink" title="插入操作：插入函数和插入修正函数"></a><strong>插入操作：</strong>插入函数和插入修正函数</h2><p>​    在前一篇文章中我已经介绍了二叉排序树，其中也有插入和删除操作。因为红黑树也是二叉排序树，因此其插入操作大同小异，不同之处在于，红黑树的性质会被插入和删除操作所破坏，因此就需要修正。<strong>修正包括两个操作</strong>：<strong>重新着色、旋转</strong>。</p>
<p>从上面的分析可知，<strong>红黑树的插入操作分为两步</strong>，首先像二叉排序树一样进行插入操作，然后调用修正函数来保持红黑树的性质。在插入操作中，我们都设置插入节点的color域为红而不是黑（如果是黑的话，性质4就不会破坏），为什么？请读者好好思考。<strong>下面为插入函数的实现：</strong></p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        插入函数源代码：
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*************************************************\</span></span><br><span class="line"><span class="comment">函数功能：插入一个节点z</span></span><br><span class="line"><span class="comment">输入：    根节点、插入的节点、哨兵</span></span><br><span class="line"><span class="comment">输出：    根节点</span></span><br><span class="line"><span class="comment">\*************************************************/</span></span><br><span class="line"><span class="function">RBTree* <span class="title">Insert</span><span class="params">(RBTree* root,RBTree* z,RBTree* NIL)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//    printf("ok ");</span></span><br><span class="line">    RBTree* leaf=NIL;</span><br><span class="line">    RBTree* p=root;<span class="comment">//指向根节点</span></span><br><span class="line">    <span class="keyword">while</span>(p!=NIL)<span class="comment">//根节点不为空</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//printf("dd");</span></span><br><span class="line">        leaf=p;    <span class="comment">//指向父节点</span></span><br><span class="line">        <span class="keyword">if</span>(z-&gt;key&lt;p-&gt;key)</span><br><span class="line">            p=p-&gt;lchild;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            p=p-&gt;rchild;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    z-&gt;p=leaf; <span class="comment">//z为y的孩子节点 y=leaf</span></span><br><span class="line">    <span class="keyword">if</span>(leaf==NIL) <span class="comment">//根节点为空</span></span><br><span class="line">        root=z;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(z-&gt;key&lt;leaf-&gt;key)</span><br><span class="line">        leaf-&gt;lchild=z;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        leaf-&gt;rchild=z;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//    printf("%d ",root-&gt;key);</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="comment">//    printf("%d ",root-&gt;color);</span></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>
<p>​    在Insert_FixUp插入修正函数中，循环截止条件为 z-&gt;p是黑色。如果z-&gt;p是红色，显然这就违返了红黑的树性质4。在循环中，我们要讨论6种情况，但是其中三种与另外三种是相互对称的，它可以由插入节点的父节点为祖父节点的左孩子还是右孩子来区分。<strong>下面我只讨论插入节点的父节点为祖父节点的左孩子的情况。</strong>在每一次迭代中，我们可能遇到以下三种情况。</p>
<ul>
<li><p><strong>情况一：叔叔是红色的</strong><br>这时只要把插入节点z的父亲z-&gt;p和uncle都设成黑色，并把祖父z-&gt;p-&gt;p设成红色。这样仍然确保了每一条路径上的黑色节点数不变。然后把z指向z-&gt;p-&gt;p，并开始新一轮的迭代。如下图6：</p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20130809b/20130809b_fig006.jpg" width="500" height="300" title="图6" alt="图6" ></p>
</li>
</ul>
<ul>
<li><strong>情况二：叔叔是黑色的情况下，插入节点为右孩子</strong><br>这时我们只要把z指向z-&gt;p，然后做一次Left-Rotate(z)。就可以把情况转化成情况三。</li>
</ul>
<ul>
<li><strong>情况三：叔叔是黑色的情况下，插入节点为左孩子</strong><br>只要把z-&gt;p设成黑色，把z-&gt;p-&gt;p设成红色，然后就调用  Right_Rotate(z-&gt;p-&gt;p)，整棵树就修正了。情况二和情况三如下图：<br><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20130809b/20130809b_fig007.jpg" width="500" height="200" title="图7" alt="图7" ></li>
</ul>
<p><strong>插入修正函数的具体实现如下：</strong></p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        插入修正函数源代码：
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*************************************************\</span></span><br><span class="line"><span class="comment">函数功能：插入修正来维持红黑树的性质</span></span><br><span class="line"><span class="comment">输入：    根节点、插入的节点、哨兵</span></span><br><span class="line"><span class="comment">输出：    根节点</span></span><br><span class="line"><span class="comment">\*************************************************/</span></span><br><span class="line"><span class="function">RBTree* <span class="title">Insert_FixUp</span><span class="params">(RBTree* root,RBTree* z,RBTree* NIL)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    RBTree* y=z;</span><br><span class="line">    <span class="keyword">while</span>(y-&gt;p-&gt;color==RED)<span class="comment">//循环截止条件为父节点为黑</span></span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(y-&gt;p==y-&gt;p-&gt;p-&gt;lchild)<span class="comment">//插入节点的父节点为祖父节点的左孩子</span></span><br><span class="line">        &#123;</span><br><span class="line">            RBTree* pr=y-&gt;p-&gt;p-&gt;rchild;</span><br><span class="line">            <span class="keyword">if</span>(pr-&gt;color==RED)<span class="comment">//情况一：叔叔是红色的</span></span><br><span class="line">            &#123;</span><br><span class="line">                y-&gt;p-&gt;color=BLACK;</span><br><span class="line">                pr-&gt;color=BLACK;</span><br><span class="line">                y-&gt;p-&gt;p-&gt;color=RED;</span><br><span class="line">                y=y-&gt;p-&gt;p;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="comment">//叔叔是黑色的，分两种情况</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(y==y-&gt;p-&gt;rchild)<span class="comment">//情况二：叔叔是黑色的情况下，插入节点为右孩子</span></span><br><span class="line">                &#123;</span><br><span class="line">                    y=y-&gt;p;</span><br><span class="line">                    root=Left_Rotate(root,y,NIL);<span class="comment">//情况二可以通过左旋变成情况三</span></span><br><span class="line">                &#125;</span><br><span class="line">                y-&gt;p-&gt;color=BLACK;<span class="comment">//情况三：叔叔是黑色的情况下，插入节点为左孩子</span></span><br><span class="line">                y-&gt;p-&gt;p-&gt;color=RED;</span><br><span class="line">                root=Right_Rotate(root,y-&gt;p-&gt;p,NIL);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">else</span><span class="comment">//插入节点的父节点为祖父节点的左孩子,下面的情况与上面类似</span></span><br><span class="line">            &#123;</span><br><span class="line">            RBTree* pl=y-&gt;p-&gt;p-&gt;lchild;</span><br><span class="line">            <span class="keyword">if</span>(pl-&gt;color==RED)</span><br><span class="line">            &#123;</span><br><span class="line">                y-&gt;p-&gt;color=BLACK;</span><br><span class="line">                pl-&gt;color=BLACK;</span><br><span class="line">                y-&gt;p-&gt;p-&gt;color=RED;</span><br><span class="line">                y=y-&gt;p-&gt;p;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(y==y-&gt;p-&gt;lchild)</span><br><span class="line">                &#123;</span><br><span class="line">                    y=y-&gt;p;</span><br><span class="line">                    root=Left_Rotate(root,y,NIL);</span><br><span class="line">                &#125;</span><br><span class="line">                y-&gt;p-&gt;color=BLACK;</span><br><span class="line">                y-&gt;p-&gt;p-&gt;color=RED;</span><br><span class="line">                root=Left_Rotate(root,y-&gt;p-&gt;p,NIL);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    root-&gt;color=BLACK;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>
<hr>
<h2 id="删除操作：删除函数和删除修正函数"><a href="#删除操作：删除函数和删除修正函数" class="headerlink" title="删除操作：删除函数和删除修正函数"></a>删除操作：删除函数和删除修正函数</h2><p>​     删除操作和插入操作一样，都可以和二叉排序树一样进行对比。红黑树的删除操作分为两步，首先像二叉排序树一样进行删除操作，然后调用修正函数来保持红黑树的性质。前一篇二叉排序树的文章也讲过，删除操作要比插入操作复杂一些，红黑树也不例外。<strong>删除函数的具体实现如下</strong>：</p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        删除函数源代码：
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*************************************************\</span></span><br><span class="line"><span class="comment">函数功能：删除一个节点z</span></span><br><span class="line"><span class="comment">输入：    根节点、要删除的节点、哨兵</span></span><br><span class="line"><span class="comment">输出：    根节点</span></span><br><span class="line"><span class="comment">\*************************************************/</span></span><br><span class="line"> <span class="function">RBTree* <span class="title">Delete</span><span class="params">(RBTree* root,RBTree* node,RBTree* NIL)</span> </span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">        RBTree* toDel = node;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;lchild != NIL &amp;&amp; node-&gt;rchild != NIL) </span><br><span class="line">        &#123;</span><br><span class="line">            toDel = TreeNext(node,NIL);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        RBTree* temp = toDel;</span><br><span class="line">        <span class="keyword">while</span> (temp-&gt;p != NIL)</span><br><span class="line">        &#123;</span><br><span class="line">            </span><br><span class="line">            temp = temp-&gt;p;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        RBTree* replace = (toDel-&gt;lchild != NIL)? toDel-&gt;lchild: toDel-&gt;rchild;</span><br><span class="line">        replace-&gt;p = toDel-&gt;p;</span><br><span class="line">        <span class="keyword">if</span> (replace-&gt;p == NIL) </span><br><span class="line">        &#123;</span><br><span class="line">            root = replace;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (toDel == toDel-&gt;p-&gt;lchild) </span><br><span class="line">        &#123;</span><br><span class="line">            replace-&gt;p-&gt;lchild = replace;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            replace-&gt;p-&gt;rchild = replace;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (toDel != node) </span><br><span class="line">        &#123;</span><br><span class="line">            node-&gt;key = toDel-&gt;key;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (toDel-&gt;color == BLACK)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//修改树，以保持平衡。</span></span><br><span class="line">            root=Del_FixUp(root,replace,NIL);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">delete</span> toDel;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;&lt;span style=<span class="string">"font-family: Calibri, sans-serif;"</span>&gt;&lt;span style=<span class="string">"font-size: 19px;"</span>&gt;</span><br><span class="line">&lt;/span&gt;&lt;/span&gt;</span><br></pre></td></tr></table></figure>
    </div>
</div>
<p>​     在Del_FixUp删除操作修正函数中，循环截止条件为z-&gt;color== RED。如果z-&gt;p是黑色，即删除的节点为黑色，显然这就违返了红黑的树性质5。在循环中，我们要讨论8种情况，但是其中4种与另外4种是相互对称的，它可以由删除的节点为父节点的左孩子还是右孩子来区分。<strong>下面我只讨论删除的节点为父节点的左孩子的情况</strong>:<br>在每一次迭代中，我们可能遇到以下4种情况：</p>
<ul>
<li><p><strong>情况一：兄弟为红色</strong><br>这时我们根据红黑树的性质可以肯定删除的节点x-&gt;p是黑色、其兄弟节点w-&gt;lchild是黑色。我们把x-&gt;pt与brother的颜色互换，然后做一次Left-Rotate(x-&gt;p)。做完之后x的新的兄弟：原w-&gt;lchild，是黑色的。因此我们在不破坏红黑树性质的前提下，把情况一转换成了情况二、情况三、情况四中的一个，如下图8：<br><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20130809b/20130809b_fig008.jpg" width="500" height="150" title="图8" alt="图8" ></p>
</li>
<li><p><strong>情况二：兄弟为黑色，其两个孩子为黑色</strong><br>这时我们只要把w设成红色,然后把x移到x-&gt;p，这一次操作不会破坏红黑树的性质。如下图9（图中节点B不一定是红色，也可能是黑色）：</p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20130809b/20130809b_fig009.jpg" width="500" height="150" title="图9" alt="图9" ></p>
</li>
<li><p><strong>情况三：兄弟为黑色，且其左孩子为红色，右孩子为黑色</strong><br>我们把w与w-&gt;lchild的颜色互换，然后做Right-Rotate(w)。这样做不会破坏红黑树的性质。这时x的新的兄弟就是原w-&gt;lchild。而情况3被转化成了情况4,如图10：</p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20130809b/20130809b_fig010.jpg" width="500" height="150" title="图10" alt="图10" ></p>
</li>
<li><p><strong>情况四：兄弟为黑色，且其右孩子为红色</strong><br>先把w与x-&gt;parent的颜色互换，再做Left-Rotate(x-&gt;parent)。这时图中节点E（也就是原w-&gt;rchild）所在的路径就肯定少了一个黑色，而x所在的路径则多了一个黑色。那么我们就把使E也为黑色，这样就保持了红黑树的性质。如下图11：</p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20130809b/20130809b_fig011.jpg" width="500" height="150" title="图11" alt="图11" ></p>
<p><strong>具体的代码实现如下：</strong><br><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        完整源代码：
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> Color&#123;RED,BLACK&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span>//红黑树的节点结构</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">enum</span> Color color;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">p</span>,*<span class="title">lchild</span>,*<span class="title">rchild</span>;</span></span><br><span class="line">    <span class="keyword">int</span> key;</span><br><span class="line">&#125;RBTree;</span><br><span class="line"></span><br><span class="line"><span class="function">RBTree* <span class="title">Insert</span><span class="params">(RBTree* root,RBTree* z,RBTree* NIL)</span></span>;<span class="comment">//插入</span></span><br><span class="line"><span class="function">RBTree* <span class="title">Insert_FixUp</span><span class="params">(RBTree* root,RBTree* z,RBTree* NIL)</span></span>;<span class="comment">//插入修正</span></span><br><span class="line"><span class="function">RBTree* <span class="title">Left_Rotate</span><span class="params">(RBTree* root,RBTree* x,RBTree* NIL)</span></span>;<span class="comment">//左旋</span></span><br><span class="line"><span class="function">RBTree* <span class="title">Right_Rotate</span><span class="params">(RBTree* root,RBTree* x,RBTree* NIL)</span></span>;<span class="comment">//右旋</span></span><br><span class="line"><span class="function">RBTree* <span class="title">Delete</span><span class="params">(RBTree* root,RBTree* node,RBTree* NIL)</span></span>;<span class="comment">//删除</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Layer</span><span class="params">(RBTree *p,<span class="keyword">int</span> n)</span></span>;<span class="comment">//广度优先遍历，用于查看红黑树的节点</span></span><br><span class="line"><span class="function">RBTree* <span class="title">TreeNext</span><span class="params">(RBTree* node,RBTree* NIL)</span></span>;<span class="comment">// 查找后继</span></span><br><span class="line"><span class="function">RBTree* <span class="title">TreePre</span><span class="params">(RBTree* node,RBTree* NIL)</span></span>;<span class="comment">// 查找前趋</span></span><br><span class="line"><span class="function">RBTree* <span class="title">TreeMax</span><span class="params">(RBTree* root,RBTree* NIL)</span></span>;<span class="comment">// 查找最大值</span></span><br><span class="line"><span class="function">RBTree* <span class="title">TreeMin</span><span class="params">(RBTree* root,RBTree* NIL)</span></span>;<span class="comment">// 查找最小值</span></span><br><span class="line"><span class="function">RBTree* <span class="title">Del_FixUp</span><span class="params">(RBTree* root,RBTree* delNode,RBTree* NIL)</span></span>;<span class="comment">//删除修正</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arrayA[]=&#123;<span class="number">11</span>,<span class="number">2</span>,<span class="number">14</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">15</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">4</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> n=<span class="keyword">sizeof</span>(arrayA)/<span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line"><span class="comment">//    printf("%d\n",BLACK);</span></span><br><span class="line"></span><br><span class="line">    RBTree* NIL=(RBTree*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(RBTree));<span class="comment">//哨兵节点即外节点</span></span><br><span class="line">    NIL-&gt;color=BLACK;</span><br><span class="line">    NIL-&gt;key=<span class="number">-1</span>;</span><br><span class="line">    NIL-&gt;lchild=NIL-&gt;rchild=<span class="literal">NULL</span>;</span><br><span class="line">    NIL-&gt;p=<span class="literal">NULL</span>;</span><br><span class="line">    RBTree *root=<span class="literal">NULL</span>;<span class="comment">//根节点</span></span><br><span class="line">    root=NIL;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        RBTree* z=(RBTree*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(RBTree));</span><br><span class="line">        z-&gt;color=RED;</span><br><span class="line">        z-&gt;key=arrayA[i];</span><br><span class="line">        z-&gt;lchild=NIL;</span><br><span class="line">        z-&gt;rchild=NIL;</span><br><span class="line">        z-&gt;p=NIL;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n插入节点的关键值为%d "</span>,z-&gt;key);    </span><br><span class="line">        root=Insert(root,z,NIL);    </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n插入修正前的广度遍历:\n"</span>);</span><br><span class="line">        Layer(root,n);</span><br><span class="line">        root=Insert_FixUp(root,z,NIL);</span><br><span class="line">    <span class="comment">//    printf("%d\n",i);</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"插入修正后的广度遍历:\n"</span>);</span><br><span class="line">        Layer(root,n);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"插入操作完成！！\n\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"删除节点的关键值为%d\n "</span>,root-&gt;lchild-&gt;rchild-&gt;key);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n删除顶节点后的广度遍历：\n"</span>);</span><br><span class="line">    root=Delete(root,root-&gt;lchild-&gt;rchild,NIL);</span><br><span class="line">    n=n<span class="number">-1</span>;<span class="comment">//删除一个节点 n减一</span></span><br><span class="line">    Layer(root,n);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*************************************************\</span></span><br><span class="line"><span class="comment">函数功能：插入一个节点z</span></span><br><span class="line"><span class="comment">输入：    根节点、插入的节点、哨兵</span></span><br><span class="line"><span class="comment">输出：    根节点</span></span><br><span class="line"><span class="comment">\*************************************************/</span></span><br><span class="line"><span class="function">RBTree* <span class="title">Insert</span><span class="params">(RBTree* root,RBTree* z,RBTree* NIL)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//    printf("ok ");</span></span><br><span class="line">    RBTree* leaf=NIL;</span><br><span class="line">    RBTree* p=root;<span class="comment">//指向根节点</span></span><br><span class="line">    <span class="keyword">while</span>(p!=NIL)<span class="comment">//根节点不为空</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//printf("dd");</span></span><br><span class="line">        leaf=p;    <span class="comment">//指向父节点</span></span><br><span class="line">        <span class="keyword">if</span>(z-&gt;key&lt;p-&gt;key)</span><br><span class="line">            p=p-&gt;lchild;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            p=p-&gt;rchild;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    z-&gt;p=leaf; <span class="comment">//z为y的孩子节点 y=leaf</span></span><br><span class="line">    <span class="keyword">if</span>(leaf==NIL) <span class="comment">//根节点为空</span></span><br><span class="line">        root=z;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(z-&gt;key&lt;leaf-&gt;key)</span><br><span class="line">        leaf-&gt;lchild=z;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        leaf-&gt;rchild=z;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//    printf("%d ",root-&gt;key);</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="comment">//    printf("%d ",root-&gt;color);</span></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*************************************************\</span></span><br><span class="line"><span class="comment">函数功能：插入修正来维持红黑树的性质</span></span><br><span class="line"><span class="comment">输入：    根节点、插入的节点、哨兵</span></span><br><span class="line"><span class="comment">输出：    根节点</span></span><br><span class="line"><span class="comment">\*************************************************/</span></span><br><span class="line"><span class="function">RBTree* <span class="title">Insert_FixUp</span><span class="params">(RBTree* root,RBTree* z,RBTree* NIL)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    RBTree* y=z;</span><br><span class="line">    <span class="keyword">while</span>(y-&gt;p-&gt;color==RED)<span class="comment">//循环截止条件为父节点为黑</span></span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(y-&gt;p==y-&gt;p-&gt;p-&gt;lchild)<span class="comment">//插入节点的父节点为祖父节点的左孩子</span></span><br><span class="line">        &#123;</span><br><span class="line">            RBTree* pr=y-&gt;p-&gt;p-&gt;rchild;</span><br><span class="line">            <span class="keyword">if</span>(pr-&gt;color==RED)<span class="comment">//情况一：叔叔是红色的</span></span><br><span class="line">            &#123;</span><br><span class="line">                y-&gt;p-&gt;color=BLACK;</span><br><span class="line">                pr-&gt;color=BLACK;</span><br><span class="line">                y-&gt;p-&gt;p-&gt;color=RED;</span><br><span class="line">                y=y-&gt;p-&gt;p;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="comment">//叔叔是黑色的，分两种情况</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(y==y-&gt;p-&gt;rchild)<span class="comment">//情况二：叔叔是黑色的情况下，插入节点为右孩子</span></span><br><span class="line">                &#123;</span><br><span class="line">                    y=y-&gt;p;</span><br><span class="line">                    root=Left_Rotate(root,y,NIL);<span class="comment">//情况二可以通过左旋变成情况三</span></span><br><span class="line">                &#125;</span><br><span class="line">                y-&gt;p-&gt;color=BLACK;<span class="comment">//情况三：叔叔是黑色的情况下，插入节点为左孩子</span></span><br><span class="line">                y-&gt;p-&gt;p-&gt;color=RED;</span><br><span class="line">                root=Right_Rotate(root,y-&gt;p-&gt;p,NIL);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">else</span><span class="comment">//插入节点的父节点为祖父节点的左孩子,下面的情况与上面类似</span></span><br><span class="line">            &#123;</span><br><span class="line">            RBTree* pl=y-&gt;p-&gt;p-&gt;lchild;</span><br><span class="line">            <span class="keyword">if</span>(pl-&gt;color==RED)</span><br><span class="line">            &#123;</span><br><span class="line">                y-&gt;p-&gt;color=BLACK;</span><br><span class="line">                pl-&gt;color=BLACK;</span><br><span class="line">                y-&gt;p-&gt;p-&gt;color=RED;</span><br><span class="line">                y=y-&gt;p-&gt;p;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(y==y-&gt;p-&gt;lchild)</span><br><span class="line">                &#123;</span><br><span class="line">                    y=y-&gt;p;</span><br><span class="line">                    root=Left_Rotate(root,y,NIL);</span><br><span class="line">                &#125;</span><br><span class="line">                y-&gt;p-&gt;color=BLACK;</span><br><span class="line">                y-&gt;p-&gt;p-&gt;color=RED;</span><br><span class="line">                root=Left_Rotate(root,y-&gt;p-&gt;p,NIL);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    root-&gt;color=BLACK;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*************************************************\</span></span><br><span class="line"><span class="comment">函数功能：左旋</span></span><br><span class="line"><span class="comment">输入：    根节点、要左旋的节点、哨兵</span></span><br><span class="line"><span class="comment">输出：    根节点</span></span><br><span class="line"><span class="comment">\*************************************************/</span></span><br><span class="line"><span class="function">RBTree* <span class="title">Left_Rotate</span><span class="params">(RBTree* root,RBTree* x,RBTree* NIL)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    RBTree* y=<span class="literal">NULL</span>;</span><br><span class="line">    y=x-&gt;rchild;</span><br><span class="line">    x-&gt;rchild=y-&gt;lchild;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(y-&gt;lchild!=NIL)</span><br><span class="line">        y-&gt;lchild-&gt;p=x;</span><br><span class="line">    y-&gt;p=x-&gt;p;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(y-&gt;p==NIL)</span><br><span class="line">       root=y;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(x==x-&gt;p-&gt;lchild)</span><br><span class="line">        x-&gt;p-&gt;lchild=y;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        x-&gt;p-&gt;rchild=y;</span><br><span class="line">    y-&gt;lchild=x;</span><br><span class="line">    x-&gt;p=y;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*************************************************\</span></span><br><span class="line"><span class="comment">函数功能：在节点z上右旋</span></span><br><span class="line"><span class="comment">输入：    根节点、要右旋的节点、哨兵</span></span><br><span class="line"><span class="comment">输出：    根节点</span></span><br><span class="line"><span class="comment">\*************************************************/</span></span><br><span class="line"><span class="function">RBTree* <span class="title">Right_Rotate</span><span class="params">(RBTree* root,RBTree* x,RBTree* NIL)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    RBTree* y=<span class="literal">NULL</span>;</span><br><span class="line">    y=x-&gt;lchild;</span><br><span class="line">    x-&gt;lchild=y-&gt;rchild;</span><br><span class="line">    <span class="keyword">if</span>(y-&gt;rchild!=NIL)</span><br><span class="line">        y-&gt;rchild-&gt;p=x;</span><br><span class="line">    y-&gt;p=x-&gt;p;</span><br><span class="line">    <span class="keyword">if</span>(y-&gt;p==NIL)</span><br><span class="line">       root=y;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(x==x-&gt;p-&gt;lchild)</span><br><span class="line">        x-&gt;p-&gt;lchild=y;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        x-&gt;p-&gt;rchild=y;</span><br><span class="line">    y-&gt;rchild=x;</span><br><span class="line">    x-&gt;p=y;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*************************************************\</span></span><br><span class="line"><span class="comment">函数功能：删除一个节点z</span></span><br><span class="line"><span class="comment">输入：    根节点、要删除的节点、哨兵</span></span><br><span class="line"><span class="comment">输出：    根节点</span></span><br><span class="line"><span class="comment">\*************************************************/</span></span><br><span class="line"> <span class="function">RBTree* <span class="title">Delete</span><span class="params">(RBTree* root,RBTree* node,RBTree* NIL)</span> </span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">        RBTree* toDel = node;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;lchild != NIL &amp;&amp; node-&gt;rchild != NIL) </span><br><span class="line">        &#123;</span><br><span class="line">            toDel = TreeNext(node,NIL);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        RBTree* temp = toDel;</span><br><span class="line">        <span class="keyword">while</span> (temp-&gt;p != NIL)</span><br><span class="line">        &#123;</span><br><span class="line">            </span><br><span class="line">            temp = temp-&gt;p;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        RBTree* replace = (toDel-&gt;lchild != NIL)? toDel-&gt;lchild: toDel-&gt;rchild;</span><br><span class="line">        replace-&gt;p = toDel-&gt;p;</span><br><span class="line">        <span class="keyword">if</span> (replace-&gt;p == NIL) </span><br><span class="line">        &#123;</span><br><span class="line">            root = replace;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (toDel == toDel-&gt;p-&gt;lchild) </span><br><span class="line">        &#123;</span><br><span class="line">            replace-&gt;p-&gt;lchild = replace;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            replace-&gt;p-&gt;rchild = replace;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (toDel != node) </span><br><span class="line">        &#123;</span><br><span class="line">            node-&gt;key = toDel-&gt;key;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (toDel-&gt;color == BLACK)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//修改树，以保持平衡。</span></span><br><span class="line">            root=Del_FixUp(root,replace,NIL);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">delete</span> toDel;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*************************************************\</span></span><br><span class="line"><span class="comment">函数功能：删除修正 维持红黑树的性质</span></span><br><span class="line"><span class="comment">输入：    根节点、要删除的节点、哨兵</span></span><br><span class="line"><span class="comment">输出：    根节点</span></span><br><span class="line"><span class="comment">\*************************************************/</span></span><br><span class="line">   <span class="function">RBTree* <span class="title">Del_FixUp</span><span class="params">(RBTree* root,RBTree* delNode,RBTree* NIL)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">        RBTree* p = delNode;</span><br><span class="line">        <span class="keyword">while</span> (p != root &amp;&amp; p-&gt;color == BLACK)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (p == p-&gt;p-&gt;lchild)<span class="comment">//要删除的节点为父节点的左孩子</span></span><br><span class="line">            &#123;</span><br><span class="line">                RBTree* brother = p-&gt;p-&gt;rchild;</span><br><span class="line">                <span class="keyword">if</span> (brother-&gt;color == RED) <span class="comment">//情况一：兄弟为红色</span></span><br><span class="line">                &#123;</span><br><span class="line">                    brother-&gt;color = BLACK;</span><br><span class="line">                    p-&gt;p-&gt;color = RED;</span><br><span class="line">                    root=Left_Rotate(root,p-&gt;p,NIL);<span class="comment">//经过旋转后 兄弟变为黑色，进入下面三种情况之一</span></span><br><span class="line">                    brother = p-&gt;p-&gt;rchild;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (brother-&gt;lchild-&gt;color == BLACK&amp;&amp; brother-&gt;rchild-&gt;color == BLACK)<span class="comment">//情况二：兄弟为黑色，其两个孩子为黑色</span></span><br><span class="line">                &#123;</span><br><span class="line">                    brother-&gt;color = RED;</span><br><span class="line">                    p = p-&gt;p;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (brother-&gt;rchild-&gt;color == BLACK)<span class="comment">//情况三：兄弟为黑色，且其左孩子为红色，右孩子为黑色</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        brother-&gt;lchild-&gt;color = BLACK;</span><br><span class="line">                        brother-&gt;color = RED;</span><br><span class="line">                        root=Right_Rotate(root,brother,NIL);<span class="comment">//转变为情况四</span></span><br><span class="line">                        brother  = brother-&gt;p;</span><br><span class="line">                    &#125;</span><br><span class="line">                    brother-&gt;color = brother-&gt;p-&gt;color;<span class="comment">//情况四：兄弟为黑色，且其右孩子为红色</span></span><br><span class="line">                    brother-&gt;p-&gt;color = BLACK;</span><br><span class="line">                    brother-&gt;rchild-&gt;color = BLACK;</span><br><span class="line">                    root=Left_Rotate(root,brother-&gt;p,NIL);</span><br><span class="line">                    p = root;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span><span class="comment">//删除的节点为父节点的右孩子,下面的情况与上面类似</span></span><br><span class="line">            &#123;</span><br><span class="line">                RBTree* brother = p-&gt;p-&gt;lchild;</span><br><span class="line">                <span class="keyword">if</span> (brother-&gt;color == RED) </span><br><span class="line">                &#123;</span><br><span class="line">                    brother-&gt;color = BLACK;</span><br><span class="line">                    p-&gt;p-&gt;color = RED;</span><br><span class="line">                    root=Right_Rotate(root,p-&gt;p,NIL);</span><br><span class="line">                    brother = p-&gt;p-&gt;lchild;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (brother-&gt;lchild-&gt;color == BLACK&amp;&amp; brother-&gt;rchild-&gt;color == BLACK)</span><br><span class="line">                &#123;</span><br><span class="line">                    brother-&gt;color = RED;</span><br><span class="line">                    p = p-&gt;p;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (brother-&gt;lchild-&gt;color == BLACK) </span><br><span class="line">                    &#123;</span><br><span class="line">                        brother-&gt;rchild-&gt;color = BLACK;</span><br><span class="line">                        brother-&gt;color = RED;</span><br><span class="line">                        root=Left_Rotate(root,brother,NIL);</span><br><span class="line">                        brother = brother-&gt;p;</span><br><span class="line">                    &#125;</span><br><span class="line">                    brother-&gt;color = brother-&gt;p-&gt;color;</span><br><span class="line">                    brother-&gt;p-&gt;color = BLACK;</span><br><span class="line">                    brother-&gt;lchild-&gt;color = BLACK;</span><br><span class="line">                    root=Right_Rotate(root,brother-&gt;p,NIL);</span><br><span class="line">                    p = root;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        p-&gt;color = BLACK;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/*************************************************\</span></span><br><span class="line"><span class="comment">函数功能：广度优先遍历</span></span><br><span class="line"><span class="comment">输入：    根节点、节点数</span></span><br><span class="line"><span class="comment">输出：    无</span></span><br><span class="line"><span class="comment">\*************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Layer</span><span class="params">(RBTree *p,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    RBTree* <span class="built_in">queue</span>[<span class="number">40</span>];<span class="comment">//queue数组用于存储节点地址</span></span><br><span class="line">    <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">    RBTree* s;</span><br><span class="line">    <span class="keyword">int</span> rear=<span class="number">0</span>;  <span class="comment">//队列尾指针</span></span><br><span class="line">    <span class="keyword">int</span> front=<span class="number">0</span>; <span class="comment">//队列头指针</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(p!=<span class="literal">NULL</span>)<span class="comment">//输入的树不为空</span></span><br><span class="line">    &#123;</span><br><span class="line">        rear=<span class="number">1</span>; <span class="comment">//初始化</span></span><br><span class="line">        front=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">queue</span>[rear]=p;</span><br><span class="line">        <span class="keyword">while</span>(front&lt;rear)<span class="comment">//判断队列是否为空</span></span><br><span class="line">        &#123;</span><br><span class="line">            front++;</span><br><span class="line">            s=<span class="built_in">queue</span>[front];</span><br><span class="line">            <span class="keyword">if</span>(s-&gt;key!=<span class="number">-1</span>)</span><br><span class="line">                count++;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"key=%d color=%d\n"</span>,s-&gt;key,s-&gt;color);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(s-&gt;lchild!=<span class="literal">NULL</span>) <span class="comment">//存储左右子节点</span></span><br><span class="line">            &#123;</span><br><span class="line">                rear++;</span><br><span class="line">                <span class="built_in">queue</span>[rear]=s-&gt;lchild;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(s-&gt;rchild!=<span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                rear++;</span><br><span class="line">                <span class="built_in">queue</span>[rear]=s-&gt;rchild;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(count&gt;=n)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*************************************************\</span></span><br><span class="line"><span class="comment">函数功能：查找一个节点在中序遍列中的下一个节点(后继)</span></span><br><span class="line"><span class="comment">输入：    一个节点、哨兵</span></span><br><span class="line"><span class="comment">输出：    该节点的后继节点</span></span><br><span class="line"><span class="comment">\*************************************************/</span></span><br><span class="line"> <span class="function">RBTree* <span class="title">TreeNext</span><span class="params">(RBTree* node,RBTree* NIL)</span> </span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">        RBTree* result;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;rchild!=NIL) </span><br><span class="line">        &#123;</span><br><span class="line">            result = TreeMin(node-&gt;rchild,NIL);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            result = node-&gt;p;</span><br><span class="line">            RBTree* temp = node;</span><br><span class="line">            <span class="keyword">while</span> (result!=NIL&amp;&amp;temp==result-&gt;rchild) </span><br><span class="line">            &#123;</span><br><span class="line">                temp = result;</span><br><span class="line">                result = result-&gt;p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"><span class="comment">/*************************************************\</span></span><br><span class="line"><span class="comment">函数功能：一个节点在中序遍列中的前一个节点(前趋)</span></span><br><span class="line"><span class="comment">输入：    一个节点、哨兵</span></span><br><span class="line"><span class="comment">输出：    该节点的前趋节点</span></span><br><span class="line"><span class="comment">\*************************************************/</span></span><br><span class="line">    <span class="function">RBTree* <span class="title">TreePre</span><span class="params">(RBTree* node,RBTree* NIL)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        RBTree* result;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;lchild !=NIL)</span><br><span class="line">        &#123;</span><br><span class="line">            result = TreeMax(node-&gt;rchild,NIL);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            result = node-&gt;p;</span><br><span class="line">            RBTree* temp = node;</span><br><span class="line">            <span class="keyword">while</span> (result != NIL &amp;&amp; temp == result-&gt;lchild)</span><br><span class="line">            &#123;</span><br><span class="line">                temp = result;</span><br><span class="line">                result = result-&gt;p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"><span class="comment">/*************************************************\</span></span><br><span class="line"><span class="comment">函数功能：找到子树中最大的节点</span></span><br><span class="line"><span class="comment">输入：    根节点、哨兵</span></span><br><span class="line"><span class="comment">输出：    子树中最大的节点</span></span><br><span class="line"><span class="comment">\*************************************************/</span></span><br><span class="line">    <span class="function">RBTree* <span class="title">TreeMax</span><span class="params">(RBTree* root,RBTree* NIL)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        RBTree* result = root;</span><br><span class="line">        <span class="keyword">while</span> (result-&gt;rchild !=NIL) </span><br><span class="line">        &#123;</span><br><span class="line">            result = result-&gt;rchild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="comment">/*************************************************\</span></span><br><span class="line"><span class="comment">函数功能：找到子树中最小的节点</span></span><br><span class="line"><span class="comment">输入：    根节点、哨兵</span></span><br><span class="line"><span class="comment">输出：    子树中最小的节点</span></span><br><span class="line"><span class="comment">\*************************************************/</span></span><br><span class="line">    <span class="function">RBTree* <span class="title">TreeMin</span><span class="params">(RBTree* root,RBTree* NIL)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        RBTree* result = root;</span><br><span class="line">        <span class="keyword">while</span> (result-&gt;lchild !=NIL) </span><br><span class="line">        &#123;</span><br><span class="line">            result = result-&gt;lchild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
    </div>
</div></p>
<hr>
<h2 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h2><p>最后给出运行结果的说明：在我电脑上的运行结果为：<br><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        运行结果：
    </div>
    <div class='spoiler-content'>
        <p>（key为关键字，color=0表示为红色，color=1表示为黑色，key=-1代表空节点）</p>
<p>插入节点的关键值为11<br>插入修正前的广度遍历:<br>key=11 color=0<br>key=-1 color=1<br>key=-1 color=1<br>插入修正后的广度遍历:<br>key=11 color=1<br>key=-1 color=1<br>key=-1 color=1</p>
<p>插入节点的关键值为2<br>插入修正前的广度遍历:<br>key=11 color=1<br>key=2 color=0<br>key=-1 color=1<br>key=-1 color=1<br>key=-1 color=1<br>插入修正后的广度遍历:<br>key=11 color=1<br>key=2 color=0<br>key=-1 color=1<br>key=-1 color=1<br>key=-1 color=1</p>
<p>插入节点的关键值为14<br>插入修正前的广度遍历:<br>key=11 color=1<br>key=2 color=0<br>key=14 color=0<br>key=-1 color=1<br>key=-1 color=1<br>key=-1 color=1<br>key=-1 color=1<br>插入修正后的广度遍历:<br>key=11 color=1<br>key=2 color=0<br>key=14 color=0<br>key=-1 color=1<br>key=-1 color=1<br>key=-1 color=1<br>key=-1 color=1</p>
<p>插入节点的关键值为1<br>插入修正前的广度遍历:<br>key=11 color=1<br>key=2 color=0<br>key=14 color=0<br>key=1 color=0<br>key=-1 color=1<br>key=-1 color=1<br>key=-1 color=1<br>key=-1 color=1<br>key=-1 color=1<br>插入修正后的广度遍历:<br>key=11 color=1<br>key=2 color=1<br>key=14 color=1<br>key=1 color=0<br>key=-1 color=1<br>key=-1 color=1<br>key=-1 color=1<br>key=-1 color=1<br>key=-1 color=1</p>
<p>插入节点的关键值为7<br>插入修正前的广度遍历:<br>key=11 color=1<br>key=2 color=1<br>key=14 color=1<br>key=1 color=0<br>key=7 color=0<br>key=-1 color=1<br>key=-1 color=1<br>key=-1 color=1<br>key=-1 color=1<br>key=-1 color=1<br>key=-1 color=1<br>插入修正后的广度遍历:<br>key=11 color=1<br>key=2 color=1<br>key=14 color=1<br>key=1 color=0<br>key=7 color=0<br>key=-1 color=1<br>key=-1 color=1<br>key=-1 color=1<br>key=-1 color=1<br>key=-1 color=1<br>key=-1 color=1</p>
<p>插入节点的关键值为15<br>插入修正前的广度遍历:<br>key=11 color=1<br>key=2 color=1<br>key=14 color=1<br>key=1 color=0<br>key=7 color=0<br>key=-1 color=1<br>key=15 color=0<br>key=-1 color=1<br>key=-1 color=1<br>key=-1 color=1<br>key=-1 color=1<br>key=-1 color=1<br>key=-1 color=1<br>插入修正后的广度遍历:<br>key=11 color=1<br>key=2 color=1<br>key=14 color=1<br>key=1 color=0<br>key=7 color=0<br>key=-1 color=1<br>key=15 color=0<br>key=-1 color=1<br>key=-1 color=1<br>key=-1 color=1<br>key=-1 color=1<br>key=-1 color=1<br>key=-1 color=1</p>
<p>插入节点的关键值为5<br>插入修正前的广度遍历:<br>key=11 color=1<br>key=2 color=1<br>key=14 color=1<br>key=1 color=0<br>key=7 color=0<br>key=-1 color=1<br>key=15 color=0<br>key=-1 color=1<br>key=-1 color=1<br>key=5 color=0<br>key=-1 color=1<br>key=-1 color=1<br>key=-1 color=1<br>key=-1 color=1<br>key=-1 color=1<br>插入修正后的广度遍历:<br>key=11 color=1<br>key=2 color=0<br>key=14 color=1<br>key=1 color=1<br>key=7 color=1<br>key=-1 color=1<br>key=15 color=0<br>key=-1 color=1<br>key=-1 color=1<br>key=5 color=0<br>key=-1 color=1<br>key=-1 color=1<br>key=-1 color=1<br>key=-1 color=1<br>key=-1 color=1</p>
<p>插入节点的关键值为8<br>插入修正前的广度遍历:<br>key=11 color=1<br>key=2 color=0<br>key=14 color=1<br>key=1 color=1<br>key=7 color=1<br>key=-1 color=1<br>key=15 color=0<br>key=-1 color=1<br>key=-1 color=1<br>key=5 color=0<br>key=8 color=0<br>key=-1 color=1<br>key=-1 color=1<br>key=-1 color=1<br>key=-1 color=1<br>key=-1 color=1<br>key=-1 color=1<br>插入修正后的广度遍历:<br>key=11 color=1<br>key=2 color=0<br>key=14 color=1<br>key=1 color=1<br>key=7 color=1<br>key=-1 color=1<br>key=15 color=0<br>key=-1 color=1<br>key=-1 color=1<br>key=5 color=0<br>key=8 color=0<br>key=-1 color=1<br>key=-1 color=1<br>key=-1 color=1<br>key=-1 color=1<br>key=-1 color=1<br>key=-1 color=1</p>
<p>插入节点的关键值为4<br>插入修正前的广度遍历:<br>key=11 color=1<br>key=2 color=0<br>key=14 color=1<br>key=1 color=1<br>key=7 color=1<br>key=-1 color=1<br>key=15 color=0<br>key=-1 color=1<br>key=-1 color=1<br>key=5 color=0<br>key=8 color=0<br>key=-1 color=1<br>key=-1 color=1<br>key=4 color=0<br>插入修正后的广度遍历:<br>key=7 color=1<br>key=2 color=0<br>key=11 color=0<br>key=1 color=1<br>key=5 color=1<br>key=8 color=1<br>key=14 color=1<br>key=-1 color=1<br>key=-1 color=1<br>key=4 color=0<br>key=-1 color=1<br>key=-1 color=1<br>key=-1 color=1<br>key=-1 color=1<br>key=15 color=0</p>
<p>插入操作完成！！</p>

    </div>
</div></p>
<p>形成的红黑树为：</p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20130809b/20130809b_fig012.jpg" width="400" height="250" title="图12" alt="图12" ></p>
<p>删除节点的关键值为5</p>
<p>删除顶节点后的广度遍历：<br>key=7 color=1<br>key=2 color=0<br>key=11 color=0<br>key=1 color=1<br>key=4 color=1<br>key=8 color=1<br>key=14 color=1<br>key=-1 color=1<br>key=-1 color=1<br>key=-1 color=1<br>key=-1 color=1<br>key=-1 color=1<br>key=-1 color=1<br>key=-1 color=1<br>key=15 color=0<br>请按任意键继续. . .</p>
<p>删除节点5后的红黑树为：</p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20130809b/20130809b_fig013.jpg" width="400" height="250" title="图13" alt="图13" ></p>
<p>本文参考资料：《算法导论》</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>Algorithm Design</tag>
      </tags>
  </entry>
  <entry>
    <title>【算法导论】二叉排序树</title>
    <url>/2013/08/09/%5B20130809%5D/</url>
    <content><![CDATA[<p><strong>二叉排序树的性质</strong>：每个节点的左子树中的所有节点的关键字都小于该节点的关键值，而右子树中的所有节点的关键字都大于该节点的关键值。</p>
<a id="more"></a>
<h3 id="二叉排序树的构造"><a href="#二叉排序树的构造" class="headerlink" title="二叉排序树的构造"></a><strong>二叉排序树的构造</strong></h3><p>二叉排序树的构造是指将一个给定的数据元素构造为相应的二叉排序树。</p>
<p><strong>基本思想为：</strong></p>
<p>对于任给的一组数据元素${ R1, R2, …, Rn } $, 可按以下方法来构造二叉排序树：</p>
<ol>
<li><p>令$R1$为二叉树的根; </p>
</li>
<li><p>若$R2&lt;R1$, 令$R2$为$R1$左子树的根结点，否则$R2$为$R1$右子树的根结点；</p>
</li>
<li><p>对$R3, …, Rn$结点，也是依次与前面生成的结点比较以确定输入结点的位置。</p>
<p>这一方法中的一个结点插入，可用以下的非递归插入算法来实现：</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**************************************\</span></span><br><span class="line"><span class="comment">函数功能：创建二叉排序树</span></span><br><span class="line"><span class="comment">输入：    原始数组</span></span><br><span class="line"><span class="comment">输出：    二叉排序树的根节点</span></span><br><span class="line"><span class="comment">\**************************************/</span></span><br><span class="line"><span class="function">bstnode* <span class="title">CreatBst</span><span class="params">(<span class="keyword">int</span>* arrayA,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	bstnode *t,*s;</span><br><span class="line">	t=<span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		s=(bstnode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(bstnode));</span><br><span class="line">		s-&gt;key=arrayA[i];<span class="comment">//从arrayA[1]开始</span></span><br><span class="line">		s-&gt;lchild=s-&gt;rchild=<span class="literal">NULL</span>;</span><br><span class="line">		t=InsertBst(t,s);<span class="comment">//调用插入函数</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="二叉排序树的插入"><a href="#二叉排序树的插入" class="headerlink" title="二叉排序树的插入"></a>二叉排序树的插入</h3><p>插入过程可以由下图一目了然：</p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20130809/20130809_fig001.jpg" width="500" height="400" title="图1" alt="图1" ></p>
<p>从上述的插入过程可以看出每次插入的新结点都是二叉排序树的叶子结点并且不需移动其他结点，所以在进行插入这样的操作时比向量（线性表）操作更方便。由于对二叉排序树进行中序遍历时，可以得到一个按关键字大小排列的有序序列，<strong>所以对一个无序序列可通过构造二叉排序树和对这个排序树进行中序遍历来产生一个有序序列。</strong></p>
<p><strong>具体的程序实现如下：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**************************************\</span></span><br><span class="line"><span class="comment">函数功能：向二叉排序树中插入节点</span></span><br><span class="line"><span class="comment">输入：    二叉排序树的根节点、要插入的节点</span></span><br><span class="line"><span class="comment">输出：    二叉排序树的根节点</span></span><br><span class="line"><span class="comment">\**************************************/</span></span><br><span class="line"><span class="function">bstnode* <span class="title">InsertBst</span><span class="params">(bstnode* t,bstnode* s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	bstnode *f,*p;</span><br><span class="line">	p=t;</span><br><span class="line">	<span class="keyword">while</span>(p!=<span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		f=p;</span><br><span class="line">	</span><br><span class="line">		<span class="keyword">if</span>(s-&gt;key&lt;=p-&gt;key)</span><br><span class="line">			p=p-&gt;lchild;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			p=p-&gt;rchild;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(t==<span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> s;</span><br><span class="line">	<span class="keyword">if</span>(s-&gt;key&lt;f-&gt;key)</span><br><span class="line">		f-&gt;lchild=s;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		f-&gt;rchild=s;</span><br><span class="line">	<span class="keyword">return</span> t;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="二叉树的删除"><a href="#二叉树的删除" class="headerlink" title="二叉树的删除"></a>二叉树的删除</h3><p>若要删除的结点由p指出，双亲结点由q指出，则<strong>二叉排序树中结点的删除可分以下三种情况考虑</strong>：</p>
<ol>
<li><p>若p指向叶子结点，则直接将该结点删除。</p>
</li>
<li><p>若p所指结点只有左子树pL或只有右子树pR，此时只要使pL或pR成为q所指结点的左子树或右子树即可，如下图(a)和(b)所示</p>
</li>
<li><p>若p所指结点的左子树pL和右子树pR均非空，则需要将pL和pR链接到合适的位置上，并且保持二叉排序树的特点，即应使中序遍历该二叉树所得序列的相对位置不变。具体做法有两种：①令pL直接链接到q的左（或右）孩子链域上，pR链接到p结点中序前趋结点s上（s是pL最右下的结点）；② 以p结点的直接中序前趋或后继替代p所指结点，然后再从原二叉排序树中删去该直接前趋或后继，如下图(d)、(e)、(f)所示。从图中可以看出使用①中做法，会使二叉树的深度增加，所以不如②中的做法好。</p>
</li>
</ol>
<p><strong>如下图所示：(红色代表要删除的节点)</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20130809/20130809_fig002.jpg" width="500" height="400" title="图2" alt="图2" ></p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20130809/20130809_fig003.jpg" width="500" height="400" title="图3" alt="图3" ></p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20130809/20130809_fig004.jpg" width="500" height="400" title="图4" alt="图4" ></p>
<p><strong>具体程序实现如下：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**************************************\</span></span><br><span class="line"><span class="comment">函数功能：在二叉排序树中删除节点</span></span><br><span class="line"><span class="comment">输入：    二叉排序树的根节点、要删除的节点的内容</span></span><br><span class="line"><span class="comment">输出：    二叉排序树的根节点</span></span><br><span class="line"><span class="comment">\**************************************/</span></span><br><span class="line"><span class="function">bstnode* <span class="title">DelBstNode</span><span class="params">(bstnode* t,<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	bstnode *p,*q,*s,*f;</span><br><span class="line">	p=t;</span><br><span class="line">	q=<span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">while</span>(p!=<span class="literal">NULL</span>)<span class="comment">//查找要删除的内容为k的节点</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(p-&gt;key==k) <span class="keyword">break</span>;</span><br><span class="line">		q=p;</span><br><span class="line">		<span class="keyword">if</span>(p-&gt;key&lt;k)</span><br><span class="line">			p=p-&gt;rchild;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			p=p-&gt;lchild;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(p==<span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"\n没有找到该节点\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> t;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;lchild==<span class="literal">NULL</span>)   <span class="comment">/* p所指结点的左子树为空 */</span></span><br><span class="line">    &#123; </span><br><span class="line">	   <span class="keyword">if</span> (q==<span class="literal">NULL</span>) </span><br><span class="line">		   t=p-&gt;rchild;       <span class="comment">/* p所指结点是原二叉排序树的根 */</span></span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span> (q-&gt;lchild==p)   <span class="comment">/* p所指结点是*q的左孩子 */</span></span><br><span class="line">  		   q-&gt;lchild=p-&gt;rchild;</span><br><span class="line">	   <span class="keyword">else</span>  q-&gt;rchild=p-&gt;rchild;  	<span class="comment">/* 将p所指右子树链接到*q的右指针域上 */</span></span><br><span class="line">       <span class="built_in">free</span>(p);                      	   <span class="comment">/* 释放被删结点 */</span></span><br><span class="line">  	&#125;	</span><br><span class="line">   <span class="keyword">else</span>     <span class="comment">/* p所指结点有左子树时，则按图12.21(e)方法进行 */</span></span><br><span class="line">    &#123;</span><br><span class="line">		f=p;  s=p-&gt;lchild; </span><br><span class="line">		<span class="keyword">while</span>(s-&gt;rchild!=<span class="literal">NULL</span> )   <span class="comment">/* 在pL中查找最右下结点 */</span></span><br><span class="line">        &#123;</span><br><span class="line">		  f=s; </span><br><span class="line">		  s=s-&gt;rchild;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> ( f==p ) </span><br><span class="line">			  f-&gt;lchild=s-&gt;lchild;    <span class="comment">/* 将s所指结点的左子树链接到*f上*/</span></span><br><span class="line">		<span class="keyword">else</span> f-&gt;rchild=s-&gt;lchild; </span><br><span class="line">		p-&gt;key=s-&gt;key;              <span class="comment">/* 将s所指结点的值赋给*p */</span></span><br><span class="line">		</span><br><span class="line">		<span class="built_in">free</span>(s);   				<span class="comment">/* 释放被删结点 */</span></span><br><span class="line">    &#125;</span><br><span class="line">   <span class="keyword">return</span>  t; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>一个完整实例如下：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxsize 20</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> key;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">node</span>*<span class="title">lchild</span>,*<span class="title">rchild</span>;</span></span><br><span class="line">&#125;bstnode;<span class="comment">//二叉排序树的节点结构</span></span><br><span class="line"></span><br><span class="line"><span class="function">bstnode* <span class="title">InsertBst</span><span class="params">(bstnode* t,bstnode* s)</span></span>;<span class="comment">//二叉排序树的插入</span></span><br><span class="line"><span class="function">bstnode* <span class="title">CreatBst</span><span class="params">(<span class="keyword">int</span>* arrayA,<span class="keyword">int</span> n)</span></span>;<span class="comment">//二叉排序树的创建</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Layer</span><span class="params">(bstnode *p)</span></span>;<span class="comment">//二叉排序树的广度优先遍历</span></span><br><span class="line"><span class="function">bstnode* <span class="title">DelBstNode</span><span class="params">(bstnode* t,<span class="keyword">int</span> k)</span></span>;<span class="comment">//二叉排序树的删除</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> arrayA[<span class="number">9</span>]=&#123;<span class="number">-1</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;;<span class="comment">//第一个节点没有用于存储数据，是为了方便计算</span></span><br><span class="line">	<span class="keyword">int</span> n=<span class="keyword">sizeof</span>(arrayA)/<span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line"></span><br><span class="line">	bstnode *head=<span class="literal">NULL</span>;<span class="comment">//初始化指向链表的头指针</span></span><br><span class="line">	head=CreatBst(arrayA,n);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"创建的二叉排序树的广度优先遍历为：\n"</span>);</span><br><span class="line">    Layer(head);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\n删除内容为5后的二叉排序树的广度优先遍历为："</span>);</span><br><span class="line">	head=DelBstNode(head,<span class="number">5</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">	Layer(head);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**************************************\</span></span><br><span class="line"><span class="comment">函数功能：向二叉排序树中插入节点</span></span><br><span class="line"><span class="comment">输入：    二叉排序树的根节点、要插入的节点</span></span><br><span class="line"><span class="comment">输出：    二叉排序树的根节点</span></span><br><span class="line"><span class="comment">\**************************************/</span></span><br><span class="line"><span class="function">bstnode* <span class="title">InsertBst</span><span class="params">(bstnode* t,bstnode* s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	bstnode *f,*p;</span><br><span class="line">	p=t;</span><br><span class="line">	<span class="keyword">while</span>(p!=<span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		f=p;</span><br><span class="line">	</span><br><span class="line">		<span class="keyword">if</span>(s-&gt;key&lt;=p-&gt;key)</span><br><span class="line">			p=p-&gt;lchild;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			p=p-&gt;rchild;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(t==<span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> s;</span><br><span class="line">	<span class="keyword">if</span>(s-&gt;key&lt;f-&gt;key)</span><br><span class="line">		f-&gt;lchild=s;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		f-&gt;rchild=s;</span><br><span class="line">	<span class="keyword">return</span> t;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**************************************\</span></span><br><span class="line"><span class="comment">函数功能：创建二叉排序树</span></span><br><span class="line"><span class="comment">输入：    原始数组</span></span><br><span class="line"><span class="comment">输出：    二叉排序树的根节点</span></span><br><span class="line"><span class="comment">\**************************************/</span></span><br><span class="line"><span class="function">bstnode* <span class="title">CreatBst</span><span class="params">(<span class="keyword">int</span>* arrayA,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	bstnode *t,*s;</span><br><span class="line">	t=<span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		s=(bstnode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(bstnode));</span><br><span class="line">		s-&gt;key=arrayA[i];<span class="comment">//从arrayA[1]开始</span></span><br><span class="line">		s-&gt;lchild=s-&gt;rchild=<span class="literal">NULL</span>;</span><br><span class="line">		t=InsertBst(t,s);<span class="comment">//调用插入函数</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**************************************\</span></span><br><span class="line"><span class="comment">函数功能：广度优先遍历二叉排序树</span></span><br><span class="line"><span class="comment">输入：    二叉排序树的根节点</span></span><br><span class="line"><span class="comment">输出：    无</span></span><br><span class="line"><span class="comment">\**************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Layer</span><span class="params">(bstnode *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	bstnode* <span class="built_in">queue</span>[maxsize];<span class="comment">//queue数组用于存储节点地址</span></span><br><span class="line">	bstnode* s;</span><br><span class="line">	<span class="keyword">int</span> rear=<span class="number">0</span>;  <span class="comment">//队列尾指针</span></span><br><span class="line">	<span class="keyword">int</span> front=<span class="number">0</span>; <span class="comment">//队列头指针</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(p!=<span class="literal">NULL</span>)<span class="comment">//输入的树不为空</span></span><br><span class="line">	&#123;</span><br><span class="line">		rear=<span class="number">1</span>; <span class="comment">//初始化</span></span><br><span class="line">		front=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">queue</span>[rear]=p;</span><br><span class="line">		<span class="keyword">while</span>(front&lt;rear)<span class="comment">//判断队列是否为空</span></span><br><span class="line">		&#123;</span><br><span class="line">			front++;</span><br><span class="line">			s=<span class="built_in">queue</span>[front];</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%d "</span>,s-&gt;key);</span><br><span class="line">			<span class="keyword">if</span>(s-&gt;lchild!=<span class="literal">NULL</span>) <span class="comment">//存储左右子节点</span></span><br><span class="line">			&#123;</span><br><span class="line">				rear++;</span><br><span class="line">				<span class="built_in">queue</span>[rear]=s-&gt;lchild;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(s-&gt;rchild!=<span class="literal">NULL</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				rear++;</span><br><span class="line">				<span class="built_in">queue</span>[rear]=s-&gt;rchild;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**************************************\</span></span><br><span class="line"><span class="comment">函数功能：在二叉排序树中删除节点</span></span><br><span class="line"><span class="comment">输入：    二叉排序树的根节点、要删除的节点的内容</span></span><br><span class="line"><span class="comment">输出：    二叉排序树的根节点</span></span><br><span class="line"><span class="comment">\**************************************/</span></span><br><span class="line"><span class="function">bstnode* <span class="title">DelBstNode</span><span class="params">(bstnode* t,<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	bstnode *p,*q,*s,*f;</span><br><span class="line">	p=t;</span><br><span class="line">	q=<span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">while</span>(p!=<span class="literal">NULL</span>)<span class="comment">//查找要删除的内容为k的节点</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(p-&gt;key==k) <span class="keyword">break</span>;</span><br><span class="line">		q=p;</span><br><span class="line">		<span class="keyword">if</span>(p-&gt;key&lt;k)</span><br><span class="line">			p=p-&gt;rchild;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			p=p-&gt;lchild;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(p==<span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"\n没有找到该节点\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> t;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;lchild==<span class="literal">NULL</span>)   <span class="comment">/* p所指结点的左子树为空 */</span></span><br><span class="line">    &#123; </span><br><span class="line">	   <span class="keyword">if</span> (q==<span class="literal">NULL</span>) </span><br><span class="line">		   t=p-&gt;rchild;       <span class="comment">/* p所指结点是原二叉排序树的根 */</span></span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span> (q-&gt;lchild==p)   <span class="comment">/* p所指结点是*q的左孩子 */</span></span><br><span class="line">  		   q-&gt;lchild=p-&gt;rchild;</span><br><span class="line">	   <span class="keyword">else</span>  q-&gt;rchild=p-&gt;rchild;  	<span class="comment">/* 将p所指右子树链接到*q的右指针域上 */</span></span><br><span class="line">       <span class="built_in">free</span>(p);                      	   <span class="comment">/* 释放被删结点 */</span></span><br><span class="line">  	&#125;	</span><br><span class="line">   <span class="keyword">else</span>     <span class="comment">/* p所指结点有左子树时，则按图12.21(e)方法进行 */</span></span><br><span class="line">    &#123;</span><br><span class="line">		f=p;  s=p-&gt;lchild; </span><br><span class="line">		<span class="keyword">while</span>(s-&gt;rchild!=<span class="literal">NULL</span> )   <span class="comment">/* 在pL中查找最右下结点 */</span></span><br><span class="line">        &#123;</span><br><span class="line">		  f=s; </span><br><span class="line">		  s=s-&gt;rchild;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> ( f==p ) </span><br><span class="line">			  f-&gt;lchild=s-&gt;lchild;    <span class="comment">/* 将s所指结点的左子树链接到*f上*/</span></span><br><span class="line">		<span class="keyword">else</span> f-&gt;rchild=s-&gt;lchild; </span><br><span class="line">		p-&gt;key=s-&gt;key;              <span class="comment">/* 将s所指结点的值赋给*p */</span></span><br><span class="line">		</span><br><span class="line">		<span class="built_in">free</span>(s);   				<span class="comment">/* 释放被删结点 */</span></span><br><span class="line">    &#125;</span><br><span class="line">   <span class="keyword">return</span>  t; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 参考文献：《计算机软件技术基础》 刘彦明 荣政 编 、《 算法导论》</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>Algorithm Design</tag>
      </tags>
  </entry>
  <entry>
    <title>【Matlab编程】哈夫曼树及编译码</title>
    <url>/2013/08/08/%5B20130808%5D/</url>
    <content><![CDATA[<h3 id=""><a href="#" class="headerlink" title=" "></a> </h3><p>哈夫曼树，又称二叉树，是一类带权路径长度最短的树。所谓路径长度，就是节点到树根之间的路径长度与节点权值的乘积。</p>
<p>哈夫曼本人曾在MIT的信息论研究生班学习。Robert Fano教授让学生们自己决定是参加期未考试还是做一个大作业。而哈夫曼选择了后者，原因很简单，因为解决一大作业可能比期未考试更容易通过。Robert Fano教授也是信息论的先驱，学过信息论的都知道有Fano不等式，Shannon-Fano编码。当时这个大作业，Fano也解决不了，哈夫曼并不知道，于是自己尝试，最终产生了哈夫曼编码，其性能比Shannon-Fano编码更好。这个故事说明，大师级人物未能解决的问题，我们不一定解决不了，因为我们的思想比较开阔，能从不同的角度看问题。还有就是turbo码的产生也印证了这个道理。但是任何成功都离不开坚持不懈的努力。这段小故事就当你我共勉。</p>
<hr>
<a id="more"></a>
<h3 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h3><p>哈夫曼树的构造由下图可清楚明了：（总的来说就是每次将两个最小的节点合并）</p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20130808/20130808_fig001.jpg" width="600" height="450" title="图1" alt="图1" ></p>
<p>用上述算法来对图12.16中的叶子结点集合构造哈夫曼树的初始状态如图12.18(a)所示，第一次合并状态如图12.18(b)所示，结果状态如图12.18(c)所示。在算法中，每次合并时都是将具有较小权值的结点置为合并后结点的左孩子，而具有较大权值的结点置为合并后结点的右孩子。<br><strong>具体实现如下：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**********************************************************\</span></span><br><span class="line"><span class="comment">函数功能：构造哈夫曼树</span></span><br><span class="line"><span class="comment">输入：    头结点、权重、元素值</span></span><br><span class="line"><span class="comment">输出：    无</span></span><br><span class="line"><span class="comment">\**********************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HuffmanTree</span><span class="params">(huffmantree *tree,<span class="keyword">double</span> *weight,<span class="keyword">int</span> *data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> i,j;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;i++)<span class="comment">//初始化</span></span><br><span class="line">	&#123;</span><br><span class="line">		tree[i].parent=<span class="number">0</span>;</span><br><span class="line">		tree[i].lchild=<span class="number">0</span>;</span><br><span class="line">		tree[i].rchild=<span class="number">0</span>;</span><br><span class="line">		tree[i].weight=<span class="number">0.0</span>;</span><br><span class="line">		tree[i].data=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		tree[i].weight=weight[i];<span class="comment">//给每个节点赋权值和内容</span></span><br><span class="line">		tree[i].data=data[i];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(i=n;i&lt;m;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> p1=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> p2=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">float</span> small1,small2;</span><br><span class="line">		small1=small2=<span class="number">10000</span>;<span class="comment">//初始化为一个很大的值</span></span><br><span class="line">		<span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;=i<span class="number">-1</span>;j++)<span class="comment">//找出最小权重的两个节点</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(tree[j].parent==<span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(tree[j].weight&lt;small1)</span><br><span class="line">				&#123;</span><br><span class="line">					small2=small1;</span><br><span class="line">					small1=tree[j].weight;</span><br><span class="line">					p2=p1;</span><br><span class="line">					p1=j;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span>(tree[j].weight&lt;small2)</span><br><span class="line">				&#123;</span><br><span class="line">					small2=tree[j].weight;</span><br><span class="line">					p2=j;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		tree[p1].parent=i;</span><br><span class="line">		tree[p2].parent=i;</span><br><span class="line">		tree[i].lchild=p1;</span><br><span class="line">		tree[i].rchild=p2;</span><br><span class="line">		tree[i].weight=tree[p1].weight+tree[p2].weight;<span class="comment">//将两个节点合并为一个节点</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>哈夫曼编码:</strong></p>
<p>通过从哈夫曼树根结点开始，对左子树分配代码“0”，右子树分配代码“1”，一直到达叶子结点为止，然后将从树根沿每条路径到达叶子结点的代码排列起来，便得到了哈夫曼编码。<strong>因为形成哈夫曼树的每一次合并操作都将对应一次代码分配，因此n个叶子结点的最大编码长度不会超过n–1</strong>，所以可为每个叶子结点分配一个长度为n的编码数组。</p>
<p><strong>基本思想是</strong>：从叶子tree[i]出发，利用双亲地址找到双亲结点tree[p]，再利用tree[p]的lchild和rchild指针域判断tree[i]是tree[p]的左孩子还是右孩子，然后决定分配代码是“0”还是“1”, 然后以tree[p]为出发点继续向上回溯，直到根结点为止。</p>
<p><strong>具体算法实现如下</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**************************************************\</span></span><br><span class="line"><span class="comment">函数功能：进行哈夫曼编码</span></span><br><span class="line"><span class="comment">输入：    用于存储编码的数组code、哈夫曼树</span></span><br><span class="line"><span class="comment">输出：    无</span></span><br><span class="line"><span class="comment">\**************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HuffmanCode</span><span class="params">(codetype *code,huffmantree *tree)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i,c,p;</span><br><span class="line">	codetype cd;<span class="comment">//缓冲变量</span></span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cd.start=n;<span class="comment">//从叶子节点开始回溯</span></span><br><span class="line">		c=i;</span><br><span class="line">		p=tree[c].parent;</span><br><span class="line">		cd.data=tree[c].data;</span><br><span class="line">		<span class="keyword">while</span>(p!=<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			cd.start--;</span><br><span class="line">			<span class="keyword">if</span>(tree[p].lchild==c)<span class="comment">//左节点则编为0，右节点则编为1</span></span><br><span class="line">				cd.bits[cd.start]=<span class="number">0</span>;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				cd.bits[cd.start]=<span class="number">1</span>;</span><br><span class="line">			c=p;</span><br><span class="line">			p=tree[c].parent;</span><br><span class="line">		&#125;</span><br><span class="line">		code[i]=cd;</span><br><span class="line">		code[i].start=cd.start;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p><strong>哈夫曼译码：</strong></p>
<p>哈夫曼树译码是指由给定的代码求出代码所表示的结点值，它是哈夫曼树编码的逆过程。</p>
<p><strong>译码的基本思想</strong>是：从根结点出发，逐个读入电文中的二进制代码；若代码为0则走向左孩子，否则走向右孩子；一旦到达叶子结点，便可译出代码所对应的字符。然后又重新从根结点开始继续译码，直到二进制电文结束。</p>
<p><strong>具体译码算法如下：</strong> </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/***************************************************\</span></span><br><span class="line"><span class="comment">函数功能：哈夫曼译码</span></span><br><span class="line"><span class="comment">输入：    存储编码的数组、哈夫曼树</span></span><br><span class="line"><span class="comment">输出：    无</span></span><br><span class="line"><span class="comment">\***************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HuffmanDecode</span><span class="params">(codetype *code,huffmantree *tree)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i=m<span class="number">-1</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\n译码结果为：\n"</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> k=code[j].start;k&lt;n;k++)<span class="comment">//循环n次，对n个码进行译码</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(code[j].bits[k]==<span class="number">0</span>)</span><br><span class="line">				i=tree[i].lchild;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				i=tree[i].rchild;</span><br><span class="line">			<span class="keyword">if</span>(tree[i].lchild==<span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"%d "</span>,code[i].data);</span><br><span class="line">				i=m<span class="number">-1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>完整实例如下：</strong>假设有6个节点，权值分别为0.4、0.3、0.1、0.1、0.08、0.02，元素值分别为2、1、3、4、6、5.则哈夫曼树的构造过程和编码如下:</p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20130808/20130808_fig002.jpg" width="600" height="250" title="图2" alt="图2" ></p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20130808/20130808_fig003.jpg" width="600" height="250" title="图3" alt="图3" ></p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20130808/20130808_fig004.jpg" width="600" height="350" title="图4" alt="图4" ></p>
<p><strong>具体的代码实现如下：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> n 6 <span class="comment">//叶子数目</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> m (2*n-1)<span class="comment">//节点总数</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxsize 10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> datatype;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">double</span> weight;</span><br><span class="line">	datatype data;</span><br><span class="line">	<span class="keyword">int</span> lchild,rchild,parent;</span><br><span class="line">&#125;huffmantree;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> bits[n];</span><br><span class="line">	<span class="keyword">int</span> start;</span><br><span class="line">	<span class="keyword">int</span> data;</span><br><span class="line">&#125;codetype;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HuffmanTree</span><span class="params">(huffmantree *tree,<span class="keyword">double</span> *weight,<span class="keyword">int</span> *data)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HuffmanCode</span><span class="params">(codetype *code,huffmantree *tree)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HuffmanDecode</span><span class="params">(codetype *code,huffmantree *tree)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">double</span> weight[]=&#123;<span class="number">0.4</span>,<span class="number">0.3</span>,<span class="number">0.1</span>,<span class="number">0.1</span>,<span class="number">0.02</span>,<span class="number">0.08</span>&#125;;</span><br><span class="line">	<span class="keyword">int</span> data[]=&#123;<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">	huffmantree head[m];</span><br><span class="line">	codetype code[n];</span><br><span class="line"></span><br><span class="line">	HuffmanTree(head,weight,data);</span><br><span class="line">	HuffmanCode(code,head);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d "</span>,head[i].parent);<span class="comment">//对应的父节点</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\n编码结果为：\n"</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=code[i].start;j&lt;n;j++)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d "</span>,code[i].bits[j]);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">		HuffmanDecode(code,head);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**********************************************************\</span></span><br><span class="line"><span class="comment">函数功能：构造哈夫曼树</span></span><br><span class="line"><span class="comment">输入：    头结点、权重、元素值</span></span><br><span class="line"><span class="comment">输出：    无</span></span><br><span class="line"><span class="comment">\**********************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HuffmanTree</span><span class="params">(huffmantree *tree,<span class="keyword">double</span> *weight,<span class="keyword">int</span> *data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> i,j;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;i++)<span class="comment">//初始化</span></span><br><span class="line">	&#123;</span><br><span class="line">		tree[i].parent=<span class="number">0</span>;</span><br><span class="line">		tree[i].lchild=<span class="number">0</span>;</span><br><span class="line">		tree[i].rchild=<span class="number">0</span>;</span><br><span class="line">		tree[i].weight=<span class="number">0.0</span>;</span><br><span class="line">		tree[i].data=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		tree[i].weight=weight[i];<span class="comment">//给每个节点赋权值和内容</span></span><br><span class="line">		tree[i].data=data[i];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(i=n;i&lt;m;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> p1=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> p2=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">float</span> small1,small2;</span><br><span class="line">		small1=small2=<span class="number">10000</span>;<span class="comment">//初始化为一个很大的值</span></span><br><span class="line">		<span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;=i<span class="number">-1</span>;j++)<span class="comment">//找出最小权重的两个节点</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(tree[j].parent==<span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(tree[j].weight&lt;small1)</span><br><span class="line">				&#123;</span><br><span class="line">					small2=small1;</span><br><span class="line">					small1=tree[j].weight;</span><br><span class="line">					p2=p1;</span><br><span class="line">					p1=j;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span>(tree[j].weight&lt;small2)</span><br><span class="line">				&#123;</span><br><span class="line">					small2=tree[j].weight;</span><br><span class="line">					p2=j;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		tree[p1].parent=i;</span><br><span class="line">		tree[p2].parent=i;</span><br><span class="line">		tree[i].lchild=p1;</span><br><span class="line">		tree[i].rchild=p2;</span><br><span class="line">		tree[i].weight=tree[p1].weight+tree[p2].weight;<span class="comment">//将两个节点合并为一个节点</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**************************************************\</span></span><br><span class="line"><span class="comment">函数功能：进行哈夫曼编码</span></span><br><span class="line"><span class="comment">输入：    用于存储编码的数组code、哈夫曼树</span></span><br><span class="line"><span class="comment">输出：    无</span></span><br><span class="line"><span class="comment">\**************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HuffmanCode</span><span class="params">(codetype *code,huffmantree *tree)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i,c,p;</span><br><span class="line">	codetype cd;<span class="comment">//缓冲变量</span></span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cd.start=n;<span class="comment">//从叶子节点开始回溯</span></span><br><span class="line">		c=i;</span><br><span class="line">		p=tree[c].parent;</span><br><span class="line">		cd.data=tree[c].data;</span><br><span class="line">		<span class="keyword">while</span>(p!=<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			cd.start--;</span><br><span class="line">			<span class="keyword">if</span>(tree[p].lchild==c)<span class="comment">//左节点则编为0，右节点则编为1</span></span><br><span class="line">				cd.bits[cd.start]=<span class="number">0</span>;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				cd.bits[cd.start]=<span class="number">1</span>;</span><br><span class="line">			c=p;</span><br><span class="line">			p=tree[c].parent;</span><br><span class="line">		&#125;</span><br><span class="line">		code[i]=cd;</span><br><span class="line">		code[i].start=cd.start;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/***************************************************\</span></span><br><span class="line"><span class="comment">函数功能：哈夫曼译码</span></span><br><span class="line"><span class="comment">输入：    存储编码的数组、哈夫曼树</span></span><br><span class="line"><span class="comment">输出：    无</span></span><br><span class="line"><span class="comment">\***************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HuffmanDecode</span><span class="params">(codetype *code,huffmantree *tree)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i=m<span class="number">-1</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\n译码结果为：\n"</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> k=code[j].start;k&lt;n;k++)<span class="comment">//循环n次，对n个码进行译码</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(code[j].bits[k]==<span class="number">0</span>)</span><br><span class="line">				i=tree[i].lchild;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				i=tree[i].rchild;</span><br><span class="line">			<span class="keyword">if</span>(tree[i].lchild==<span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"%d "</span>,code[i].data);</span><br><span class="line">				i=m<span class="number">-1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注：如果程序出错，可能是使用的开发平台版本不同，请点击如下链接： <a href="http://blog.csdn.net/tengweitw/article/details/9791883" target="_blank" rel="noopener">解释说明</a></p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>Matlab Coding</tag>
      </tags>
  </entry>
  <entry>
    <title>【算法导论】求二叉树的叶子数和深度</title>
    <url>/2013/08/06/%5B20130806d%5D/</url>
    <content><![CDATA[<p>二叉树的遍历算法是许多二叉树运算的算法设计的基础，因此遍历算法的应用很广泛。下面以遍历算法求二叉树的叶子数和深度为例，来加深对于二叉树遍历算法的理解。</p>
<a id="more"></a>
<p><strong>1. 统计二叉树中的叶子结点数</strong><br>因为叶子结点是二叉树中那些左孩子和右孩子均不存在的结点，所以可在二叉树的遍历过程中，对这种特殊结点进行计数，来完成对叶子结点数的统计。这个统计可在任何一种遍历方式下给出，下面是利用<strong>中序遍历</strong>来实现的算法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**********************************************\</span></span><br><span class="line"><span class="comment">函数功能：计算叶子节点个数</span></span><br><span class="line"><span class="comment">输入：    二叉树的根节点</span></span><br><span class="line"><span class="comment">输出：    叶子节点个数</span></span><br><span class="line"><span class="comment">\**********************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countleaf</span><span class="params">(bitree *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> count=<span class="number">0</span>;<span class="comment">//注意这里是静态变量，也可以改为全局变量</span></span><br><span class="line">	<span class="keyword">if</span>(p!=<span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		count=countleaf(p-&gt;lchild);</span><br><span class="line">		<span class="keyword">if</span>((p-&gt;lchild==<span class="literal">NULL</span>)&amp;&amp;(p-&gt;rchild==<span class="literal">NULL</span>))</span><br><span class="line">			count=count+<span class="number">1</span>;</span><br><span class="line">		count=countleaf(p-&gt;rchild);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2.求二叉树的深度<br>     二叉树的深度是二叉树中结点层次的最大值。可通过先序遍历来计算二叉树中每个结点的层次, 其中的最大值即为二叉树的深度。<br><strong>具体算法如下：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**********************************************\</span></span><br><span class="line"><span class="comment">函数功能：计算树的深度</span></span><br><span class="line"><span class="comment">输入：    二叉树的根节点、当前树的深度</span></span><br><span class="line"><span class="comment">输出：    树的深度</span></span><br><span class="line"><span class="comment">\**********************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">treedepth</span><span class="params">(bitree*p,<span class="keyword">int</span> l)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> h=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(p!=<span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		l++;</span><br><span class="line">		<span class="keyword">if</span>(l&gt;h)</span><br><span class="line">			h=l;</span><br><span class="line">		h=treedepth(p-&gt;lchild,l);</span><br><span class="line">		h=treedepth(p-&gt;rchild,l);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>两者的完整实例如下：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxsize 20</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> datatype;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	datatype data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span></span><br><span class="line">&#125;bitree;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Layer</span><span class="params">(bitree *p)</span></span>;</span><br><span class="line"><span class="function">bitree* <span class="title">CreatBitree</span><span class="params">(<span class="keyword">int</span>* arrayA,<span class="keyword">int</span> n)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countleaf</span><span class="params">(bitree *p)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">treedepth</span><span class="params">(bitree*p,<span class="keyword">int</span> l)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> arrayA[<span class="number">10</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;<span class="comment">//第一个节点没有用于存储数据</span></span><br><span class="line">	<span class="keyword">int</span> n=<span class="keyword">sizeof</span>(arrayA)/<span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line">    <span class="keyword">int</span> l=<span class="number">0</span>;<span class="comment">//二叉树的深度</span></span><br><span class="line">	bitree *head=<span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	head=CreatBitree(arrayA,n);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"二叉树的叶子数为：%d"</span>,countleaf(head));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"二叉树的深度为：  %d"</span>,treedepth(head,l));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"按广度优先搜索遍历的结果为："</span>);</span><br><span class="line"><span class="comment">//	Layer(head);</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*************************************************\</span></span><br><span class="line"><span class="comment">函数功能：建立二叉树（按照顺序方式）</span></span><br><span class="line"><span class="comment">输入：    原始数组</span></span><br><span class="line"><span class="comment">输出：    二叉树的头结点</span></span><br><span class="line"><span class="comment">\*************************************************/</span></span><br><span class="line"><span class="function">bitree* <span class="title">CreatBitree</span><span class="params">(<span class="keyword">int</span>* arrayA,<span class="keyword">int</span> n)</span><span class="comment">//顺序存储 建立二叉树</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	bitree *root;</span><br><span class="line">	bitree *<span class="built_in">queue</span>[maxsize];</span><br><span class="line">	bitree *p;</span><br><span class="line">	<span class="keyword">int</span> front,rear;</span><br><span class="line">	front=<span class="number">1</span>;rear=<span class="number">0</span>;</span><br><span class="line">	root=<span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		p=(bitree*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(bitree));</span><br><span class="line">		p-&gt;data=arrayA[i];</span><br><span class="line">		p-&gt;lchild=<span class="literal">NULL</span>;</span><br><span class="line">		p-&gt;rchild=<span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">		rear++;</span><br><span class="line">		<span class="built_in">queue</span>[rear]=p;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(rear==<span class="number">1</span>)</span><br><span class="line">			root=p;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(i%<span class="number">2</span>==<span class="number">0</span>)</span><br><span class="line">				<span class="built_in">queue</span>[front]-&gt;lchild=p;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">queue</span>[front]-&gt;rchild=p;</span><br><span class="line">				front=front+<span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**********************************************\</span></span><br><span class="line"><span class="comment">函数功能：计算叶子节点个数</span></span><br><span class="line"><span class="comment">输入：    二叉树的根节点</span></span><br><span class="line"><span class="comment">输出：    叶子节点个数</span></span><br><span class="line"><span class="comment">\**********************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countleaf</span><span class="params">(bitree *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> count=<span class="number">0</span>;<span class="comment">//注意这里是静态变量，也可以改为全局变量</span></span><br><span class="line">	<span class="keyword">if</span>(p!=<span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		count=countleaf(p-&gt;lchild);</span><br><span class="line">		<span class="keyword">if</span>((p-&gt;lchild==<span class="literal">NULL</span>)&amp;&amp;(p-&gt;rchild==<span class="literal">NULL</span>))</span><br><span class="line">			count=count+<span class="number">1</span>;</span><br><span class="line">		count=countleaf(p-&gt;rchild);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**********************************************\</span></span><br><span class="line"><span class="comment">函数功能：计算树的深度</span></span><br><span class="line"><span class="comment">输入：    二叉树的根节点、当前树的深度</span></span><br><span class="line"><span class="comment">输出：    树的深度</span></span><br><span class="line"><span class="comment">\**********************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">treedepth</span><span class="params">(bitree*p,<span class="keyword">int</span> l)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> h=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(p!=<span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		l++;</span><br><span class="line">		<span class="keyword">if</span>(l&gt;h)</span><br><span class="line">			h=l;</span><br><span class="line">		h=treedepth(p-&gt;lchild,l);</span><br><span class="line">		h=treedepth(p-&gt;rchild,l);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>Algorithm Design</tag>
      </tags>
  </entry>
  <entry>
    <title>【算法导论】二叉树的广度优先遍历</title>
    <url>/2013/08/06/%5B20130806c%5D/</url>
    <content><![CDATA[<p><strong>广度优先遍历</strong>：又称按层次遍历，也就是先遍历二叉树的第一层节点，然后遍历第二层节点……最后遍历最下层节点。而对每一层的遍历是按照从左至右的方式进行的。</p>
<a id="more"></a>
<p><strong>基本思想</strong>：按照广度优先遍历的方式，上一层中先被访问的节点，它的下层孩子也必然先被访问，因此在算法实现时，需要使用一个队列。在遍历进行之前先把二叉树的根结点的存储地址入队，然后依次从队列中出队结点的存储地址，每出队一个结点的存储地址则对该结点进行访问，然后依次将该结点的左孩子和右孩子的存储地址入队，如此反复，直到队空为止。</p>
<p><strong>具体算法如下：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxsize 20</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> datatype;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	datatype data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span></span><br><span class="line">&#125;bitree;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Layer</span><span class="params">(bitree *p)</span></span>;</span><br><span class="line"><span class="function">bitree* <span class="title">CreatBitree</span><span class="params">(<span class="keyword">int</span>* arrayA,<span class="keyword">int</span> n)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countleaf</span><span class="params">(bitree *p)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">treedepth</span><span class="params">(bitree*p,<span class="keyword">int</span> l)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> arrayA[<span class="number">10</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;<span class="comment">//第一个节点没有用于存储数据</span></span><br><span class="line">	<span class="keyword">int</span> n=<span class="keyword">sizeof</span>(arrayA)/<span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line">    <span class="keyword">int</span> l=<span class="number">0</span>;<span class="comment">//二叉树的深度</span></span><br><span class="line">	bitree *head=<span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	head=CreatBitree(arrayA,n);</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"按广度优先搜索遍历的结果为："</span>);</span><br><span class="line">	Layer(head);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**************************************************\</span></span><br><span class="line"><span class="comment">函数功能：二叉树的广度优先遍历</span></span><br><span class="line"><span class="comment">输入：二叉树的根节点</span></span><br><span class="line"><span class="comment">输出：无</span></span><br><span class="line"><span class="comment">\**************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Layer</span><span class="params">(bitree *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	bitree* <span class="built_in">queue</span>[maxsize];<span class="comment">//queue数组用于存储节点地址</span></span><br><span class="line">	bitree* s;</span><br><span class="line">	<span class="keyword">int</span> rear=<span class="number">0</span>;  <span class="comment">//队列尾指针</span></span><br><span class="line">	<span class="keyword">int</span> front=<span class="number">0</span>; <span class="comment">//队列头指针</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(p!=<span class="literal">NULL</span>)<span class="comment">//输入的树不为空</span></span><br><span class="line">	&#123;</span><br><span class="line">		rear=<span class="number">1</span>; <span class="comment">//初始化</span></span><br><span class="line">		front=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">queue</span>[rear]=p;</span><br><span class="line">		<span class="keyword">while</span>(front&lt;rear)<span class="comment">//判断队列是否为空</span></span><br><span class="line">		&#123;</span><br><span class="line">			front++;</span><br><span class="line">			s=<span class="built_in">queue</span>[front];</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%d "</span>,s-&gt;data);</span><br><span class="line">			<span class="keyword">if</span>(s-&gt;lchild!=<span class="literal">NULL</span>) <span class="comment">//存储左右子节点</span></span><br><span class="line">			&#123;</span><br><span class="line">				rear++;</span><br><span class="line">				<span class="built_in">queue</span>[rear]=s-&gt;lchild;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(s-&gt;rchild!=<span class="literal">NULL</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				rear++;</span><br><span class="line">				<span class="built_in">queue</span>[rear]=s-&gt;rchild;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*************************************************\</span></span><br><span class="line"><span class="comment">函数功能：建立二叉树（按照顺序方式）</span></span><br><span class="line"><span class="comment">输入：    原始数组</span></span><br><span class="line"><span class="comment">输出：    二叉树的头结点</span></span><br><span class="line"><span class="comment">\*************************************************/</span></span><br><span class="line"><span class="function">bitree* <span class="title">CreatBitree</span><span class="params">(<span class="keyword">int</span>* arrayA,<span class="keyword">int</span> n)</span><span class="comment">//顺序存储 建立二叉树</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	bitree *root;</span><br><span class="line">	bitree *<span class="built_in">queue</span>[maxsize];</span><br><span class="line">	bitree *p;</span><br><span class="line">	<span class="keyword">int</span> front,rear;</span><br><span class="line">	front=<span class="number">1</span>;rear=<span class="number">0</span>;</span><br><span class="line">	root=<span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		p=(bitree*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(bitree));</span><br><span class="line">		p-&gt;data=arrayA[i];</span><br><span class="line">		p-&gt;lchild=<span class="literal">NULL</span>;</span><br><span class="line">		p-&gt;rchild=<span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">		rear++;</span><br><span class="line">		<span class="built_in">queue</span>[rear]=p;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(rear==<span class="number">1</span>)</span><br><span class="line">			root=p;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(i%<span class="number">2</span>==<span class="number">0</span>)</span><br><span class="line">				<span class="built_in">queue</span>[front]-&gt;lchild=p;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">queue</span>[front]-&gt;rchild=p;</span><br><span class="line">				front=front+<span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>Algorithm Design</tag>
      </tags>
  </entry>
  <entry>
    <title>【算法导论】二叉树的深度优先遍历</title>
    <url>/2013/08/06/%5B20130806b%5D/</url>
    <content><![CDATA[<p><strong>二叉树的遍历</strong>可以分为深度优先遍历和广度优先遍历。本篇介绍深度优先遍历，下一篇介绍广度优先遍历。</p>
<a id="more"></a>
<p>​    根据二叉树的递归定义可知，二叉树是由根结点(D)、左子树(L)和右子树(R)三个基本部分组成。只要能依次遍历这三个基本部分，便可遍历整个二叉树。这三个部分的排列组合为3！=6种，若限定按照先左后右进行遍历，则只有三种遍历方式：DLR(先序)、LDR(中序)、LRD(后序)。</p>
<p><strong>具体实现如下：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxsize 10</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> datatype;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	datatype data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span></span><br><span class="line">&#125; bitree;<span class="comment">//二叉树的节点结构</span></span><br><span class="line"></span><br><span class="line"><span class="function">bitree* <span class="title">CreatBitree</span><span class="params">(<span class="keyword">int</span>* arrayA,<span class="keyword">int</span> n)</span></span>;<span class="comment">//创建二叉树（以顺序存储方式）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preorder</span><span class="params">(bitree *p)</span></span>;<span class="comment">//先序遍历算法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">midorder</span><span class="params">(bitree *p)</span></span>;<span class="comment">//中序遍历算法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postorder</span><span class="params">(bitree *p)</span></span>;<span class="comment">//后序遍历算法</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> arrayA[<span class="number">9</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;;<span class="comment">//第一个节点没有用于存储数据，是为了方便计算</span></span><br><span class="line">	<span class="keyword">int</span> n=<span class="keyword">sizeof</span>(arrayA)/<span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line"></span><br><span class="line">	bitree *head=<span class="literal">NULL</span>;<span class="comment">//初始化指向链表的头指针</span></span><br><span class="line"></span><br><span class="line">	head=CreatBitree(arrayA,n);<span class="comment">//建立链表</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"前序遍历："</span>);</span><br><span class="line">	preorder(head);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\n中序遍历："</span>);</span><br><span class="line">	midorder(head);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\n后序遍历："</span>);</span><br><span class="line">	postorder(head);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">bitree* <span class="title">CreatBitree</span><span class="params">(<span class="keyword">int</span>* arrayA,<span class="keyword">int</span> n)</span><span class="comment">//顺序存储 建立二叉树</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	bitree *root;</span><br><span class="line">	bitree *<span class="built_in">queue</span>[maxsize];<span class="comment">//队列用于保存已输入节点的地址</span></span><br><span class="line">	bitree *p;</span><br><span class="line">	<span class="keyword">int</span> front,rear;</span><br><span class="line">	front=<span class="number">1</span>;rear=<span class="number">0</span>;<span class="comment">//指向队列的头尾</span></span><br><span class="line">	root=<span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		p=(bitree*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(bitree));<span class="comment">//创立节点并赋值</span></span><br><span class="line">		p-&gt;data=arrayA[i];</span><br><span class="line">		p-&gt;lchild=<span class="literal">NULL</span>;</span><br><span class="line">		p-&gt;rchild=<span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">		rear++;</span><br><span class="line">		<span class="built_in">queue</span>[rear]=p;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(rear==<span class="number">1</span>)<span class="comment">//判断是否为输入的第一个节点</span></span><br><span class="line">			root=p;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(i%<span class="number">2</span>==<span class="number">0</span>)<span class="comment">//新节点为左孩子</span></span><br><span class="line">				<span class="built_in">queue</span>[front]-&gt;lchild=p;</span><br><span class="line">			<span class="keyword">else</span><span class="comment">//新节点为右孩子</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">queue</span>[front]-&gt;rchild=p;</span><br><span class="line">				front=front+<span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preorder</span><span class="params">(bitree *p)</span><span class="comment">//前序遍历</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(p!=<span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d "</span>,p-&gt;data);</span><br><span class="line">		preorder(p-&gt;lchild);</span><br><span class="line">		preorder(p-&gt;rchild);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">midorder</span><span class="params">(bitree *p)</span><span class="comment">//中序遍历</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(p!=<span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		</span><br><span class="line">		midorder(p-&gt;lchild);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d "</span>,p-&gt;data);</span><br><span class="line">		midorder(p-&gt;rchild);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postorder</span><span class="params">(bitree *p)</span><span class="comment">//后序遍历</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(p!=<span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		postorder(p-&gt;lchild);</span><br><span class="line">		postorder(p-&gt;rchild);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d "</span>,p-&gt;data);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>Algorithm Design</tag>
      </tags>
  </entry>
  <entry>
    <title>【算法导论】二叉树的建立</title>
    <url>/2013/08/06/%5B20130806%5D/</url>
    <content><![CDATA[<h3 id=""><a href="#" class="headerlink" title=" "></a> </h3><p><strong>基本概念：</strong></p>
<p>​    <em>有序树与无序树</em>：若将树中的每个节点的各个子树都看成是从左到右有次序的，则称该树为有序树，否则为无序数。</p>
<a id="more"></a>
<p>​    <em>顺序存储</em>：从根节点起，自上而下，从左至右的方式对节点进行顺序编号，编号即对应为要存储的数组的下标。于是节点与数组元素就一一对应了。</p>
<p>​    <em>满二叉树、完全二叉树、非完全二叉树</em>的区别：</p>
<p>​        <img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20130806/20130806_fig001.jpg" width="500" height="250" title="图1" alt="图1" ></p>
<p><strong>二叉树的性质：</strong></p>
<ul>
<li><strong>性质1</strong> 在二叉树的第i层上至多有$2i-1$个结点($i≥1$)</li>
<li><strong>性质2</strong> 深度为k的二叉树至多有$2k－1$个结点($k≥1$)</li>
<li><strong>性质3</strong> 对任何一棵二叉树，如果其终端结点数为$n_0$，度为2的结点数为$n_2$，则$n_0=n_2+1$</li>
<li><strong>性质4</strong> 具有n个结点的完全二叉树的深度为$\lceil \log_2n\rceil+1$或$\lfloor\log_2(n+1)\rfloor$。</li>
</ul>
<p><strong>二叉树建立的基本思想：</strong>依次从原数组中读取结点信息，建立一个新结点来存储这个元素信息。若新结点是第一个结点，则令其为根结点，否则将新结点作为孩子链接到它的双亲结点上。如此反复进行，直到数组元素全部读完为止。为了使新结点能够与双亲结点正确相连，并考虑到这种方法中先建立的结点其孩子结点也一定先建立的特点，可以设置一个指针类型的数组构成的队列来保存已输入结点的地址，并使队尾(rear)指向当前输入的结点，队头(front)指向这个结点的双亲结点。由于根结点的地址放在队列的第一个单元里，所以当rear为偶数时（<strong>注意根节点不是数组的第一个元素</strong>），则rear所指的结点应作为左孩子与其双亲链接，否则rear所指的结点应作为右孩子与其双亲链接。若一个双亲结点与两个孩子链接完毕，则进行出队操作，使队头指针指向下一个待链接的双亲结点。</p>
<p><strong>具体算法如下：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxsize 10</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> datatype;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	datatype data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span></span><br><span class="line">&#125; bitree;<span class="comment">//二叉树的节点结构</span></span><br><span class="line"></span><br><span class="line"><span class="function">bitree* <span class="title">CreatBitree</span><span class="params">(<span class="keyword">int</span>* arrayA,<span class="keyword">int</span> n)</span></span>;<span class="comment">//创建二叉树（以顺序存储方式）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preorder</span><span class="params">(bitree *p)</span></span>;<span class="comment">//先序遍历算法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">midorder</span><span class="params">(bitree *p)</span></span>;<span class="comment">//中序遍历算法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postorder</span><span class="params">(bitree *p)</span></span>;<span class="comment">//后序遍历算法</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> arrayA[<span class="number">9</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;;<span class="comment">//第一个节点没有用于存储数据，是为了方便计算</span></span><br><span class="line">	<span class="keyword">int</span> n=<span class="keyword">sizeof</span>(arrayA)/<span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line"></span><br><span class="line">	bitree *head=<span class="literal">NULL</span>;<span class="comment">//初始化指向链表的头指针</span></span><br><span class="line"></span><br><span class="line">	head=CreatBitree(arrayA,n);<span class="comment">//建立链表</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">bitree* <span class="title">CreatBitree</span><span class="params">(<span class="keyword">int</span>* arrayA,<span class="keyword">int</span> n)</span><span class="comment">//顺序存储 建立二叉树</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	bitree *root;</span><br><span class="line">	bitree *<span class="built_in">queue</span>[maxsize];<span class="comment">//队列用于保存已输入节点的地址</span></span><br><span class="line">	bitree *p;</span><br><span class="line">	<span class="keyword">int</span> front,rear;</span><br><span class="line">	front=<span class="number">1</span>;rear=<span class="number">0</span>;<span class="comment">//指向队列的头尾</span></span><br><span class="line">	root=<span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		p=(bitree*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(bitree));<span class="comment">//创立节点并赋值</span></span><br><span class="line">		p-&gt;data=arrayA[i];</span><br><span class="line">		p-&gt;lchild=<span class="literal">NULL</span>;</span><br><span class="line">		p-&gt;rchild=<span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">		rear++;</span><br><span class="line">		<span class="built_in">queue</span>[rear]=p;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(rear==<span class="number">1</span>)<span class="comment">//判断是否为输入的第一个节点</span></span><br><span class="line">			root=p;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(i%<span class="number">2</span>==<span class="number">0</span>)<span class="comment">//新节点为左孩子</span></span><br><span class="line">				<span class="built_in">queue</span>[front]-&gt;lchild=p;</span><br><span class="line">			<span class="keyword">else</span><span class="comment">//新节点为右孩子</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">queue</span>[front]-&gt;rchild=p;</span><br><span class="line">				front=front+<span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>Algorithm Design</tag>
      </tags>
  </entry>
  <entry>
    <title>【算法导论】排序算法总结</title>
    <url>/2013/08/02/%5B20130802b%5D/</url>
    <content><![CDATA[<p>​    从六月初开始看算法导论，陆陆续续看了有2个月了，但实际看的时间只有半个月左右。这期间都忙着找导师、期末考试，同时还回家修养了十来天。真正专心的看算法是在离家返校后，由于没有考试和作业的烦恼，天天都沉浸在算法中，感觉效率较高。这段时间学到的东西较多，下面来总结一下：</p>
<a id="more"></a>
<p>​    <strong>学到的排序算法可以分为两类：比较排序、非比较排序。</strong>(这些排序算法的详细介绍及c程序实现在本文末都给出了链接，欢迎参考与指正！)</p>
<p>​    比较排序有：插入排序法、合并排序法、堆排序法、冒泡排序法、选择排序法、快速排序法等等、</p>
<p>​    非比较排序有：计数排序法、基数排序法、桶排序法。</p>
<p>​    下面以我的理解来分别说说它们各自的特点。不过在此之前，我先阐述两个概念： <strong>原地排序  稳定排序</strong></p>
<p>​    <strong>原地排序</strong>：如果对数组A进行排序，则这些数据是在A中进行重新排序的，在任何时候，至多只有其中的常数个数字是存储在数组之外的。</p>
<p>​    <strong>稳定排序</strong>：原数组中相同元素的相对位置（即前后关系）在经过排序后仍然不变。例如$a[5]={3,2,3,1,5}$,经过稳定排序后为：$a[5]={1,2,3,3,5}$.</p>
<p>​    谁最实用？对于较短的数组，比如说元素个数才十几二十个，用冒泡排序法就可以了，因为我们大多数人对冒泡排序法可谓是信手拈来，可以不假思索就可以写出，尽管其时间复杂度比较大。当然快速排序法是非常值得推荐的，他的适用范围很广，用的十分普遍。</p>
<p>​    <strong>插入排序</strong>：时间复杂度：$O(n*n)$，是原定排序，稳定排序(在本文中所有说稳定排序的意思是可以是稳定排序，对于是否是稳定排序，还取决于具体的程序，看进行数据间比较时是否带等号，但是快速排序肯定不是稳定排序)。其实我们玩斗地主，摸牌的过程就是在进行插入排序！当原始数组为正序排列时，所用时间最短；当原始数组为逆序排序时，所用时间最长。所以插入排序适合于原数组大多数元素已经排好的情况。(所谓正序、逆序只是相对的概念，如果要对数组从小到大排序，则如果原数组本身是从大到小排列的，则称为逆序，否则称为正序)。</p>
<p>​    <strong>合并排序</strong>：时间复杂度：$O(nlogn)$， 不是原地排序，可以是稳定排序。它和快速排序一样是基于分而治之的思想的（稍有不同），但是它比快速排序要快一点。尽管如此，由于它不是原地排序，需要占用较多空间，所以运用没有快速排序广泛。它和插入排序相比，它的最坏运行情况是$O(nlogn)$，插入排序的最坏运行情况为$O(n*n)$，但插入排序中的常数因子使得在$n$比较小时，运行要更快一点。</p>
<p>​    <strong>冒泡排序</strong>：时间复杂度为：$O(n*n)$，原地排序，稳定排序。由于平常遇到的排序都很简单，并且大家可以对冒泡排序信手拈来，因此用的十分普遍。</p>
<p>​    <strong>选择排序</strong>：时间复杂度为：$O(n*n)$，原地排序，稳定排序。实际上，选择排序和冒泡排序的思想上是一致的，只是在具体操作中使用了一点技巧，避免了数据的多次交换，因此运行时间比冒泡排序快一点。</p>
<p>​    <strong>堆排序</strong>：时间复杂度：$O(nlogn)$，是原地排序。它是将插入排序和合并排序的优点集于一身。像插入排序一样是原地排序，像合并排序一样运行时间为$O(nlogn)$。虽然堆排序是一个漂亮的算法，但是实际中，快速排序的一个好的实现往往要优于堆排序。但是堆有个很常见的应用：作为高效的优先级队列。</p>
<p>​    <strong>快速排序</strong>：时间复杂度：$O(nlogn)$，不稳定排序，原地排序。最坏的运行时间为$O(n*n)$，它的运行时间与划分的对称性有关。加入随机化后，在平均情况下，划分就能比较均匀，从而就能获得较好性能。</p>
<p>​    <strong>由定理可知，比较排序时间复杂度最好为$O(nlogn)$</strong>，在上述的比较排序算法中，时间复杂度为$O(nlogn)$较好的算法有：合并排序、堆排序、快速排序。其中快速排序运用最广泛，因为合并排序不是原地排序，需占用较多空间，堆排序的数据交换比较多。</p>
<p>​    <strong>计数排序</strong>：$O(n)$，稳定排序、不是原地排序。其思想比较独特，运用条件是数组的元素的值域在某一个范围内，并且由于不是原地排序，需要占用额外的内存，所以运用不是很广。</p>
<p>​    <strong>基数排序</strong>：$O(n)$，稳定排序、不是原地排序。基数排序就是不断地调用计数排序。其思想比较新颖，在进行比较两个数的大小是反其道而行之，先从个位数开始比较。相比于从高位开始比较，它避免了记录中间过程的值。</p>
<p>​    <strong>桶排序</strong>：$O(n)$，稳定排序、不是原地排序。也是基于分而治之的思想，先将序列进行分类，然后分别处理，最后再合并。与合并算法不同的是，合并的时候不需要进行比较。</p>
<p>​    上述的非比较排序中，其时间复杂度都是线性的，由于是非比较的排序，所以比较排序算法的下界$O(nlogn)$就不适用了。他们都只有在一些特定的条件下使用，因此运用不是很广泛，但是这些思想却是值得我们学习的。</p>
<p><strong>下面附上上述各个排序算法的详细介绍及C程序实现的链接，欢迎各位拍砖</strong>！</p>
<p>  比较排序：  <a href="http://blog.csdn.net/tengweitw/article/details/9006943" target="_blank" rel="noopener">插入排序</a>  <a href="http://blog.csdn.net/tengweitw/article/details/9056485" target="_blank" rel="noopener">合并排序</a>  <a href="http://blog.csdn.net/tengweitw/article/details/9152899" target="_blank" rel="noopener">堆排序</a> <a href="http://blog.csdn.net/tengweitw/article/details/9707525" target="_blank" rel="noopener">冒泡排序</a> <a href="http://blog.csdn.net/tengweitw/article/details/9707801" target="_blank" rel="noopener">选择排序</a> <a href="http://blog.csdn.net/tengweitw/article/details/9627659" target="_blank" rel="noopener">快速排序</a></p>
<p>非比较排序：  <a href="http://blog.csdn.net/tengweitw/article/details/9629567" target="_blank" rel="noopener">计数排序</a>  <a href="http://blog.csdn.net/tengweitw/article/details/9670303" target="_blank" rel="noopener">基数排序</a>  <a href="http://blog.csdn.net/tengweitw/article/details/9713333" target="_blank" rel="noopener">桶排序</a></p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>Algorithm Design</tag>
      </tags>
  </entry>
  <entry>
    <title>【算法导论】桶排序</title>
    <url>/2013/08/02/%5B20130802%5D/</url>
    <content><![CDATA[<p><strong>时间复杂度为</strong>：O(n)</p>
<p><strong>基本思想</strong>：将要排列的序列分成n组，每组分别进行排序，然后在合并到一起，这里面有分而治之的思想。</p>
<a id="more"></a>
<p><strong>实例说明</strong>：大家学c语言肯定学过switch-case结构，最常见的题型就是对成绩进行分类，但是这里我们是对其进行排名。假设有十个学生的成绩如下：78,17,39,26,72,94,21,12,23,68。我们可以把成绩先进行分段（称为桶），每十分分为一段，共分为10段。然后在每段内进行排序，每一段的排序可以采用插入排序，最后再进行合并即可。各段的内容为：</p>
<p> 桶编号：桶中元素</p>
<p>​      0： </p>
<p>​      1：12 、17</p>
<p>​      2：21 、23 、26</p>
<p>​      3：39</p>
<p>​      4：</p>
<p>​      5：</p>
<p>​      6：68</p>
<p>​      7：72 、 78</p>
<p>​      8：</p>
<p>​      9：94</p>
<p>具体的程序实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;malloc.h&gt;  </span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inc_sort</span><span class="params">(<span class="keyword">int</span> arrayA[],<span class="keyword">int</span> size,<span class="keyword">int</span> bucket_size)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span>  </span><br><span class="line">    <span class="keyword">int</span> key;  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> * <span class="title">next</span>;</span>  </span><br><span class="line">&#125;KeyNode;  </span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> raw[]=&#123;<span class="number">78</span>,<span class="number">17</span>,<span class="number">39</span>,<span class="number">26</span>,<span class="number">72</span>,<span class="number">94</span>,<span class="number">21</span>,<span class="number">12</span>,<span class="number">23</span>,<span class="number">68</span>&#125;;   </span><br><span class="line">    <span class="keyword">int</span> size=<span class="keyword">sizeof</span>(raw)/<span class="keyword">sizeof</span>(<span class="keyword">int</span>);     </span><br><span class="line">    inc_sort(raw,size,<span class="number">10</span>);  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/****************************************************\</span></span><br><span class="line"><span class="comment">函数功能：对输入数组进行桶排序</span></span><br><span class="line"><span class="comment">输入：数组及其大小、桶的大小</span></span><br><span class="line"><span class="comment">输出：无</span></span><br><span class="line"><span class="comment">\****************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inc_sort</span><span class="params">(<span class="keyword">int</span> arrayA[],<span class="keyword">int</span> size,<span class="keyword">int</span> bucket_size)</span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    KeyNode **bucket=(KeyNode **)<span class="built_in">malloc</span>(bucket_size*<span class="keyword">sizeof</span>(KeyNode *)); <span class="comment">//指向指针的指针，bucket相当于二维数组 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;bucket_size;i++)</span><br><span class="line">	&#123;  </span><br><span class="line">        bucket[i]=(KeyNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(KeyNode));<span class="comment">//动态开辟空间  </span></span><br><span class="line">        bucket[i]-&gt;key=<span class="number">0</span>; <span class="comment">//初始化桶中的数据  </span></span><br><span class="line">        bucket[i]-&gt;next=<span class="literal">NULL</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;size;j++)</span><br><span class="line">	&#123;  </span><br><span class="line">        KeyNode *node=(KeyNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(KeyNode));<span class="comment">//创立节点</span></span><br><span class="line">        node-&gt;key=arrayA[j];  </span><br><span class="line">        node-&gt;next=<span class="literal">NULL</span>;  </span><br><span class="line">       </span><br><span class="line">        <span class="keyword">int</span> index=arrayA[j]/<span class="number">10</span>; <span class="comment">//映射函数计算桶号和散列函数相似    </span></span><br><span class="line">          </span><br><span class="line">        KeyNode *p=bucket[index];<span class="comment">//初始化p成为桶中数据链表的头指针  </span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(p-&gt;key==<span class="number">0</span>)<span class="comment">//当桶中还没有数据   </span></span><br><span class="line">            bucket[index]-&gt;next=node;  </span><br><span class="line">   		<span class="keyword">else</span></span><br><span class="line">		&#123;  </span><br><span class="line">            <span class="comment">//链表结构的插入排序  </span></span><br><span class="line">            <span class="keyword">while</span>((p-&gt;next!=<span class="literal">NULL</span>)&amp;&amp;(p-&gt;next-&gt;key&lt;=node-&gt;key))<span class="comment">//插入的数据大于当前数据时，从头结点开始</span></span><br><span class="line">                p=p-&gt;next;                                   <span class="comment">//直到找到大于它的节点为止</span></span><br><span class="line">            node-&gt;next=p-&gt;next;  </span><br><span class="line">            p-&gt;next=node;        </span><br><span class="line">        &#125; </span><br><span class="line">		(bucket[index]-&gt;key)++;</span><br><span class="line">    &#125;  </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;bucket_size;i++)  </span><br><span class="line">	&#123;</span><br><span class="line">        <span class="keyword">for</span>(KeyNode *k=bucket[i]-&gt;next; k!=<span class="literal">NULL</span>; k=k-&gt;next)  </span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%d "</span>,k-&gt;key); </span><br><span class="line">	<span class="comment">//	printf("\n");</span></span><br><span class="line">	&#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>); </span><br><span class="line"></span><br><span class="line">	<span class="built_in">free</span>(bucket);<span class="comment">//记得释放申请的内存空间</span></span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>Algorithm Design</tag>
      </tags>
  </entry>
  <entry>
    <title>【算法导论】选择排序</title>
    <url>/2013/08/01/%5B20130801b%5D/</url>
    <content><![CDATA[<p>​    <strong>选择排序</strong>其实是冒泡法的一种改进，<strong>其基本思路</strong>也是：先确定最小元素，再找次最小元素，最后确定最大元素。</p>
<a id="more"></a>
<p>​    它与冒泡排序的<strong>最大区别</strong>在于：冒泡排序是只要碰见比它大的元素就交换，而选择排序是直接将元素放在最终的确定位置，从而避免了多次交换过程。</p>
<p>​    <strong>举例说明：</strong>数组$a[5]={3,4,2,5,1}$.通过一轮比较知$1$应当放在数组$a[0]$上。所以我们可以直接将$a[0]$与$a[4]$进行交换，从而避免了$a[4]$在比较过程中与其它元素的交换。在中间比较时，不需要记录值，只需要记住索引就可找到元素。</p>
<p>  具体程序如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SelectSort</span><span class="params">(<span class="keyword">int</span>* arrayA,<span class="keyword">int</span> n)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> arrayA[]=&#123;<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">5</span>&#125;;</span><br><span class="line">	<span class="keyword">int</span> n=<span class="keyword">sizeof</span>(arrayA)/<span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line">	SelectSort(arrayA,n);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d "</span>,arrayA[i]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SelectSort</span><span class="params">(<span class="keyword">int</span>* arrayA,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> index=i;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;n;j++)<span class="comment">//注意j从i+1开始，因为前面的元素已经排好了</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(arrayA[j]&lt;arrayA[index])</span><br><span class="line">				index=j;<span class="comment">//只需要记录索引值</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//如果当前最小数据索引不是i，也就是说排在i位置的数据在index处</span></span><br><span class="line">        <span class="keyword">if</span> (index!=i)        </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//交换数据，确定i位置的数据。</span></span><br><span class="line">            <span class="keyword">int</span> temp = arrayA[i];</span><br><span class="line">            arrayA[i] = arrayA[index];</span><br><span class="line">            arrayA[index] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>Algorithm Design</tag>
      </tags>
  </entry>
  <entry>
    <title>【算法导论】冒泡排序</title>
    <url>/2013/08/01/%5B20130801%5D/</url>
    <content><![CDATA[<p><strong>时间复杂度</strong>：O(n*n)</p>
<p><strong>基本思想</strong>：从数组最后一个元素开始，依次与前一个元素比较，若比前一个元素小，则与之交换位置，然后再与当前前一个元素比较，直到遇到比它大的元素为止。例如：假设数组为：$a[5]={3,4,2,5,1}$;则运算过程为：首先$1$与$5$比较，由于$1&lt;5$，从而交换位置，数组变为$a[5]={3,4,2,1,5}$;然后$1$与当前前一个元素$2$比较，一直重复上述操作，经过一次循环后，数组变为$a[5]={1,3,4,2,5}$;第二次循环从倒数第二个元素开始……，总共循环$n-1$次就可以得到正确结果。总的来说，首先将最小的元素放在数组前面，然后放次最小的元素，依此类推。</p>
<a id="more"></a>
<p>上述过程的图解为：</p>
<p>​     <img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20130801/20130801_fig001.jpg" width="550" height="200" title="图1" alt="图1" ></p>
<p>注：这里的红色为要进行比较的元素。</p>
<p>具体实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort</span><span class="params">(<span class="keyword">int</span>* arrayA,<span class="keyword">int</span> n)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> arrayA[]=&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">5</span>&#125;;</span><br><span class="line">	<span class="keyword">int</span> n=<span class="keyword">sizeof</span>(arrayA)/<span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line"></span><br><span class="line">	BubbleSort(arrayA,n);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d "</span>,arrayA[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort</span><span class="params">(<span class="keyword">int</span>* arrayA,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=n<span class="number">-1</span>;j&gt;i;j--)<span class="comment">//j&gt;i即可是因为前面的元素已经排好了</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> temp=<span class="number">0</span>;</span><br><span class="line">			<span class="keyword">if</span>(arrayA[j]&lt;arrayA[j<span class="number">-1</span>])</span><br><span class="line">			&#123;</span><br><span class="line">				temp=arrayA[j];</span><br><span class="line">				arrayA[j]=arrayA[j<span class="number">-1</span>];</span><br><span class="line">				arrayA[j<span class="number">-1</span>]=temp;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line"></span><br><span class="line">		&#125;	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>Algorithm Design</tag>
      </tags>
  </entry>
  <entry>
    <title>【算法导论】基数排序</title>
    <url>/2013/07/31/%5B20130731c%5D/</url>
    <content><![CDATA[<p><strong>时间复杂度</strong>：$O(n)$.</p>
<p><strong>基本思路</strong>：两个数比较大小，我们的直观感觉是先比较高位，若相同则比较低位。但是这样做需要记录额外的数据，浪费空间。而基数排序则是先比较低位，再比较高位。通过各个位的比较进行排序，如果数组元素最大有$N$位，则总共需要$N$次排序。注意：按位排序必须是稳定排序（两个相等的数其在序列的前后位置顺序，在排序前后不改变），所以在这我选择了计数排序。</p>
<a id="more"></a>
<p>具体操作见下图：</p>
<p>​     <img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20130731c/20130731c_fig001.jpg" width="400" height="300" title="图1" alt="图1" ></p>
<p><strong>具体实现如下</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CountSort</span><span class="params">(<span class="keyword">int</span>* arrayA,<span class="keyword">int</span>* arrayD,<span class="keyword">int</span> n,<span class="keyword">int</span> k)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RadixSort</span><span class="params">(<span class="keyword">int</span>* arrayA,<span class="keyword">int</span> n)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> arrayD[]=&#123;<span class="number">1046</span>,<span class="number">2084</span>,<span class="number">9046</span>,<span class="number">12074</span>,<span class="number">56</span>,<span class="number">7026</span>,<span class="number">8099</span>,<span class="number">17059</span>,<span class="number">33</span>,<span class="number">1</span>&#125;;</span><br><span class="line">	<span class="keyword">int</span> n=<span class="keyword">sizeof</span>(arrayD)/<span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line">	RadixSort(arrayD,n);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d "</span>,arrayD[i]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/****************************************\</span></span><br><span class="line"><span class="comment">函数功能：进行非比较的计数排序</span></span><br><span class="line"><span class="comment">输入：数组D为原始数组</span></span><br><span class="line"><span class="comment">输出：无</span></span><br><span class="line"><span class="comment">\****************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RadixSort</span><span class="params">(<span class="keyword">int</span>* arrayD,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> base=<span class="number">1</span>;<span class="comment">//用于取出各个位</span></span><br><span class="line">	<span class="keyword">int</span>* arrayA=(<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;<span class="number">5</span>;k++)<span class="comment">//这里的5由原始数组最大数据位数确定</span></span><br><span class="line">	&#123;	</span><br><span class="line">		base*=<span class="number">10</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)<span class="comment">//这里用来取各个位上的数</span></span><br><span class="line">		&#123;</span><br><span class="line">			arrayA[i]=arrayD[i]%base;</span><br><span class="line">			arrayA[i]/=base/<span class="number">10</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		CountSort(arrayA,arrayD,n,<span class="number">10</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">free</span>(arrayA);<span class="comment">//记得释放空间</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/****************************************\</span></span><br><span class="line"><span class="comment">函数功能：进行非比较的计数排序</span></span><br><span class="line"><span class="comment">输入：数组A、D，D为原始数组</span></span><br><span class="line"><span class="comment">输出：无</span></span><br><span class="line"><span class="comment">\****************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CountSort</span><span class="params">(<span class="keyword">int</span>* arrayA,<span class="keyword">int</span>*arrayD,<span class="keyword">int</span> n,<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span>* arrayB=(<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*n);</span><br><span class="line">	<span class="keyword">int</span>* arrayC=(<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*k);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=k;i++)</span><br><span class="line">		arrayC[i]=<span class="number">0</span>;<span class="comment">//数组C初始化</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">		arrayC[arrayA[j]]=arrayC[arrayA[j]]+<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k;i++)</span><br><span class="line">		arrayC[i]=arrayC[i]+arrayC[i<span class="number">-1</span>];<span class="comment">//得到各个元素的位置</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> j=n<span class="number">-1</span>;j&gt;=<span class="number">0</span>;j--)</span><br><span class="line">	&#123;</span><br><span class="line">		arrayB[arrayC[arrayA[j]]<span class="number">-1</span>]=arrayD[j];</span><br><span class="line">		arrayC[arrayA[j]]=arrayC[arrayA[j]]<span class="number">-1</span>;<span class="comment">//进行计数排序</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		arrayD[i]=arrayB[i];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>Algorithm Design</tag>
      </tags>
  </entry>
  <entry>
    <title>【算法导论】第$i$小的元素</title>
    <url>/2013/07/31/%5B20130731b%5D/</url>
    <content><![CDATA[<p>   <strong>时间复杂度</strong>：$O(n)$.</p>
<p>   <strong>基本思想</strong>：和快速排序的思想相似，也是对数组进行递归划分，但是有所差别的是，快速排序会递归处理划分的两边，而随机化的选择算法只选择一边。</p>
<a id="more"></a>
<p>   <strong>具体步骤为</strong>:<strong>首先</strong>，随机选择一个数组元素作为主元，从而将数组分解为两个子数组，并得到主元在元素中的位置$q$，假设较小子数组元素的个数为$k-1$；<strong>然后</strong>比较$i$与$k$的大小，来确定下一次递归选择哪一边的子数组（注意$i$的值的改变情况）；<strong>最后</strong>，当$i==k$时，就求得了第$i$小的元素。<strong>具体实例见图解</strong>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20130731b/20130731_fig001.jpg" width="600" height="650" title="图1" alt="图1" ></p>
<p><strong>具体的程序实现如下：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Partition</span><span class="params">(<span class="keyword">int</span>*arrayA,<span class="keyword">int</span> n,<span class="keyword">int</span> p,<span class="keyword">int</span> r)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RandomPartition</span><span class="params">(<span class="keyword">int</span>* arrayA,<span class="keyword">int</span> n,<span class="keyword">int</span> p,<span class="keyword">int</span> r)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RandomSelect</span><span class="params">(<span class="keyword">int</span>* arrayA,<span class="keyword">int</span> n,<span class="keyword">int</span> p,<span class="keyword">int</span> r,<span class="keyword">int</span> i)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> arrayA[<span class="number">8</span>]=&#123;<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">5</span>&#125;;</span><br><span class="line">	<span class="keyword">int</span> n=<span class="keyword">sizeof</span>(arrayA)/<span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line">	<span class="keyword">int</span> p=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> r=<span class="number">7</span>;</span><br><span class="line">	<span class="keyword">int</span> i=<span class="number">4</span>;</span><br><span class="line">	<span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line">	result=RandomSelect(arrayA,n,p,r,i);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"数组中第%d小的数是%d\n"</span>,i,result);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**************************************************\</span></span><br><span class="line"><span class="comment">函数功能：将原数组分成全大于和全小于x的两个子数组</span></span><br><span class="line"><span class="comment">输入：原始数组、要对数组进行操作的起始和结束下标p、r</span></span><br><span class="line"><span class="comment">	  即只对数组指定部分进行操作。</span></span><br><span class="line"><span class="comment">输出：x在数组中的位置</span></span><br><span class="line"><span class="comment">\**************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Partition</span><span class="params">(<span class="keyword">int</span>*arrayA,<span class="keyword">int</span> n,<span class="keyword">int</span> p,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> x=arrayA[r];<span class="comment">//使主元x选为数组选中部分的最后一个元素</span></span><br><span class="line">	<span class="keyword">int</span> i=p<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">int</span> temp=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> j=p;j&lt;=r<span class="number">-1</span>;j++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(arrayA[j]&lt;=x)</span><br><span class="line">		&#123;</span><br><span class="line">			i++;</span><br><span class="line">			temp=arrayA[i];</span><br><span class="line">			arrayA[i]=arrayA[j];</span><br><span class="line">			arrayA[j]=temp;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	temp=arrayA[i+<span class="number">1</span>];</span><br><span class="line">	arrayA[i+<span class="number">1</span>]=arrayA[r];</span><br><span class="line">	arrayA[r]=temp;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> i+<span class="number">1</span>;<span class="comment">//最终主元的位置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**************************************************\</span></span><br><span class="line"><span class="comment">函数功能：用随机数确定主元</span></span><br><span class="line"><span class="comment">输入：原始数组、要对数组进行操作的起始和结束下标p、r</span></span><br><span class="line"><span class="comment">	  即只对数组指定部分进行操作</span></span><br><span class="line"><span class="comment">输出：x在数组中的位置</span></span><br><span class="line"><span class="comment">\**************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RandomPartition</span><span class="params">(<span class="keyword">int</span>* arrayA,<span class="keyword">int</span> n,<span class="keyword">int</span> p,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> suiji=<span class="number">0</span>;</span><br><span class="line">	srand(time(<span class="number">0</span>));</span><br><span class="line">	suiji=rand()%(r-p)+p;<span class="comment">//产生大于等于p,小于r的随机数</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"suiji=%d\n"</span>,suiji);</span><br><span class="line">	<span class="keyword">int</span> temp=<span class="number">0</span>;</span><br><span class="line">	temp=arrayA[r]; <span class="comment">//使主元由随机数确定</span></span><br><span class="line">	arrayA[r]=arrayA[suiji];</span><br><span class="line">	arrayA[suiji]=temp;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> Partition(arrayA,n,p,r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**************************************************\</span></span><br><span class="line"><span class="comment">函数功能：找出数组中第i小的数</span></span><br><span class="line"><span class="comment">输入：原始数组、要对数组进行操作的起始和结束下标p、r</span></span><br><span class="line"><span class="comment">	  即只对数组指定部分进行操作</span></span><br><span class="line"><span class="comment">输出：x在数组中的位置</span></span><br><span class="line"><span class="comment">\**************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RandomSelect</span><span class="params">(<span class="keyword">int</span>* arrayA,<span class="keyword">int</span> n,<span class="keyword">int</span> p,<span class="keyword">int</span> r,<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> q=<span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(p==r)</span><br><span class="line">		<span class="keyword">return</span> arrayA[p];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> j=p;j&lt;=r;j++)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d "</span>,arrayA[j]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">	q=RandomPartition(arrayA,n,p,r);<span class="comment">//主元的位置</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"gaihou:\n"</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> j=p;j&lt;=r;j++)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d "</span>,arrayA[j]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\n\n"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> k=q-p+<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(i==k)</span><br><span class="line">		<span class="keyword">return</span> arrayA[q];</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(i&lt;k)</span><br><span class="line">		<span class="keyword">return</span> RandomSelect(arrayA,n,p,q<span class="number">-1</span>,i);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> RandomSelect(arrayA,n,q+<span class="number">1</span>,r,i-k);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>Algorithm Design</tag>
      </tags>
  </entry>
  <entry>
    <title>【算法导论】最大值和最小值</title>
    <url>/2013/07/31/%5B20130731%5D/</url>
    <content><![CDATA[<p><strong>时间复杂度</strong>:$O(3*floor(n/2))$</p>
<p><strong>基本思想</strong>：成对地处理元素。先将一对输入元素相互比较，然后把较小的与当前最小值比较，较大的与当前最大值比较，因此每两个元素比较三次。</p>
<a id="more"></a>
<p><strong>注意分情况</strong>：当n为奇数时，将最大值和最小值都设置为第一个元素值；当n为偶数时，将前两个元素较大的元素设置为最大值，较小的设置为最小值。</p>
<p><strong>其具体实现如下</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MinMax</span><span class="params">(<span class="keyword">int</span>* arrayA,<span class="keyword">int</span> n,<span class="keyword">int</span>* minmax)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> minmax[<span class="number">2</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="keyword">int</span> arrayA[<span class="number">10</span>]=&#123;<span class="number">4</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">9</span>&#125;;</span><br><span class="line">	<span class="keyword">int</span> n=<span class="keyword">sizeof</span>(arrayA)/<span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line"></span><br><span class="line">	MinMax(arrayA,n,minmax);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Min=%d Max=%d\n"</span>,minmax[<span class="number">0</span>],minmax[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**************************************************\</span></span><br><span class="line"><span class="comment">函数功能：查找最大值和最小值</span></span><br><span class="line"><span class="comment">输入：原始数组、用于存储最大最小值的数组</span></span><br><span class="line"><span class="comment">输出：无</span></span><br><span class="line"><span class="comment">\**************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MinMax</span><span class="params">(<span class="keyword">int</span>* arrayA,<span class="keyword">int</span> n,<span class="keyword">int</span>* minmax)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> min=<span class="number">0</span>;<span class="comment">//初始化</span></span><br><span class="line">	<span class="keyword">int</span> max=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(n%<span class="number">2</span>==<span class="number">0</span>)<span class="comment">//n为奇数</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(arrayA[<span class="number">0</span>]&gt;arrayA[<span class="number">1</span>])</span><br><span class="line">		&#123;</span><br><span class="line">			max=arrayA[<span class="number">0</span>];</span><br><span class="line">			min=arrayA[<span class="number">1</span>];<span class="comment">//最大最小值分别赋值为第一二元素</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			max=arrayA[<span class="number">1</span>];</span><br><span class="line">			min=arrayA[<span class="number">0</span>];</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;n<span class="number">-1</span>;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(arrayA[i]&gt;arrayA[i+<span class="number">1</span>])</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(arrayA[i]&gt;max)</span><br><span class="line">					max=arrayA[i];</span><br><span class="line">				<span class="keyword">if</span>(arrayA[i+<span class="number">1</span>]&lt;min)</span><br><span class="line">					min=arrayA[i+<span class="number">1</span>];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(arrayA[i+<span class="number">1</span>]&gt;max)</span><br><span class="line">					max=arrayA[i+<span class="number">1</span>];</span><br><span class="line">				<span class="keyword">if</span>(arrayA[i]&lt;min)</span><br><span class="line">					min=arrayA[i];</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span><span class="comment">//n为偶数</span></span><br><span class="line">	&#123;</span><br><span class="line">		max=min=arrayA[<span class="number">0</span>];<span class="comment">//最大最小值都赋值为第一个元素</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;n<span class="number">-1</span>;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(arrayA[j]&gt;arrayA[j+<span class="number">1</span>])</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(arrayA[j]&gt;max)</span><br><span class="line">					max=arrayA[j];</span><br><span class="line">				<span class="keyword">if</span>(arrayA[j+<span class="number">1</span>]&lt;min)</span><br><span class="line">					min=arrayA[j+<span class="number">1</span>];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(arrayA[j+<span class="number">1</span>]&gt;max)</span><br><span class="line">					max=arrayA[j+<span class="number">1</span>];</span><br><span class="line">				<span class="keyword">if</span>(arrayA[j]&lt;min)</span><br><span class="line">					min=arrayA[j];</span><br><span class="line">			&#125;		</span><br><span class="line">		</span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">	minmax[<span class="number">0</span>]=min;</span><br><span class="line">	minmax[<span class="number">1</span>]=max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>Algorithm Design</tag>
      </tags>
  </entry>
  <entry>
    <title>【算法导论】计数排序</title>
    <url>/2013/07/30/%5B20130730b%5D/</url>
    <content><![CDATA[<p><strong>比较排序</strong>：通过元素间的比较对序列进行排序的算法称为比较排序。</p>
<p>常见的比较排序算法有：冒泡排序法、插入排序法、合并排序法、快速排序法，堆排序法等等。任何比较排序法在最坏情况下的时间复杂度为$O(nlogn)$。因此，<strong>合并排序和堆排序是渐进最优的</strong>。</p>
<a id="more"></a>
<p><strong>非比较排序</strong>：用非比较的方法来进行排序的算法。</p>
<p>常见的非比较排序算法有：计数排序法、基数排序法、桶排序法。<strong>它们都是以线性时间运行的</strong>。由于是非比较的，因此下界$O(nlogn)$对它们是不适用的。</p>
<p>下面来讨论<strong>计数排序</strong>：</p>
<p><strong>前提假设</strong>：序列的值域在$0$到$k$之间。</p>
<p><strong>时间复杂度</strong>：$O(n)$</p>
<p><strong>基本思想</strong>：对于序列中的每一个元素，计算得到小于该元素的元素个数，从而确定了该元素在最终输出元素的位置。</p>
<p>从下图中可以了解算法的过程（其中A数组是原始序列，B数组为最终序列，C数组为临时辅助序列。）：</p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20130730b/20130730b_fig001.jpg" width="700" height="450" title="图1" alt="图1" ></p>
<p><strong>注</strong>：黑色方框看不清不要紧，代表的是B数组还没有填充的空间</p>
<p><strong>具体的实现如下：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CountSort</span><span class="params">(<span class="keyword">int</span>* arrayA,<span class="keyword">int</span>* arrayB,<span class="keyword">int</span>* arrayC,<span class="keyword">int</span> n,<span class="keyword">int</span> k)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> arrayA[<span class="number">8</span>]=&#123;<span class="number">2</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">3</span>&#125;;</span><br><span class="line">	<span class="keyword">int</span> arrayB[<span class="number">8</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="keyword">int</span> n=<span class="keyword">sizeof</span>(arrayA)/<span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line">	<span class="keyword">int</span> k=<span class="number">5</span>;<span class="comment">//k为数组中的最大值</span></span><br><span class="line">	<span class="keyword">int</span> arrayC[<span class="number">6</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">	CountSort(arrayA,arrayB,arrayC,n,k);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d "</span>,arrayB[i]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/****************************************\</span></span><br><span class="line"><span class="comment">函数功能：进行非比较的计数排序</span></span><br><span class="line"><span class="comment">输入：数组A、B、C（注意A　B长度相同，与C不一定相同）</span></span><br><span class="line"><span class="comment">输出：无</span></span><br><span class="line"><span class="comment">\****************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CountSort</span><span class="params">(<span class="keyword">int</span>* arrayA,<span class="keyword">int</span>* arrayB,<span class="keyword">int</span>* arrayC,<span class="keyword">int</span> n,<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=k;i++)</span><br><span class="line">		arrayC[i]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">		arrayC[arrayA[j]]=arrayC[arrayA[j]]+<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k;i++)</span><br><span class="line">		arrayC[i]=arrayC[i]+arrayC[i<span class="number">-1</span>];</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> j=n<span class="number">-1</span>;j&gt;=<span class="number">0</span>;j--)</span><br><span class="line">	&#123;</span><br><span class="line">		arrayB[arrayC[arrayA[j]]<span class="number">-1</span>]=arrayA[j];</span><br><span class="line">		arrayC[arrayA[j]]=arrayC[arrayA[j]]<span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>Algorithm Design</tag>
      </tags>
  </entry>
  <entry>
    <title>【算法导论】快速排序</title>
    <url>/2013/07/30/%5B20130730%5D/</url>
    <content><![CDATA[<p>​    快速排序的最坏运行时间为$O(n^2)$，虽然这最坏情况的时间复杂度比较大，但快速排序通常是用于排序的最佳实用选择，这是因为其平均性能相当好，平均时间复杂度为$O(nlogn)$，并且$O(nlogn)$中的隐含常数因子很小。另外，它能够进行就地排序，因此在虚拟内存中也能较好的运行。</p>
<a id="more"></a>
<p>​    快速排序算法的性能：其运行时间与划分是否对称有关，而是否对称与主元的选取有关。从渐进的意义上讲，如果对称，就和合并的算法一样快，如果不对称，就和插入排序算法一样慢。需要注意的是，但每次递归是都是按照常数比例划分时，从渐进意义上看，与对称划分效果一样，都是$O(nlogn)$.</p>
<p>​    <strong>和合并排序一样，快速排序也是基于分治模式的</strong>。分治过程分为三个步骤：分解、解决、合并。</p>
<p>​    快速合并的<strong>基本思想</strong>：从要排序的序列中，随意取一个值作为主元，从而将序列以此分为大于和小于主元的两个子序列，然后重复上述过程（递归调用）。</p>
<p>下面以一个分解过程为例：</p>
<p>​    假设要排序的序列为：2、8、7、1、3、5、6、4。首先，随便选取主元，在这里我们选择4；其次，通过分解将原序列分为子序列2、1、3和子序列7、5、6、8；最后分别以两个子序列为原序列，不断重复上述过程。分解过程的图解如下：</p>
<p>​     <img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20130730/20130730_fig001.jpg" width="600" height="650" title="图1" alt="图1" ></p>
<p> 具体实现如下：</p>
<ul>
<li><p>分解过程：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**************************************************\</span></span><br><span class="line"><span class="comment">函数功能：将原数组分成全大于和全小于x的两个子数组</span></span><br><span class="line"><span class="comment">输入：原始数组、要对数组进行操作的起始和结束下标</span></span><br><span class="line"><span class="comment">输出：x在数组中的位置</span></span><br><span class="line"><span class="comment">\**************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Partition</span><span class="params">(<span class="keyword">int</span>*Array,<span class="keyword">int</span> n,<span class="keyword">int</span> p,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> x=Array[r];</span><br><span class="line">	<span class="keyword">int</span> i=p<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">int</span> temp=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> j=p;j&lt;=r<span class="number">-1</span>;j++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(Array[j]&lt;=x)</span><br><span class="line">		&#123;</span><br><span class="line">			i++;</span><br><span class="line">			temp=Array[i];</span><br><span class="line">			Array[i]=Array[j];</span><br><span class="line">			Array[j]=temp;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	temp=Array[i+<span class="number">1</span>];</span><br><span class="line">	Array[i+<span class="number">1</span>]=Array[r];</span><br><span class="line">	Array[r]=temp;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>递归过程：</p>
</li>
</ul>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**************************************************\</span></span><br><span class="line"><span class="comment">函数功能：递归调用分解函数，进行快速排序</span></span><br><span class="line"><span class="comment">输入：原始数组、要对数组进行操作的起始和结束下标</span></span><br><span class="line"><span class="comment">输出：无</span></span><br><span class="line"><span class="comment">\**************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(<span class="keyword">int</span>* Array,<span class="keyword">int</span> n,<span class="keyword">int</span> p,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> q=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(p&lt;r)</span><br><span class="line">	&#123;</span><br><span class="line">		q=Partition(Array,n,p,r);</span><br><span class="line">		QuickSort(Array,n,p,q<span class="number">-1</span>);</span><br><span class="line">		QuickSort(Array,n,q+<span class="number">1</span>,r);</span><br><span class="line">	&#125;</span><br><span class="line">｝</span><br></pre></td></tr></table></figure>
<p>  完整实例：</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Partition</span><span class="params">(<span class="keyword">int</span>*Array,<span class="keyword">int</span> n,<span class="keyword">int</span> p,<span class="keyword">int</span> r)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(<span class="keyword">int</span>* Array,<span class="keyword">int</span> n,<span class="keyword">int</span> p,<span class="keyword">int</span> r)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> Array[<span class="number">8</span>]=&#123;<span class="number">2</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">4</span>&#125;;</span><br><span class="line">	<span class="keyword">int</span> n=<span class="keyword">sizeof</span>(Array)/<span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line">	<span class="keyword">int</span> p=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> r=n<span class="number">-1</span>;</span><br><span class="line">	QuickSort(Array,n,p,r);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;n;k++)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d "</span>,Array[k]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**************************************************\</span></span><br><span class="line"><span class="comment">函数功能：将原数组分成全大于和全小于x的两个子数组</span></span><br><span class="line"><span class="comment">输入：原始数组、要对数组进行操作的起始和结束下标</span></span><br><span class="line"><span class="comment">输出：x在数组中的位置</span></span><br><span class="line"><span class="comment">\**************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Partition</span><span class="params">(<span class="keyword">int</span>*Array,<span class="keyword">int</span> n,<span class="keyword">int</span> p,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> x=Array[r];</span><br><span class="line">	<span class="keyword">int</span> i=p<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">int</span> temp=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> j=p;j&lt;=r<span class="number">-1</span>;j++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(Array[j]&lt;=x)</span><br><span class="line">		&#123;</span><br><span class="line">			i++;</span><br><span class="line">			temp=Array[i];</span><br><span class="line">			Array[i]=Array[j];</span><br><span class="line">			Array[j]=temp;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	temp=Array[i+<span class="number">1</span>];</span><br><span class="line">	Array[i+<span class="number">1</span>]=Array[r];</span><br><span class="line">	Array[r]=temp;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**************************************************\</span></span><br><span class="line"><span class="comment">函数功能：递归调用分解函数，进行快速排序</span></span><br><span class="line"><span class="comment">输入：原始数组、要对数组进行操作的起始和结束下标</span></span><br><span class="line"><span class="comment">输出：无</span></span><br><span class="line"><span class="comment">\**************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(<span class="keyword">int</span>* Array,<span class="keyword">int</span> n,<span class="keyword">int</span> p,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> q=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(p&lt;r)</span><br><span class="line">	&#123;</span><br><span class="line">		q=Partition(Array,n,p,r);</span><br><span class="line">		QuickSort(Array,n,p,q<span class="number">-1</span>);</span><br><span class="line">		QuickSort(Array,n,q+<span class="number">1</span>,r);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>Algorithm Design</tag>
      </tags>
  </entry>
  <entry>
    <title>【算法导论】堆排序</title>
    <url>/2013/06/22/%5B20130622%5D/</url>
    <content><![CDATA[<p>​    堆排序像合并排序一样，时间复杂度为$O(nlogn)$;像插入排序一样，是一种原地排序（在任何时候只有常数个元素存储在数组外）。</p>
<a id="more"></a>
<p>​    <strong>二叉堆的概念</strong>：是一种数组对象，可以被视为一棵完全二叉树，树的每一层都是填满的，最后一层可能除外。</p>
<p>​    <strong>二叉树有两种：最大堆和最小堆</strong>。最大堆：父节点不小于子节点。最小堆：父节点不大于子节点。在堆排序中我们使用最大堆；最小堆通常在构造优先队列时使用。</p>
<p>​    进行堆排序分为<strong>三个模块</strong>：1.保持最大堆性质；2.建堆；3：进行排序。</p>
<h4 id="保持最大堆性质"><a href="#保持最大堆性质" class="headerlink" title="保持最大堆性质"></a>保持最大堆性质</h4><p>​      以下图为例，使以$i$为根的子树成为最大堆：</p>
<p>​      <img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20130622/20130622_fig001.jpg" width="600" height="400" title="图1" alt="图1" ></p>
<p>  <strong>具体程序如下</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*****************************************\</span></span><br><span class="line"><span class="comment"> 输入：原始数组arrayA 父节点的下标i             </span></span><br><span class="line"><span class="comment"> 功能：使以i为根的子树成为最大堆</span></span><br><span class="line"><span class="comment"> 时间复杂度：lgn即树的层数</span></span><br><span class="line"><span class="comment">\*****************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MaxHeapify</span><span class="params">(<span class="keyword">int</span>* arrayA,<span class="keyword">int</span> n,<span class="keyword">int</span> i)</span><span class="comment">//i为父节点的在数组的下标</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> Length=n;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> l=<span class="number">2</span>*i;<span class="comment">//l为左子节点的在数组的下标</span></span><br><span class="line">	<span class="keyword">int</span> r=l+<span class="number">1</span>;<span class="comment">//r为右子节点的在数组的下标</span></span><br><span class="line">	<span class="keyword">int</span> largest=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> temp=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>((l&lt;Length)&amp;&amp;(arrayA[l]&gt;arrayA[i]))</span><br><span class="line">       largest=l;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		largest=i;</span><br><span class="line">	<span class="keyword">if</span>((r&lt;Length)&amp;&amp;(arrayA[r]&gt;arrayA[largest]))</span><br><span class="line">	    largest=r;</span><br><span class="line">	<span class="keyword">if</span>(largest!=i)</span><br><span class="line">	&#123;</span><br><span class="line">		temp=arrayA[i];</span><br><span class="line">		arrayA[i]=arrayA[largest];</span><br><span class="line">		arrayA[largest]=temp;</span><br><span class="line">		MaxHeapify(arrayA,n,largest);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="建堆：使数组arrayA中的元素成为最大堆"><a href="#建堆：使数组arrayA中的元素成为最大堆" class="headerlink" title="建堆：使数组arrayA中的元素成为最大堆"></a><strong>建堆</strong>：使数组arrayA中的元素成为最大堆</h4><p>​     <img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20130622/20130622_fig002.jpg" width="700" height="600" title="图2" alt="图2" ></p>
<p><strong>具体程序如下</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*****************************************\</span></span><br><span class="line"><span class="comment"> 输入：原始数组arrayA              </span></span><br><span class="line"><span class="comment"> 功能：使数组arrayA中的元素成为最大堆</span></span><br><span class="line"><span class="comment"> 时间复杂度：nlgn</span></span><br><span class="line"><span class="comment">\*****************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BuildMaxHeap</span><span class="params">(<span class="keyword">int</span>* arrayA,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=n/<span class="number">2</span>;i&gt;<span class="number">0</span>;i--)</span><br><span class="line">		MaxHeapify(arrayA,n,i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a><strong>堆排序</strong></h4><p>  <strong>主要思想</strong>是将每次的堆的顶节点与最末的叶节点进行交换，然后重新根据最大堆性质使得顶节点（根）成为最大值，如此循环。</p>
<p>​     <img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20130622/20130622_fig003.jpg" width="700" height="600" title="图3" alt="图3" ></p>
<p>具体程序如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*****************************************\</span></span><br><span class="line"><span class="comment"> 输入：原始数组arrayA              </span></span><br><span class="line"><span class="comment"> 功能：进行从小到大的排序</span></span><br><span class="line"><span class="comment"> 时间复杂度：nlgn</span></span><br><span class="line"><span class="comment">\*****************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeapSort</span><span class="params">(<span class="keyword">int</span>* arrayA,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> temp=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> Length=n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=Length<span class="number">-1</span>;i&gt;=<span class="number">2</span>;i--)</span><br><span class="line">	&#123;</span><br><span class="line">		temp=arrayA[<span class="number">1</span>];</span><br><span class="line">		arrayA[<span class="number">1</span>]=arrayA[i];</span><br><span class="line">		arrayA[i]=temp;</span><br><span class="line">		n--;</span><br><span class="line">		MaxHeapify(arrayA,n,<span class="number">1</span>);</span><br><span class="line">	   </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>下面将三个步骤综合起来，总的排序算法程序如下</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;ctime&gt; </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MaxHeapify</span><span class="params">(<span class="keyword">int</span>* arrayA,<span class="keyword">int</span> n,<span class="keyword">int</span> i)</span></span>;<span class="comment">//保持最大堆的性质</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BuildMaxHeap</span><span class="params">(<span class="keyword">int</span>* arrayA,<span class="keyword">int</span> n)</span></span>;<span class="comment">//构造堆</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeapSort</span><span class="params">(<span class="keyword">int</span>* arrayA,<span class="keyword">int</span> n)</span></span>;<span class="comment">//进行堆排序</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> arrayA[<span class="number">11</span>]=&#123;<span class="number">0</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">16</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">14</span>,<span class="number">8</span>,<span class="number">7</span>&#125;;<span class="comment">//第一个空间不用，是为了方便下标计算</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> Length=<span class="keyword">sizeof</span>(arrayA)/<span class="keyword">sizeof</span>(<span class="keyword">int</span>);<span class="comment">//数组的长度</span></span><br><span class="line"></span><br><span class="line">	BuildMaxHeap(arrayA,Length);<span class="comment">//利用数组arrayA建立最大堆</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"原序列为："</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;Length;i++)</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;arrayA[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	HeapSort(arrayA,Length);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"排序好的序列为："</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;Length;i++)</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;arrayA[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*****************************************\</span></span><br><span class="line"><span class="comment"> 输入：原始数组arrayA 父节点的下标i             </span></span><br><span class="line"><span class="comment"> 功能：使以i为根的子树成为最大堆</span></span><br><span class="line"><span class="comment"> 时间复杂度：lgn即树的层数</span></span><br><span class="line"><span class="comment">\*****************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MaxHeapify</span><span class="params">(<span class="keyword">int</span>* arrayA,<span class="keyword">int</span> n,<span class="keyword">int</span> i)</span><span class="comment">//i为父节点的在数组的下标</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> Length=n;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> l=<span class="number">2</span>*i;<span class="comment">//l为左子节点的在数组的下标</span></span><br><span class="line">	<span class="keyword">int</span> r=l+<span class="number">1</span>;<span class="comment">//r为右子节点的在数组的下标</span></span><br><span class="line">	<span class="keyword">int</span> largest=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> temp=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>((l&lt;Length)&amp;&amp;(arrayA[l]&gt;arrayA[i]))</span><br><span class="line">       largest=l;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		largest=i;</span><br><span class="line">	<span class="keyword">if</span>((r&lt;Length)&amp;&amp;(arrayA[r]&gt;arrayA[largest]))</span><br><span class="line">	    largest=r;</span><br><span class="line">	<span class="keyword">if</span>(largest!=i)</span><br><span class="line">	&#123;</span><br><span class="line">		temp=arrayA[i];</span><br><span class="line">		arrayA[i]=arrayA[largest];</span><br><span class="line">		arrayA[largest]=temp;</span><br><span class="line">		MaxHeapify(arrayA,n,largest);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*****************************************\</span></span><br><span class="line"><span class="comment"> 输入：原始数组arrayA              </span></span><br><span class="line"><span class="comment"> 功能：使数组arrayA中的元素成为最大堆</span></span><br><span class="line"><span class="comment"> 时间复杂度：nlgn</span></span><br><span class="line"><span class="comment">\*****************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BuildMaxHeap</span><span class="params">(<span class="keyword">int</span>* arrayA,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=n/<span class="number">2</span>;i&gt;<span class="number">0</span>;i--)</span><br><span class="line">		MaxHeapify(arrayA,n,i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*****************************************\</span></span><br><span class="line"><span class="comment"> 输入：原始数组arrayA              </span></span><br><span class="line"><span class="comment"> 功能：进行从小到大的排序</span></span><br><span class="line"><span class="comment"> 时间复杂度：nlgn</span></span><br><span class="line"><span class="comment">\*****************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeapSort</span><span class="params">(<span class="keyword">int</span>* arrayA,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> temp=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> Length=n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=Length<span class="number">-1</span>;i&gt;=<span class="number">2</span>;i--)</span><br><span class="line">	&#123;</span><br><span class="line">		temp=arrayA[<span class="number">1</span>];</span><br><span class="line">		arrayA[<span class="number">1</span>]=arrayA[i];</span><br><span class="line">		arrayA[i]=temp;</span><br><span class="line">		n--;</span><br><span class="line">		MaxHeapify(arrayA,n,<span class="number">1</span>);</span><br><span class="line">	   </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意：我是在vs2008上运行的，与vc 6.0有点区别，主要是循环体中的循环变量的作用域，出错体现在循环变量的重复定义上。例如：在vs2008或vs2010上，程序为：</strong></p>
<p><strong>#include<stdio.h><br>void main()<br>{<br>int i=0;<br>for(int i=0;i&lt;5;i++)<br>printf(“%d “,i);<br>}</strong></p>
<p><strong>则在VC 6.0上需改为：</strong></p>
<p><strong>#include<stdio.h><br>void main()<br>{<br>int i=0;<br>for(i=0;i&lt;5;i++)<br>printf(“%d “,i);<br>}</strong></p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>Algorithm Design</tag>
      </tags>
  </entry>
  <entry>
    <title>【算法导论】合并排序法</title>
    <url>/2013/06/08/%5B20130608%5D/</url>
    <content><![CDATA[<p> <strong>分治法：</strong>将原问题划分为n个规模较小而结构与原问题相似的子问题；递归地解决这些子问题，然后再合并其结果，就得到了原问题的解。分治法在每一个递归上都有三个步骤<strong>：分解、解决、合并。</strong>而在本文中的合并排序法正是运用了这种分而治之的策略：把一个n个元素的数组先分成两个数组，然后继续分下去，知道分成n个数组；然后将其逐一合并排序，最终得到排列好了的数组。下面我们首先看一看合并排序了原理框图：（<strong>图中黑色部分看不见不要紧，只需了解是将数组L、R中浅颜色的元素从小到大依次填入数组A中</strong>）</p>
<a id="more"></a>
<p>  <img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20130608/20130608_fig001.jpg" width="650" height="450" title="图1" alt="图1" ></p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20130608/20130608_fig002.jpg" width="700" height="400" title="图2" alt="图2" ></p>
<p>上述原理的具体代码实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/***************************************</span></span><br><span class="line"><span class="comment">/              合并排序</span></span><br><span class="line"><span class="comment">/输入：数组arrayA、数组长度、p q r为数组下标</span></span><br><span class="line"><span class="comment">/输出：由小到大的数组</span></span><br><span class="line"><span class="comment">/时间复杂度：n</span></span><br><span class="line"><span class="comment">***************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge</span><span class="params">(<span class="keyword">int</span>* arrayA,<span class="keyword">int</span> p,<span class="keyword">int</span> q,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> n1=q-p+<span class="number">1</span>;<span class="comment">//计算两个数组的长度</span></span><br><span class="line">	<span class="keyword">int</span> n2=r-q;<span class="comment">//且这两个数组是已排列好的数组</span></span><br><span class="line">	<span class="keyword">int</span> arrayL[<span class="number">100</span>]=&#123;<span class="number">0</span>&#125;;<span class="comment">//数组大小要大于n1</span></span><br><span class="line">	<span class="keyword">int</span> arrayR[<span class="number">100</span>]=&#123;<span class="number">0</span>&#125;;<span class="comment">//数组大小要大于n2</span></span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n1;i++)<span class="comment">//对两个数组赋初值</span></span><br><span class="line">		arrayL[i]=arrayA[p+i];</span><br><span class="line">	    arrayL[i]=<span class="number">10000</span>;<span class="comment">//作为哨兵，判断是否到结尾</span></span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n2;i++)   <span class="comment">//也可以不用哨兵</span></span><br><span class="line">		arrayR[i]=arrayA[q+i+<span class="number">1</span>];</span><br><span class="line">	    arrayR[i]=<span class="number">10000</span>;</span><br><span class="line"></span><br><span class="line">    i=<span class="number">0</span>;j=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> k=p;k&lt;=r;k++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(arrayL[i]&lt;=arrayR[j])</span><br><span class="line">			arrayA[k]=arrayL[i++];</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			arrayA[k]=arrayR[j++];	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面演示了合并排序在对一个数组的处理过程：</p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20130608/20130608_fig003.jpg" width="600" height="400" title="图3" alt="图3" ></p>
<p>上图中的合并排序过程的总的测试程序如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;ctime&gt; </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge</span><span class="params">(<span class="keyword">int</span>* arrayA,<span class="keyword">int</span> p,<span class="keyword">int</span> q,<span class="keyword">int</span> r)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSort</span><span class="params">(<span class="keyword">int</span>* arrayA,<span class="keyword">int</span> p,<span class="keyword">int</span> r)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">clock_t</span> start,finish;</span><br><span class="line">    <span class="keyword">double</span> totaltime;</span><br><span class="line">    start=clock();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> arrayA[<span class="number">6</span>]=&#123;<span class="number">5</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">3</span>&#125;;</span><br><span class="line">	<span class="keyword">int</span> Length=<span class="keyword">sizeof</span>(arrayA)/<span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line">	MergeSort(arrayA,<span class="number">0</span>,<span class="number">5</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;Length;i++)</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;arrayA[i];</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    finish=clock();</span><br><span class="line">    totaltime=(<span class="keyword">double</span>)(finish-start)/CLOCKS_PER_SEC;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"此两个程序的运行时间为"</span>&lt;&lt;totaltime&lt;&lt;<span class="string">"秒！"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="comment">//上述由于数组太小，运行时间很短，可以循环</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/***************************************</span></span><br><span class="line"><span class="comment">/              合并排序</span></span><br><span class="line"><span class="comment">/输入：数组arrayA、数组长度、p q r为数组下标</span></span><br><span class="line"><span class="comment">/输出：由小到大的数组</span></span><br><span class="line"><span class="comment">/时间复杂度：n</span></span><br><span class="line"><span class="comment">***************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge</span><span class="params">(<span class="keyword">int</span>* arrayA,<span class="keyword">int</span> p,<span class="keyword">int</span> q,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> n1=q-p+<span class="number">1</span>;<span class="comment">//计算两个数组的长度</span></span><br><span class="line">	<span class="keyword">int</span> n2=r-q;<span class="comment">//且这两个数组是已排列好的数组</span></span><br><span class="line">	<span class="keyword">int</span> arrayL[<span class="number">100</span>]=&#123;<span class="number">0</span>&#125;;<span class="comment">//数组大小要大于n1</span></span><br><span class="line">	<span class="keyword">int</span> arrayR[<span class="number">100</span>]=&#123;<span class="number">0</span>&#125;;<span class="comment">//数组大小要大于n2</span></span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n1;i++)<span class="comment">//对两个数组赋初值</span></span><br><span class="line">		arrayL[i]=arrayA[p+i];</span><br><span class="line">	    arrayL[i]=<span class="number">10000</span>;<span class="comment">//作为哨兵，判断是否到结尾</span></span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n2;i++)   <span class="comment">//也可以不用哨兵</span></span><br><span class="line">		arrayR[i]=arrayA[q+i+<span class="number">1</span>];</span><br><span class="line">	    arrayR[i]=<span class="number">10000</span>;</span><br><span class="line"></span><br><span class="line">    i=<span class="number">0</span>;j=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> k=p;k&lt;=r;k++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(arrayL[i]&lt;=arrayR[j])</span><br><span class="line">			arrayA[k]=arrayL[i++];</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			arrayA[k]=arrayR[j++];	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/***************************************</span></span><br><span class="line"><span class="comment">/              </span></span><br><span class="line"><span class="comment">/输入：数组arrayA、p  r为数组下标,用于对数组p-r的元素排序</span></span><br><span class="line"><span class="comment">/输出：由小到大的数组</span></span><br><span class="line"><span class="comment">/时间复杂度：最坏情况下为nlgn</span></span><br><span class="line"><span class="comment">***************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSort</span><span class="params">(<span class="keyword">int</span>* arrayA,<span class="keyword">int</span> p,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> q=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(p&lt;r)</span><br><span class="line">	&#123;</span><br><span class="line">		q=(p+r)/<span class="number">2</span>;<span class="comment">//将数组进行分解</span></span><br><span class="line">		MergeSort(arrayA,p,q);</span><br><span class="line">		MergeSort(arrayA,q+<span class="number">1</span>,r);</span><br><span class="line">		Merge(arrayA,p,q,r);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意：我是在vs2008上运行的，与vc 6.0有点区别，主要是循环体中的循环变量的作用域，出错体现在循环变量的重复定义上。例如：在vs2008或vs2010上，程序为：</strong></p>
<p><strong>#include<stdio.h><br>void main()<br>{<br>int i=0;<br>for(int i=0;i&lt;5;i++)<br>printf(“%d “,i);<br>}</strong></p>
<p><strong>则在VC 6.0上需改为：</strong></p>
<p><strong>#include<stdio.h><br>void main()<br>{<br>int i=0;<br>for(i=0;i&lt;5;i++)<br>printf(“%d “,i);<br>}</strong>　</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>Algorithm Design</tag>
      </tags>
  </entry>
  <entry>
    <title>【C/C++】精确系统计时：秒，毫秒，微秒</title>
    <url>/2013/06/02/%5B20130602b%5D/</url>
    <content><![CDATA[<p>对于<strong>秒/毫秒级</strong>计时，我们可以使用其自带库函数。在头文件time.h中，clock() 函数返回从 开启这个程序进程 到 程序中调用clock（）函数 时之间的CPU时钟计时单元数，返回单位是毫秒。另外，系统还定义了一个符号常量CLOCKS_PER_SEC。该常量等于每秒钟包括的系统时间单位数。因此，除以这个单位数，就可以得到秒数。time.h中将clock_t作为clock()作为clock()返回类型的别名。</p>
<p>对于<strong>微秒级</strong>计时，我们可以使用windows.h中的库函数QueryPerformanceCounter()。这个函数返回高精确度性能计数器的值,它可以以微妙为单位计时。由于该函数的精确计时的最小单位是与系统有关的，所以我们必须使用QueryPerformanceFrequency() 查询系统以得到QueryPerformanceCounter()返回的嘀哒声的频率，即返回每秒嘀哒声的个数。</p>
<a id="more"></a>
<hr>
<p>下面具体举例说明：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//---------秒级计时----------//</span></span><br><span class="line"><span class="comment">//void main()</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//	clock_t start, end;</span></span><br><span class="line"><span class="comment">//	start = clock();</span></span><br><span class="line"><span class="comment">//	Sleep(2300);</span></span><br><span class="line"><span class="comment">//	end = clock();</span></span><br><span class="line"><span class="comment">//	cout &lt;&lt; (end - start)/ double(CLOCKS_PER_SEC) &lt;&lt; " s" &lt;&lt; endl; </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//---------毫秒级计时----------//</span></span><br><span class="line"><span class="comment">//void main() </span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//	clock_t start,end;</span></span><br><span class="line"><span class="comment">//	start = clock();</span></span><br><span class="line"><span class="comment">//	Sleep(2300);</span></span><br><span class="line"><span class="comment">//	end = clock();</span></span><br><span class="line"><span class="comment">//	cout &lt;&lt; end - start &lt;&lt; " ms" &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//	</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//---------微秒级计时----------//</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	LARGE_INTEGER cpu_freqence;</span><br><span class="line">	LARGE_INTEGER start;</span><br><span class="line">	LARGE_INTEGER <span class="built_in">end</span>;</span><br><span class="line">	<span class="keyword">double</span> run_time = <span class="number">0.0</span>;</span><br><span class="line">	QueryPerformanceFrequency(&amp;cpu_freqence);</span><br><span class="line">	QueryPerformanceCounter(&amp;start);</span><br><span class="line">	Sleep(<span class="number">2300</span>);</span><br><span class="line">	QueryPerformanceCounter(&amp;<span class="built_in">end</span>);</span><br><span class="line">	run_time = (((<span class="built_in">end</span>.QuadPart - start.QuadPart) * <span class="number">1000.0f</span>) / cpu_freqence.QuadPart);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; run_time &lt;&lt; <span class="string">" ms"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
  </entry>
  <entry>
    <title>【算法导论】插入排序法</title>
    <url>/2013/06/02/%5B20130602%5D/</url>
    <content><![CDATA[<p>插入排序法的时间复杂度为n的平方，<strong>对于较小的输入规模来说，插入排序法比合并排序法更快些</strong>。在最佳情况下，即输入数组已经排序好，则时间复杂度可表示为n,是一个线性函数；在最差情况下，即输入数组是逆序排列时，时间复杂度为 $an^2+bn+c$. 插入排序法的具体实现方法如下：</p>
<a id="more"></a>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20130602/20130602_fig001.jpg" width="660" height="440" title="图1" alt="图1" ></p>
<p><strong>具体的c/c++语言实现如下：</strong></p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        c/c++语言实现：
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;ctime&gt; </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsectionSortAscend</span><span class="params">(<span class="keyword">int</span>* arrayA,<span class="keyword">int</span> Length)</span></span>;<span class="comment">//插入排序法：升序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsectionSortDescend</span><span class="params">(<span class="keyword">int</span>* arrayA,<span class="keyword">int</span> Length)</span></span>;<span class="comment">//插入排序法：降序</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">clock_t</span> start,finish;</span><br><span class="line">    <span class="keyword">double</span> totaltime;</span><br><span class="line">    start=clock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> arrayA[<span class="number">6</span>]=&#123;<span class="number">5</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">3</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> Length=<span class="keyword">sizeof</span>(arrayA)/<span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line"></span><br><span class="line">    InsectionSortDescend(arrayA,Length);</span><br><span class="line">    InsectionSortAscend(arrayA,Length);</span><br><span class="line">    </span><br><span class="line">    finish=clock();</span><br><span class="line">    totaltime=(<span class="keyword">double</span>)(finish-start)/CLOCKS_PER_SEC;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"此两个程序的运行时间为"</span>&lt;&lt;totaltime&lt;&lt;<span class="string">"秒！"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*****************************************</span></span><br><span class="line"><span class="comment">/            插入排序</span></span><br><span class="line"><span class="comment">/输入：数组arrayA、数组长度</span></span><br><span class="line"><span class="comment">/输出：由小到大已排列好的数组</span></span><br><span class="line"><span class="comment">/时间复杂度：n的平方</span></span><br><span class="line"><span class="comment">/*****************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsectionSortAscend</span><span class="params">(<span class="keyword">int</span>* arrayA,<span class="keyword">int</span> Length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> temp=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;Length;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        temp=arrayA[i];</span><br><span class="line">        j=i<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(j&gt;=<span class="number">0</span>&amp;&amp;arrayA[j]&gt;temp)</span><br><span class="line">        &#123;</span><br><span class="line">            arrayA[j+<span class="number">1</span>]=arrayA[j];</span><br><span class="line">            j=j<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        arrayA[j+<span class="number">1</span>]=temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;Length;i++)</span><br><span class="line">       <span class="built_in">cout</span>&lt;&lt;arrayA[i];</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*****************************************</span></span><br><span class="line"><span class="comment">/            插入排序</span></span><br><span class="line"><span class="comment">/输入：数组arrayA、数组长度</span></span><br><span class="line"><span class="comment">/输出：由大到小已排列好的数组</span></span><br><span class="line"><span class="comment">/时间复杂度：n的平方</span></span><br><span class="line"><span class="comment">/*****************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsectionSortDescend</span><span class="params">(<span class="keyword">int</span>* arrayA,<span class="keyword">int</span> Length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> temp=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i=Length<span class="number">-2</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        temp=arrayA[i];</span><br><span class="line">        j=i+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(j&lt;Length&amp;&amp;arrayA[j]&gt;temp)</span><br><span class="line">        &#123;</span><br><span class="line">            arrayA[j<span class="number">-1</span>]=arrayA[j];</span><br><span class="line">            j=j+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        arrayA[j<span class="number">-1</span>]=temp;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;Length;i++)</span><br><span class="line">       <span class="built_in">cout</span>&lt;&lt;arrayA[i];</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>
<p><strong>注意：我是在vs2008上运行的，与vc 6.0有点区别，主要是循环体中的循环变量的作用域，出错体现在循环变量的重复定义上。例如：在vs2008或vs2010上 (现在都已经VS2019啦！— tengweitw于2020年07月24日)，程序为：</strong></p>
<p><strong>#include<stdio.h><br>void main()<br>{<br>int i=0;<br>for(int i=0;i&lt;5;i++)<br>printf(“%d “,i);<br>}</strong></p>
<p><strong>则在VC 6.0上需改为：</strong></p>
<p><strong>#include<stdio.h><br>void main()<br>{<br>int i=0;<br>for(i=0;i&lt;5;i++)<br>printf(“%d “,i);<br>}</strong>　</p>
<p>排序法除了上述所说的之外还有大家都经常用的冒泡排序法，其时间复杂度为 $n$ 的平方。在这里我就不具体介绍了 (其实，后面也介绍了，哈哈哈！ — tengweitw于2020年07月24日)。</p>
<p>(我也不清楚，当初为什么加了下面这一段，难道是为了凑字数？— tengweitw于2020年07月24日)</p>
<p>下面简单介绍一下如何高效的计算多项式：</p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20130602/20130602_fig002.jpg" width="600" height="300" title="图2" alt="图2" ></p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>Algorithm Design</tag>
      </tags>
  </entry>
  <entry>
    <title>【C/C++】输入与输出(Cin &amp; Cout)</title>
    <url>/2013/06/01/%5B20130601%5D/</url>
    <content><![CDATA[<p>为成为国际语言，C++必须能处理需要16位的国际字符集Unicode,于是在传统的8位char型的基础上添加了wchar_t字符类型。在程序包含iostream文件时，将自动创建8个流对象：cin、cout、cerr、clog以及相对应的用于宽字符流的：wcin、wcout、wcerr、wclog。</p>
<a id="more"></a>
<h4 id="Cin"><a href="#Cin" class="headerlink" title="Cin"></a>Cin</h4><p><strong>可以将hex oct dec与cin连用，用于指定将输入的整数的进制</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;hex&gt;&gt;a;<span class="comment">//输入12h</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;a&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//输出18d</span></span><br></pre></td></tr></table></figure>
<p><strong>当把输入传给字符数组时，会自动在后面加上一个空值字符，使之成为一个字符串。</strong></p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> name[<span class="number">10</span>];</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;name;<span class="comment">//当输入&gt;=10时，会出错，因为会自动加'\0'</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;name&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<p><strong>cin检查输入</strong></p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;a;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;a&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> name[<span class="number">10</span>];</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;name;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;name&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<p>当输入123sdf或者123 sdf时，结果是a=123 name=sdf</p>
<p><strong>流状态:</strong></p>
<p>​        由3个ios_base元素组成：eofibtbadbit failbit。</p>
<p>​        当cin到达文件末尾是，它将设置eofbit</p>
<p>​        当cin未能读取预期的字符时（如类型不对），它将设置failbit</p>
<p>​        当cin试图读取不可访问的文件时，可能设置failbit</p>
<p>​        当有无法诊断的错误时，设置badbit</p>
<p>​        当全部3个状态都设置为0时，说明一切正常</p>
<p><strong>设置状态</strong></p>
<p><em>clear:</em></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">clear</span>();<span class="comment">//将使用默认参数0，这将清楚全部3个状态位：eofibt badbit failbit</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">clear</span>(eofbit);<span class="comment">//将状态设置为eofbit，另外两个状态被清除</span></span><br></pre></td></tr></table></figure>
<p>而setstate()只影响参数对应的位</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">setstate(eofbit);<span class="comment">//将设置eofbit,不会影响其它位</span></span><br></pre></td></tr></table></figure>
<p><strong>get与getline</strong></p>
<p>​        get(char&amp;)与get(void)不跳过空白的单字符</p>
<p>​        get(char<em>,int,char)与getline(char</em>,int,char)默认情况下是读取整行而不是一个单词。</p>
<p>​        get(void)返回的是int型,因为它可能返回EOF=-1,则下面是错误的</p>
<p>​        cin.get().get()</p>
<p><strong>到底采用哪一种输入方式?</strong></p>
<ul>
<li>如果希望跳过空白，则使用cin&gt;&gt;ch</li>
<li>如果希望程序检查每一个字符，则用cin.get(ch)</li>
</ul>
<p><strong>get()与getline()的主要区别</strong>在于：get()将换行符或则者分界符留在输入流中，这样接下来的输入操作首先看到的将是换行符或者是分界符，而getline()抽取并丢弃输入流中的换行符</p>
<p><strong>ignore(int n,char)将读取并丢弃接下来的n个字符或直到到达第一个char。</strong></p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"></span><br><span class="line"> <span class="built_in">cin</span>.ignore(<span class="number">5</span>,<span class="string">'3'</span>);</span><br><span class="line"></span><br><span class="line"> <span class="built_in">cin</span>&gt;&gt;a;<span class="comment">//输入1312</span></span><br><span class="line"></span><br><span class="line"> <span class="built_in">cout</span>&lt;&lt;a&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//输出12</span></span><br></pre></td></tr></table></figure>
<p>cin.read()与cin.get()不同的是，read()不会在输入之后加’\0’,因此不能将输入转为字符串</p>
<p>cin.peek()用于返回下一个输入的字符，但是并不把这个字符从缓存中读取出来。</p>
<p>Cin.putback()用于将一个字符插入到输入字符串中，即下一个要读取的字符就是你插入的字符。</p>
<hr>
<h4 id="Cout"><a href="#Cout" class="headerlink" title="Cout"></a>Cout</h4><ul>
<li><strong>可以直接输出数组名和字符指针以及字符常量。</strong></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> name[<span class="number">10</span>]=<span class="string">"tengwei"</span>;</span><br><span class="line">	<span class="keyword">char</span> *p=<span class="string">"xidian university"</span>;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"hello world!\n"</span>;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;name&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;p&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//这里显示的是字符串而不是p的值（即不是字符串的地址）</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;&amp;name&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//数组的首地址</span></span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;&amp;p&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//指针p的地址</span></span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;(<span class="keyword">void</span>*)p&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//这才是字符串的地址!需进行强制转化</span></span><br><span class="line">                         <span class="comment">//对于其它指针类型，cout认为是void*</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意如何输出字符串地址!</p>
<ul>
<li><p><strong>Ostream定义了put()和write()方法，分别用于字符的显示与字符串的显示</strong></p>
<p>cout.put()是用来输出单个字符的 比如cout.put(‘\n’); cout.put(‘a’);<br>cout.write(<em>s,num);是用来输出字符串的。</em>s是字符串的地址，num是想要输出的字符串的长度,空格也算就算是空字符也算在内。</p>
<p>例如：cout.write(“tengweitw”,4);将输出teng</p>
</li>
</ul>
<ul>
<li><p><strong>Write()方法也可用于数值数据：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">longval=<span class="number">560031841</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>.<span class="built_in">write</span>((<span class="keyword">char</span>*)&amp;val,<span class="keyword">sizeof</span>(<span class="keyword">int</span>));<span class="comment">//结果为aha!</span></span><br></pre></td></tr></table></figure>
<p>Val被显示为4个字符的组合，由于val的十六进制为21616861，而61h变为十进制正好是97即a,68h=104d=h,21h=33=!</p>
</li>
</ul>
<p>  Cout进行输出时，并不会立刻发送到目的地，而是先存储在缓存区，直到缓存区填满，然后程序刷新缓存区，把内容发出去，并清空缓存区。这样做可以节省大量时间，毕竟不希望每次有数据就立即发送，因为这样要存取硬盘很多次，浪费时间。我们可以调用flush来刷新，如下面都可以：</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"hello"</span>&lt;&lt;<span class="built_in">flush</span>;</span><br><span class="line">  </span><br><span class="line"><span class="built_in">flush</span>(<span class="built_in">cout</span>);</span><br><span class="line">  </span><br><span class="line"><span class="built_in">cout</span>.<span class="built_in">flush</span>();</span><br></pre></td></tr></table></figure>
<ul>
<li><p><strong>进制间转换</strong></p>
<p>十进制：dec</p>
<p>八进制： oct</p>
<p>十六进制： hex</p>
<p>Dec oct hex 这些控制符不是成员函数。它们的作用是长期的，直达重新设置为止。</p>
</li>
</ul>
<p>  <strong>调整字段宽度：</strong></p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Int <span class="title">width</span><span class="params">()</span></span>;<span class="comment">//返回当前设置</span></span><br><span class="line"></span><br><span class="line"><span class="function">Int <span class="title">width</span><span class="params">(<span class="keyword">int</span> i)</span></span>;<span class="comment">//设置宽度为i</span></span><br></pre></td></tr></table></figure>
<p>  注意width只影响接下来的一个项目而已,然后恢复默认值</p>
<p>  <strong>填充字符:</strong></p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Cout.Fill(‘*’);<span class="comment">// 它们的作用是长期的，直达重新设置为止。</span></span><br></pre></td></tr></table></figure>
<p>  <strong>精度设置</strong></p>
<p>  在默认情况下，精度为显示的总位数，在定点模式和科学模式下，精度指的是小数点后面的位数,默认精度为6（末尾0不显示）</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Cout.precision(<span class="number">2</span>); <span class="comment">// 它们的作用是长期的，直达重新设置为止。</span></span><br></pre></td></tr></table></figure>
<p>  <strong>打印末尾的0和小数点</strong></p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cout</span>.setf(ios_base::showpoint);</span><br></pre></td></tr></table></figure>
<ul>
<li><p><strong>Setf()的用法</strong><br>setf()用于控制小数点被显示是的其它几个格式选项。</p>
<p>Setf()有两个函数原型:</p>
<p><code>fmtflags setf (fmtflags fmtfl, fmtflags mask);``fmtflags setf (fmtflags fmtfl);</code></p>
<p>其中fmtfl和mask的可选值如下：</p>
</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>fmtfl  format flag value</th>
<th>mask  field bitmask</th>
</tr>
</thead>
<tbody>
<tr>
<td>left, right or internal</td>
<td>adjustfield</td>
</tr>
<tr>
<td>dec, oct or hex</td>
<td>basefield</td>
</tr>
<tr>
<td>scientific or fixed</td>
<td>floatfield</td>
</tr>
</tbody>
</table>
</div>
<p>  具体可以查看此链接：<a href="http://www.cplusplus.com/reference/ios/ios_base/setf/" target="_blank" rel="noopener">http://www.cplusplus.com/reference/ios/ios_base/setf/</a></p>
<p>  具体调用如下：</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="literal">true</span>&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//1</span></span><br><span class="line">	<span class="built_in">cout</span>.setf(ios_base::boolalpha);<span class="comment">//输入输出bool值，可以为true或false</span></span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="literal">true</span>&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span>.setf(ios_base::showbase);<span class="comment">//对于输出，使用C++基数前缀</span></span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;hex&lt;&lt;<span class="number">63</span>&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//0x3f</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span>.setf(ios_base::showpoint);<span class="comment">//显示末尾的小数点</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;dec&lt;&lt;<span class="number">6.3</span>&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//6.30000</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span>.setf(ios_base::uppercase);<span class="comment">//对于进制输出，使用大写字母，E表示法</span></span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;hex&lt;&lt;<span class="number">63</span>&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//0X3F是大写</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span>.setf(ios_base::showpos);<span class="comment">//在整数前面加上+</span></span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;dec&lt;&lt;<span class="number">63</span>&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//+63</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*下面为有两个参数的输入*/</span></span><br><span class="line">	<span class="built_in">cout</span>.unsetf(ios_base::basefield);</span><br><span class="line">	<span class="built_in">cout</span>.unsetf(ios_base::adjustfield);</span><br><span class="line">	<span class="built_in">cout</span>.unsetf(ios_base::floatfield);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span>.setf(ios_base::dec,ios_base::basefield);<span class="comment">//使用基数,若输入是小数则无效</span></span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="number">12.34</span>&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//12.34,输入是小数则无效</span></span><br><span class="line">	<span class="built_in">cout</span>.setf(ios_base::oct,ios_base::basefield);<span class="comment">//使用基数,若输入是小数则无效</span></span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="number">12</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span>.setf(ios_base::hex,ios_base::basefield);<span class="comment">//使用基数,若输入是小数则无效</span></span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="number">12</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span>.setf(ios_base::fixed,ios_base::floatfield);<span class="comment">//使用定点计数法</span></span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="number">12.34</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span>.setf(ios_base::scientific,ios_base::floatfield);<span class="comment">//使用科学计数法</span></span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="number">12.34</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span>.unsetf(ios_base::basefield);<span class="comment">//消除指定域的设置，恢复默认状态</span></span><br><span class="line">	<span class="built_in">cout</span>.unsetf(ios_base::adjustfield);<span class="comment">//消除指定域的设置，恢复默认状态</span></span><br><span class="line">	<span class="built_in">cout</span>.unsetf(ios_base::floatfield);<span class="comment">//消除指定域的设置，恢复默认状态</span></span><br><span class="line">	<span class="built_in">cout</span>.unsetf(ios_base::showpoint);<span class="comment">//showpoint等个不在上面个域内,应该单独消除</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span>.setf(ios_base::left,ios_base::adjustfield);<span class="comment">//左对齐</span></span><br><span class="line">	<span class="built_in">cout</span>.setf(ios_base::right,ios_base::adjustfield);<span class="comment">//右对齐</span></span><br><span class="line">	<span class="built_in">cout</span>.setf(ios_base::internal,ios_base::adjustfield);<span class="comment">//符号或基数前缀左对齐，值右对齐</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  上面所用的一些函数都可以用下面的标准控制符来调用：</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span><span class="comment">//与上面的相对应，就不写注释了</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">  	<span class="built_in">cout</span>&lt;&lt;boolalpha&lt;&lt;<span class="literal">true</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  <span class="comment">//	cout&lt;&lt;noboolapha&lt;&lt;true&lt;&lt;endl;//在我的电脑上noboolapha不支持</span></span><br><span class="line">  </span><br><span class="line">  	<span class="built_in">cout</span>&lt;&lt;showbase&lt;&lt;hex&lt;&lt;<span class="number">63</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  	<span class="built_in">cout</span>&lt;&lt;noshowbase&lt;&lt;hex&lt;&lt;<span class="number">63</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  </span><br><span class="line">  	<span class="built_in">cout</span>&lt;&lt;showpoint&lt;&lt;<span class="number">12.34</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  	<span class="built_in">cout</span>&lt;&lt;noshowpoint&lt;&lt;<span class="number">12.34</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  </span><br><span class="line">  	<span class="built_in">cout</span>&lt;&lt;showpos&lt;&lt;<span class="number">12.34</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  	<span class="built_in">cout</span>&lt;&lt;noshowpos&lt;&lt;<span class="number">12.34</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  </span><br><span class="line">  	<span class="built_in">cout</span>&lt;&lt;uppercase&lt;&lt;hex&lt;&lt;<span class="number">63</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  	<span class="built_in">cout</span>&lt;&lt;nouppercase&lt;&lt;hex&lt;&lt;<span class="number">63</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  </span><br><span class="line">  	<span class="built_in">cout</span>&lt;&lt;internal&lt;&lt;<span class="number">63</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  	<span class="built_in">cout</span>&lt;&lt;left&lt;&lt;<span class="number">63</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  	<span class="built_in">cout</span>&lt;&lt;right&lt;&lt;<span class="number">63</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  	<span class="built_in">cout</span>&lt;&lt;dec&lt;&lt;<span class="number">63</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  	<span class="built_in">cout</span>&lt;&lt;hex&lt;&lt;<span class="number">63</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  	<span class="built_in">cout</span>&lt;&lt;oct&lt;&lt;<span class="number">63</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  	<span class="built_in">cout</span>&lt;&lt;fixed&lt;&lt;<span class="number">12.34</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  	<span class="built_in">cout</span>&lt;&lt;scientific&lt;&lt;<span class="number">12.34</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>  <img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20130601/20130601_fig001.jpg" width="600" height="400" title="图1" alt="图1" ></p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>【C/C++】数组越界</title>
    <url>/2013/05/12/%5B20130512%5D/</url>
    <content><![CDATA[<p>在上篇文章<a href="http://www.tengweitw.com/2013/05/11/[20130511]/" target="_blank" rel="noopener">《内存对齐》</a>中说到了内存问题，今天我也遇到了可以用内存映射来解释的问题: 数组越界访问，出现死循环。</p>
 <a id="more"></a>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">int</span> a[<span class="number">5</span>];</span><br><span class="line"><span class="comment">//    int i;</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;&amp;i&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;=<span class="number">5</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		a[i]=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;a[i]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的程序中，发生了数组越界访问，那么将会发生什么情况呢？一般来说的话，会系统中断，出现提示框，然而，这里发生了死循环。</p>
<p>我首先用下面的程序查看了 $i$ 和数组元素的地址：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">int</span> a[<span class="number">5</span>];</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;&amp;i&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		a[i]=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;&amp;a[i]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在我的电脑（小端模式）下结果如下：</p>
<p>   i的地址为：  12FF44<br>a[0]的地址为：  12FF30<br>a[1]的地址为：  12FF34<br>a[2]的地址为：  12FF38<br>a[3]的地址为：  12FF3C<br>a[4]的地址为：  12FF40</p>
<p>按照这种内存存储方式，a[5]的地址为：  12FF44 与 $i$ 的地址相同！又因为我令a[i]=0, 则每当循环到a[5]=0时，$i=0$, 从而满足了循环条件，陷入了死循环。</p>
<p>当我把变量定义顺序改变时，将i在数组后定义即：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a[<span class="number">5</span>];</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;&amp;i&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		a[i]=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;&amp;a[i]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出的地址为：</p>
<p>   i的地址为：  12FF30<br>a[0]的地址为：  12FF34<br>a[1]的地址为：  12FF38<br>a[2]的地址为：  12FF3c<br>a[3]的地址为：  12FF40<br>a[4]的地址为：  12FF44</p>
<p>这时若发生越界的话，a[5]的地址为：  12FF48 与$i$ 的地址不同，系统会中断，出现错误提示框</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>【C/C++】内存对齐</title>
    <url>/2013/05/11/%5B20130511%5D/</url>
    <content><![CDATA[<p>在了解内存对齐方式前，先介绍计算机的存储方式：Big Endian与Little Endian：</p>
<ul>
<li>Big Endian:  即数据的高位在低地址，地位在高地址，并且把最高字节的地址作为变量的首地址</li>
<li><p>Little Endian: 即数据的高位在高地址，数据的低位在低地址，并且把最低字节的地址作为变量首地址。</p>
<a id="more"></a>
</li>
</ul>
<p>现实中，某些基于RISC(精简指令集)的cpu比如SPARC、PowerPC等，采用Big Endian，而Intel系列cpu采用Little Endian。如果想要知道自己的电脑是什么存储格式只需要输入以下代码： </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	 <span class="keyword">char</span> ch[]=&#123;<span class="number">0x12</span>,<span class="number">0x34</span>,<span class="number">0x56</span>,<span class="number">0x78</span>&#125;;</span><br><span class="line">	 <span class="keyword">int</span>* p=(<span class="keyword">int</span>*)ch;</span><br><span class="line">	 <span class="built_in">cout</span>&lt;&lt;hex&lt;&lt;*p&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//如果是78563412，说明是 Little Endian,如果是12345678，则是Big Endian</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>自然对齐</strong>：如果一个变量的内存地址正好位于它字节长度的整数倍，它就被称做自然对齐</p>
<p>​    对于标准数据类型，它的地址只要是它的长度的整数倍，而非标准数据类型按下面的原则对齐：<br>　- 数组 ：按照基本数据类型对齐，只要第一个对齐后面的自然也就对齐。<br>　- 联合 ：按其包含的长度最大的数据类型对齐。<br>　- 结构体： 结构体中每个数据类型都要对齐。     </p>
<p><strong>字节对齐的好处</strong>：<br>　  字节对齐的根本原因在于CPU访问数据的效率问题。学过微机原理的都知道规则字和非规则字，8086cpu访问规则字只要一个周期，而访问非规则字需要两个周期。在这里原理也是一样的，只不过这里是32位的操作系统，最多一次访问4字节，而8086是16位的，一次最多访问2字节。假设上面整型变量的地址是自然对齐，比如为0x00000000，则CPU如果取它的值的话需要访问一次内存，一次直接取从0x00000000-0x00000003的一个int型，如果变量在0x00000001，则第一次访问0x00000001的char型，第二次取从0x00000002-0x00000003的short型，第三次是0x00000004的char型，然后组合得到所要的数据，如果变量在0x00000002地址上的话则要访问两次内存，第一次为short，第二次为short，然后组合得到整型数据。如果变量在0x00000003地址上的话，则与在 0x00000001类似。 </p>
<p> 我们通过下面的例子来说明自然对齐：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a=<span class="number">0x0abcde11</span>;<span class="comment">//a b c 的地址依次减小</span></span><br><span class="line">	<span class="keyword">int</span> b=<span class="number">0x012345678</span>;</span><br><span class="line">	<span class="keyword">double</span> c=<span class="number">0x0f23456789abcdef1</span>;</span><br><span class="line">    <span class="keyword">char</span> d=<span class="number">0x0fa</span>;</span><br><span class="line"></span><br><span class="line">   	<span class="keyword">char</span> *ptr=(<span class="keyword">char</span>*)&amp;a;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a b每个字节的内容：\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"  地址  :内容\n"</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%x  :%x\n"</span>,ptr+<span class="number">3</span>-i,*(ptr+<span class="number">3</span>-i));<span class="comment">//说明整数是按 little-endian存储的</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\na b c d的首地址和地址与字节长度的余值：\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"a: %x :%d\n"</span>,&amp;a,<span class="keyword">long</span>(&amp;a)%<span class="keyword">sizeof</span>(a));<span class="comment">//从这里可以看成变量的内存地址按变量顺序递减的 </span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"b: %x :%d\n"</span>,&amp;b,<span class="keyword">long</span>(&amp;b)%<span class="keyword">sizeof</span>(b));<span class="comment">//各个变量并不一定存放在连续的内存单元</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"c: %x :%d\n"</span>,&amp;c,<span class="keyword">long</span>(&amp;c)%<span class="keyword">sizeof</span>(c));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"d: %x :%d\n"</span>,&amp;d,<span class="keyword">long</span>(&amp;d)%<span class="keyword">sizeof</span>(d));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面程序在我电脑的运行结果为：</p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20130511/20130511_fig001.jpg" width="400" height="300" title="图1" alt="图1" ></p>
<p>由上面的结果可以知道：</p>
<ul>
<li>地址随变量顺序而减小（你可以通过改变变量定义顺序来测试）；</li>
<li>我的电脑采用的是Little Endian；</li>
<li>各个变量并不一定存放在连续的内存单元（由c d的地址可知）</li>
</ul>
<p>对于数组，无论是静态数组还是动态数组都是连续存储的，可以用下面程序来查看：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">array</span>[<span class="number">5</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;&amp;<span class="built_in">array</span>[i]&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//输出静态数组的每个元素的地址</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> *pt=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>];</span><br><span class="line">	<span class="keyword">for</span>( i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;hex&lt;&lt;(pt+i)&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//输出动态数组的每个元素的地址</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">delete</span> []pt;<span class="comment">//注意要释放内存</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>  上面我们讨论了基本数据类型的内存存储，下面我们来看看类的存储结构。首先我们看看下面这个类：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">person1</span></span></span><br><span class="line"><span class="class">	&#123;</span></span><br><span class="line">		<span class="keyword">bool</span> m_isMan;</span><br><span class="line">		<span class="keyword">float</span> m_height;</span><br><span class="line">		<span class="keyword">bool</span> m_isFat;</span><br><span class="line">		<span class="keyword">double</span> m_weight;</span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">char</span> m_books;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(person1)&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//32=4+4+8+8+8</span></span><br></pre></td></tr></table></figure>
<p>这里person类的长度为32，其内存单元示意图如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20130511/20130511_fig002.jpg" width="150" height="220" title="图2" alt="图2" ></p>
<p>在这里是按8字节边界来对齐的。上述变量已经都自然对齐了，为什么person对象最后还要填充7字节？因为当你定义person类型的数组时，如果不填充7字节，则除了第一个元素外其它的元素就可能不是自然对齐了。</p>
<p>下面通过使用编译指令来定义对齐方式：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(push,4)<span class="comment">// 按4字节边界对齐</span></span></span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">person2</span></span></span><br><span class="line"><span class="class">	&#123;</span></span><br><span class="line">		<span class="keyword">bool</span> m_isMan;</span><br><span class="line">		<span class="keyword">float</span> m_height;</span><br><span class="line">		<span class="keyword">bool</span> m_isFat;</span><br><span class="line">		<span class="keyword">double</span> m_weight;</span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">char</span> m_books;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(person2)&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//24=4+4+4+8+4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(pop)</span></span><br></pre></td></tr></table></figure>
<p>这里person类的长度为24，其内存单元示意图如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20130511/20130511_fig003.jpg" width="150" height="220" title="图3" alt="图3" ></p>
<p>显然，在这里m_weight的地址不一定能被8整除，即不一定是自然对齐的。</p>
<p>从上面可以知道，内存的大小和存取的效率随编译方式和变量定义有关，最好的方法是：<strong>按照字节大小从大到小依次定义变量成员，并尽可能采用小的成员对齐方式。</strong></p>
<ul>
<li><p>从小到大定义变量：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//按照从小到大字节长度来定义变量</span></span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">person4</span></span></span><br><span class="line"><span class="class">	&#123;</span></span><br><span class="line">		<span class="keyword">bool</span> m_isMan;</span><br><span class="line">		<span class="keyword">bool</span> m_isFat;</span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">char</span> m_books;</span><br><span class="line">		<span class="keyword">float</span> m_height;</span><br><span class="line">		<span class="keyword">double</span> m_weight;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(person4)&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//16=1+1+1+1字节的填充+4+8</span></span><br></pre></td></tr></table></figure>
<p>这里person类的长度为16，其内存单元示意图如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20130511/20130511_fig004.jpg" width="150" height="220" title="图4" alt="图4" ></p>
</li>
<li><p>从大到小定义变量：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//按照从大到小字节长度来定义变量</span></span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">person3</span></span></span><br><span class="line"><span class="class">	&#123;</span></span><br><span class="line">		<span class="keyword">double</span> m_weight;</span><br><span class="line">		<span class="keyword">float</span> m_height;</span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">char</span> m_books;</span><br><span class="line">		<span class="keyword">bool</span> m_isMan;</span><br><span class="line">		<span class="keyword">bool</span> m_isFat;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(person3)&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//16=8+4+1+1+1+1字节的填充</span></span><br></pre></td></tr></table></figure>
<p>这里person类的长度为16，其内存单元示意图如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20130511/20130511_fig005.jpg" width="150" height="220" title="图5" alt="图5" ></p>
</li>
</ul>
<p>​     从上面可以看出两者所占内存一样，但是稳定度不同，从小到大的方式的对齐方式而发生有的成员变量不会自然对齐。如下所示</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"> <span class="meta">#<span class="meta-keyword">pragma</span> pack(push,1)<span class="comment">// 按4字节边界对齐</span></span></span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">person5</span></span></span><br><span class="line"><span class="class">	&#123;</span></span><br><span class="line">		<span class="keyword">bool</span> m_isMan;</span><br><span class="line">		<span class="keyword">bool</span> m_isFat;</span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">char</span> m_books;</span><br><span class="line"> 		<span class="keyword">float</span> m_height;</span><br><span class="line">  		<span class="keyword">double</span> m_weight;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(person5)&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//15=1+1+1+4+8</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(pop)</span></span><br></pre></td></tr></table></figure>
<p>这里person类的长度为15，其内存单元示意图如下：     </p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20130511/20130511_fig006.jpg" width="150" height="150" title="图6" alt="图6" ></p>
<p>在上面的程序中，double的偏移量为1+1+1+4=7，很有可能不会自然对齐,所以最好采用从大到小的方式来定义成员变量。</p>
<p>​        </p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>【C/C++】编程常用命名方法</title>
    <url>/2013/05/08/%5B20130508b%5D/</url>
    <content><![CDATA[<ol>
<li><strong>匈牙利命名法</strong><br>通过在变量名之前增加小写字母的符号前缀，以标识变量的属性、类型、作用域等参数。简单地说，即“变量名＝属性＋类型＋对象描述”的形式。<br>示例：m_lpszStr，表示指向以 0 字符结尾的字符串的长指针成员变量</li>
<li><strong>骆驼命名法</strong><br>也叫驼峰式大小写。其主要规范为，混合使用大小写字母来构造变量名或函数名。<br>示例：printEmployeePaychecks()，如代码所示，函数的每一个逻辑断点均用大写字母标识</li>
<li><strong>帕斯卡命名法</strong><br>与骆驼命名法类似，骆驼命名法是首字母小写，而帕斯卡命名法则需要首字母大写。源自 Pascal 语言的命名惯例，也称为大驼峰式命名法。<br>示例：LoginCheck()，string UserName</li>
</ol>
<a id="more"></a>
<p>下面介绍一种比较适用的程序命名方法：</p>
<ul>
<li>类型名和函数名均以大写字母开头的单词组合而成 eg: class Node; class LeftNode; void Set(int value); void SetValue(int value);</li>
<li>变量名和参数名的第一个单词小写，后面的单词首字母大写 eg: int flag; int flagShip;</li>
<li>符号常量和宏名全大写，并且单词之间用下划线连接 eg: const int MAX=100; const int MAX_LENGTH=1024;</li>
<li>静态变量加前缀s<em> eg: static int s_num;<br>全局变量加前缀g</em> eg: int g<em>Total=100;<br>类的成员变量加前缀m</em> eg: class Node { int m_length; int m_width; }</li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>【C/C++】cctype中的字符函数</title>
    <url>/2013/05/08/%5B20130508%5D/</url>
    <content><![CDATA[<p>c++中头文件为<cctype> ，c中则是<ctype.h>。</p>
<p>这些函数以一个数值或者字符作为参数并返回布尔值true或flase,或者是字符，具体因函数不同</p>
<p>这里面的函数可以分为两类：</p>
<a id="more"></a>
<p><strong>判断函数</strong></p>
<p>它们检查输入参数是否属于某个类别:</p>
<p><strong><a href="http://www.cplusplus.com/reference/cctype/isalnum/" target="_blank" rel="noopener">isalnum</a></strong></p>
<p>如果参数是字母数字，即字母或数字，该函数返回true</p>
<p><a href="http://www.cplusplus.com/reference/cctype/isalpha/" target="_blank" rel="noopener"><strong>isalpha</strong></a></p>
<p>如果参数是字母，该函数返回真</p>
<p><a href="http://www.cplusplus.com/reference/cctype/isblank/" target="_blank" rel="noopener"><strong>isblank</strong> </a></p>
<p>如果参数是空格或水平制表符，该函数返回true</p>
<p><a href="http://www.cplusplus.com/reference/cctype/iscntrl/" target="_blank" rel="noopener"><strong>iscntrl</strong></a></p>
<p>如果参数是控制字符，该函数返回true</p>
<p><a href="http://www.cplusplus.com/reference/cctype/isdigit/" target="_blank" rel="noopener"><strong>isdigit</strong></a></p>
<p>如果参数是数字（0～9），该函数返回true</p>
<p><a href="http://www.cplusplus.com/reference/cctype/isgraph/" target="_blank" rel="noopener"><strong>isgraph</strong></a></p>
<p>如果参数是除空格之外的打印字符，该函数返回true</p>
<p><a href="http://www.cplusplus.com/reference/cctype/islower/" target="_blank" rel="noopener"><strong>islower</strong></a></p>
<p>如果参数是小写字母，该函数返回true</p>
<p><a href="http://www.cplusplus.com/reference/cctype/isprint/" target="_blank" rel="noopener"><strong>isprint</strong></a></p>
<p>如果参数是打印字符（包括空格），该函数返回true</p>
<p><a href="http://www.cplusplus.com/reference/cctype/ispunct/" target="_blank" rel="noopener"><strong>ispunct</strong></a></p>
<p>如果参数是标点符号，该函数返回true</p>
<p><strong><a href="http://www.cplusplus.com/reference/cctype/isspace/" target="_blank" rel="noopener">isspace</a></strong></p>
<p>如果参数是标准空白字符，如空格、进纸、换行符、回车、水平制表符<br>或者垂直制表符，该函数返回true</p>
<p><a href="http://www.cplusplus.com/reference/cctype/isupper/" target="_blank" rel="noopener"><strong>isupper</strong></a></p>
<p>如果参数是大写字母，该函数返回true</p>
<p><a href="http://www.cplusplus.com/reference/cctype/isxdigit/" target="_blank" rel="noopener"><strong>isxdigit</strong></a></p>
<p>如果参数是十六进制的数字，即0～9、a~f、A~F，该函数返回true</p>
<p> <strong>字符转换函数：</strong></p>
<p><a href="http://www.cplusplus.com/reference/cctype/tolower/" target="_blank" rel="noopener"><strong>tolower</strong></a></p>
<p>如果参数是大写字符，则返回其小写，否则返回该参数</p>
<p><a href="http://www.cplusplus.com/reference/cctype/toupper/" target="_blank" rel="noopener"><strong>toupper</strong></a></p>
<p>如果参数是小写字母，则返回其大写，否则返回该参数</p>
<p>我们将ASCII值从0~127的字符通过第一个函数集的函数进行判断，返回值为true的用x标记，结果如下表：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>ASCII values</th>
<th>characters</th>
<th><a href="http://www.cplusplus.com/iscntrl" target="_blank" rel="noopener">is</a><a href="http://www.cplusplus.com/iscntrl" target="_blank" rel="noopener">c</a><a href="http://www.cplusplus.com/iscntrl" target="_blank" rel="noopener">ntr</a><a href="http://www.cplusplus.com/iscntrl" target="_blank" rel="noopener">l</a></th>
<th><a href="http://www.cplusplus.com/isblank" target="_blank" rel="noopener">is</a><a href="http://www.cplusplus.com/isblank" target="_blank" rel="noopener">blank</a></th>
<th><a href="http://www.cplusplus.com/isspace" target="_blank" rel="noopener">is</a><a href="http://www.cplusplus.com/isspace" target="_blank" rel="noopener">space</a></th>
<th><a href="http://www.cplusplus.com/isupper" target="_blank" rel="noopener">is</a><a href="http://www.cplusplus.com/isupper" target="_blank" rel="noopener">upper</a></th>
<th><a href="http://www.cplusplus.com/islower" target="_blank" rel="noopener">is</a><a href="http://www.cplusplus.com/islower" target="_blank" rel="noopener">lower</a></th>
<th><a href="http://www.cplusplus.com/isalpha" target="_blank" rel="noopener">is</a><a href="http://www.cplusplus.com/isalpha" target="_blank" rel="noopener">alpha</a></th>
<th><a href="http://www.cplusplus.com/isdigit" target="_blank" rel="noopener">is</a><a href="http://www.cplusplus.com/isdigit" target="_blank" rel="noopener">digit</a></th>
<th><a href="http://www.cplusplus.com/isxdigit" target="_blank" rel="noopener">is</a><a href="http://www.cplusplus.com/isxdigit" target="_blank" rel="noopener">xdigit</a></th>
<th><a href="http://www.cplusplus.com/isalnum" target="_blank" rel="noopener">is</a><a href="http://www.cplusplus.com/isalnum" target="_blank" rel="noopener">alnum</a></th>
<th><a href="http://www.cplusplus.com/ispunct" target="_blank" rel="noopener">is</a><a href="http://www.cplusplus.com/ispunct" target="_blank" rel="noopener">punct</a></th>
<th><a href="http://www.cplusplus.com/isgraph" target="_blank" rel="noopener">is</a><a href="http://www.cplusplus.com/isgraph" target="_blank" rel="noopener">graph</a></th>
<th><a href="http://www.cplusplus.com/isprint" target="_blank" rel="noopener">is</a><a href="http://www.cplusplus.com/isprint" target="_blank" rel="noopener">print</a></th>
</tr>
</thead>
<tbody>
<tr>
<td>0x00 .. 0x08</td>
<td>NUL, (other control codes)</td>
<td>x</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>0x09</td>
<td>tab (‘\t’)</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>0x0A .. 0x0D</td>
<td>(white-space control codes:’\f’,’\v’,’\n’,’\r’)</td>
<td>x</td>
<td></td>
<td>x</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>0x0E .. 0x1F</td>
<td>(other control codes)</td>
<td>x</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>0x20</td>
<td>space (‘ ‘)</td>
<td></td>
<td>x</td>
<td>x</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>x</td>
</tr>
<tr>
<td>0x21 .. 0x2F</td>
<td>!”#$%&amp;’()*+,-./</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>x</td>
<td>x</td>
<td>x</td>
</tr>
<tr>
<td>0x30 .. 0x39</td>
<td>0123456789</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>x</td>
<td>x</td>
<td>x</td>
<td></td>
<td>x</td>
<td>x</td>
</tr>
<tr>
<td>0x3a .. 0x40</td>
<td>:;&lt;=&gt;?@</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>x</td>
<td>x</td>
<td>x</td>
</tr>
<tr>
<td>0x41 .. 0x46</td>
<td>ABCDEF</td>
<td></td>
<td></td>
<td></td>
<td>x</td>
<td></td>
<td>x</td>
<td></td>
<td>x</td>
<td>x</td>
<td></td>
<td>x</td>
<td>x</td>
</tr>
<tr>
<td>0x47 .. 0x5A</td>
<td>GHIJKLMNOPQRSTUVWXYZ</td>
<td></td>
<td></td>
<td></td>
<td>x</td>
<td></td>
<td>x</td>
<td></td>
<td></td>
<td>x</td>
<td></td>
<td>x</td>
<td>x</td>
</tr>
<tr>
<td>0x5B .. 0x60</td>
<td>[]^_`</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>x</td>
<td>x</td>
<td>x</td>
</tr>
<tr>
<td>0x61 .. 0x66</td>
<td>abcdef</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>x</td>
<td>x</td>
<td></td>
<td>x</td>
<td>x</td>
<td></td>
<td>x</td>
<td>x</td>
</tr>
<tr>
<td>0x67 .. 0x7A</td>
<td>ghijklmnopqrstuvwxyz</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>x</td>
<td>x</td>
<td></td>
<td></td>
<td>x</td>
<td></td>
<td>x</td>
<td>x</td>
</tr>
<tr>
<td>0x7B .. 0x7E</td>
<td>{  &#124;  }~</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>x</td>
<td>x</td>
<td>x</td>
</tr>
<tr>
<td>0x7F</td>
<td>(DEL)</td>
<td>x</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</div>
<p>扩展的ASCII字符集用上述函数的判断结果依赖于平台。一般来说，在许多支持扩展的ASCII字符集的平台下，标准C里面的<a href="http://www.cplusplus.com/ispunct" target="_blank" rel="noopener">ispunct</a>, <a href="http://www.cplusplus.com/isgraph" target="_blank" rel="noopener">isgraph</a> 和<a href="http://www.cplusplus.com/isprint" target="_blank" rel="noopener">isprint</a> 函数返回true.</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>【C/C++】ASCII字符集</title>
    <url>/2013/05/07/%5B20130507%5D/</url>
    <content><![CDATA[<p>编程时经常要使用ASCII字符集，所以专门放在这里，以便日后查看：</p>
<a id="more"></a>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20130507/20130507_fig001.jpg" width="800" height="600" title="图1" alt="图1" ></p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20130507/20130507_fig002.jpg" width="800" height="600" title="图2" alt="图2" ></p>
<p>当然，如果不能上网，也可以通过计算机来查询ASCII字符集：</p>
<p>方法一：C语言实现，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">128</span>;i++)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d is '%c' \n"</span>,i,i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法二： Matlab实现，截图如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/tengweitw/FigureBed@latest/20130507/20130507_fig003.jpg" width="500" height="200" title="图3" alt="图3" ></p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>【C/C++】基本数据类型</title>
    <url>/2013/05/06/%5B20130506%5D/</url>
    <content><![CDATA[<p>标准C基本数据类型：int char long short float double void以及它们与signed、unsigned的组合。标准C++增加了bool型和wchar_t型，在32位操作系统上，它们的长度如下表：</p>
<a id="more"></a>
<div class="table-container">
<table>
<thead>
<tr>
<th>类型标识符</th>
<th>类型说明</th>
<th>长度（字节）</th>
<th>范围</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>char</td>
<td>字符型</td>
<td>1</td>
<td>-128 ~ 127</td>
<td>-27 ~ (27 -1)</td>
</tr>
<tr>
<td>unsigned char</td>
<td>无符字符型</td>
<td>1</td>
<td>0 ~ 255</td>
<td>0 ~ (28 -1)</td>
</tr>
<tr>
<td>short int</td>
<td>短整型</td>
<td>2</td>
<td>-32768 ~ 32767</td>
<td>2-15 ~ (215 - 1)</td>
</tr>
<tr>
<td>unsigned short int</td>
<td>无符短整型</td>
<td>2</td>
<td>0 ~ 65535</td>
<td>0 ~ (216 - 1)</td>
</tr>
<tr>
<td>long int</td>
<td>长整型</td>
<td>4</td>
<td>-2147483648 ~ 2147483646</td>
<td>-231 ~ (231 - 0)</td>
</tr>
<tr>
<td>int</td>
<td>整型</td>
<td>4</td>
<td>-2147483648 ~ 2147483647</td>
<td>-231 ~ (231 - 1)</td>
</tr>
<tr>
<td>unsigned int</td>
<td>无符整型</td>
<td>4</td>
<td>0 ~ 4294967295</td>
<td>0 ~ (232-1)</td>
</tr>
<tr>
<td>float</td>
<td>实型（单精度）</td>
<td>4</td>
<td>1.18<em>10-38 ~ 3.40</em>1038</td>
<td>7位有效位</td>
</tr>
<tr>
<td>double</td>
<td>实型（双精度）</td>
<td>8</td>
<td>2.23<em>10-308 ~ 1.79</em>10308</td>
<td>15位有效位</td>
</tr>
<tr>
<td>long double</td>
<td>实型（长双精度）</td>
<td>10</td>
<td>3.37<em>10-4932 ~ 1.18</em>104932</td>
<td>19位有效位</td>
</tr>
</tbody>
</table>
</div>
<p>在不同的平台下，字长不同，具体可以通过以下代码查看：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;  </span></span></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="comment">//字符型 有符号和无符号的字节数一样 只是范围不同  </span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"char is %d\n"</span>,<span class="keyword">sizeof</span>(<span class="keyword">char</span>));  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"unsigned char is %d\n"</span>,<span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> <span class="keyword">char</span>));  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//整数型  </span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"short int is %d\n"</span>,<span class="keyword">sizeof</span>(<span class="keyword">short</span> <span class="keyword">int</span>));  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"unsigned short int is %d\n"</span>,<span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">int</span>));  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"long int is %d\n"</span>,<span class="keyword">sizeof</span>(<span class="keyword">long</span> <span class="keyword">int</span>));  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"int is %d\n"</span>,<span class="keyword">sizeof</span>(<span class="keyword">int</span>));  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"unsigned int is %d\n"</span>,<span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span>));  </span><br><span class="line">      </span><br><span class="line">    <span class="comment">//浮点型  </span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"float is %d\n"</span>,<span class="keyword">sizeof</span>(<span class="keyword">float</span>));  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"double is %d\n"</span>,<span class="keyword">sizeof</span>(<span class="keyword">double</span>));  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"long double is %d\n"</span>,<span class="keyword">sizeof</span>(<span class="keyword">long</span> <span class="keyword">double</span>));  </span><br><span class="line">      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在头文件climits.h中，定义了符号常量来表示类型的限制。其列表如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>name</th>
<th>expresses</th>
<th>value*</th>
</tr>
</thead>
<tbody>
<tr>
<td>CHAR_BIT</td>
<td>Number of bits in a <code>char</code> object (byte)</td>
<td><code>8</code> or greater</td>
</tr>
<tr>
<td>SCHAR_MIN</td>
<td>Minimum value for an object of type <code>signed char</code></td>
<td><code>-127</code> (<code>-27+1</code>) or less</td>
</tr>
<tr>
<td>SCHAR_MAX</td>
<td>Maximum value for an object of type <code>signed char</code></td>
<td><code>127</code> (<code>27-1</code>) or greater</td>
</tr>
<tr>
<td>UCHAR_MAX</td>
<td>Maximum value for an object of type <code>unsigned char</code></td>
<td><code>255</code> (<code>28-1</code>) or greater</td>
</tr>
<tr>
<td>CHAR_MIN</td>
<td>Minimum value for an object of type <code>char</code></td>
<td>either SCHAR_MIN or <code>0</code></td>
</tr>
<tr>
<td>CHAR_MAX</td>
<td>Maximum value for an object of type <code>char</code></td>
<td>either SCHAR_MAX or UCHAR_MAX</td>
</tr>
<tr>
<td>MB_LEN_MAX</td>
<td>Maximum number of bytes in a multibyte character, for any locale</td>
<td><code>1</code> or greater</td>
</tr>
<tr>
<td>SHRT_MIN</td>
<td>Minimum value for an object of type <code>short int</code></td>
<td><code>-32767</code> (<code>-215+1</code>) or less</td>
</tr>
<tr>
<td>SHRT_MAX</td>
<td>Maximum value for an object of type <code>short int</code></td>
<td><code>32767</code> (<code>215-1</code>) or greater</td>
</tr>
<tr>
<td>USHRT_MAX</td>
<td>Maximum value for an object of type <code>unsigned short int</code></td>
<td><code>65535</code> (<code>216-1</code>) or greater</td>
</tr>
<tr>
<td>INT_MIN</td>
<td>Minimum value for an object of type <code>int</code></td>
<td><code>-32767</code> (<code>-215+1</code>) or less</td>
</tr>
<tr>
<td>INT_MAX</td>
<td>Maximum value for an object of type <code>int</code></td>
<td><code>32767</code> (<code>215-1</code>) or greater</td>
</tr>
<tr>
<td>UINT_MAX</td>
<td>Maximum value for an object of type <code>unsigned int</code></td>
<td><code>65535</code> (<code>216-1</code>) or greater</td>
</tr>
<tr>
<td>LONG_MIN</td>
<td>Minimum value for an object of type <code>long int</code></td>
<td><code>-2147483647</code> (<code>-231+1</code>) or less</td>
</tr>
<tr>
<td>LONG_MAX</td>
<td>Maximum value for an object of type <code>long int</code></td>
<td><code>2147483647</code> (<code>231-1</code>) or greater</td>
</tr>
<tr>
<td>ULONG_MAX</td>
<td>Maximum value for an object of type <code>unsigned long int</code></td>
<td><code>4294967295</code> (<code>232-1</code>) or greater</td>
</tr>
<tr>
<td>LLONG_MIN</td>
<td>Minimum value for an object of type <code>long long int</code></td>
<td><code>-9223372036854775807</code> (<code>-263+1</code>) or less</td>
</tr>
<tr>
<td>LLONG_MAX</td>
<td>Maximum value for an object of type <code>long long int</code></td>
<td><code>9223372036854775807</code> (<code>263-1</code>) or greater</td>
</tr>
<tr>
<td>ULLONG_MAX</td>
<td>Maximum value for an object of type <code>unsigned long long int</code></td>
<td><code>18446744073709551615</code> (<code>264-1</code>) or greater</td>
</tr>
</tbody>
</table>
</div>
<p>* 其精确值依赖于你的系统和库的实现</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>【生活随笔】决定</title>
    <url>/2013/05/05/%5B20130505%5D/</url>
    <content><![CDATA[<p>注册csdn已经有一年多了，从来也没有进这个论坛看看，当初也只是因为要下载资料而注册的。现在决定转战到这里，一是因为QQ号前不久被盗，一些资料幸好没丢，于是想来将一些个人的文档、程序保存在这里；二是因为csdn中国最大的程序员论坛，想向一些大牛请教请教，毕竟QQ空间的技术大牛并不多，也极少有人会将技术贴发在QQ空间。</p>
<a id="more"></a>
<p>  今天是五四青年节，希望我现在的决定不是一时的兴趣，希望每个月都能发几篇像样的伪技术贴。业精于勤，荒于嬉；行成于思，毁于随。今天看林锐的高质量程序设计指南，发现本书的作者之一韩永泉的csdn帐号是northwest_wolf,于是我便取了个名字-nineheaded_bird。从今天起，每个月都写一些东西，将来会对自己的科研会有一定的帮助的。贵在坚持！回首过去，大学的时光都虚度了，乘现在还有时间，好好弥补，希望还来得及。</p>
<p>  Yesterday is History,Tomorry is a Mystery,Today is a gift,That’s why we call it the present！</p>
<hr>
<p><strong>更新于2020-06-30：</strong></p>
<p>从今天开始，我将转战到自己的个人博客：tengweitw.com 。之所以想要转移，一方面是因为个人博客的可自定义程度高，另一方面，csdn好多改变已经不符合我的价值观：</p>
<ul>
<li>推出了博文付费功能，看个文章都需要付费。虽然，我也认可知识付费。</li>
<li>尽管个人设置不要c币，但有时下载仍强制需要c币。虽然，我有很多c币。</li>
<li>官方鼓励那些博人眼球的标题，好多被推荐的文章都是标题党。虽然，有些质量也比较高。</li>
</ul>
<p>这个个人博客是始建于2015年，是基于github和hexo部署的。我将把我所有的博客的内容重新编辑保存为markown格式，陆续上传到个人博客。我希望在今后能够写出一些有深度的文章，而不是和以前一样写的十分浅显。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>Life Thoughts</tag>
      </tags>
  </entry>
</search>
